within ;
model hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu
  "Air supply unit model with heatpump heating and cooling and auxiliary electric heater for heating"
// Model automatically generated by Dymola from FMI model description
extends fmuIcon;
public
  type Modelica_Blocks_Interfaces_BooleanInput = Boolean;
  type Modelica_Blocks_Interfaces_BooleanOutput = Boolean;
  type Modelica_Blocks_Interfaces_RealInput = Real;
  type Modelica_Blocks_Interfaces_RealOutput = Real;
  type Modelica_Media_Interfaces_PartialMedium_MassFlowRate = Real (unit = "kg/s", quantity = "MassFlowRate.unusablePartialMedium", min = -100000.0, max = 100000.0);
  type Buildings_Types_Reset = enumeration(
      Disabled                                      "Disabled",
      Parameter "Use parameter value",
      Input "Use input signal");
  constant Real refIneFre = 0.015 "refrigerant inertia parameter";
  parameter Real k_hea = 0.18 "Proportional gain of heating controller";
  parameter Modelica.SIunits.Time Ti_hea = 2400 "Integral time constant of heating controller";
  parameter Modelica.SIunits.ThermodynamicTemperature maxSAT = 310 "max supply air temperature";
  parameter Real uLowSta1 = 0.05 "PI lower bound to activate stage 1";
  parameter Real uUppSta1 = 0.15 "PI upper bound to activate stage 1";
  parameter Real uLowSta2 = 0.35 "PI lower bound to activate stage 2";
  parameter Real uUppSta2 = 0.45 "PI upper bound to activate stage 2";
  parameter Real kSta1 = 0.05 "PI center line to activate stage 1";
  parameter Real kSta2 = 0.35 "PI center line to activate stage 2";
  parameter Real banSta1 = 0.01 "PI band to activate stage 1";
  parameter Real banSta2 = 0.01 "PI band to activate stage 2";
protected
  record rtuHP_rec
    constant Real refIneFre = 0.015 "refrigerant inertia parameter";
    Modelica_Blocks_Interfaces_RealOutput PEle(unit = "W", quantity = "Power") "Electrical power consumed by the unit";
    Modelica_Blocks_Interfaces_RealInput TEvaIn(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature") "Outside air dry bulb temperature";
    Modelica_Blocks_Interfaces_RealInput sta "Heating stage";
    Modelica_Blocks_Interfaces_RealOutput TSup(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature") "Electrical power consumed by the unit";
  protected
    record inSou_rec
      constant Integer nPorts = 1 "Number of ports";
      constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
      parameter Modelica.Media.Interfaces.Types.MassFraction 'X[1]'(quantity = "water") = 0.01 "Fixed value of composition";
      parameter Modelica.Media.Interfaces.Types.MassFraction 'X[2]'(quantity = "air") = 0.99 "Fixed value of composition";
      parameter Modelica.SIunits.MassFlowRate m_flow(nominal = 0.405, min = -100000.0, max = 100000.0) = 1 "Fixed mass flow rate going out of the fluid port";
      parameter Modelica.Media.Interfaces.Types.Temperature T = 293.15 "Fixed value of temperature";
      Modelica_Blocks_Interfaces_RealInput T_in(unit = "K", displayUnit = "degC") "Prescribed boundary temperature";
    protected
      record 'ports[1]_rec'
        Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
        parameter Modelica.Media.Interfaces.Types.AbsolutePressure p(fixed=false) "Thermodynamic pressure in the connection point";
        Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end 'ports[1]_rec';
    public
      'ports[1]_rec' 'ports[1]';
    end inSou_rec;
  public
    inSou_rec inSou annotation(Dialog);
  protected
    record outSou_rec
      constant Integer nPorts = 1 "Number of ports";
      constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
      parameter Modelica.Media.Interfaces.Types.MassFraction 'X[1]'(quantity = "water") = 0.01 "Fixed value of composition";
      parameter Modelica.Media.Interfaces.Types.MassFraction 'X[2]'(quantity = "air") = 0.99 "Fixed value of composition";
      parameter Modelica.Media.Interfaces.Types.AbsolutePressure p = 101325 "Fixed value of pressure";
      parameter Modelica.Media.Interfaces.Types.Temperature T = 293.15 "Fixed value of temperature";
    protected
      record 'ports[1]_rec'
        parameter Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", fixed=false) "Mass flow rate from the connection point into the component";
        Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
        parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(fixed=false) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end 'ports[1]_rec';
    public
      'ports[1]_rec' 'ports[1]';
    end outSou_rec;
  public
    outSou_rec outSou annotation(Dialog);
  protected
    record heaPum_rec
      constant Boolean allowFlowReversal1 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1";
      constant Boolean allowFlowReversal2 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2";
      constant Modelica.SIunits.MassFlowRate m1_flow_nominal(min = 0.0) = 0.3 "Nominal mass flow rate";
      constant Modelica.SIunits.MassFlowRate m2_flow_nominal(min = 0.0) = 0.3 "Nominal mass flow rate";
      constant Modelica_Media_Interfaces_PartialMedium_MassFlowRate m1_flow_small(quantity = "MassFlowRate.Air", min = 0.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
      constant Modelica_Media_Interfaces_PartialMedium_MassFlowRate m2_flow_small(quantity = "MassFlowRate.Air", min = 0.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
      Modelica_Media_Interfaces_PartialMedium_MassFlowRate m1_flow(quantity = "MassFlowRate.Air") "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
      constant Modelica.SIunits.PressureDifference dp1(displayUnit = "Pa") = 0.0 "Pressure difference between port_a1 and port_b1";
      Modelica_Media_Interfaces_PartialMedium_MassFlowRate m2_flow(quantity = "MassFlowRate.Air") "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
      constant Modelica.SIunits.PressureDifference dp2(displayUnit = "Pa") = 0.0 "Pressure difference between port_a2 and port_b2";
      constant Boolean use_rev = false "Is the vapour compression machine reversible?";
      constant Boolean use_autoCalc = true "Enable automatic estimation of volumes and mass flows?";
      constant Modelica.SIunits.Power Q_useNominal = 6535 "Nominal usable heat flow of the vapour compression machine (HP: Heating; Chiller: Cooling)";
      constant Real scalingFactor = 1.35 "Scaling-factor of vapour compression machine";
      constant Boolean use_refIne = true "Consider the inertia of the refrigerant cycle";
      constant Modelica.SIunits.Frequency refIneFre_constant = 0.015 "Cut off frequency for inertia of refrigerant cycle";
      constant Integer nthOrder = 3 "Order of refrigerant cycle interia";
      constant Boolean useBusConnectorOnly = true "Set true to use bus connector for modeSet, nSet and iceFac input";
      constant Modelica.SIunits.MassFlowRate mFlow_conNominal = 0.5 "Manual input of the nominal mass flow rate (if not automatically calculated)";
      constant Modelica.SIunits.Volume VCon = 0.4 "Manual input of the condenser volume (if not automatically calculated)";
      constant Modelica.SIunits.PressureDifference dpCon_nominal = 0 "Pressure drop at nominal mass flow rate";
      constant Real deltaM_con = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
      constant Boolean use_conCap = false "If heat losses at capacitor side are considered or not";
      constant Modelica.SIunits.HeatCapacity CCon = 100 "Heat capacity of Condenser (= cp*m). If you want to neglace the dry mass of the condenser, you can set this value to zero";
      constant Modelica.SIunits.ThermalConductance GConOut = 5 "Constant parameter for heat transfer to the ambient. Represents a sum of thermal resistances such as conductance, insulation and natural convection. If you want to simulate a condenser with additional dry mass but without external heat losses, set the value to zero";
      constant Modelica.SIunits.ThermalConductance GConIns = 0.0 "Constant parameter for heat transfer to heat exchangers capacity. Represents a sum of thermal resistances such as forced convection and conduction inside of the capacity";
      constant Modelica.SIunits.MassFlowRate mFlow_evaNominal = 0.5 "Manual input of the nominal mass flow rate (if not automatically calculated)";
      constant Modelica.SIunits.Volume VEva = 0.04 "Manual input of the evaporator volume (if not automatically calculated)";
      constant Modelica.SIunits.PressureDifference dpEva_nominal = 0 "Pressure drop at nominal mass flow rate";
      constant Real deltaM_eva = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
      constant Boolean use_evaCap = false "If heat losses at capacitor side are considered or not";
      constant Modelica.SIunits.HeatCapacity CEva = 100 "Heat capacity of Evaporator (= cp*m). If you want to neglace the dry mass of the evaporator, you can set this value to zero";
      constant Modelica.SIunits.ThermalConductance GEvaOut = 5 "Constant parameter for heat transfer to the ambient. Represents a sum of thermal resistances such as conductance, insulation and natural convection. If you want to simulate a evaporator with additional dry mass but without external heat losses, set the value to zero";
      constant Modelica.SIunits.ThermalConductance GEvaIns = 0.0 "Constant parameter for heat transfer to heat exchangers capacity. Represents a sum of thermal resistances such as forced convection and conduction inside of the capacity";
      constant Modelica.SIunits.Time tauSenT = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
      constant Boolean transferHeat = true "If true, temperature T converges towards TAmb when no flow";
      constant Boolean allowFlowReversalEva = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
      constant Boolean allowFlowReversalCon = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
      constant Modelica.SIunits.Time tauHeaTraEva = 1200 "Time constant for heat transfer in temperature sensors in evaporator, default 20 minutes";
      parameter Modelica.SIunits.Temperature TAmbEva_nominal = 273.15 "Fixed ambient temperature for heat transfer of sensors at the evaporator side";
      constant Modelica.SIunits.Time tauHeaTraCon = 1200 "Time constant for heat transfer in temperature sensors in condenser, default 20 minutes";
      parameter Modelica.SIunits.Temperature TAmbCon_nominal = 288.15 "Fixed ambient temperature for heat transfer of sensors at the condenser side";
      constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
      constant Modelica.Media.Interfaces.Types.AbsolutePressure pCon_start = 101325 "Start value of pressure";
      constant Modelica.Media.Interfaces.Types.Temperature TCon_start = 290.15 "Start value of temperature";
      parameter Modelica.SIunits.Temperature TConCap_start = 293.15 "Initial temperature of heat capacity of condenser";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XCon_start[1]' = 0.01 "Start value of mass fractions m_i/m";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XCon_start[2]' = 0.99 "Start value of mass fractions m_i/m";
      constant Modelica.Media.Interfaces.Types.AbsolutePressure pEva_start = 101325 "Start value of pressure";
      constant Modelica.Media.Interfaces.Types.Temperature TEva_start = 281.15 "Start value of temperature";
      parameter Modelica.SIunits.Temperature TEvaCap_start = 293.15 "Initial temperature of heat capacity at evaporator";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XEva_start[1]' = 0.01 "Start value of mass fractions m_i/m";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XEva_start[2]' = 0.99 "Start value of mass fractions m_i/m";
      parameter Real 'x_start[1]' = 0 "Initial or guess values of states";
      parameter Real 'x_start[2]' = 0 "Initial or guess values of states";
      parameter Real 'x_start[3]' = 0 "Initial or guess values of states";
      parameter Real yRefIne_start = 0 "Initial or guess value of output (= state)";
      constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state (only affects fluid-models)";
      constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state (only affects fluid-models)";
      constant Boolean machineType = true "=true if heat pump; =false if chiller";
      constant Boolean show_TPort = false "= true, if actual temperature at port is computed";
      constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
      constant Boolean homotopyInitialization = false "= true, use homotopy method";
      parameter Boolean linearized = false "= true, use linear relation between m_flow and dp for any flow rate";
    protected
      record port_a1_rec
        Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
        Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
        Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_a1_rec;
    public
      port_a1_rec port_a1;
    protected
      record port_b1_rec
        Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
        Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
        Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_b1_rec;
    public
      port_b1_rec port_b1;
    protected
      record port_a2_rec
        Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
        Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
        Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_a2_rec;
    public
      port_a2_rec port_a2;
    protected
      record port_b2_rec
        Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
        Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
        Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_b2_rec;
    public
      port_b2_rec port_b2;
    protected
      record innerCycle_rec
        constant Boolean use_rev = false "True if the vapour compression machine is reversible";
        constant Real scalingFactor = 1.35 "Scaling factor of vapour compression machine";
        Modelica_Blocks_Interfaces_RealOutput QCon(unit = "W", displayUnit = "kW") "Heat Flow to condenser";
        Modelica_Blocks_Interfaces_RealOutput QEva(unit = "W", displayUnit = "kW") "Heat flow from evaporator";
        Modelica_Blocks_Interfaces_RealOutput Pel(unit = "W", displayUnit = "kW") "Electrical power consumed by compressor";
      protected
        record sigBus_rec
          Real nSet "Relative rotational speed of compressor between 0 and 1";
          Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
          Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
          Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
          Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
          Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
          Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
          Modelica.SIunits.Power PelMea "Total electrical active power";
          Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
          Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
          constant Real iceFacMea = 1.0 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
        end sigBus_rec;
      public
        sigBus_rec sigBus;
      protected
        record switchQEva_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W", displayUnit = "kW") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          constant Modelica_Blocks_Interfaces_RealInput u3(unit = "W", displayUnit = "kW") = 0 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
        end switchQEva_rec;
      public
        switchQEva_rec switchQEva;
      protected
        record switchQCon_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W", displayUnit = "kW") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          constant Modelica_Blocks_Interfaces_RealInput u3(unit = "W", displayUnit = "kW") = 0.0 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
        end switchQCon_rec;
      public
        switchQCon_rec switchQCon;
      protected
        record switchPel_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W", displayUnit = "kW") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          constant Modelica_Blocks_Interfaces_RealInput u3(unit = "W", displayUnit = "kW") = 0.0 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
        end switchPel_rec;
      public
        switchPel_rec switchPel;
      protected
        record PerformanceDataHPHeating_rec
          Modelica_Blocks_Interfaces_RealOutput Pel(unit = "W", displayUnit = "kW") "Electrical Power consumed by HP";
          Modelica_Blocks_Interfaces_RealOutput QCon(unit = "W", displayUnit = "kW") "Heat flow rate through Condenser";
          Modelica_Blocks_Interfaces_RealOutput QEva(unit = "W", displayUnit = "kW") "Heat flow rate through Evaporator";
          constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
          constant Boolean extrapolation = true "False to hold last value";
          constant Boolean printAsserts = false "WARNING: This will lead to a lot of state-events if extrapolation occurs frequently! If extrapolation is enabled, the user will get warnings when extrapolation occurs.";
        protected
          record sigBus_rec
            Real nSet "Relative rotational speed of compressor between 0 and 1";
            Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
            Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
            Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
            Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
            Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
            Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
            Modelica.SIunits.Power PelMea "Total electrical active power";
            Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
            Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
            constant Real iceFacMea = 1.0 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
          end sigBus_rec;
        public
          sigBus_rec sigBus;
        protected
          record calcRedQCon_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = 1 "Gain of input signal 2";
          end calcRedQCon_rec;
        public
          calcRedQCon_rec calcRedQCon annotation(Dialog);
        protected
          record proRedQEva_rec
            constant Modelica_Blocks_Interfaces_RealInput u1 = 1.0 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end proRedQEva_rec;
        public
          proRedQEva_rec proRedQEva;
        protected
          record dataTable_rec
            parameter Real 'tableQdot_con[1,1]' = 0.0 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,2]' = -13.9 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,3]' = -8.3 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,4]' = -2.8 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,5]' = 2.8 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,6]' = 8.3 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,7]' = 13.9 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,8]' = 19.4 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,1]' = 18 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,2]' = 1800 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,3]' = 2640 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,4]' = 3430 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,5]' = 4330 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,6]' = 5370 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,7]' = 6540 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,8]' = 7850 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,1]' = 21 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,2]' = 1610 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,3]' = 2380 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,4]' = 3260 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,5]' = 4130 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,6]' = 5140 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,7]' = 6280 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,8]' = 7570 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,1]' = 24 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,2]' = 1390 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,3]' = 2150 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,4]' = 3080 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,5]' = 3940 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,6]' = 4910 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,7]' = 6030 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,8]' = 7910 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,1]' = 0.0 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,2]' = -13.9 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,3]' = -8.3 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,4]' = -2.8 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,5]' = 2.8 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,6]' = 8.3 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,7]' = 13.9 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,8]' = 19.4 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,1]' = 18 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,2]' = 850 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,3]' = 930 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,4]' = 1010 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,5]' = 1110 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,6]' = 1220 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,7]' = 1370 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,8]' = 1570 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,1]' = 21 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,2]' = 980 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,3]' = 1060 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,4]' = 1160 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,5]' = 1250 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,6]' = 1370 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,7]' = 1530 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,8]' = 1730 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,1]' = 24 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,2]' = 1110 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,3]' = 1210 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,4]' = 1310 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,5]' = 1420 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,6]' = 1540 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,7]' = 1710 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,8]' = 1920 "Electrical power table; T in degC; Q_flow in W";
            parameter Modelica.SIunits.MassFlowRate mFlow_conNom = 0.1894736842105263 "Nominal mass flow rate in condenser";
            parameter Modelica.SIunits.MassFlowRate mFlow_evaNom = 0.75 "Nominal mass flow rate in evaporator";
            parameter Real 'tableUppBou[1,1]' = -15.0 "Points to define upper boundary for sink temperature";
            parameter Real 'tableUppBou[1,2]' = 25.0 "Points to define upper boundary for sink temperature";
            parameter Real 'tableUppBou[2,1]' = 20.0 "Points to define upper boundary for sink temperature";
            parameter Real 'tableUppBou[2,2]' = 25.0 "Points to define upper boundary for sink temperature";
          end dataTable_rec;
        public
          dataTable_rec dataTable annotation(Dialog);
        protected
          record Qdot_ConTable_rec
            Modelica_Blocks_Interfaces_RealInput u1(unit = "degC") "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2(unit = "degC") "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
            constant Boolean extrapolation = true "False to hold last value";
            constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
            parameter Real 'table[1,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
          protected
            record combiTable2D_rec
              Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
              Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
              constant Boolean tableOnFile = false "= true, if table is defined on file or in function usertab";
              parameter Real 'table[1,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Boolean verboseRead = true "= true, if info message that file is loading is to be printed";
              constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
              constant Modelica.Blocks.Types.Extrapolation extrapolation = Modelica.Blocks.Types.Extrapolation.LastTwoPoints "Extrapolation of data outside the definition range";
              constant Boolean verboseExtrapolation = false "= true, if warning messages are to be printed if table input is outside the definition range";
              parameter Real 'u_min[1]'(fixed=false) "Minimum abscissa value defined in table";
              parameter Real 'u_min[2]'(fixed=false) "Minimum abscissa value defined in table";
              parameter Real 'u_max[1]'(fixed=false) "Maximum abscissa value defined in table";
              parameter Real 'u_max[2]'(fixed=false) "Maximum abscissa value defined in table";
            end combiTable2D_rec;
          public
            combiTable2D_rec combiTable2D annotation(Dialog);
          protected
            record realPassThrough2_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough2_rec;
          public
            realPassThrough2_rec realPassThrough2;
          protected
            record realPassThrough1_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough1_rec;
          public
            realPassThrough1_rec realPassThrough1;
          end Qdot_ConTable_rec;
        public
          Qdot_ConTable_rec Qdot_ConTable annotation(Dialog);
        protected
          record P_eleTable_rec
            Modelica_Blocks_Interfaces_RealInput u1(unit = "degC") "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2(unit = "degC") "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
            constant Boolean extrapolation = true "False to hold last value";
            constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
            parameter Real 'table[1,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[1,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[2,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[3,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            parameter Real 'table[4,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
          protected
            record combiTable2D_rec
              Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
              Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
              constant Boolean tableOnFile = false "= true, if table is defined on file or in function usertab";
              parameter Real 'table[1,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[1,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[2,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[3,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,1]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,2]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,3]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,4]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,5]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,6]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,7]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Real 'table[4,8]'(fixed=false) "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Boolean verboseRead = true "= true, if info message that file is loading is to be printed";
              constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
              constant Modelica.Blocks.Types.Extrapolation extrapolation = Modelica.Blocks.Types.Extrapolation.LastTwoPoints "Extrapolation of data outside the definition range";
              constant Boolean verboseExtrapolation = false "= true, if warning messages are to be printed if table input is outside the definition range";
              parameter Real 'u_min[1]'(fixed=false) "Minimum abscissa value defined in table";
              parameter Real 'u_min[2]'(fixed=false) "Minimum abscissa value defined in table";
              parameter Real 'u_max[1]'(fixed=false) "Maximum abscissa value defined in table";
              parameter Real 'u_max[2]'(fixed=false) "Maximum abscissa value defined in table";
            end combiTable2D_rec;
          public
            combiTable2D_rec combiTable2D annotation(Dialog);
          protected
            record realPassThrough2_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough2_rec;
          public
            realPassThrough2_rec realPassThrough2;
          protected
            record realPassThrough1_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough1_rec;
          public
            realPassThrough1_rec realPassThrough1;
          end P_eleTable_rec;
        public
          P_eleTable_rec P_eleTable annotation(Dialog);
        protected
          record t_Ev_in_rec
            Modelica_Blocks_Interfaces_RealOutput y(unit = "degC") "Connector of Real output signal containing input signal u in another unit";
          end t_Ev_in_rec;
        public
          t_Ev_in_rec t_Ev_in;
        protected
          record t_Co_ou_rec
            Modelica_Blocks_Interfaces_RealOutput y(unit = "degC") "Connector of Real output signal containing input signal u in another unit";
          end t_Co_ou_rec;
        public
          t_Co_ou_rec t_Co_ou;
        protected
          record nTimesPel_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end nTimesPel_rec;
        public
          nTimesPel_rec nTimesPel;
        protected
          record nTimesQCon_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end nTimesQCon_rec;
        public
          nTimesQCon_rec nTimesQCon;
        protected
          record nTimesSF_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            constant Modelica_Blocks_Interfaces_RealInput u2 = 1.35 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end nTimesSF_rec;
        public
          nTimesSF_rec nTimesSF;
        end PerformanceDataHPHeating_rec;
      public
        PerformanceDataHPHeating_rec PerformanceDataHPHeating annotation(Dialog);
      protected
        record gainEva_rec
          constant Real k(unit = "1") = -1 "Gain value multiplied with input signal";
          Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
          Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
        end gainEva_rec;
      public
        gainEva_rec gainEva;
      protected
        record constZero_rec
          constant Real k = 0 "Constant output value";
          constant Modelica_Blocks_Interfaces_RealOutput y = 0.0 "Connector of Real output signal";
        end constZero_rec;
      public
        constZero_rec constZero;
      end innerCycle_rec;
    public
      innerCycle_rec innerCycle annotation(Dialog);
    protected
      record con_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
        Modelica.SIunits.MassFlowRate m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa") = 0.0 "Pressure difference between port_a and port_b";
        constant Boolean computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction";
        constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
        constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa", min = 0.0) = 0.0 "Pressure difference";
        constant Boolean linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate";
        constant Real deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar";
        constant Modelica.SIunits.Time tau = 30 "Time constant at nominal flow (if energyDynamics <> SteadyState)";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
        constant Modelica.Media.Interfaces.Types.AbsolutePressure p_start = 101325.0 "Start value of pressure";
        constant Modelica.Media.Interfaces.Types.Temperature T_start = 290.15 "Start value of temperature";
        constant Modelica.Media.Interfaces.Types.MassFraction 'X_start[1]'(quantity = "water") = 0.01 "Start value of mass fractions m_i/m";
        constant Modelica.Media.Interfaces.Types.MassFraction 'X_start[2]'(quantity = "air") = 0.99 "Start value of mass fractions m_i/m";
        constant Boolean is_con = true "Type of heat exchanger";
        parameter Modelica.SIunits.Volume V(fixed=false) "Volume in condenser";
        constant Boolean use_cap = false "False if capacity and heat losses are neglected";
        constant Modelica.SIunits.HeatCapacity C = 135.0 "Capacity of heat exchanger. If you want to neglace the dry mass of the heat exchanger, you can set this value to zero";
        parameter Modelica.SIunits.Temperature TCap_start(fixed=false) "Initial temperature of heat capacity";
        constant Modelica.SIunits.ThermalConductance GOut = 6.75 "Formular for calculation of heat transfer coefficient on the outside. If you want to simulate a heat exchanger with additional dry mass but without external heat losses, set the value to zero";
        constant Modelica_Blocks_Interfaces_RealOutput GInn = 0.0 "Formular for calculation of heat transfer coefficient on the inside";
        Modelica_Blocks_Interfaces_RealInput QFlow_in "Heat flow rate to the medium";
      protected
        record port_a_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record vol_rec
          constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Media.Interfaces.Types.AbsolutePressure p_start = 101325.0 "Start value of pressure";
          constant Modelica.Media.Interfaces.Types.Temperature T_start = 290.15 "Start value of temperature";
          constant Modelica.Media.Interfaces.Types.MassFraction 'X_start[1]'(quantity = "water") = 0.01 "Start value of mass fractions m_i/m";
          constant Modelica.Media.Interfaces.Types.MassFraction 'X_start[2]'(quantity = "air") = 0.99 "Start value of mass fractions m_i/m";
          constant Real mSenFac(min = 1.0) = 1 "Factor for scaling the sensible thermal mass of the volume";
          constant Boolean prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
          constant Boolean simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate";
          constant Integer nPorts = 2 "Number of ports";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports.";
          parameter Modelica.SIunits.Volume V(fixed=false) "Volume";
          Modelica.Media.Interfaces.Types.Temperature T "Temperature of the fluid";
          Modelica_Blocks_Interfaces_RealOutput U(unit = "J") "Internal energy of the component";
          Modelica.SIunits.Pressure p "Pressure of the fluid";
          Modelica_Blocks_Interfaces_RealOutput m(unit = "kg") "Mass of the component";
          Modelica.SIunits.MassFraction 'Xi[1]' "Species concentration of the fluid";
          Modelica_Blocks_Interfaces_RealOutput 'mXi[1]'(unit = "kg", min = 0.0) "Species mass of the component";
          constant Boolean use_C_flow = false "Set to true to enable input connector for trace substance";
        protected
          record 'ports[1]_rec'
            Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air") "Mass flow rate from the connection point into the component";
            Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
            Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[1]_rec';
        public
          'ports[1]_rec' 'ports[1]';
        protected
          record 'ports[2]_rec'
            Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air") "Mass flow rate from the connection point into the component";
            Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
            Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[2]_rec';
        public
          'ports[2]_rec' 'ports[2]';
        protected
          record heatPort_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end heatPort_rec;
        public
          heatPort_rec heatPort;
        end vol_rec;
      public
        vol_rec vol;
      protected
        record preDro_rec
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          Modelica.SIunits.MassFlowRate m_flow(nominal = 0.405) "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
          constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa", nominal = 1.0) = 0 "Pressure difference between port_a and port_b";
          constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
          constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa") = 0.0 "Pressure drop at nominal mass flow rate";
          constant Boolean linearized = false "= true, use linear relation between m_flow and dp for any flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_turbulent(min = 0.0) = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent";
          constant Real deltaM(min = 1E-06) = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
          constant Real k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
        protected
          record port_a_rec
            Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
            Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
            Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_a_rec;
        public
          port_a_rec port_a;
        protected
          record port_b_rec
            Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
            Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
            Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_b_rec;
        public
          port_b_rec port_b;
        end preDro_rec;
      public
        preDro_rec preDro;
      protected
        record preHea_rec
          constant Modelica.SIunits.Temperature T_ref = 293.15 "Reference temperature";
          constant Modelica.SIunits.LinearTemperatureCoefficient alpha = 0 "Temperature coefficient of heat flow rate";
        protected
          record port_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end port_rec;
        public
          port_rec port;
        end preHea_rec;
      public
        preHea_rec preHea;
      end con_rec;
    public
      con_rec con;
    protected
      record eva_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
        Modelica.SIunits.MassFlowRate m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa") = 0.0 "Pressure difference between port_a and port_b";
        constant Boolean computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction";
        constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
        constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa", min = 0.0) = 0.0 "Pressure difference";
        constant Boolean linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate";
        constant Real deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar";
        constant Modelica.SIunits.Time tau = 30 "Time constant at nominal flow (if energyDynamics <> SteadyState)";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
        constant Modelica.Media.Interfaces.Types.AbsolutePressure p_start = 101325.0 "Start value of pressure";
        constant Modelica.Media.Interfaces.Types.Temperature T_start = 281.15 "Start value of temperature";
        constant Modelica.Media.Interfaces.Types.MassFraction 'X_start[1]'(quantity = "water") = 0.01 "Start value of mass fractions m_i/m";
        constant Modelica.Media.Interfaces.Types.MassFraction 'X_start[2]'(quantity = "air") = 0.99 "Start value of mass fractions m_i/m";
        constant Boolean is_con = false "Type of heat exchanger";
        parameter Modelica.SIunits.Volume V(fixed=false) "Volume in condenser";
        constant Boolean use_cap = false "False if capacity and heat losses are neglected";
        constant Modelica.SIunits.HeatCapacity C = 135.0 "Capacity of heat exchanger. If you want to neglace the dry mass of the heat exchanger, you can set this value to zero";
        parameter Modelica.SIunits.Temperature TCap_start(fixed=false) "Initial temperature of heat capacity";
        constant Modelica.SIunits.ThermalConductance GOut = 6.75 "Formular for calculation of heat transfer coefficient on the outside. If you want to simulate a heat exchanger with additional dry mass but without external heat losses, set the value to zero";
        constant Modelica_Blocks_Interfaces_RealOutput GInn = 0.0 "Formular for calculation of heat transfer coefficient on the inside";
        Modelica_Blocks_Interfaces_RealInput QFlow_in "Heat flow rate to the medium";
      protected
        record port_a_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record vol_rec
          constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Media.Interfaces.Types.AbsolutePressure p_start = 101325.0 "Start value of pressure";
          constant Modelica.Media.Interfaces.Types.Temperature T_start = 281.15 "Start value of temperature";
          constant Modelica.Media.Interfaces.Types.MassFraction 'X_start[1]'(quantity = "water") = 0.01 "Start value of mass fractions m_i/m";
          constant Modelica.Media.Interfaces.Types.MassFraction 'X_start[2]'(quantity = "air") = 0.99 "Start value of mass fractions m_i/m";
          constant Real mSenFac(min = 1.0) = 1 "Factor for scaling the sensible thermal mass of the volume";
          constant Boolean prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
          constant Boolean simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate";
          constant Integer nPorts = 2 "Number of ports";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports.";
          parameter Modelica.SIunits.Volume V(fixed=false) "Volume";
          Modelica.Media.Interfaces.Types.Temperature T "Temperature of the fluid";
          Modelica_Blocks_Interfaces_RealOutput U(unit = "J") "Internal energy of the component";
          Modelica.SIunits.Pressure p "Pressure of the fluid";
          Modelica_Blocks_Interfaces_RealOutput m(unit = "kg") "Mass of the component";
          Modelica.SIunits.MassFraction 'Xi[1]' "Species concentration of the fluid";
          Modelica_Blocks_Interfaces_RealOutput 'mXi[1]'(unit = "kg", min = 0.0) "Species mass of the component";
          constant Boolean use_C_flow = false "Set to true to enable input connector for trace substance";
        protected
          record 'ports[1]_rec'
            Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air") "Mass flow rate from the connection point into the component";
            Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
            Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[1]_rec';
        public
          'ports[1]_rec' 'ports[1]';
        protected
          record 'ports[2]_rec'
            Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air") "Mass flow rate from the connection point into the component";
            Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
            Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[2]_rec';
        public
          'ports[2]_rec' 'ports[2]';
        protected
          record heatPort_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end heatPort_rec;
        public
          heatPort_rec heatPort;
        end vol_rec;
      public
        vol_rec vol;
      protected
        record preDro_rec
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          Modelica.SIunits.MassFlowRate m_flow(nominal = 0.405) "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
          constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa", nominal = 1.0) = 0 "Pressure difference between port_a and port_b";
          constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
          constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa") = 0.0 "Pressure drop at nominal mass flow rate";
          constant Boolean linearized = false "= true, use linear relation between m_flow and dp for any flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_turbulent(min = 0.0) = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent";
          constant Real deltaM(min = 1E-06) = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
          constant Real k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
        protected
          record port_a_rec
            Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
            Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
            Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_a_rec;
        public
          port_a_rec port_a;
        protected
          record port_b_rec
            Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
            Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
            Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_b_rec;
        public
          port_b_rec port_b;
        end preDro_rec;
      public
        preDro_rec preDro;
      protected
        record preHea_rec
          constant Modelica.SIunits.Temperature T_ref = 293.15 "Reference temperature";
          constant Modelica.SIunits.LinearTemperatureCoefficient alpha = 0 "Temperature coefficient of heat flow rate";
        protected
          record port_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end port_rec;
        public
          port_rec port;
        end preHea_rec;
      public
        preHea_rec preHea;
      end eva_rec;
    public
      eva_rec eva;
    protected
      record heatFlowIneEva_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        constant Integer n = 3 "Order of filter";
        constant Modelica.SIunits.Frequency f = 0.015 "Cut-off frequency";
        constant Boolean normalized = true "= true, if amplitude at f_cut is 3 dB, otherwise unmodified filter";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
        parameter Real 'x_start[1]'(fixed=false) "Initial or guess values of states";
        parameter Real 'x_start[2]'(fixed=false) "Initial or guess values of states";
        parameter Real 'x_start[3]'(fixed=false) "Initial or guess values of states";
        parameter Real y_start(fixed=false) "Initial value of output (remaining states are in steady state)";
        Real 'x[1]' "Filter states";
        Real '_x[1]_der' "der(Filter states)";
        Real 'x[2]' "Filter states";
        Real '_x[2]_der' "der(Filter states)";
        Real 'x[3]' "Filter states";
        Real '_x[3]_der' "der(Filter states)";
      end heatFlowIneEva_rec;
    public
      heatFlowIneEva_rec heatFlowIneEva;
    protected
      record heatFlowIneCon_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        constant Integer n = 3 "Order of filter";
        constant Modelica.SIunits.Frequency f = 0.015 "Cut-off frequency";
        constant Boolean normalized = true "= true, if amplitude at f_cut is 3 dB, otherwise unmodified filter";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
        parameter Real 'x_start[1]'(fixed=false) "Initial or guess values of states";
        parameter Real 'x_start[2]'(fixed=false) "Initial or guess values of states";
        parameter Real 'x_start[3]'(fixed=false) "Initial or guess values of states";
        parameter Real y_start(fixed=false) "Initial value of output (remaining states are in steady state)";
        Real 'x[1]' "Filter states";
        Real '_x[1]_der' "der(Filter states)";
        Real 'x[2]' "Filter states";
        Real '_x[2]_der' "der(Filter states)";
        Real 'x[3]' "Filter states";
        Real '_x[3]_der' "der(Filter states)";
      end heatFlowIneCon_rec;
    public
      heatFlowIneCon_rec heatFlowIneCon;
    protected
      record sigBus_rec
        Real nSet "Relative rotational speed of compressor between 0 and 1";
        Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
        Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
        Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
        Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
        Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
        Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
        Modelica.SIunits.Power PelMea "Total electrical active power";
        Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
        Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
        constant Real iceFacMea = 1.0 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
      end sigBus_rec;
    public
      sigBus_rec sigBus;
    protected
      record senT_a2_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
        Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
        constant Modelica.SIunits.Temperature T_start = 281.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        parameter Modelica.SIunits.Temperature TAmb(fixed=false) "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_a2_rec;
    public
      senT_a2_rec senT_a2;
    protected
      record senT_b2_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
        Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
        constant Modelica.SIunits.Temperature T_start = 281.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        parameter Modelica.SIunits.Temperature TAmb(fixed=false) "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_b2_rec;
    public
      senT_b2_rec senT_b2;
    protected
      record mFlow_eva_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        Modelica_Blocks_Interfaces_RealOutput m_flow(unit = "kg/s", quantity = "MassFlowRate") "Mass flow rate from port_a to port_b";
      protected
        record port_a_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end mFlow_eva_rec;
    public
      mFlow_eva_rec mFlow_eva;
    protected
      record senT_b1_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
        Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
        constant Modelica.SIunits.Temperature T_start = 290.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        parameter Modelica.SIunits.Temperature TAmb(fixed=false) "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_b1_rec;
    public
      senT_b1_rec senT_b1;
    protected
      record senT_a1_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
        Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
        constant Modelica.SIunits.Temperature T_start = 290.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        parameter Modelica.SIunits.Temperature TAmb(fixed=false) "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_a1_rec;
    public
      senT_a1_rec senT_a1;
    protected
      record mFlow_con_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        Modelica_Blocks_Interfaces_RealOutput m_flow(unit = "kg/s", quantity = "MassFlowRate") "Mass flow rate from port_a to port_b";
      protected
        record port_a_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
          Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
          Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end mFlow_con_rec;
    public
      mFlow_con_rec mFlow_con;
    protected
      record greaterThreshold_rec
        constant Real threshold = 1E-15 "Comparison with respect to threshold";
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
      end greaterThreshold_rec;
    public
      greaterThreshold_rec greaterThreshold;
    end heaPum_rec;
  public
    heaPum_rec heaPum annotation(Dialog);
  protected
    record heaOn_rec
      parameter Boolean k = true "Constant output value";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
    end heaOn_rec;
  public
    heaOn_rec heaOn annotation(Dialog);
  protected
    record senTAct_rec
      constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
      constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.3 "Nominal mass flow rate, used for regularization near zero flow";
      constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
      constant Modelica.SIunits.Time tau(min = 0.0) = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
      constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
      Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
      Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
      constant Modelica.SIunits.Temperature T_start = 303.15 "Initial or guess value of output (= state)";
      constant Boolean transferHeat = false "if true, temperature T converges towards TAmb when no flow";
      constant Modelica.SIunits.Temperature TAmb = 291.15 "Fixed ambient temperature for heat transfer";
      constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200 "Time constant for heat transfer, default 20 minutes";
    protected
      record port_a_rec
        Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60) "Mass flow rate from the connection point into the component";
        Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
        Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_a_rec;
    public
      port_a_rec port_a;
    protected
      record port_b_rec
        Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", max = 1E+60) "Mass flow rate from the connection point into the component";
        Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
        Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(nominal = 45300.945) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_b_rec;
    public
      port_b_rec port_b;
    end senTAct_rec;
  public
    senTAct_rec senTAct;
  protected
    record iceFac_rec
      constant Real k = 1 "Constant output value";
      constant Modelica_Blocks_Interfaces_RealOutput y = 1.0 "Connector of Real output signal";
    end iceFac_rec;
  public
    iceFac_rec iceFac;
  protected
    record nSetGai_rec
      parameter Real k(unit = "1") = 0.5 "Gain value multiplied with input signal";
      Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
      Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
    end nSetGai_rec;
  public
    nSetGai_rec nSetGai annotation(Dialog);
  protected
    record sigBus1_rec
      Real nSet "Relative rotational speed of compressor between 0 and 1";
      Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
      Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
      Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
      Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
      Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
      Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
      Modelica.SIunits.Power PelMea "Total electrical active power";
      Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
      Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
      constant Real iceFacMea = 1 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
    end sigBus1_rec;
  public
    sigBus1_rec sigBus1;
  protected
    record port_a_rec
      Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air") "Mass flow rate from the connection point into the component";
      parameter Modelica.Media.Interfaces.Types.AbsolutePressure p(fixed=false) "Thermodynamic pressure in the connection point";
      Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end port_a_rec;
  public
    port_a_rec port_a;
  protected
    record port_b_rec
      Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air") "Mass flow rate from the connection point into the component";
      Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
      Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end port_b_rec;
  public
    port_b_rec port_b;
  end rtuHP_rec;
public
  rtuHP_rec rtuHP annotation(Dialog);
protected
  record supFan_rec
    constant Integer nPorts = 1 "Number of ports";
    constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
    parameter Modelica.Media.Interfaces.Types.MassFraction 'X[1]'(quantity = "water") = 0.01 "Fixed value of composition";
    parameter Modelica.Media.Interfaces.Types.MassFraction 'X[2]'(quantity = "air") = 0.99 "Fixed value of composition";
    parameter Modelica.SIunits.MassFlowRate m_flow = 0 "Fixed mass flow rate going out of the fluid port";
    parameter Modelica.Media.Interfaces.Types.Temperature T = 293.15 "Fixed value of temperature";
    Modelica_Blocks_Interfaces_RealInput m_flow_in(unit = "kg/s") "Prescribed mass flow rate";
    Modelica_Blocks_Interfaces_RealInput T_in(unit = "K", displayUnit = "degC") "Prescribed boundary temperature";
  protected
    record 'ports[1]_rec'
      Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
      Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
      Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end 'ports[1]_rec';
  public
    'ports[1]_rec' 'ports[1]';
  end supFan_rec;
public
  supFan_rec supFan annotation(Dialog);
protected
  record roo_rec
    constant Integer nPorts = 1 "Number of ports";
    constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
    parameter Modelica.Media.Interfaces.Types.MassFraction 'X[1]'(quantity = "water") = 0.01 "Fixed value of composition";
    parameter Modelica.Media.Interfaces.Types.MassFraction 'X[2]'(quantity = "air") = 0.99 "Fixed value of composition";
    parameter Modelica.Media.Interfaces.Types.AbsolutePressure p = 101325 "Fixed value of pressure";
    parameter Modelica.Media.Interfaces.Types.Temperature T = 293.15 "Fixed value of temperature";
  protected
    record 'ports[1]_rec'
      Modelica_Media_Interfaces_PartialMedium_MassFlowRate m_flow(quantity = "MassFlowRate.Air", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
      Modelica.Media.Interfaces.Types.AbsolutePressure p "Thermodynamic pressure in the connection point";
      parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy h_outflow(fixed=false) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Modelica.Media.Interfaces.Types.MassFraction 'Xi_outflow[1]' "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end 'ports[1]_rec';
  public
    'ports[1]_rec' 'ports[1]';
  end roo_rec;
public
  roo_rec roo annotation(Dialog);
protected
  record rtuConFMU_rec
    parameter Real k_hea(fixed=false) "Proportional gain of heating controller";
    parameter Modelica.SIunits.Time Ti_hea(fixed=false) "Integral time constant of heating controller";
    parameter Modelica.SIunits.ThermodynamicTemperature maxSAT(fixed=false) "max supply air temperature";
    parameter Real uLowSta1(fixed=false) "PI lower bound to activate stage 1";
    parameter Real uUppSta1(fixed=false) "PI upper bound to activate stage 1";
    parameter Real uLowSta2(fixed=false) "PI lower bound to activate stage 2";
    parameter Real uUppSta2(fixed=false) "PI upper bound to activate stage 2";
    parameter Real kSta1(fixed=false) "PI center line to activate stage 1";
    parameter Real kSta2(fixed=false) "PI center line to activate stage 2";
    parameter Real banSta1(fixed=false) "PI band to activate stage 1";
    parameter Real banSta2(fixed=false) "PI band to activate stage 2";
    Modelica_Blocks_Interfaces_RealInput TSetRooHea(unit = "K", displayUnit = "degC") "Zone heating setpoint temperature";
    Modelica_Blocks_Interfaces_RealInput TRoo(unit = "K", displayUnit = "degC") "Zone temperature measurement";
    Modelica_Blocks_Interfaces_RealOutput heaSta(unit = "1") "Control signal for heating";
    Modelica_Blocks_Interfaces_RealInput TSup(unit = "K", displayUnit = "degC") "Supply air temperature";
    Modelica_Blocks_Interfaces_BooleanOutput heaCal "Control signal for heating";
    Modelica_Blocks_Interfaces_RealOutput PI_y "Control signal for heating";
  protected
    record conHea_rec
      Modelica_Blocks_Interfaces_RealInput u_s "Connector of setpoint input signal";
      Modelica_Blocks_Interfaces_RealInput u_m "Connector of measurement input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of actuator output signal";
      Real controlError "Control error (set point - measurement)";
      constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
      parameter Real k(min = 0.0, fixed=false) "Gain of controller";
      parameter Modelica.SIunits.Time Ti(min = 1E-60, fixed=false) "Time constant of Integrator block";
      parameter Modelica.SIunits.Time Td(min = 0.0) = 0.1 "Time constant of Derivative block";
      constant Real yMax = 1 "Upper limit of output";
      constant Real yMin = 0 "Lower limit of output";
      parameter Real wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
      parameter Real wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
      parameter Real Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
      parameter Real Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
      constant Modelica.Blocks.Types.InitPID initType = Modelica.Blocks.Types.InitPID.InitialOutput "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
      constant Real xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
      parameter Real xd_start = 0 "Initial or guess value for state of derivative block";
      constant Real y_start = 0 "Initial value of output";
      constant Boolean strict = true "= true, if strict limits with noEvent(..)";
      parameter Boolean reverseAction = false "Set to true for throttling the water flow rate through a cooling coil controller";
      constant Buildings_Types_Reset reset = Buildings_Types_Reset.Parameter "Type of controller output reset";
      constant Real y_reset = 0.0 "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == Buildings.Types.Reset.Parameter";
      Modelica_Blocks_Interfaces_BooleanInput trigger "Resets the controller output when trigger becomes true";
    protected
      record addP_rec
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
        Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        parameter Real k1(fixed=false) "Gain of input signal 1";
        parameter Real k2(fixed=false) "Gain of input signal 2";
      end addP_rec;
    public
      addP_rec addP;
    protected
      record P_rec
        parameter Real k(unit = "1") = 1 "Gain value multiplied with input signal";
        Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
        Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
      end P_rec;
    public
      P_rec P annotation(Dialog);
    protected
      record addPID_rec
        constant Real k1 = 1 "Gain of input signal 1";
        constant Real k2 = 1 "Gain of input signal 2";
        constant Real k3 = 1 "Gain of input signal 3";
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
        constant Modelica_Blocks_Interfaces_RealInput u2 = 0 "Connector of Real input signal 2";
        Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end addPID_rec;
    public
      addPID_rec addPID;
    protected
      record I_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        Real _y_der "der(Connector of Real output signal)";
        parameter Real k(unit = "1", fixed=false) "Integrator gain";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
        constant Real y_start = 0.0 "Initial or guess value of output (= state)";
        constant Buildings_Types_Reset reset = Buildings_Types_Reset.Input "Type of integrator reset";
        constant Real y_reset = 0.0 "Value to which integrator is reset, used if reset = Buildings.Types.Reset.Parameter";
        Modelica_Blocks_Interfaces_RealInput y_reset_in "Input signal for state to which integrator is reset, enabled if reset = Buildings.Types.Reset.Input";
        Modelica_Blocks_Interfaces_BooleanInput trigger "Resets the integrator output when trigger becomes true";
      end I_rec;
    public
      I_rec I;
    end conHea_rec;
  public
    conHea_rec conHea annotation(Dialog);
  protected
    record swiHea_rec
      Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
      Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end swiHea_rec;
  public
    swiHea_rec swiHea;
  protected
    record offHea_rec
      parameter Real k = 0 "Constant output value";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end offHea_rec;
  public
    offHea_rec offHea annotation(Dialog);
  protected
    record onOffConSupHeatSetPoi_rec
      Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
      parameter Real bandwidth = 0.5 "Bandwidth around reference signal";
      parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
    end onOffConSupHeatSetPoi_rec;
  public
    onOffConSupHeatSetPoi_rec onOffConSupHeatSetPoi annotation(Dialog);
  protected
    record UpperLimSup_rec
      parameter Real k(fixed=false) "Constant output value";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end UpperLimSup_rec;
  public
    UpperLimSup_rec UpperLimSup;
  protected
    record heatStage_rec
      parameter Real uLowSta1(fixed=false) "PI lower bound to activate stage 1";
      parameter Real uUppSta1(fixed=false) "PI upper bound to activate stage 1";
      parameter Real uLowSta2(fixed=false) "PI lower bound to activate stage 2";
      parameter Real uUppSta2(fixed=false) "PI upper bound to activate stage 2";
      parameter Real kSta1(fixed=false) "PI center line to activate stage 1";
      parameter Real kSta2(fixed=false) "PI center line to activate stage 2";
      parameter Real banSta1(fixed=false) "PI band to activate stage 1";
      parameter Real banSta2(fixed=false) "PI band to activate stage 2";
      Modelica_Blocks_Interfaces_RealInput uHea "Zone temperature measurement";
      Modelica_Blocks_Interfaces_RealOutput y_Sta "Zone temperature measurement";
    protected
      record realToBoolean1_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
        parameter Real threshold = 0.001 "Output signal y is true, if input u >= threshold";
      end realToBoolean1_rec;
    public
      realToBoolean1_rec realToBoolean1 annotation(Dialog);
    protected
      record add_rec
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
        Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        parameter Real k1 = 1 "Gain of input signal 1";
        parameter Real k2 = 1 "Gain of input signal 2";
      end add_rec;
    public
      add_rec add annotation(Dialog);
    protected
      record switch4_rec
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
        Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
        Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end switch4_rec;
    public
      switch4_rec switch4;
    protected
      record const7_rec
        parameter Real k = 0 "Constant output value";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end const7_rec;
    public
      const7_rec const7 annotation(Dialog);
    protected
      record booleanToReal_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Connector of Boolean input signal";
        parameter Real realTrue = 1.0 "Output signal for true Boolean input";
        parameter Real realFalse = 0.0 "Output signal for false Boolean input";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end booleanToReal_rec;
    public
      booleanToReal_rec booleanToReal annotation(Dialog);
    protected
      record booleanToReal1_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Connector of Boolean input signal";
        parameter Real realTrue = 1.0 "Output signal for true Boolean input";
        parameter Real realFalse = 0.0 "Output signal for false Boolean input";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end booleanToReal1_rec;
    public
      booleanToReal1_rec booleanToReal1 annotation(Dialog);
    protected
      record const1_rec
        parameter Real k(fixed=false) "Constant output value";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end const1_rec;
    public
      const1_rec const1;
    protected
      record onOffSta1_rec
        Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
        parameter Real bandwidth(fixed=false) "Bandwidth around reference signal";
        parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
      end onOffSta1_rec;
    public
      onOffSta1_rec onOffSta1 annotation(Dialog);
    protected
      record const2_rec
        parameter Real k(fixed=false) "Constant output value";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end const2_rec;
    public
      const2_rec const2;
    protected
      record onOffSta2_rec
        Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
        parameter Real bandwidth(fixed=false) "Bandwidth around reference signal";
        parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
      end onOffSta2_rec;
    public
      onOffSta2_rec onOffSta2 annotation(Dialog);
    protected
      record not1_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Boolean input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Boolean output signal";
      end not1_rec;
    public
      not1_rec not1;
    protected
      record not2_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Boolean input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Boolean output signal";
      end not2_rec;
    public
      not2_rec not2;
    end heatStage_rec;
  public
    heatStage_rec heatStage annotation(Dialog);
  protected
    record swiTim_rec
      Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
      Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end swiTim_rec;
  public
    swiTim_rec swiTim;
  protected
    record onOffConHea_rec
      Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
      Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
      parameter Real bandwidth = 1 "Bandwidth around reference signal";
      parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
    end onOffConHea_rec;
  public
    onOffConHea_rec onOffConHea annotation(Dialog);
  protected
    record UppLimSwi_rec
      Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
      Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end UppLimSwi_rec;
  public
    UppLimSwi_rec UppLimSwi;
  protected
    record NotLim_rec
      Modelica_Blocks_Interfaces_BooleanInput u "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
    end NotLim_rec;
  public
    NotLim_rec NotLim;
  protected
    record onDelay_rec
      Modelica_Blocks_Interfaces_BooleanInput u "Boolean input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Boolean output signal";
      parameter Modelica.SIunits.Time delayTime = 120 "Delay time";
    end onDelay_rec;
  public
    onDelay_rec onDelay annotation(Dialog);
  protected
    record realToBoolean_rec
      Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
      parameter Real threshold = 0.5 "Output signal y is true, if input u >= threshold";
    end realToBoolean_rec;
  public
    realToBoolean_rec realToBoolean annotation(Dialog);
  protected
    record realToBoolean1_rec
      Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
      parameter Real threshold = 0.1 "Output signal y is true, if input u >= threshold";
    end realToBoolean1_rec;
  public
    realToBoolean1_rec realToBoolean1 annotation(Dialog);
  end rtuConFMU_rec;
public
  rtuConFMU_rec rtuConFMU annotation(Dialog);
  parameter Real _u_m_flow_start = 0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_m_flow(unit = "kg/s", nominal = 0.405, min = -100000.0, max = 100000.0, start = _u_m_flow_start)
  annotation (Placement(transformation(extent={{-124,47},{-84,87}})));
  parameter Real _u_TDryBul_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_TDryBul(unit = "K", displayUnit = "degC", start = _u_TDryBul_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,14},{-84,54}})));
  parameter Real _u_TRoo_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_TRoo(unit = "K", displayUnit = "degC", start = _u_TRoo_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,-20},{-84,20}})));
  parameter Real _u_TRooSetPoi_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_TRooSetPoi(unit = "K", displayUnit = "degC", start = _u_TRooSetPoi_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,-53},{-84,-13}})));
  parameter Real _u_TMix_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_TMix(unit = "K", displayUnit = "degC", start = _u_TMix_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,-86},{-84,-46}})));
  Modelica.Blocks.Interfaces.RealOutput y_TSup(unit = "K", displayUnit = "degC", min = 0.0)
  annotation (Placement(transformation(extent={{100,40},{140,80}})));
  Modelica.Blocks.Interfaces.RealOutput y_PEleHP(unit = "W")
  annotation (Placement(transformation(extent={{100,0},{140,40}})));
  Modelica.Blocks.Interfaces.BooleanOutput y_HeaCal
  annotation (Placement(transformation(extent={{100,-40},{140,0}})));
  Modelica.Blocks.Interfaces.RealOutput y_PI
  annotation (Placement(transformation(extent={{100,-80},{140,-40}})));
public
  parameter String fmi_instanceName="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  constant Integer fmi_NumberOfContinuousStates = 16;
  constant Integer fmi_NumberOfEventIndicators = 48;
protected
  Real fmi_x[fmi_NumberOfContinuousStates](each fixed=false) "States";
  Real fmi_z[fmi_NumberOfEventIndicators] "Event indicators";
  Boolean fmi_z_positive[fmi_NumberOfEventIndicators](each start=false, fixed=true);
  fmi_Functions.fmiModel fmi;
  parameter Real fmi_Initialized(fixed=false);
  Real myTime;
  Boolean fmi_StepEvent;
  Boolean fmi_NewStates;
  Boolean fmi_NewStates2(start=false,fixed=true);
  Real fmi_TNext(start=fmi_TNext_Start,fixed=true);
  parameter Real fmi_TNext_Start(fixed=false);
package fmi_Functions
  class fmiModel
  extends ExternalObject;
    function constructor "Initialize FMI model"
      extends Modelica.Icons.Function;
      input String instanceName;
      input Boolean loggingOn;
      output fmiModel fmi;
      external"C" fmi = hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiInstantiateModel2(instanceName, loggingOn)
      annotation(Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_Instantiate_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_Instantiate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_MYSTRCMP_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_MYSTRCMP_C 1
int hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021mystrcmp(const void *_a, const void *_b) {
  char *a = _a;
  char *const *b = _b;
  return strcmp(a, *b);
}
#endif
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021Logger(fmiComponent c, fmiString instanceName, fmiStatus status,
	 fmiString category, fmiString message, ...) {
  char msg[4096];
  char buf[4096];
  int len;
  va_list ap;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len <4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmiFatal:
      ModelicaMessage(\"[fmiFatal]: \");
      break;
    case fmiError:
      ModelicaMessage(\"[fmiError]: \");
      break;
    case fmiDiscard:
      ModelicaMessage(\"[fmiDiscard]: \");
      break;
    case fmiWarning:
      ModelicaMessage(\"[fmiWarning]: \");
      break;
    case fmiOK:
      ModelicaMessage(\"[fmiOK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiInstantiateModel2(const char*instanceName, fmiBoolean loggingOn) {
  static fmiMECallbackFunctions funcs = {&hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021Logger, &calloc, &free};
  struct dy_Extended* res;

  res = calloc(1, sizeof(struct dy_Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibrary(\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1.so\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1.so) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiateModel=(fmiInstantiateModelFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiInstantiateModel\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInstantiateModel!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInstantiateModel\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiFreeModelInstance=(fmiFreeModelInstanceFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiFreeModelInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmiFreeModelInstance!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiFreeModelInstance\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetTime=(fmiSetTimeFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiSetTime\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetTime!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetTime\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetContinuousStates=(fmiSetContinuousStatesFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiSetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetContinuousStates=(fmiGetContinuousStatesFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiGetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiCompletedIntegratorStep=(fmiCompletedIntegratorStepFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiCompletedIntegratorStep\"))) {
      ModelicaError(\"GetProcAddress failed for fmiCompletedIntegratorStep!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiCompletedIntegratorStep\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEventUpdate=(fmiEventUpdateFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiEventUpdate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiEventUpdate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEventUpdate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiInitialize=(fmiInitializeFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiInitialize\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInitialize!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInitialize\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDerivatives=(fmiGetDerivativesFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiGetDerivatives\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetDerivatives!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetDerivatives\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetEventIndicators=(fmiGetEventIndicatorsFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiGetEventIndicators\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetEventIndicators!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetEventIndicators\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmiTerminateFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiTerminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiTerminate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiTerminate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmiSetRealFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiSetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmiGetRealFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiGetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmiSetIntegerFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiSetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmiGetIntegerFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiGetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmiSetBooleanFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiSetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmiGetBooleanFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiGetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmiSetStringFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiSetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmiGetStringFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiGetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetString!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmiSetDebugLoggingFunc)GetProcAddress(res->hInst,\"hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmiSetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetDebugLogging!\");
      return 0;
    }
    res->m=res->dyFmiInstantiateModel(instanceName, \"{fc2ae65e-a3d7-409d-ac4c-026813d78021}\", funcs, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->dyFirstTimeEvent=1e37;res->currentMode=dyInstantiationMode;}
  }
  return res;
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end constructor;

    function destructor "Release storage of FMI model"
      extends Modelica.Icons.Function;
      input fmiModel fmi;
      external"C"
                 hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiFreeModelInstance2(fmi);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_Free_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_Free_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiFreeModelInstance2(void*m) {
  struct dy_Extended*a=m;
  if (a) {
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeModelInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end destructor;
  end fmiModel;

    function fmiSetTime
      input fmiModel fmi;
      input Real ti;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetTime2(fmi, ti);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetTime_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetTime_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetTime2(void*m, double ti) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyInstantiationMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti>a->dyTime || (a->currentMode==dyEventMode && ti==a->dyTime && !isModelicaEvent())){
      a->currentMode=dyContinuousTimeMode;
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti <= a->dyTime && a->currentMode == dyContinuousTimeMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK ) ModelicaError(\"SetTime failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiSetTime;

    function fmiSetContinuousStates
      input fmiModel fmi;
      input Real x[:];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetContinuousStates2(
        fmi,
        x,
        size(x, 1));
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetContinuousStates_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetContinuousStates2(void*m, const double*x, size_t nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      status=a->dyFmiSetContinuousStates(a->m, x, nx);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetContinuousStates failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiSetContinuousStates;

    function fmiGetContinuousStates
      input fmiModel fmi;
      input Integer nx;
      output Real x[nx];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetContinuousStates2(
        fmi,
        x,
        nx);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetContinuousStates_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetContinuousStates2(void*m, double*x, int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetContinuousStates(a->m, x, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetContinuousStates failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiGetContinuousStates;

    function fmiCompletedStep
      input fmiModel fmi;
      output Real crossing;
      external"C" crossing = hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiCompletedStep2(fmi);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_CompletedStep_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_CompletedStep_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiCompletedStep2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if (a->dyTime>a->dyLastTime) {
      fmiBoolean b=0;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->dyLastTime=a->dyTime;
      if (b) a->dyTriggered=1;
    } else status=fmiOK;
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"CompletedIntegratorStep failed\");
  return a->dyTriggered && a->dyTime>=a->dyLastTime;
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiCompletedStep;

    function CompletedStep
      input fmiModel fmi;
      output Real crossing;
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      crossing := fmiCompletedStep(fmi);
      annotation(LateInline=true);
    end CompletedStep;

    function fmiEventUpdate
      input fmiModel fmi;
      output Real tnext;
      output Boolean stateReset;
      external"C" stateReset = hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiEventUpdate2(fmi, tnext);
      annotation(Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_EventUpdate_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_EventUpdate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
int hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiEventUpdate2(void*m, double*tnext){
  struct dy_Extended*a=m;
  fmiEventInfo ev;
  fmiStatus status=fmiFatal;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      fmiBoolean b;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->currentMode=dyEventMode;
    }
    status=a->dyFmiEventUpdate(a->m, 0, &ev);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
  }
  if (ev.terminateSimulation) terminate(\"Terminate signaled by FMU\");
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"EventUpdate failed\");
  *tnext=ev.nextEventTime;
  return ev.stateValuesChanged;
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiEventUpdate;

    function EventUpdate
      input fmiModel fmi;
      output Real tnext;
      output Boolean stateReset;
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      (tnext, stateReset) := fmiEventUpdate(fmi);
      annotation(LateInline=true);
    end EventUpdate;

    function fmiInitialize
      input fmiModel fmi;
      output Real tnext;
      output Real initialized=1;
      external"C" tnext = hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiInitialize2(fmi);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_Initialize_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_Initialize_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiInitialize2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  fmiBoolean toleranceControlled=fmiFalse;
  fmiReal tolerance=0;
  fmiEventInfo ev;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiInitialize(a->m, toleranceControlled, tolerance, &ev);
      a->currentMode=dyEventMode;
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->dyFirstTimeEvent=ev.nextEventTime;
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"Initialize failed\");
  return a->dyFirstTimeEvent;
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiInitialize;

    function fmiGetDerivatives
    input fmiModel fmi;
    input Integer nx;
    output Real dx[nx];
    external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetDerivatives2(
      fmi,
      dx,
      nx);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetDerivatives_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetDerivatives_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetDerivatives2(void*m,double*dx,int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetDerivatives(a->m, dx, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetDerivatives failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiGetDerivatives;

    function GetDerivatives
      input fmiModel fmi;
      input Integer nx;
      output Real dx[nx];
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      dx := fmiGetDerivatives(fmi, nx);
      annotation(LateInline=true);
    end GetDerivatives;

    function fmiGetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetEventIndicators2(
        fmi,
        z,
        nz);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetEventIndicators_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetEventIndicators_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetEventIndicators2(void*m,double*z,int nz) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetEventIndicators(a->m, z, nz);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetEventIndicators failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiGetEventIndicators;

    function GetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      z := fmiGetEventIndicators(fmi, nz);
      annotation(LateInline=true);
    end GetEventIndicators;

    function GetOutput
      input fmiModel fmi;
      input Real Time;
      input Integer outputValueReference[1];
      output Real outputVariable;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1],1);
      annotation(LateInline=true);
    end GetOutput;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      output Real dummy= 1;
      external"C"
                 hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetReal_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealParam
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
    protected
      Real oldVals[size(refs, 1)];
      external"C"
                 hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetRealParam2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetRealParam_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetRealParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetRealParam2(void*m, const int*refs, size_t nrefs, const double*vals, double*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetReal(a->m, refs, nrefs, oldVals);
      for(i=0; i<nrefs;++i){
        if( abs(vals[i]-oldVals[i])> 5e-16){
          ModelicaError(\"SetRealParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealParam;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      input Real dummy;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}, dummy));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      input Real preAvailable;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetReal_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetReal failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiGetReal;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      input Integer dummy;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}, dummy));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetInteger_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiGetInteger;

    function fmiSetInteger
    input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
      output Real dummy= 1;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetInteger_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiSetIntegerParam
    input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetIntegerParam2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetIntegerParam_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetIntegerParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetIntegerParam2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i=0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      for(i = 0; i< nrefs; ++i){
        if(vals[i]!=oldVals[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetIntegerParam;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      input Integer dummy;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}, dummy));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetBoolean_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetBoolean_C 1
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(vals));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetBoolean failed\");
  for(i=nr-1;i>=0;i--) vals[i]=((fmiBoolean*)(vals))[i];
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiGetBoolean;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
      output Real dummy2= 1;
    protected
      Boolean dummy[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetBoolean_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetBoolean_C 1
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals,int*dummy) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetBooleanParam
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetBooleanParam2(
      fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetBooleanParam_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetBooleanParam_C 1
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetBooleanParam2(void*m, const int* refs, size_t nr, const int* vals,int*dummy,int*oldVals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
    }else{
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(oldVals));
      for(i=nr-1;i>=0;i--){
        oldVals[i]=((fmiBoolean*)(oldVals))[i];
        if(oldVals[i]!=dummy[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBooleanParam;

    function fmiGetString
      input fmiModel fmi;
      input Integer refs[:];
      output String vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetString_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_GetString_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiGetString2(void*m, const int*refs, size_t nrefs, fmiString* vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"StringInteger failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1");
    end fmiGetString;

    function fmiSetString
    input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetString_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetString_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetString2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiSetStringParam
    input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetStringParam2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetStringParam_C
#define hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_SetStringParam_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_126537409402681378021_fmiSetStringParam2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetStringParam;

    function noHysteresis
      input Real x;
      output Real y;
    algorithm
      y:=x+(if (x < 0) then -1 else 1);
    end noHysteresis;
end fmi_Functions;
equation
  when initial() then
    fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn);
  end when;
  fmi_StepEvent = fmi_Functions.CompletedStep(fmi, myTime, {u_TDryBul, u_TMix, u_TRoo, u_TRooSetPoi, u_m_flow}, fill(0,0), fill(false,0), {352321537, 352321540, 352321538, 352321539, 352321536}, fill(0,0), fill(0,0))>0.5;
  der(fmi_x) = fmi_Functions.GetDerivatives(fmi, size(fmi_x, 1), myTime, {u_TDryBul, u_TMix, u_TRoo, u_TRooSetPoi, u_m_flow}, fill(0,0), fill(false,0), {352321537, 352321540, 352321538, 352321539, 352321536}, fill(0,0), fill(0,0));
  fmi_z  = fmi_Functions.GetEventIndicators(fmi, fmi_NumberOfEventIndicators, myTime, {u_TDryBul, u_TMix, u_TRoo, u_TRooSetPoi, u_m_flow}, fill(0,0), fill(false,0), {352321537, 352321540, 352321538, 352321539, 352321536}, fill(0,0), fill(0,0));
  for i in 1:size(fmi_z,1) loop
    fmi_z_positive[i] = fmi_Functions.noHysteresis(fmi_z[i]) > 0;
  end for;
  when cat(1, change(fmi_z_positive), {time>=pre(fmi_TNext), fmi_StepEvent, not initial()}) then
    (fmi_TNext, fmi_NewStates) =  fmi_Functions.EventUpdate(fmi, myTime, {u_TDryBul, u_TMix, u_TRoo, u_TRooSetPoi, u_m_flow}, fill(0,0), fill(false,0), {352321537, 352321540, 352321538, 352321539, 352321536}, fill(0,0), fill(0,0));
    fmi_NewStates2 = if fmi_NewStates then not pre(fmi_NewStates2) else pre(fmi_NewStates2);
  end when;
  for i in 1:size(fmi_x,1) loop
    when {fmi_NewStates2, not fmi_NewStates2} then
      reinit(fmi_x[i], fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x,1))*{if i==j then 1 else 0 for j in 1:size(fmi_x,1)});
    end when;
  end for;
algorithm
  fmi_Functions.fmiSetTime(fmi, time);
  myTime := time;
  fmi_Functions.fmiSetContinuousStates(fmi, fmi_x);
initial algorithm
 // 129 Real parameters
  fmi_Functions.fmiSetRealParam(fmi, {16777216, 16777217, 16777218, 16777219, 16777220, 16777221, 16777222, 16777223, 16777224, 16777225, 16777226, 16777227, 16777228, 16777229, 16777230, 16777231, 16777232, 16777233, 16777234, 16777309, 16777310, 16777311, 16777312, 16777313, 16777314, 16777315, 16777316, 16777235, 16777236, 16777237, 16777238, 16777239, 16777240, 16777241, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 16777251, 16777252, 16777253, 16777254, 16777255, 16777256, 16777257, 16777258, 16777259, 16777260, 16777261, 16777262, 16777263, 16777264, 16777265, 16777266, 16777267, 16777268, 16777269, 16777270, 16777271, 16777272, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 16777282, 16777283, 16777284, 16777285, 16777286, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777293, 16777294, 16777295, 16777296, 16777297, 16777298, 16777299, 16777300, 16777301, 16777302, 16777303, 16777304, 16777305, 16777306, 16777336}, {k_hea, Ti_hea, maxSAT, uLowSta1, uUppSta1, uLowSta2, uUppSta2, kSta1, kSta2, banSta1, banSta2, rtuHP.inSou.'X[1]', rtuHP.inSou.'X[2]', rtuHP.inSou.m_flow, rtuHP.inSou.T, rtuHP.outSou.'X[1]', rtuHP.outSou.'X[2]', rtuHP.outSou.p, rtuHP.outSou.T, rtuHP.heaPum.TAmbEva_nominal, rtuHP.heaPum.TAmbCon_nominal, rtuHP.heaPum.TConCap_start, rtuHP.heaPum.TEvaCap_start, rtuHP.heaPum.'x_start[1]', rtuHP.heaPum.'x_start[2]', rtuHP.heaPum.'x_start[3]', rtuHP.heaPum.yRefIne_start, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.k1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.k2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.mFlow_conNom, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.mFlow_evaNom, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[2,2]', rtuHP.nSetGai.k});
  fmi_Functions.fmiSetRealParam(fmi, {16777337, 16777338, 16777339, 16777340, 16777341, 16777342, 16777343, 16777344, 16777345, 16777346, 16777347, 16777348, 16777349, 16777350, 16777352, 16777354, 16777355, 16777357, 16777358, 16777359, 16777360, 16777361, 16777362, 16777363, 16777364, 16777367, 16777369, 16777370, 16777371}, {supFan.'X[1]', supFan.'X[2]', supFan.m_flow, supFan.T, roo.'X[1]', roo.'X[2]', roo.p, roo.T, rtuConFMU.conHea.Td, rtuConFMU.conHea.wp, rtuConFMU.conHea.wd, rtuConFMU.conHea.Ni, rtuConFMU.conHea.Nd, rtuConFMU.conHea.xd_start, rtuConFMU.conHea.P.k, rtuConFMU.offHea.k, rtuConFMU.onOffConSupHeatSetPoi.bandwidth, rtuConFMU.heatStage.realToBoolean1.threshold, rtuConFMU.heatStage.add.k1, rtuConFMU.heatStage.add.k2, rtuConFMU.heatStage.const7.k, rtuConFMU.heatStage.booleanToReal.realTrue, rtuConFMU.heatStage.booleanToReal.realFalse, rtuConFMU.heatStage.booleanToReal1.realTrue, rtuConFMU.heatStage.booleanToReal1.realFalse, rtuConFMU.onOffConHea.bandwidth, rtuConFMU.onDelay.delayTime, rtuConFMU.realToBoolean.threshold, rtuConFMU.realToBoolean1.threshold});
 // 0 Real start values
 // 0 Integer parameters
 // 0 Integer start values
 // 9 Boolean parameters
  fmi_Functions.fmiSetBooleanParam(fmi, {16777317, 16777307, 16777308, 16777335, 16777351, 16777356, 16777365, 16777366, 16777368}, {rtuHP.heaPum.linearized, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.verboseRead, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.verboseRead, rtuHP.heaOn.k, rtuConFMU.conHea.reverseAction, rtuConFMU.onOffConSupHeatSetPoi.pre_y_start, rtuConFMU.heatStage.onOffSta1.pre_y_start, rtuConFMU.heatStage.onOffSta2.pre_y_start, rtuConFMU.onOffConHea.pre_y_start});
 // 0 Boolean start values
 // 0 Enumeration parameters
 // 0 Enumeration start values
 // 0 String parameters
 // Set InitalInputs
fmi_Functions.fmiSetReal(fmi, {352321537, 352321540, 352321538, 352321539, 352321536}, {_u_TDryBul_start, _u_TMix_start, _u_TRoo_start, _u_TRooSetPoi_start, _u_m_flow_start});
  fmi_Functions.fmiSetTime(fmi, time);
  (fmi_TNext_Start,fmi_Initialized) :=fmi_Functions.fmiInitialize(fmi);
  fmi_x :=fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x, 1));
initial equation
 // 188 Real Dependent Parameters
{rtuHP.inSou.'ports[1]'.p, rtuHP.outSou.'ports[1]'.m_flow, rtuHP.outSou.'ports[1]'.h_outflow, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_min[1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_min[2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_max[1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_max[2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,5]'} = fmi_Functions.fmiGetReal(fmi, {234881041, 234881037, 100663313, 100663372, 100663373, 100663374, 100663375, 100663376, 100663377, 100663378, 100663379, 100663380, 100663381, 100663382, 100663383, 100663384, 100663385, 100663386, 100663387, 100663388, 100663389, 100663390, 100663391, 100663392, 100663393, 100663394, 100663395, 100663396, 100663397, 100663398, 100663399, 100663400, 100663401, 100663402, 100663403, 100663406, 100663407, 100663408, 100663409, 100663410, 100663411, 100663412, 100663413, 100663414, 100663415, 100663416, 100663417, 100663418, 100663419, 100663420, 100663421, 100663422, 100663423, 100663424, 100663425, 100663426, 100663427, 100663428, 100663429, 100663430, 100663431, 100663432, 100663433, 100663434, 100663435, 100663436, 100663437, 100663441, 100663442, 100663443, 100663444, 100663449, 100663450, 100663451, 100663452, 100663453, 100663454, 100663455, 100663456, 100663457, 100663458, 100663459, 100663460, 100663461, 100663462, 100663463, 100663464, 100663465, 100663466, 100663467, 100663468, 100663469, 100663470, 100663471, 100663472, 100663473, 100663474, 100663475, 100663476, 100663477}, fmi_Initialized);
{rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_min[1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_min[2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_max[1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_max[2]', rtuHP.heaPum.con.V, rtuHP.heaPum.con.TCap_start, rtuHP.heaPum.con.vol.V, rtuHP.heaPum.eva.V, rtuHP.heaPum.eva.TCap_start, rtuHP.heaPum.eva.vol.V, rtuHP.heaPum.heatFlowIneEva.'x_start[1]', rtuHP.heaPum.heatFlowIneEva.'x_start[2]', rtuHP.heaPum.heatFlowIneEva.'x_start[3]', rtuHP.heaPum.heatFlowIneEva.y_start, rtuHP.heaPum.heatFlowIneCon.'x_start[1]', rtuHP.heaPum.heatFlowIneCon.'x_start[2]', rtuHP.heaPum.heatFlowIneCon.'x_start[3]', rtuHP.heaPum.heatFlowIneCon.y_start, rtuHP.heaPum.senT_a2.TAmb, rtuHP.heaPum.senT_b2.TAmb, rtuHP.heaPum.senT_b1.TAmb, rtuHP.heaPum.senT_a1.TAmb, rtuHP.port_a.p, roo.'ports[1]'.h_outflow, rtuConFMU.k_hea, rtuConFMU.Ti_hea, rtuConFMU.maxSAT, rtuConFMU.uLowSta1, rtuConFMU.uUppSta1, rtuConFMU.uLowSta2, rtuConFMU.uUppSta2, rtuConFMU.kSta1, rtuConFMU.kSta2, rtuConFMU.banSta1, rtuConFMU.banSta2, rtuConFMU.conHea.k, rtuConFMU.conHea.Ti, rtuConFMU.conHea.addP.k1, rtuConFMU.conHea.addP.k2, rtuConFMU.conHea.I.k, rtuConFMU.UpperLimSup.k, rtuConFMU.heatStage.uLowSta1, rtuConFMU.heatStage.uUppSta1, rtuConFMU.heatStage.uLowSta2, rtuConFMU.heatStage.uUppSta2, rtuConFMU.heatStage.kSta1, rtuConFMU.heatStage.kSta2, rtuConFMU.heatStage.banSta1, rtuConFMU.heatStage.banSta2, rtuConFMU.heatStage.const1.k, rtuConFMU.heatStage.onOffSta1.bandwidth, rtuConFMU.heatStage.const2.k, rtuConFMU.heatStage.onOffSta2.bandwidth} = fmi_Functions.fmiGetReal(fmi, {100663478, 100663479, 100663480, 100663485, 100663486, 100663487, 100663488, 100663489, 100663490, 100663491, 100663492, 100663493, 100663494, 100663495, 100663496, 100663497, 100663498, 100663499, 100663500, 100663501, 100663502, 100663503, 100663504, 100663505, 100663506, 100663507, 100663508, 100663509, 100663510, 100663511, 100663512, 100663513, 100663514, 100663515, 100663516, 100663520, 100663521, 100663522, 100663523, 100663662, 100663665, 100663617, 100663750, 100663753, 100663707, 100663763, 100663764, 100663765, 100663766, 100663774, 100663775, 100663776, 100663777, 100663792, 100663810, 100663833, 100663851, 234881151, 100663911, 100663924, 100663925, 100663926, 100663927, 100663928, 100663929, 100663930, 100663931, 100663932, 100663933, 100663934, 100663937, 100663938, 100663948, 100663949, 100664112, 100663982, 100663983, 100663984, 100663985, 100663986, 100663987, 100663988, 100663989, 100663990, 100663997, 100663999, 100664000, 100664002}, fmi_Initialized);
 // 0 Integer Dependent Parameters
 // 0 Boolean Dependent Parameters
 // 0 Enumeration Dependent Parameters
 // 0 String Dependent Parameters
equation
    y_TSup =  fmi_Functions.GetOutput(fmi,myTime,{335544320}, fill(0.0,0),fill(0,0), fill(false,0), fill(0,0), fill(0,0), fill(0,0));
    y_PEleHP =  fmi_Functions.GetOutput(fmi,myTime,{335544321}, {u_TRoo, u_TRooSetPoi},fill(0,0), fill(false,0), {352321538, 352321539}, fill(0,0), fill(0,0));
    y_PI =  fmi_Functions.GetOutput(fmi,myTime,{335544323}, {u_TRoo, u_TRooSetPoi},fill(0,0), fill(false,0), {352321538, 352321539}, fill(0,0), fill(0,0));
algorithm
    fmi_Functions.fmiSetReal(fmi, {352321538, 352321539}, {u_TRoo, u_TRooSetPoi});
    y_HeaCal :=fmi_Functions.fmiGetBooleanScalar(
    fmi,
    335544322,
    integer(myTime));
equation
{rtuHP.PEle, rtuHP.TEvaIn, rtuHP.sta, rtuHP.TSup, rtuHP.inSou.T_in, rtuHP.inSou.'ports[1]'.m_flow, rtuHP.inSou.'ports[1]'.h_outflow, rtuHP.inSou.'ports[1]'.'Xi_outflow[1]', rtuHP.outSou.'ports[1]'.p, rtuHP.outSou.'ports[1]'.'Xi_outflow[1]', rtuHP.heaPum.m1_flow, rtuHP.heaPum.m2_flow, rtuHP.heaPum.port_a1.m_flow, rtuHP.heaPum.port_a1.p, rtuHP.heaPum.port_a1.h_outflow, rtuHP.heaPum.port_a1.'Xi_outflow[1]', rtuHP.heaPum.port_b1.m_flow, rtuHP.heaPum.port_b1.p, rtuHP.heaPum.port_b1.h_outflow, rtuHP.heaPum.port_b1.'Xi_outflow[1]', rtuHP.heaPum.port_a2.m_flow, rtuHP.heaPum.port_a2.p, rtuHP.heaPum.port_a2.h_outflow, rtuHP.heaPum.port_a2.'Xi_outflow[1]', rtuHP.heaPum.port_b2.m_flow, rtuHP.heaPum.port_b2.p, rtuHP.heaPum.port_b2.h_outflow, rtuHP.heaPum.port_b2.'Xi_outflow[1]', rtuHP.heaPum.innerCycle.QCon, rtuHP.heaPum.innerCycle.QEva, rtuHP.heaPum.innerCycle.Pel, rtuHP.heaPum.innerCycle.sigBus.nSet, rtuHP.heaPum.innerCycle.sigBus.TEvaInMea, rtuHP.heaPum.innerCycle.sigBus.TConInMea, rtuHP.heaPum.innerCycle.sigBus.TEvaOutMea, rtuHP.heaPum.innerCycle.sigBus.TConOutMea, rtuHP.heaPum.innerCycle.sigBus.PelMea, rtuHP.heaPum.innerCycle.sigBus.m_flowEvaMea, rtuHP.heaPum.innerCycle.sigBus.m_flowConMea, rtuHP.heaPum.innerCycle.switchQEva.u1, rtuHP.heaPum.innerCycle.switchQEva.y, rtuHP.heaPum.innerCycle.switchQCon.u1, rtuHP.heaPum.innerCycle.switchQCon.y, rtuHP.heaPum.innerCycle.switchPel.u1, rtuHP.heaPum.innerCycle.switchPel.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Pel, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QCon, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QEva, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.nSet, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TEvaInMea, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TConInMea, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TEvaOutMea, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TConOutMea, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.PelMea, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.m_flowEvaMea, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.m_flowConMea, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.proRedQEva.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.proRedQEva.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough2.u, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough2.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough1.u, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough1.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough2.u, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough2.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough1.u, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough1.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.t_Ev_in.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.t_Co_ou.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesQCon.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesQCon.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesQCon.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesSF.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesSF.y, rtuHP.heaPum.innerCycle.gainEva.u, rtuHP.heaPum.innerCycle.gainEva.y, rtuHP.heaPum.con.m_flow, rtuHP.heaPum.con.QFlow_in, rtuHP.heaPum.con.port_a.m_flow, rtuHP.heaPum.con.port_a.p, rtuHP.heaPum.con.port_a.h_outflow, rtuHP.heaPum.con.port_a.'Xi_outflow[1]', rtuHP.heaPum.con.port_b.m_flow} = fmi_Functions.fmiGetReal(fmi, {335544321, 436207617, 369099350, 33554442, 436207617, 905970039, 637534212, 234881035, 234881041, 234881039, 436207616, 234881037, 436207616, 234881151, 637534807, 637534808, 905969949, 234881151, 637534807, 637534808, 234881037, 234881041, 637534239, 637534240, 905970039, 234881041, 637534239, 637534240, 637534259, 637534260, 369098809, 369099347, 33554438, 33554441, 33554439, 33554440, 335544321, 234881037, 436207616, 637534261, 637534260, 637534263, 637534259, 369098810, 369098809, 369098810, 637534263, 637534269, 369099347, 33554438, 33554441, 33554439, 33554440, 335544321, 234881037, 436207616, 637534270, 369098815, 637534272, 637534270, 637534270, 369098823, 369098824, 637534281, 369098937, 369098938, 637534316, 369098938, 369098938, 369098937, 369098937, 369098823, 369098824, 369098902, 369098937, 369098938, 369098939, 369098938, 369098938, 369098937, 369098937, 369098824, 369098823, 369098981, 369098939, 369098815, 637534316, 369098981, 637534275, 369099347, 369098981, 637534270, 637534446, 436207616, 33554437, 436207616, 234881151, 637534807, 637534808, 905969949}, myTime);
{rtuHP.heaPum.con.port_b.p, rtuHP.heaPum.con.port_b.h_outflow, rtuHP.heaPum.con.port_b.'Xi_outflow[1]', rtuHP.heaPum.con.vol.T, rtuHP.heaPum.con.vol.U, rtuHP.heaPum.con.vol.p, rtuHP.heaPum.con.vol.m, rtuHP.heaPum.con.vol.'Xi[1]', rtuHP.heaPum.con.vol.'mXi[1]', rtuHP.heaPum.con.vol.'ports[1]'.m_flow, rtuHP.heaPum.con.vol.'ports[1]'.p, rtuHP.heaPum.con.vol.'ports[1]'.h_outflow, rtuHP.heaPum.con.vol.'ports[1]'.'Xi_outflow[1]', rtuHP.heaPum.con.vol.'ports[2]'.m_flow, rtuHP.heaPum.con.vol.'ports[2]'.p, rtuHP.heaPum.con.vol.'ports[2]'.h_outflow, rtuHP.heaPum.con.vol.'ports[2]'.'Xi_outflow[1]', rtuHP.heaPum.con.vol.heatPort.T, rtuHP.heaPum.con.preDro.m_flow, rtuHP.heaPum.con.preDro.port_a.m_flow, rtuHP.heaPum.con.preDro.port_a.p, rtuHP.heaPum.con.preDro.port_a.h_outflow, rtuHP.heaPum.con.preDro.port_a.'Xi_outflow[1]', rtuHP.heaPum.con.preDro.port_b.m_flow, rtuHP.heaPum.con.preDro.port_b.p, rtuHP.heaPum.con.preDro.port_b.h_outflow, rtuHP.heaPum.con.preDro.port_b.'Xi_outflow[1]', rtuHP.heaPum.con.preHea.port.T, rtuHP.heaPum.eva.m_flow, rtuHP.heaPum.eva.QFlow_in, rtuHP.heaPum.eva.port_a.m_flow, rtuHP.heaPum.eva.port_a.p, rtuHP.heaPum.eva.port_a.h_outflow, rtuHP.heaPum.eva.port_a.'Xi_outflow[1]', rtuHP.heaPum.eva.port_b.m_flow, rtuHP.heaPum.eva.port_b.p, rtuHP.heaPum.eva.port_b.h_outflow, rtuHP.heaPum.eva.port_b.'Xi_outflow[1]', rtuHP.heaPum.eva.vol.T, rtuHP.heaPum.eva.vol.U, rtuHP.heaPum.eva.vol.p, rtuHP.heaPum.eva.vol.m, rtuHP.heaPum.eva.vol.'Xi[1]', rtuHP.heaPum.eva.vol.'mXi[1]', rtuHP.heaPum.eva.vol.'ports[1]'.m_flow, rtuHP.heaPum.eva.vol.'ports[1]'.p, rtuHP.heaPum.eva.vol.'ports[1]'.h_outflow, rtuHP.heaPum.eva.vol.'ports[1]'.'Xi_outflow[1]', rtuHP.heaPum.eva.vol.'ports[2]'.m_flow, rtuHP.heaPum.eva.vol.'ports[2]'.p, rtuHP.heaPum.eva.vol.'ports[2]'.h_outflow, rtuHP.heaPum.eva.vol.'ports[2]'.'Xi_outflow[1]', rtuHP.heaPum.eva.vol.heatPort.T, rtuHP.heaPum.eva.preDro.m_flow, rtuHP.heaPum.eva.preDro.port_a.m_flow, rtuHP.heaPum.eva.preDro.port_a.p, rtuHP.heaPum.eva.preDro.port_a.h_outflow, rtuHP.heaPum.eva.preDro.port_a.'Xi_outflow[1]', rtuHP.heaPum.eva.preDro.port_b.m_flow, rtuHP.heaPum.eva.preDro.port_b.p, rtuHP.heaPum.eva.preDro.port_b.h_outflow, rtuHP.heaPum.eva.preDro.port_b.'Xi_outflow[1]', rtuHP.heaPum.eva.preHea.port.T, rtuHP.heaPum.heatFlowIneEva.u, rtuHP.heaPum.heatFlowIneEva.y, rtuHP.heaPum.heatFlowIneEva.'x[1]', rtuHP.heaPum.heatFlowIneEva.'_x[1]_der', rtuHP.heaPum.heatFlowIneEva.'x[2]', rtuHP.heaPum.heatFlowIneEva.'_x[2]_der', rtuHP.heaPum.heatFlowIneEva.'x[3]', rtuHP.heaPum.heatFlowIneEva.'_x[3]_der', rtuHP.heaPum.heatFlowIneCon.u, rtuHP.heaPum.heatFlowIneCon.y, rtuHP.heaPum.heatFlowIneCon.'x[1]', rtuHP.heaPum.heatFlowIneCon.'_x[1]_der', rtuHP.heaPum.heatFlowIneCon.'x[2]', rtuHP.heaPum.heatFlowIneCon.'_x[2]_der', rtuHP.heaPum.heatFlowIneCon.'x[3]', rtuHP.heaPum.heatFlowIneCon.'_x[3]_der', rtuHP.heaPum.sigBus.nSet, rtuHP.heaPum.sigBus.TEvaInMea, rtuHP.heaPum.sigBus.TConInMea, rtuHP.heaPum.sigBus.TEvaOutMea, rtuHP.heaPum.sigBus.TConOutMea, rtuHP.heaPum.sigBus.PelMea, rtuHP.heaPum.sigBus.m_flowEvaMea, rtuHP.heaPum.sigBus.m_flowConMea, rtuHP.heaPum.senT_a2.T, rtuHP.heaPum.senT_a2._T_der, rtuHP.heaPum.senT_a2.port_a.m_flow, rtuHP.heaPum.senT_a2.port_a.p, rtuHP.heaPum.senT_a2.port_a.h_outflow, rtuHP.heaPum.senT_a2.port_a.'Xi_outflow[1]', rtuHP.heaPum.senT_a2.port_b.m_flow, rtuHP.heaPum.senT_a2.port_b.p, rtuHP.heaPum.senT_a2.port_b.h_outflow, rtuHP.heaPum.senT_a2.port_b.'Xi_outflow[1]', rtuHP.heaPum.senT_b2.T, rtuHP.heaPum.senT_b2._T_der, rtuHP.heaPum.senT_b2.port_a.m_flow} = fmi_Functions.fmiGetReal(fmi, {234881151, 637534807, 637534808, 905969986, 33554443, 234881151, 100664040, 637534531, 33554444, 436207616, 234881151, 637534807, 637534808, 905969949, 234881151, 637534807, 637534808, 905969986, 436207616, 436207616, 234881151, 637534807, 637534808, 905969949, 234881151, 637534811, 234881145, 905969986, 234881037, 33554434, 234881037, 234881041, 637534239, 637534240, 905970039, 234881041, 637534239, 637534240, 905970076, 33554445, 234881041, 100664090, 637534621, 33554446, 234881037, 234881041, 637534239, 637534240, 905970039, 234881041, 637534239, 637534240, 905970076, 234881037, 234881037, 234881041, 637534239, 637534240, 905970039, 234881041, 637534212, 234881035, 905970076, 637534670, 33554434, 33554432, 587202560, 33554433, 587202561, 33554434, 587202562, 637534681, 33554437, 33554435, 587202563, 33554436, 587202564, 33554437, 587202565, 369099347, 33554438, 33554441, 33554439, 33554440, 335544321, 234881037, 436207616, 33554438, 587202566, 234881037, 234881041, 637534239, 637534240, 905970039, 234881041, 637534212, 234881035, 33554439, 587202567, 234881037}, myTime);
{rtuHP.heaPum.senT_b2.port_a.p, rtuHP.heaPum.senT_b2.port_a.h_outflow, rtuHP.heaPum.senT_b2.port_a.'Xi_outflow[1]', rtuHP.heaPum.senT_b2.port_b.m_flow, rtuHP.heaPum.senT_b2.port_b.p, rtuHP.heaPum.senT_b2.port_b.h_outflow, rtuHP.heaPum.senT_b2.port_b.'Xi_outflow[1]', rtuHP.heaPum.mFlow_eva.m_flow, rtuHP.heaPum.mFlow_eva.port_a.m_flow, rtuHP.heaPum.mFlow_eva.port_a.p, rtuHP.heaPum.mFlow_eva.port_a.h_outflow, rtuHP.heaPum.mFlow_eva.port_a.'Xi_outflow[1]', rtuHP.heaPum.mFlow_eva.port_b.m_flow, rtuHP.heaPum.mFlow_eva.port_b.p, rtuHP.heaPum.mFlow_eva.port_b.h_outflow, rtuHP.heaPum.mFlow_eva.port_b.'Xi_outflow[1]', rtuHP.heaPum.senT_b1.T, rtuHP.heaPum.senT_b1._T_der, rtuHP.heaPum.senT_b1.port_a.m_flow, rtuHP.heaPum.senT_b1.port_a.p, rtuHP.heaPum.senT_b1.port_a.h_outflow, rtuHP.heaPum.senT_b1.port_a.'Xi_outflow[1]', rtuHP.heaPum.senT_b1.port_b.m_flow, rtuHP.heaPum.senT_b1.port_b.p, rtuHP.heaPum.senT_b1.port_b.h_outflow, rtuHP.heaPum.senT_b1.port_b.'Xi_outflow[1]', rtuHP.heaPum.senT_a1.T, rtuHP.heaPum.senT_a1._T_der, rtuHP.heaPum.senT_a1.port_a.m_flow, rtuHP.heaPum.senT_a1.port_a.p, rtuHP.heaPum.senT_a1.port_a.h_outflow, rtuHP.heaPum.senT_a1.port_a.'Xi_outflow[1]', rtuHP.heaPum.senT_a1.port_b.m_flow, rtuHP.heaPum.senT_a1.port_b.p, rtuHP.heaPum.senT_a1.port_b.h_outflow, rtuHP.heaPum.senT_a1.port_b.'Xi_outflow[1]', rtuHP.heaPum.mFlow_con.m_flow, rtuHP.heaPum.mFlow_con.port_a.m_flow, rtuHP.heaPum.mFlow_con.port_a.p, rtuHP.heaPum.mFlow_con.port_a.h_outflow, rtuHP.heaPum.mFlow_con.port_a.'Xi_outflow[1]', rtuHP.heaPum.mFlow_con.port_b.m_flow, rtuHP.heaPum.mFlow_con.port_b.p, rtuHP.heaPum.mFlow_con.port_b.h_outflow, rtuHP.heaPum.mFlow_con.port_b.'Xi_outflow[1]', rtuHP.heaPum.greaterThreshold.u, rtuHP.senTAct.T, rtuHP.senTAct._T_der, rtuHP.senTAct.port_a.m_flow, rtuHP.senTAct.port_a.p, rtuHP.senTAct.port_a.h_outflow, rtuHP.senTAct.port_a.'Xi_outflow[1]', rtuHP.senTAct.port_b.m_flow, rtuHP.senTAct.port_b.p, rtuHP.senTAct.port_b.h_outflow, rtuHP.senTAct.port_b.'Xi_outflow[1]', rtuHP.nSetGai.u, rtuHP.nSetGai.y, rtuHP.sigBus1.nSet, rtuHP.sigBus1.TEvaInMea, rtuHP.sigBus1.TConInMea, rtuHP.sigBus1.TEvaOutMea, rtuHP.sigBus1.TConOutMea, rtuHP.sigBus1.PelMea, rtuHP.sigBus1.m_flowEvaMea, rtuHP.sigBus1.m_flowConMea, rtuHP.port_a.m_flow, rtuHP.port_a.h_outflow, rtuHP.port_a.'Xi_outflow[1]', rtuHP.port_b.m_flow, rtuHP.port_b.p, rtuHP.port_b.h_outflow, rtuHP.port_b.'Xi_outflow[1]', supFan.m_flow_in, supFan.T_in, supFan.'ports[1]'.m_flow, supFan.'ports[1]'.p, supFan.'ports[1]'.h_outflow, supFan.'ports[1]'.'Xi_outflow[1]', roo.'ports[1]'.m_flow, roo.'ports[1]'.p, roo.'ports[1]'.'Xi_outflow[1]', rtuConFMU.TSetRooHea, rtuConFMU.TRoo, rtuConFMU.heaSta, rtuConFMU.TSup, rtuConFMU.PI_y, rtuConFMU.conHea.u_s, rtuConFMU.conHea.u_m, rtuConFMU.conHea.y, rtuConFMU.conHea.controlError, rtuConFMU.conHea.addP.u1, rtuConFMU.conHea.addP.u2, rtuConFMU.conHea.addP.y, rtuConFMU.conHea.P.u, rtuConFMU.conHea.P.y, rtuConFMU.conHea.addPID.u1, rtuConFMU.conHea.addPID.u3, rtuConFMU.conHea.addPID.y, rtuConFMU.conHea.I.u} = fmi_Functions.fmiGetReal(fmi, {234881041, 100663313, 234881039, 905970039, 234881041, 637534239, 637534240, 234881037, 234881037, 234881041, 637534239, 637534240, 905970039, 234881041, 637534212, 234881035, 33554440, 587202568, 436207616, 234881151, 100663911, 234881149, 905969949, 234881151, 637534807, 637534808, 33554441, 587202569, 436207616, 234881151, 637534807, 637534808, 905969949, 234881151, 637534811, 234881145, 436207616, 436207616, 234881151, 637534807, 637534808, 905969949, 234881151, 637534811, 234881145, 369099347, 33554442, 587202570, 436207616, 234881151, 100663911, 234881149, 905969949, 234881151, 637534807, 637534808, 369099350, 369099347, 369099347, 33554438, 33554441, 33554439, 33554440, 335544321, 234881037, 436207616, 436207616, 637534807, 637534808, 905969949, 234881151, 637534807, 637534808, 436207616, 436207620, 905969949, 234881151, 637534811, 234881145, 436207616, 234881151, 234881149, 436207619, 436207618, 369099350, 33554442, 335544323, 905970333, 905970334, 335544323, 905970303, 905970333, 905970334, 369099403, 369099403, 369099406, 369099406, 33554447, 369099411, 637534880}, myTime);
{rtuConFMU.conHea.I.y, rtuConFMU.conHea.I._y_der, rtuConFMU.conHea.I.y_reset_in, rtuConFMU.swiHea.u1, rtuConFMU.swiHea.u3, rtuConFMU.swiHea.y, rtuConFMU.offHea.y, rtuConFMU.onOffConSupHeatSetPoi.reference, rtuConFMU.UpperLimSup.y, rtuConFMU.heatStage.uHea, rtuConFMU.heatStage.y_Sta, rtuConFMU.heatStage.realToBoolean1.u, rtuConFMU.heatStage.add.u1, rtuConFMU.heatStage.add.u2, rtuConFMU.heatStage.add.y, rtuConFMU.heatStage.switch4.u1, rtuConFMU.heatStage.switch4.u3, rtuConFMU.heatStage.switch4.y, rtuConFMU.heatStage.const7.y, rtuConFMU.heatStage.booleanToReal.y, rtuConFMU.heatStage.booleanToReal1.y, rtuConFMU.heatStage.const1.y, rtuConFMU.heatStage.onOffSta1.reference, rtuConFMU.heatStage.onOffSta1.u, rtuConFMU.heatStage.const2.y, rtuConFMU.heatStage.onOffSta2.reference, rtuConFMU.heatStage.onOffSta2.u, rtuConFMU.swiTim.u1, rtuConFMU.swiTim.u3, rtuConFMU.swiTim.y, rtuConFMU.onOffConHea.reference, rtuConFMU.onOffConHea.u, rtuConFMU.UppLimSwi.u1, rtuConFMU.UppLimSwi.u3, rtuConFMU.UppLimSwi.y, rtuConFMU.realToBoolean.u, rtuConFMU.realToBoolean1.u} = fmi_Functions.fmiGetReal(fmi, {33554447, 587202575, 369099573, 369099435, 234881162, 369099436, 234881162, 100663982, 100663982, 335544323, 369099435, 335544323, 369099448, 369099449, 369099450, 369099450, 234881168, 369099435, 234881168, 369099449, 369099448, 100663997, 100663997, 335544323, 100664000, 100664000, 335544323, 369099459, 234881162, 369099350, 905970333, 905970334, 234881162, 369099436, 369099459, 369099459, 335544323}, myTime);
{rtuHP.heaPum.innerCycle.sigBus.modeSet, rtuHP.heaPum.innerCycle.sigBus.onOffMea, rtuHP.heaPum.innerCycle.switchQEva.u2, rtuHP.heaPum.innerCycle.switchQCon.u2, rtuHP.heaPum.innerCycle.switchPel.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.modeSet, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.onOffMea, rtuHP.heaPum.sigBus.modeSet, rtuHP.heaPum.sigBus.onOffMea, rtuHP.heaPum.greaterThreshold.y, rtuHP.heaOn.y, rtuHP.sigBus1.modeSet, rtuHP.sigBus1.onOffMea, rtuConFMU.heaCal, rtuConFMU.conHea.trigger, rtuConFMU.conHea.I.trigger, rtuConFMU.swiHea.u2, rtuConFMU.onOffConSupHeatSetPoi.y, rtuConFMU.heatStage.realToBoolean1.y, rtuConFMU.heatStage.switch4.u2, rtuConFMU.heatStage.booleanToReal.u, rtuConFMU.heatStage.booleanToReal1.u, rtuConFMU.heatStage.onOffSta1.y, rtuConFMU.heatStage.onOffSta2.y, rtuConFMU.heatStage.not1.u, rtuConFMU.heatStage.not1.y, rtuConFMU.heatStage.not2.u, rtuConFMU.heatStage.not2.y, rtuConFMU.swiTim.u2, rtuConFMU.onOffConHea.y, rtuConFMU.UppLimSwi.u2, rtuConFMU.NotLim.u, rtuConFMU.NotLim.y, rtuConFMU.onDelay.u, rtuConFMU.onDelay.y, rtuConFMU.realToBoolean.y, rtuConFMU.realToBoolean1.y} = fmi_Functions.fmiGetBoolean(fmi, {234881143, 905970260, 234881143, 234881143, 234881143, 234881143, 905970260, 234881143, 905970260, 905970260, 234881143, 234881143, 905970260, 335544322, 369099461, 369099461, 369099461, 369099437, 369099447, 369099447, 369099451, 369099452, 369099454, 369099457, 369099454, 369099451, 369099457, 369099452, 369099460, 369099461, 369099462, 369099437, 369099462, 369099463, 369099460, 369099463, 335544322}, integer(myTime));
  annotation (__Dymola_FMUImportVersion="Dymola 2020x", experiment(StartTime=19872000.0, StopTime=19958400.0, Tolerance=1E-06),
    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 1.0 ME")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 1.0</li>
<li>modelName = hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1</li>
<li>generationTool = Dymola Version 2020x (64-bit), 2019-10-10 (requires license to execute)</li>
<li>generationDateAndTime = 2022-03-23T21:56:34Z</li>
</ul>
<p><br><b>Co-Simulation Attributes</b></p>
<ul>
<li>canHandleVariableCommunicationStepSize = true</li>
<li>canHandleEvents = true</li>
<li>canRejectSteps = false</li>
<li>canInterpolateInputs = false</li>
<li>maxOutputDerivativeOrder = 1</li>
<li>canRunAsynchronuously = false</li>
<li>canSignalEvents = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = false</li>
</ul>
</html>"));
end hil_flexlab_model_Fluid_Aachen_HP_2stage_FMU_1_fmu;
