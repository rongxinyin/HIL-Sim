within ;
model hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu
  "Air supply unit model with heatpump heating and cooling and auxiliary electric heater for heating"
extends fmuIcon;
// Model automatically generated by Dymola from FMI model description
public
  type Modelica_Blocks_Interfaces_BooleanInput = Boolean;
  type Modelica_Blocks_Interfaces_BooleanOutput = Boolean;
  type Modelica_Blocks_Interfaces_RealInput = Real;
  type Modelica_Blocks_Interfaces_RealOutput = Real;
  type Buildings_Types_Reset = enumeration(
      Disabled                                      "Disabled",
      Parameter "Use parameter value",
      Input "Use input signal");
  constant Real refIneFre = 0.015 "refrigerant inertia parameter";
  parameter Real k_hea = 0.18 "Proportional gain of heating controller";
  parameter Modelica.SIunits.Time Ti_hea = 2400 "Integral time constant of heating controller";
  parameter Modelica.SIunits.ThermodynamicTemperature maxSAT = 310 "max supply air temperature";
  parameter Real uLowSta1 = 0.05 "PI lower bound to activate stage 1";
  parameter Real uUppSta1 = 0.15 "PI upper bound to activate stage 1";
  parameter Real uLowSta2 = 0.35 "PI lower bound to activate stage 2";
  parameter Real uUppSta2 = 0.45 "PI upper bound to activate stage 2";
  parameter Real kSta1 = 0.05 "PI center line to activate stage 1";
  parameter Real kSta2 = 0.35 "PI center line to activate stage 2";
  parameter Real banSta1 = 0.01 "PI band to activate stage 1";
  parameter Real banSta2 = 0.01 "PI band to activate stage 2";
protected
  record rtuHP_rec
    constant Real refIneFre = 0.015 "refrigerant inertia parameter";
    Modelica_Blocks_Interfaces_RealOutput PEle(unit = "W", quantity = "Power") "Electrical power consumed by the unit";
    Modelica_Blocks_Interfaces_RealInput TEvaIn(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature") "Outside air dry bulb temperature";
    Modelica_Blocks_Interfaces_RealInput sta "Heating stage";
    Modelica_Blocks_Interfaces_RealOutput TSup(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature") "Electrical power consumed by the unit";
  protected
    record inSou_rec
      constant Integer nPorts = 1 "Number of ports";
      constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
      parameter Real 'X[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Fixed value of composition";
      parameter Real 'X[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Fixed value of composition";
      parameter Modelica.SIunits.MassFlowRate m_flow(nominal = 0.405, min = -100000.0, max = 100000.0) = 1 "Fixed mass flow rate going out of the fluid port";
      parameter Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 293.15 "Fixed value of temperature";
      Modelica_Blocks_Interfaces_RealInput T_in(unit = "K", displayUnit = "degC") "Prescribed boundary temperature";
    protected
      record 'ports[1]_rec'
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end 'ports[1]_rec';
    public
      'ports[1]_rec' 'ports[1]';
    end inSou_rec;
  public
    inSou_rec inSou annotation(Dialog);
  protected
    record outSou_rec
      constant Integer nPorts = 1 "Number of ports";
      constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
      parameter Real 'X[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Fixed value of composition";
      parameter Real 'X[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Fixed value of composition";
      parameter Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325 "Fixed value of pressure";
      parameter Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 293.15 "Fixed value of temperature";
    protected
      record 'ports[1]_rec'
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end 'ports[1]_rec';
    public
      'ports[1]_rec' 'ports[1]';
    end outSou_rec;
  public
    outSou_rec outSou annotation(Dialog);
  protected
    record heaPum_rec
      constant Boolean allowFlowReversal1 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1";
      constant Boolean allowFlowReversal2 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2";
      constant Modelica.SIunits.MassFlowRate m1_flow_nominal(min = 0.0) = 0.3 "Nominal mass flow rate";
      constant Modelica.SIunits.MassFlowRate m2_flow_nominal(min = 0.0) = 0.3 "Nominal mass flow rate";
      constant Real m1_flow_small(unit = "kg/s", quantity = "MassFlowRate.Air", min = 0.0, max = 100000.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
      constant Real m2_flow_small(unit = "kg/s", quantity = "MassFlowRate.Air", min = 0.0, max = 100000.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
      Real m1_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
      constant Modelica.SIunits.PressureDifference dp1(displayUnit = "Pa") = 0.0 "Pressure difference between port_a1 and port_b1";
      Real m2_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
      constant Modelica.SIunits.PressureDifference dp2(displayUnit = "Pa") = 0.0 "Pressure difference between port_a2 and port_b2";
      constant Boolean use_rev = false "Is the vapour compression machine reversible?";
      constant Boolean use_autoCalc = true "Enable automatic estimation of volumes and mass flows?";
      constant Modelica.SIunits.Power Q_useNominal = 6535 "Nominal usable heat flow of the vapour compression machine (HP: Heating; Chiller: Cooling)";
      constant Real scalingFactor = 1.35 "Scaling-factor of vapour compression machine";
      constant Boolean use_refIne = true "Consider the inertia of the refrigerant cycle";
      constant Modelica.SIunits.Frequency refIneFre_constant = 0.015 "Cut off frequency for inertia of refrigerant cycle";
      constant Integer nthOrder = 3 "Order of refrigerant cycle interia";
      constant Boolean useBusConnectorOnly = true "Set true to use bus connector for modeSet, nSet and iceFac input";
      constant Modelica.SIunits.MassFlowRate mFlow_conNominal = 0.5 "Manual input of the nominal mass flow rate (if not automatically calculated)";
      constant Modelica.SIunits.Volume VCon = 0.4 "Manual input of the condenser volume (if not automatically calculated)";
      constant Modelica.SIunits.PressureDifference dpCon_nominal = 0 "Pressure drop at nominal mass flow rate";
      constant Real deltaM_con = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
      constant Boolean use_conCap = false "If heat losses at capacitor side are considered or not";
      constant Modelica.SIunits.HeatCapacity CCon = 100 "Heat capacity of Condenser (= cp*m). If you want to neglace the dry mass of the condenser, you can set this value to zero";
      constant Modelica.SIunits.ThermalConductance GConOut = 5 "Constant parameter for heat transfer to the ambient. Represents a sum of thermal resistances such as conductance, insulation and natural convection. If you want to simulate a condenser with additional dry mass but without external heat losses, set the value to zero";
      constant Modelica.SIunits.ThermalConductance GConIns = 0.0 "Constant parameter for heat transfer to heat exchangers capacity. Represents a sum of thermal resistances such as forced convection and conduction inside of the capacity";
      constant Modelica.SIunits.MassFlowRate mFlow_evaNominal = 0.5 "Manual input of the nominal mass flow rate (if not automatically calculated)";
      constant Modelica.SIunits.Volume VEva = 0.04 "Manual input of the evaporator volume (if not automatically calculated)";
      constant Modelica.SIunits.PressureDifference dpEva_nominal = 0 "Pressure drop at nominal mass flow rate";
      constant Real deltaM_eva = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
      constant Boolean use_evaCap = false "If heat losses at capacitor side are considered or not";
      constant Modelica.SIunits.HeatCapacity CEva = 100 "Heat capacity of Evaporator (= cp*m). If you want to neglace the dry mass of the evaporator, you can set this value to zero";
      constant Modelica.SIunits.ThermalConductance GEvaOut = 5 "Constant parameter for heat transfer to the ambient. Represents a sum of thermal resistances such as conductance, insulation and natural convection. If you want to simulate a evaporator with additional dry mass but without external heat losses, set the value to zero";
      constant Modelica.SIunits.ThermalConductance GEvaIns = 0.0 "Constant parameter for heat transfer to heat exchangers capacity. Represents a sum of thermal resistances such as forced convection and conduction inside of the capacity";
      constant Modelica.SIunits.Time tauSenT = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
      constant Boolean transferHeat = true "If true, temperature T converges towards TAmb when no flow";
      constant Boolean allowFlowReversalEva = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
      constant Boolean allowFlowReversalCon = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
      constant Modelica.SIunits.Time tauHeaTraEva = 1200 "Time constant for heat transfer in temperature sensors in evaporator, default 20 minutes";
      parameter Modelica.SIunits.Temperature TAmbEva_nominal = 273.15 "Fixed ambient temperature for heat transfer of sensors at the evaporator side";
      constant Modelica.SIunits.Time tauHeaTraCon = 1200 "Time constant for heat transfer in temperature sensors in condenser, default 20 minutes";
      parameter Modelica.SIunits.Temperature TAmbCon_nominal = 288.15 "Fixed ambient temperature for heat transfer of sensors at the condenser side";
      constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
      constant Modelica.Media.Interfaces.Types.AbsolutePressure pCon_start = 101325 "Start value of pressure";
      constant Modelica.Media.Interfaces.Types.Temperature TCon_start = 290.15 "Start value of temperature";
      parameter Modelica.SIunits.Temperature TConCap_start = 293.15 "Initial temperature of heat capacity of condenser";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XCon_start[1]' = 0.01 "Start value of mass fractions m_i/m";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XCon_start[2]' = 0.99 "Start value of mass fractions m_i/m";
      constant Modelica.Media.Interfaces.Types.AbsolutePressure pEva_start = 101325 "Start value of pressure";
      constant Modelica.Media.Interfaces.Types.Temperature TEva_start = 281.15 "Start value of temperature";
      parameter Modelica.SIunits.Temperature TEvaCap_start = 293.15 "Initial temperature of heat capacity at evaporator";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XEva_start[1]' = 0.01 "Start value of mass fractions m_i/m";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XEva_start[2]' = 0.99 "Start value of mass fractions m_i/m";
      parameter Real 'x_start[1]' = 0 "Initial or guess values of states";
      parameter Real 'x_start[2]' = 0 "Initial or guess values of states";
      parameter Real 'x_start[3]' = 0 "Initial or guess values of states";
      parameter Real yRefIne_start = 0 "Initial or guess value of output (= state)";
      constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state (only affects fluid-models)";
      constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state (only affects fluid-models)";
      constant Boolean machineType = true "=true if heat pump; =false if chiller";
      constant Boolean show_TPort = false "= true, if actual temperature at port is computed";
      constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
      constant Boolean homotopyInitialization = false "= true, use homotopy method";
      parameter Boolean linearized = false "= true, use linear relation between m_flow and dp for any flow rate";
    protected
      record port_a1_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_a1_rec;
    public
      port_a1_rec port_a1;
    protected
      record port_b1_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_b1_rec;
    public
      port_b1_rec port_b1;
    protected
      record port_a2_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_a2_rec;
    public
      port_a2_rec port_a2;
    protected
      record port_b2_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_b2_rec;
    public
      port_b2_rec port_b2;
    protected
      record innerCycle_rec
        constant Boolean use_rev = false "True if the vapour compression machine is reversible";
        constant Real scalingFactor = 1.35 "Scaling factor of vapour compression machine";
        Modelica_Blocks_Interfaces_RealOutput QCon(unit = "W", displayUnit = "kW") "Heat Flow to condenser";
        Modelica_Blocks_Interfaces_RealOutput QEva(unit = "W", displayUnit = "kW") "Heat flow from evaporator";
        Modelica_Blocks_Interfaces_RealOutput Pel(unit = "W", displayUnit = "kW") "Electrical power consumed by compressor";
      protected
        record sigBus_rec
          Real nSet "Relative rotational speed of compressor between 0 and 1";
          Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
          Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
          Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
          Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
          Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
          Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
          Modelica.SIunits.Power PelMea "Total electrical active power";
          Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
          Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
          constant Real iceFacMea = 1.0 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
        end sigBus_rec;
      public
        sigBus_rec sigBus;
      protected
        record switchQEva_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W", displayUnit = "kW") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          constant Modelica_Blocks_Interfaces_RealInput u3(unit = "W", displayUnit = "kW") = 0 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
        end switchQEva_rec;
      public
        switchQEva_rec switchQEva;
      protected
        record switchQCon_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W", displayUnit = "kW") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          constant Modelica_Blocks_Interfaces_RealInput u3(unit = "W", displayUnit = "kW") = 0.0 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
        end switchQCon_rec;
      public
        switchQCon_rec switchQCon;
      protected
        record switchPel_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W", displayUnit = "kW") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          constant Modelica_Blocks_Interfaces_RealInput u3(unit = "W", displayUnit = "kW") = 0.0 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
        end switchPel_rec;
      public
        switchPel_rec switchPel;
      protected
        record PerformanceDataHPHeating_rec
          Modelica_Blocks_Interfaces_RealOutput Pel(unit = "W", displayUnit = "kW") "Electrical Power consumed by HP";
          Modelica_Blocks_Interfaces_RealOutput QCon(unit = "W", displayUnit = "kW") "Heat flow rate through Condenser";
          Modelica_Blocks_Interfaces_RealOutput QEva(unit = "W", displayUnit = "kW") "Heat flow rate through Evaporator";
          constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
          constant Boolean extrapolation = true "False to hold last value";
          constant Boolean printAsserts = false "WARNING: This will lead to a lot of state-events if extrapolation occurs frequently! If extrapolation is enabled, the user will get warnings when extrapolation occurs.";
        protected
          record sigBus_rec
            Real nSet "Relative rotational speed of compressor between 0 and 1";
            Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
            Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
            Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
            Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
            Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
            Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
            Modelica.SIunits.Power PelMea "Total electrical active power";
            Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
            Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
            constant Real iceFacMea = 1.0 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
          end sigBus_rec;
        public
          sigBus_rec sigBus;
        protected
          record calcRedQCon_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = 1 "Gain of input signal 2";
          end calcRedQCon_rec;
        public
          calcRedQCon_rec calcRedQCon annotation(Dialog);
        protected
          record proRedQEva_rec
            constant Modelica_Blocks_Interfaces_RealInput u1 = 1.0 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end proRedQEva_rec;
        public
          proRedQEva_rec proRedQEva;
        protected
          record dataTable_rec
            parameter Real 'tableQdot_con[1,1]' = 0.0 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,2]' = -13.9 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,3]' = -8.3 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,4]' = -2.8 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,5]' = 2.8 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,6]' = 8.3 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,7]' = 13.9 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,8]' = 19.4 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,1]' = 18 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,2]' = 1800 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,3]' = 2640 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,4]' = 3430 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,5]' = 4330 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,6]' = 5370 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,7]' = 6540 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,8]' = 7850 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,1]' = 21 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,2]' = 1610 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,3]' = 2380 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,4]' = 3260 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,5]' = 4130 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,6]' = 5140 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,7]' = 6280 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,8]' = 7570 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,1]' = 24 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,2]' = 1390 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,3]' = 2150 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,4]' = 3080 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,5]' = 3940 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,6]' = 4910 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,7]' = 6030 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,8]' = 7910 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,1]' = 0.0 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,2]' = -13.9 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,3]' = -8.3 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,4]' = -2.8 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,5]' = 2.8 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,6]' = 8.3 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,7]' = 13.9 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,8]' = 19.4 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,1]' = 18 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,2]' = 850 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,3]' = 930 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,4]' = 1010 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,5]' = 1110 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,6]' = 1220 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,7]' = 1370 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,8]' = 1570 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,1]' = 21 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,2]' = 980 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,3]' = 1060 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,4]' = 1160 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,5]' = 1250 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,6]' = 1370 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,7]' = 1530 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,8]' = 1730 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,1]' = 24 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,2]' = 1110 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,3]' = 1210 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,4]' = 1310 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,5]' = 1420 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,6]' = 1540 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,7]' = 1710 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,8]' = 1920 "Electrical power table; T in degC; Q_flow in W";
            parameter Modelica.SIunits.MassFlowRate mFlow_conNom = 0.1894736842105263 "Nominal mass flow rate in condenser";
            parameter Modelica.SIunits.MassFlowRate mFlow_evaNom = 0.75 "Nominal mass flow rate in evaporator";
            parameter Real 'tableUppBou[1,1]' = -15.0 "Points to define upper boundary for sink temperature";
            parameter Real 'tableUppBou[1,2]' = 25.0 "Points to define upper boundary for sink temperature";
            parameter Real 'tableUppBou[2,1]' = 20.0 "Points to define upper boundary for sink temperature";
            parameter Real 'tableUppBou[2,2]' = 25.0 "Points to define upper boundary for sink temperature";
          end dataTable_rec;
        public
          dataTable_rec dataTable annotation(Dialog);
        protected
          record Qdot_ConTable_rec
            Real u1_inBaseUnit(unit = "K") = fmi_Functions.from_degC(u1);
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Real u2_inBaseUnit(unit = "K") = fmi_Functions.from_degC(u2);
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
            constant Boolean extrapolation = true "False to hold last value";
            constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
            Real 'table[1,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
          protected
            record combiTable2D_rec
              Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
              Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
              constant Boolean tableOnFile = false "= true, if table is defined on file or in function usertab";
              Real 'table[1,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Boolean verboseRead = true "= true, if info message that file is loading is to be printed";
              constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
              constant Modelica.Blocks.Types.Extrapolation extrapolation = Modelica.Blocks.Types.Extrapolation.LastTwoPoints "Extrapolation of data outside the definition range";
              constant Boolean verboseExtrapolation = false "= true, if warning messages are to be printed if table input is outside the definition range";
              Real 'u_min[1]' "Minimum abscissa value defined in table";
              Real 'u_min[2]' "Minimum abscissa value defined in table";
              Real 'u_max[1]' "Maximum abscissa value defined in table";
              Real 'u_max[2]' "Maximum abscissa value defined in table";
            end combiTable2D_rec;
          public
            combiTable2D_rec combiTable2D annotation(Dialog);
          protected
            record realPassThrough2_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough2_rec;
          public
            realPassThrough2_rec realPassThrough2;
          protected
            record realPassThrough1_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough1_rec;
          public
            realPassThrough1_rec realPassThrough1;
          end Qdot_ConTable_rec;
        public
          Qdot_ConTable_rec Qdot_ConTable annotation(Dialog);
        protected
          record P_eleTable_rec
            Real u1_inBaseUnit(unit = "K") = fmi_Functions.from_degC(u1);
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Real u2_inBaseUnit(unit = "K") = fmi_Functions.from_degC(u2);
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
            constant Boolean extrapolation = true "False to hold last value";
            constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
            Real 'table[1,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
          protected
            record combiTable2D_rec
              Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
              Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
              constant Boolean tableOnFile = false "= true, if table is defined on file or in function usertab";
              Real 'table[1,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Boolean verboseRead = true "= true, if info message that file is loading is to be printed";
              constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
              constant Modelica.Blocks.Types.Extrapolation extrapolation = Modelica.Blocks.Types.Extrapolation.LastTwoPoints "Extrapolation of data outside the definition range";
              constant Boolean verboseExtrapolation = false "= true, if warning messages are to be printed if table input is outside the definition range";
              Real 'u_min[1]' "Minimum abscissa value defined in table";
              Real 'u_min[2]' "Minimum abscissa value defined in table";
              Real 'u_max[1]' "Maximum abscissa value defined in table";
              Real 'u_max[2]' "Maximum abscissa value defined in table";
            end combiTable2D_rec;
          public
            combiTable2D_rec combiTable2D annotation(Dialog);
          protected
            record realPassThrough2_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough2_rec;
          public
            realPassThrough2_rec realPassThrough2;
          protected
            record realPassThrough1_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough1_rec;
          public
            realPassThrough1_rec realPassThrough1;
          end P_eleTable_rec;
        public
          P_eleTable_rec P_eleTable annotation(Dialog);
        protected
          record t_Ev_in_rec
            Real y_inBaseUnit(unit = "K") = fmi_Functions.from_degC(y);
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal containing input signal u in another unit";
          end t_Ev_in_rec;
        public
          t_Ev_in_rec t_Ev_in;
        protected
          record t_Co_ou_rec
            Real y_inBaseUnit(unit = "K") = fmi_Functions.from_degC(y);
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal containing input signal u in another unit";
          end t_Co_ou_rec;
        public
          t_Co_ou_rec t_Co_ou;
        protected
          record nTimesPel_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end nTimesPel_rec;
        public
          nTimesPel_rec nTimesPel;
        protected
          record nTimesQCon_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end nTimesQCon_rec;
        public
          nTimesQCon_rec nTimesQCon;
        protected
          record nTimesSF_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            constant Modelica_Blocks_Interfaces_RealInput u2 = 1.35 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end nTimesSF_rec;
        public
          nTimesSF_rec nTimesSF;
        end PerformanceDataHPHeating_rec;
      public
        PerformanceDataHPHeating_rec PerformanceDataHPHeating annotation(Dialog);
      protected
        record gainEva_rec
          constant Real k = -1 "Gain value multiplied with input signal";
          Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
          Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
        end gainEva_rec;
      public
        gainEva_rec gainEva;
      protected
        record constZero_rec
          constant Real k = 0 "Constant output value";
          constant Modelica_Blocks_Interfaces_RealOutput y = 0.0 "Connector of Real output signal";
        end constZero_rec;
      public
        constZero_rec constZero;
      end innerCycle_rec;
    public
      innerCycle_rec innerCycle annotation(Dialog);
    protected
      record con_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
        Modelica.SIunits.MassFlowRate m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa") = 0.0 "Pressure difference between port_a and port_b";
        constant Boolean computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction";
        constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
        constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa", min = 0.0) = 0.0 "Pressure difference";
        constant Boolean linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate";
        constant Real deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar";
        constant Modelica.SIunits.Time tau = 30 "Time constant at nominal flow (if energyDynamics <> SteadyState)";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
        constant Real p_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325.0 "Start value of pressure";
        constant Real T_start(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 290.15 "Start value of temperature";
        constant Real 'X_start[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Start value of mass fractions m_i/m";
        constant Real 'X_start[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Start value of mass fractions m_i/m";
        constant Boolean is_con = true "Type of heat exchanger";
        Modelica.SIunits.Volume V "Volume in condenser";
        constant Boolean use_cap = false "False if capacity and heat losses are neglected";
        constant Modelica.SIunits.HeatCapacity C = 135.0 "Capacity of heat exchanger. If you want to neglace the dry mass of the heat exchanger, you can set this value to zero";
        Modelica.SIunits.Temperature TCap_start "Initial temperature of heat capacity";
        constant Modelica.SIunits.ThermalConductance GOut = 6.75 "Formular for calculation of heat transfer coefficient on the outside. If you want to simulate a heat exchanger with additional dry mass but without external heat losses, set the value to zero";
        constant Modelica_Blocks_Interfaces_RealOutput GInn = 0.0 "Formular for calculation of heat transfer coefficient on the inside";
        Modelica_Blocks_Interfaces_RealInput QFlow_in "Heat flow rate to the medium";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record vol_rec
          constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state";
          constant Real p_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325.0 "Start value of pressure";
          constant Real T_start(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 290.15 "Start value of temperature";
          constant Real 'X_start[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Start value of mass fractions m_i/m";
          constant Real 'X_start[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Start value of mass fractions m_i/m";
          constant Real mSenFac(min = 1.0) = 1 "Factor for scaling the sensible thermal mass of the volume";
          constant Boolean prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
          constant Boolean simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate";
          constant Integer nPorts = 2 "Number of ports";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports.";
          Modelica.SIunits.Volume V "Volume";
          Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) "Temperature of the fluid";
          Modelica_Blocks_Interfaces_RealOutput U(unit = "J") "Internal energy of the component";
          Modelica.SIunits.Pressure p "Pressure of the fluid";
          Modelica_Blocks_Interfaces_RealOutput m(unit = "kg") "Mass of the component";
          Modelica.SIunits.MassFraction 'Xi[1]' "Species concentration of the fluid";
          Modelica_Blocks_Interfaces_RealOutput 'mXi[1]'(unit = "kg", min = 0.0) "Species mass of the component";
          constant Boolean use_C_flow = false "Set to true to enable input connector for trace substance";
        protected
          record 'ports[1]_rec'
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[1]_rec';
        public
          'ports[1]_rec' 'ports[1]';
        protected
          record 'ports[2]_rec'
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[2]_rec';
        public
          'ports[2]_rec' 'ports[2]';
        protected
          record heatPort_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end heatPort_rec;
        public
          heatPort_rec heatPort;
        protected
          record dynBal_rec
            Modelica.SIunits.Energy U(nominal = 100000.0, fixed=false) "Internal energy of fluid";
            Modelica.SIunits.Mass 'mXi[1]'(fixed=false) "Masses of independent components in the fluid";
          end dynBal_rec;
        public
          dynBal_rec dynBal;
        end vol_rec;
      public
        vol_rec vol;
      protected
        record preDro_rec
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          Modelica.SIunits.MassFlowRate m_flow(nominal = 0.405) "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
          constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa", nominal = 1.0) = 0 "Pressure difference between port_a and port_b";
          constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
          constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa") = 0.0 "Pressure drop at nominal mass flow rate";
          constant Boolean linearized = false "= true, use linear relation between m_flow and dp for any flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_turbulent(min = 0.0) = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent";
          constant Real deltaM(min = 1E-06) = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
          constant Real k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
        protected
          record port_a_rec
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_a_rec;
        public
          port_a_rec port_a;
        protected
          record port_b_rec
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_b_rec;
        public
          port_b_rec port_b;
        end preDro_rec;
      public
        preDro_rec preDro;
      protected
        record preHea_rec
          constant Modelica.SIunits.Temperature T_ref = 293.15 "Reference temperature";
          constant Modelica.SIunits.LinearTemperatureCoefficient alpha = 0 "Temperature coefficient of heat flow rate";
        protected
          record port_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end port_rec;
        public
          port_rec port;
        end preHea_rec;
      public
        preHea_rec preHea;
      end con_rec;
    public
      con_rec con;
    protected
      record eva_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
        Modelica.SIunits.MassFlowRate m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa") = 0.0 "Pressure difference between port_a and port_b";
        constant Boolean computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction";
        constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
        constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa", min = 0.0) = 0.0 "Pressure difference";
        constant Boolean linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate";
        constant Real deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar";
        constant Modelica.SIunits.Time tau = 30 "Time constant at nominal flow (if energyDynamics <> SteadyState)";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
        constant Real p_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325.0 "Start value of pressure";
        constant Real T_start(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 281.15 "Start value of temperature";
        constant Real 'X_start[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Start value of mass fractions m_i/m";
        constant Real 'X_start[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Start value of mass fractions m_i/m";
        constant Boolean is_con = false "Type of heat exchanger";
        Modelica.SIunits.Volume V "Volume in condenser";
        constant Boolean use_cap = false "False if capacity and heat losses are neglected";
        constant Modelica.SIunits.HeatCapacity C = 135.0 "Capacity of heat exchanger. If you want to neglace the dry mass of the heat exchanger, you can set this value to zero";
        Modelica.SIunits.Temperature TCap_start "Initial temperature of heat capacity";
        constant Modelica.SIunits.ThermalConductance GOut = 6.75 "Formular for calculation of heat transfer coefficient on the outside. If you want to simulate a heat exchanger with additional dry mass but without external heat losses, set the value to zero";
        constant Modelica_Blocks_Interfaces_RealOutput GInn = 0.0 "Formular for calculation of heat transfer coefficient on the inside";
        Modelica_Blocks_Interfaces_RealInput QFlow_in "Heat flow rate to the medium";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record vol_rec
          constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state";
          constant Real p_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325.0 "Start value of pressure";
          constant Real T_start(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 281.15 "Start value of temperature";
          constant Real 'X_start[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Start value of mass fractions m_i/m";
          constant Real 'X_start[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Start value of mass fractions m_i/m";
          constant Real mSenFac(min = 1.0) = 1 "Factor for scaling the sensible thermal mass of the volume";
          constant Boolean prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
          constant Boolean simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate";
          constant Integer nPorts = 2 "Number of ports";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports.";
          Modelica.SIunits.Volume V "Volume";
          Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) "Temperature of the fluid";
          Modelica_Blocks_Interfaces_RealOutput U(unit = "J") "Internal energy of the component";
          Modelica.SIunits.Pressure p "Pressure of the fluid";
          Modelica_Blocks_Interfaces_RealOutput m(unit = "kg") "Mass of the component";
          Modelica.SIunits.MassFraction 'Xi[1]' "Species concentration of the fluid";
          Modelica_Blocks_Interfaces_RealOutput 'mXi[1]'(unit = "kg", min = 0.0) "Species mass of the component";
          constant Boolean use_C_flow = false "Set to true to enable input connector for trace substance";
        protected
          record 'ports[1]_rec'
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[1]_rec';
        public
          'ports[1]_rec' 'ports[1]';
        protected
          record 'ports[2]_rec'
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[2]_rec';
        public
          'ports[2]_rec' 'ports[2]';
        protected
          record heatPort_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end heatPort_rec;
        public
          heatPort_rec heatPort;
        protected
          record dynBal_rec
            Modelica.SIunits.Energy U(nominal = 100000.0, fixed=false) "Internal energy of fluid";
            Modelica.SIunits.Mass 'mXi[1]'(fixed=false) "Masses of independent components in the fluid";
          end dynBal_rec;
        public
          dynBal_rec dynBal;
        end vol_rec;
      public
        vol_rec vol;
      protected
        record preDro_rec
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          Modelica.SIunits.MassFlowRate m_flow(nominal = 0.405) "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
          constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa", nominal = 1.0) = 0 "Pressure difference between port_a and port_b";
          constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
          constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa") = 0.0 "Pressure drop at nominal mass flow rate";
          constant Boolean linearized = false "= true, use linear relation between m_flow and dp for any flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_turbulent(min = 0.0) = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent";
          constant Real deltaM(min = 1E-06) = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
          constant Real k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
        protected
          record port_a_rec
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_a_rec;
        public
          port_a_rec port_a;
        protected
          record port_b_rec
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_b_rec;
        public
          port_b_rec port_b;
        end preDro_rec;
      public
        preDro_rec preDro;
      protected
        record preHea_rec
          constant Modelica.SIunits.Temperature T_ref = 293.15 "Reference temperature";
          constant Modelica.SIunits.LinearTemperatureCoefficient alpha = 0 "Temperature coefficient of heat flow rate";
        protected
          record port_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end port_rec;
        public
          port_rec port;
        end preHea_rec;
      public
        preHea_rec preHea;
      end eva_rec;
    public
      eva_rec eva;
    protected
      record heatFlowIneEva_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        constant Integer n = 3 "Order of filter";
        constant Modelica.SIunits.Frequency f = 0.015 "Cut-off frequency";
        constant Boolean normalized = true "= true, if amplitude at f_cut is 3 dB, otherwise unmodified filter";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
        Real 'x_start[1]' "Initial or guess values of states";
        Real 'x_start[2]' "Initial or guess values of states";
        Real 'x_start[3]' "Initial or guess values of states";
        Real y_start "Initial value of output (remaining states are in steady state)";
        Real 'x[1]'(fixed=false) "Filter states";
        Real 'x[2]'(fixed=false) "Filter states";
        Real 'x[3]'(fixed=false) "Filter states";
      end heatFlowIneEva_rec;
    public
      heatFlowIneEva_rec heatFlowIneEva;
    protected
      record heatFlowIneCon_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        constant Integer n = 3 "Order of filter";
        constant Modelica.SIunits.Frequency f = 0.015 "Cut-off frequency";
        constant Boolean normalized = true "= true, if amplitude at f_cut is 3 dB, otherwise unmodified filter";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
        Real 'x_start[1]' "Initial or guess values of states";
        Real 'x_start[2]' "Initial or guess values of states";
        Real 'x_start[3]' "Initial or guess values of states";
        Real y_start "Initial value of output (remaining states are in steady state)";
        Real 'x[1]'(fixed=false) "Filter states";
        Real 'x[2]'(fixed=false) "Filter states";
        Real 'x[3]'(fixed=false) "Filter states";
      end heatFlowIneCon_rec;
    public
      heatFlowIneCon_rec heatFlowIneCon;
    protected
      record sigBus_rec
        Real nSet "Relative rotational speed of compressor between 0 and 1";
        Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
        Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
        Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
        Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
        Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
        Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
        Modelica.SIunits.Power PelMea "Total electrical active power";
        Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
        Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
        constant Real iceFacMea = 1.0 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
      end sigBus_rec;
    public
      sigBus_rec sigBus;
    protected
      record senT_a2_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0, fixed=false) "Temperature of the passing fluid";
        constant Modelica.SIunits.Temperature T_start = 281.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        Modelica.SIunits.Temperature TAmb "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_a2_rec;
    public
      senT_a2_rec senT_a2;
    protected
      record senT_b2_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0, fixed=false) "Temperature of the passing fluid";
        constant Modelica.SIunits.Temperature T_start = 281.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        Modelica.SIunits.Temperature TAmb "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_b2_rec;
    public
      senT_b2_rec senT_b2;
    protected
      record mFlow_eva_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        Modelica_Blocks_Interfaces_RealOutput m_flow(unit = "kg/s", quantity = "MassFlowRate") "Mass flow rate from port_a to port_b";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end mFlow_eva_rec;
    public
      mFlow_eva_rec mFlow_eva;
    protected
      record senT_b1_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0, fixed=false) "Temperature of the passing fluid";
        constant Modelica.SIunits.Temperature T_start = 290.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        Modelica.SIunits.Temperature TAmb "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_b1_rec;
    public
      senT_b1_rec senT_b1;
    protected
      record senT_a1_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0, fixed=false) "Temperature of the passing fluid";
        constant Modelica.SIunits.Temperature T_start = 290.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        Modelica.SIunits.Temperature TAmb "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_a1_rec;
    public
      senT_a1_rec senT_a1;
    protected
      record mFlow_con_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        Modelica_Blocks_Interfaces_RealOutput m_flow(unit = "kg/s", quantity = "MassFlowRate") "Mass flow rate from port_a to port_b";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end mFlow_con_rec;
    public
      mFlow_con_rec mFlow_con;
    protected
      record greaterThreshold_rec
        constant Real threshold = 1E-15 "Comparison with respect to threshold";
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
      end greaterThreshold_rec;
    public
      greaterThreshold_rec greaterThreshold;
    end heaPum_rec;
  public
    heaPum_rec heaPum annotation(Dialog);
  protected
    record heaOn_rec
      parameter Boolean k = true "Constant output value";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
    end heaOn_rec;
  public
    heaOn_rec heaOn annotation(Dialog);
  protected
    record senTAct_rec
      constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
      constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.3 "Nominal mass flow rate, used for regularization near zero flow";
      constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
      constant Modelica.SIunits.Time tau(min = 0.0) = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
      constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
      Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature", min = 0.0, fixed=false) "Temperature of the passing fluid";
      constant Modelica.SIunits.Temperature T_start = 303.15 "Initial or guess value of output (= state)";
      constant Boolean transferHeat = false "if true, temperature T converges towards TAmb when no flow";
      constant Modelica.SIunits.Temperature TAmb = 291.15 "Fixed ambient temperature for heat transfer";
      constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200 "Time constant for heat transfer, default 20 minutes";
    protected
      record port_a_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_a_rec;
    public
      port_a_rec port_a;
    protected
      record port_b_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_b_rec;
    public
      port_b_rec port_b;
    end senTAct_rec;
  public
    senTAct_rec senTAct;
  protected
    record iceFac_rec
      constant Real k = 1 "Constant output value";
      constant Modelica_Blocks_Interfaces_RealOutput y = 1.0 "Connector of Real output signal";
    end iceFac_rec;
  public
    iceFac_rec iceFac;
  protected
    record nSetGai_rec
      parameter Real k = 0.5 "Gain value multiplied with input signal";
      Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
      Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
    end nSetGai_rec;
  public
    nSetGai_rec nSetGai annotation(Dialog);
  protected
    record sigBus1_rec
      Real nSet "Relative rotational speed of compressor between 0 and 1";
      Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
      Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
      Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
      Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
      Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
      Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
      Modelica.SIunits.Power PelMea "Total electrical active power";
      Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
      Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
      constant Real iceFacMea = 1 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
    end sigBus1_rec;
  public
    sigBus1_rec sigBus1;
  protected
    record port_a_rec
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end port_a_rec;
  public
    port_a_rec port_a;
  protected
    record port_b_rec
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end port_b_rec;
  public
    port_b_rec port_b;
  end rtuHP_rec;
public
  rtuHP_rec rtuHP annotation(Dialog);
protected
  record supFan_rec
    constant Integer nPorts = 1 "Number of ports";
    constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
    parameter Real 'X[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Fixed value of composition";
    parameter Real 'X[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Fixed value of composition";
    parameter Modelica.SIunits.MassFlowRate m_flow = 0 "Fixed mass flow rate going out of the fluid port";
    parameter Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 293.15 "Fixed value of temperature";
    Modelica_Blocks_Interfaces_RealInput m_flow_in(unit = "kg/s") "Prescribed mass flow rate";
    Modelica_Blocks_Interfaces_RealInput T_in(unit = "K", displayUnit = "degC") "Prescribed boundary temperature";
  protected
    record 'ports[1]_rec'
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end 'ports[1]_rec';
  public
    'ports[1]_rec' 'ports[1]';
  end supFan_rec;
public
  supFan_rec supFan annotation(Dialog);
protected
  record roo_rec
    constant Integer nPorts = 1 "Number of ports";
    constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
    parameter Real 'X[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Fixed value of composition";
    parameter Real 'X[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Fixed value of composition";
    parameter Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325 "Fixed value of pressure";
    parameter Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 293.15 "Fixed value of temperature";
  protected
    record 'ports[1]_rec'
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end 'ports[1]_rec';
  public
    'ports[1]_rec' 'ports[1]';
  end roo_rec;
public
  roo_rec roo annotation(Dialog);
protected
  record rtuConFMU_rec
    Real k_hea "Proportional gain of heating controller";
    Modelica.SIunits.Time Ti_hea "Integral time constant of heating controller";
    Modelica.SIunits.ThermodynamicTemperature maxSAT "max supply air temperature";
    Real uLowSta1 "PI lower bound to activate stage 1";
    Real uUppSta1 "PI upper bound to activate stage 1";
    Real uLowSta2 "PI lower bound to activate stage 2";
    Real uUppSta2 "PI upper bound to activate stage 2";
    Real kSta1 "PI center line to activate stage 1";
    Real kSta2 "PI center line to activate stage 2";
    Real banSta1 "PI band to activate stage 1";
    Real banSta2 "PI band to activate stage 2";
    Modelica_Blocks_Interfaces_RealInput TSetRooHea(unit = "K", displayUnit = "degC") "Zone heating setpoint temperature";
    Modelica_Blocks_Interfaces_RealInput TRoo(unit = "K", displayUnit = "degC") "Zone temperature measurement";
    Modelica_Blocks_Interfaces_RealOutput heaSta "Control signal for heating";
    Modelica_Blocks_Interfaces_RealInput TSup(unit = "K", displayUnit = "degC") "Supply air temperature";
    Modelica_Blocks_Interfaces_BooleanOutput heaCal "Control signal for heating";
    Modelica_Blocks_Interfaces_RealOutput PI_y "Control signal for heating";
  protected
    record conHea_rec
      Modelica_Blocks_Interfaces_RealInput u_s "Connector of setpoint input signal";
      Modelica_Blocks_Interfaces_RealInput u_m "Connector of measurement input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of actuator output signal";
      Real controlError "Control error (set point - measurement)";
      constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
      Real k(min = 0.0) "Gain of controller";
      Modelica.SIunits.Time Ti(min = 1E-60) "Time constant of Integrator block";
      parameter Modelica.SIunits.Time Td(min = 0.0) = 0.1 "Time constant of Derivative block";
      constant Real yMax = 1 "Upper limit of output";
      constant Real yMin = 0 "Lower limit of output";
      parameter Real wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
      parameter Real wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
      parameter Real Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
      parameter Real Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
      constant Modelica.Blocks.Types.InitPID initType = Modelica.Blocks.Types.InitPID.InitialOutput "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
      constant Real xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
      parameter Real xd_start = 0 "Initial or guess value for state of derivative block";
      constant Real y_start = 0 "Initial value of output";
      constant Boolean strict = true "= true, if strict limits with noEvent(..)";
      parameter Boolean reverseAction = false "Set to true for throttling the water flow rate through a cooling coil controller";
      constant Buildings_Types_Reset reset = Buildings_Types_Reset.Parameter "Type of controller output reset";
      constant Real y_reset = 0.0 "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == Buildings.Types.Reset.Parameter";
      Modelica_Blocks_Interfaces_BooleanInput trigger "Resets the controller output when trigger becomes true";
    protected
      record addP_rec
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
        Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        Real k1 "Gain of input signal 1";
        Real k2 "Gain of input signal 2";
      end addP_rec;
    public
      addP_rec addP;
    protected
      record P_rec
        parameter Real k = 1 "Gain value multiplied with input signal";
        Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
        Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
      end P_rec;
    public
      P_rec P annotation(Dialog);
    protected
      record addPID_rec
        constant Real k1 = 1 "Gain of input signal 1";
        constant Real k2 = 1 "Gain of input signal 2";
        constant Real k3 = 1 "Gain of input signal 3";
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
        constant Modelica_Blocks_Interfaces_RealInput u2 = 0 "Connector of Real input signal 2";
        Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end addPID_rec;
    public
      addPID_rec addPID;
    protected
      record I_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y(fixed=false) "Connector of Real output signal";
        Real k "Integrator gain";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
        constant Real y_start = 0.0 "Initial or guess value of output (= state)";
        constant Buildings_Types_Reset reset = Buildings_Types_Reset.Input "Type of integrator reset";
        constant Real y_reset = 0.0 "Value to which integrator is reset, used if reset = Buildings.Types.Reset.Parameter";
        Modelica_Blocks_Interfaces_RealInput y_reset_in "Input signal for state to which integrator is reset, enabled if reset = Buildings.Types.Reset.Input";
        Modelica_Blocks_Interfaces_BooleanInput trigger "Resets the integrator output when trigger becomes true";
      end I_rec;
    public
      I_rec I;
    end conHea_rec;
  public
    conHea_rec conHea annotation(Dialog);
  protected
    record swiHea_rec
      Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
      Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end swiHea_rec;
  public
    swiHea_rec swiHea;
  protected
    record offHea_rec
      parameter Real k = 0 "Constant output value";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end offHea_rec;
  public
    offHea_rec offHea annotation(Dialog);
  protected
    record onOffConSupHeatSetPoi_rec
      Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
      parameter Real bandwidth = 0.5 "Bandwidth around reference signal";
      parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
    end onOffConSupHeatSetPoi_rec;
  public
    onOffConSupHeatSetPoi_rec onOffConSupHeatSetPoi annotation(Dialog);
  protected
    record UpperLimSup_rec
      Real k "Constant output value";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end UpperLimSup_rec;
  public
    UpperLimSup_rec UpperLimSup;
  protected
    record heatStage_rec
      Real uLowSta1 "PI lower bound to activate stage 1";
      Real uUppSta1 "PI upper bound to activate stage 1";
      Real uLowSta2 "PI lower bound to activate stage 2";
      Real uUppSta2 "PI upper bound to activate stage 2";
      Real kSta1 "PI center line to activate stage 1";
      Real kSta2 "PI center line to activate stage 2";
      Real banSta1 "PI band to activate stage 1";
      Real banSta2 "PI band to activate stage 2";
      Modelica_Blocks_Interfaces_RealInput uHea "Zone temperature measurement";
      Modelica_Blocks_Interfaces_RealOutput y_Sta "Zone temperature measurement";
    protected
      record realToBoolean1_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
        parameter Real threshold = 0.001 "Output signal y is true, if input u >= threshold";
      end realToBoolean1_rec;
    public
      realToBoolean1_rec realToBoolean1 annotation(Dialog);
    protected
      record add_rec
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
        Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        parameter Real k1 = 1 "Gain of input signal 1";
        parameter Real k2 = 1 "Gain of input signal 2";
      end add_rec;
    public
      add_rec add annotation(Dialog);
    protected
      record switch4_rec
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
        Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
        Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end switch4_rec;
    public
      switch4_rec switch4;
    protected
      record const7_rec
        parameter Real k = 0 "Constant output value";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end const7_rec;
    public
      const7_rec const7 annotation(Dialog);
    protected
      record booleanToReal_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Connector of Boolean input signal";
        parameter Real realTrue = 1.0 "Output signal for true Boolean input";
        parameter Real realFalse = 0.0 "Output signal for false Boolean input";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end booleanToReal_rec;
    public
      booleanToReal_rec booleanToReal annotation(Dialog);
    protected
      record booleanToReal1_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Connector of Boolean input signal";
        parameter Real realTrue = 1.0 "Output signal for true Boolean input";
        parameter Real realFalse = 0.0 "Output signal for false Boolean input";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end booleanToReal1_rec;
    public
      booleanToReal1_rec booleanToReal1 annotation(Dialog);
    protected
      record const1_rec
        Real k "Constant output value";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end const1_rec;
    public
      const1_rec const1;
    protected
      record onOffSta1_rec
        Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
        Real bandwidth "Bandwidth around reference signal";
        parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
      end onOffSta1_rec;
    public
      onOffSta1_rec onOffSta1 annotation(Dialog);
    protected
      record const2_rec
        Real k "Constant output value";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end const2_rec;
    public
      const2_rec const2;
    protected
      record onOffSta2_rec
        Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
        Real bandwidth "Bandwidth around reference signal";
        parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
      end onOffSta2_rec;
    public
      onOffSta2_rec onOffSta2 annotation(Dialog);
    protected
      record not1_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Boolean input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Boolean output signal";
      end not1_rec;
    public
      not1_rec not1;
    protected
      record not2_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Boolean input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Boolean output signal";
      end not2_rec;
    public
      not2_rec not2;
    end heatStage_rec;
  public
    heatStage_rec heatStage annotation(Dialog);
  protected
    record swiTim_rec
      Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
      Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end swiTim_rec;
  public
    swiTim_rec swiTim;
  protected
    record onOffConHea_rec
      Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
      Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
      parameter Real bandwidth = 1 "Bandwidth around reference signal";
      parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
    end onOffConHea_rec;
  public
    onOffConHea_rec onOffConHea annotation(Dialog);
  protected
    record UppLimSwi_rec
      Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
      Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end UppLimSwi_rec;
  public
    UppLimSwi_rec UppLimSwi;
  protected
    record NotLim_rec
      Modelica_Blocks_Interfaces_BooleanInput u "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
    end NotLim_rec;
  public
    NotLim_rec NotLim;
  protected
    record onDelay_rec
      Modelica_Blocks_Interfaces_BooleanInput u "Boolean input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Boolean output signal";
      parameter Modelica.SIunits.Time delayTime = 120 "Delay time";
    end onDelay_rec;
  public
    onDelay_rec onDelay annotation(Dialog);
  protected
    record realToBoolean_rec
      Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
      parameter Real threshold = 0.5 "Output signal y is true, if input u >= threshold";
    end realToBoolean_rec;
  public
    realToBoolean_rec realToBoolean annotation(Dialog);
  protected
    record realToBoolean1_rec
      Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
      parameter Real threshold = 0.1 "Output signal y is true, if input u >= threshold";
    end realToBoolean1_rec;
  public
    realToBoolean1_rec realToBoolean1 annotation(Dialog);
  end rtuConFMU_rec;
public
  rtuConFMU_rec rtuConFMU annotation(Dialog);
  parameter Real _u_m_flow_start = 0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_m_flow(unit = "kg/s", nominal = 0.405, min = -100000.0, max = 100000.0, start = _u_m_flow_start)
  annotation (Placement(transformation(extent={{-124,47},{-84,87}})));
  parameter Real _u_TDryBul_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_TDryBul(unit = "K", displayUnit = "degC", start = _u_TDryBul_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,14},{-84,54}})));
  parameter Real _u_TRoo_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_TRoo(unit = "K", displayUnit = "degC", start = _u_TRoo_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,-20},{-84,20}})));
  parameter Real _u_TRooSetPoi_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_TRooSetPoi(unit = "K", displayUnit = "degC", start = _u_TRooSetPoi_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,-53},{-84,-13}})));
  parameter Real _u_TMix_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput u_TMix(unit = "K", displayUnit = "degC", start = _u_TMix_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,-86},{-84,-46}})));
  Modelica.Blocks.Interfaces.RealOutput y_TSup(unit = "K", displayUnit = "degC", min = 0.0)
  annotation (Placement(transformation(extent={{100,40},{140,80}})));
  Modelica.Blocks.Interfaces.RealOutput y_PEleHP(unit = "W")
  annotation (Placement(transformation(extent={{100,0},{140,40}})));
  Modelica.Blocks.Interfaces.BooleanOutput y_HeaCal
  annotation (Placement(transformation(extent={{100,-40},{140,0}})));
  Modelica.Blocks.Interfaces.RealOutput y_PI
  annotation (Placement(transformation(extent={{100,-80},{140,-40}})));
public
  parameter String fmi_instanceName="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  parameter String fmi_resourceLocation="file:///"+ModelicaServices.ExternalReferences.loadResource("modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/resources")
  annotation (Dialog(tab="FMI", group="Instantiation"));
protected
  constant Integer fmi_NumberOfEventIndicators = 48;
  Real fmi_z[fmi_NumberOfEventIndicators] "Event indicators";
  Boolean fmi_z_positive[fmi_NumberOfEventIndicators](each start=false, fixed=true);
  fmi_Functions.fmiModel fmi;
  parameter Real zeroOffset = 0; //will fix in later implementations
  Boolean fmi_NewStates;
  Boolean fmi_NewStates2(start=false, fixed=true);
  Boolean fmi_StepEvent;
  Boolean fmi_DiscreteInputChanged;
  Boolean fmi_iterationConverged(start=false, fixed=true);
  Integer fmi_NextMode;
  Boolean fmi_flip(start=false, fixed=true);
  Real fmi_TNext(start=1e37, fixed=true);
  Real myTime;
  parameter Real myTimeStart(fixed=false);
  Boolean _first(start=true);
  parameter Boolean _startValuesNotSet(fixed=false,start=true);
  Real fmi_dummy;
package fmi_Functions
    class fmiModel
      extends ExternalObject;
      function constructor "Initialize FMI model"
        extends Modelica.Icons.Function;
        input String instanceName;
        input Boolean loggingOn;
        input String resourceLocation;
        output fmiModel fmi;
        external"C" fmi = hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiInstantiateModel2(instanceName, loggingOn, resourceLocation)
        annotation(Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_Instantiate_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_Instantiate_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149Logger(fmi2ComponentEnvironment componentEnvironment, fmi2String instanceName, fmi2Status status,
  fmi2String category, fmi2String message, ...) {
  char msg[4096];
  char buf[4096];
  va_list ap;
  int len;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len < 4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmi2Fatal:
      ModelicaMessage(\"[fmi2Fatal]: \");
      break;
    case fmi2Error:
      ModelicaMessage(\"[fmi2Error]: \");
      break;
    case fmi2Discard:
      ModelicaMessage(\"[fmi2Discard]: \");
      break;
    case fmi2Warning:
      ModelicaMessage(\"[fmi2Warning]: \");
      break;
    case fmi2OK:
      ModelicaMessage(\"[fmi2OK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiInstantiateModel2(const char*instanceName, fmi2Boolean loggingOn, fmi2String resourceLocation) {
  static fmi2CallbackFunctions funcs = {&hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149Logger, &calloc, &free, NULL, NULL};
  struct dy_fmi2Extended* res;
  res = calloc(1, sizeof(struct dy_fmi2Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibrary(\"hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU.so\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU.so) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiate=(fmi2InstantiateFunc)GetProcAddress(res->hInst,\"fmi2Instantiate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Instantiate!\");
      return 0;
    }
    if (!(res->dyFmiFreeInstance=(fmi2FreeInstanceFunc)GetProcAddress(res->hInst,\"fmi2FreeInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeInstance!\");
      return 0;
    }
    if (!(res->dyFmiSetupExperiment=(fmi2SetupExperimentFunc)GetProcAddress(res->hInst,\"fmi2SetupExperiment\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetupExperiment!\");
      return 0;
    }
    if (!(res->dyFmiEnterInitializationMode=(fmi2EnterInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2EnterInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiExitInitializationMode=(fmi2ExitInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2ExitInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2ExitInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmi2TerminateFunc)GetProcAddress(res->hInst,\"fmi2Terminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Terminate!\");
      return 0;
    }
    if (!(res->dyFmiReset=(fmi2ResetFunc)GetProcAddress(res->hInst,\"fmi2Reset\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Reset!\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmi2SetRealFunc)GetProcAddress(res->hInst,\"fmi2SetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmi2GetRealFunc)GetProcAddress(res->hInst,\"fmi2GetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmi2SetIntegerFunc)GetProcAddress(res->hInst,\"fmi2SetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmi2GetIntegerFunc)GetProcAddress(res->hInst,\"fmi2GetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmi2SetBooleanFunc)GetProcAddress(res->hInst,\"fmi2SetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmi2GetBooleanFunc)GetProcAddress(res->hInst,\"fmi2GetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmi2SetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmi2SetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetDebugLogging!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmi2SetStringFunc)GetProcAddress(res->hInst,\"fmi2SetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmi2GetStringFunc)GetProcAddress(res->hInst,\"fmi2GetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetString!\");
      return 0;
    }
    if (!(res->dyFmiSetContinuousStates=(fmi2SetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmi2SetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetContinuousStates=(fmi2GetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmi2GetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetTime=(fmi2SetTimeFunc)GetProcAddress(res->hInst,\"fmi2SetTime\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetTime!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetTime\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiCompletedIntegratorStep=(fmi2CompletedIntegratorStepFunc)GetProcAddress(res->hInst,\"fmi2CompletedIntegratorStep\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2CompletedIntegratorStep!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiCompletedIntegratorStep\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEnterEventMode=(fmi2EnterEventModeFunc)GetProcAddress(res->hInst,\"fmi2EnterEventMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterEventMode!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEnterEventMode\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiNewDiscreteStates=(fmi2NewDiscreteStatesFunc)GetProcAddress(res->hInst,\"fmi2NewDiscreteStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2NewDiscreteStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiNewDiscreteStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEnterContinuousTimeMode=(fmi2EnterContinuousTimeModeFunc)GetProcAddress(res->hInst,\"fmi2EnterContinuousTimeMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterContinuousTimeMode!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEnterContinuousTimeMode\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDerivatives=(fmi2GetDerivativesFunc)GetProcAddress(res->hInst,\"fmi2GetDerivatives\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetDerivatives!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetDerivatives\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetEventIndicators=(fmi2GetEventIndicatorsFunc)GetProcAddress(res->hInst,\"fmi2GetEventIndicators\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetEventIndicators!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetEventIndicators\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDirectionalDerivative=(fmi2GetDirectionalDerivativeFunc)GetProcAddress(res->hInst,\"fmi2GetDirectionalDerivative\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetDirectionalDerivative!\");
      return 0;
    }
    if (!(res->dyFmiGetFMUstate=(fmi2GetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2GetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSetFMUstate=(fmi2SetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiFreeFMUstate=(fmi2FreeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2FreeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSerializedFMUstateSize=(fmi2SerializedFMUstateSizeFunc)GetProcAddress(res->hInst,\"fmi2SerializedFMUstateSize\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializedFMUstateSize!\");
      return 0;
    }
    if (!(res->dyFmiSerializeFMUstate=(fmi2SerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiDeSerializeFMUstate=(fmi2DeSerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2DeSerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2DeSerializeFMUstate!\");
      return 0;
    }
    res->m=res->dyFmiInstantiate(instanceName, fmi2ModelExchange, \"{adff7f86-3a2c-4ea3-bd76-6b325cbdd149}\",resourceLocation, &funcs, fmi2False, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->discreteInputChanged=1;res->currentMode=dyfmi2InstantiationMode;res->dyLastStepTime=0;res->dyFMUstate=NULL;}
  }
  return res;
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
      end constructor;

      function destructor "Release storage of FMI model"
        extends Modelica.Icons.Function;
        input fmiModel fmi;
        external"C"
                   hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiFreeModelInstance2(fmi);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_Free_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_Free_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiFreeModelInstance2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    if(a->dyFMUstate)
    a->dyFmiFreeFMUstate(a->m, &a->dyFMUstate);
    /*a->dyFmiSetDebugLogging(a->m,fmi2True,0,NULL);*/
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
      end destructor;
    end fmiModel;

    function  fmiSetTime
    input fmiModel fmi;
    input Real ti;
    external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetTime2(fmi, ti);
    annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetTime_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetTime_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetTime2(void*m, double ti) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(ti > a->dyTime || (a->currentMode == dyfmi2EventMode && ti==a->dyTime && !isModelicaEvent())){
      a->dyTime=ti;
      if(a->currentMode == dyfmi2EventMode){
        status = a->dyFmiEnterContinuousTimeMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterContinuousTimeMode failed!\");
        a->currentMode = dyfmi2ContinuousTimeMode;
      }
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti < a->dyTime && a->currentMode == dyfmi2ContinuousTimeMode){
       a->dyTime=ti;
       status=a->dyFmiSetTime(a->m, ti);
    }else{
       status=fmi2OK;
    }
  }
  if (status!=fmi2OK ) ModelicaError(\"SetTime failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU",__Dymola_IdemPotent=true);
    end fmiSetTime;

    function fmiSetContinuousStates
    input fmiModel fmi;
    input Real x[:];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetContinuousStates2(
       fmi,
       x,
       size(x, 1));
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetContinuousStates_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetContinuousStates2(void*m, const double*x, size_t nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
     status=a->dyFmiSetContinuousStates(a->m, x, nx);
    }else{
     status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetContinuousStates failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiSetContinuousStates;

    function  fmiGetContinuousStates
    input fmiModel fmi;
    input Integer nx;
    output Real x[nx];
    input Real preAvailable;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetContinuousStates2(
        fmi,
        x,
        nx);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetContinuousStates_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetContinuousStates_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetContinuousStates2(void*m, double*x, int nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetContinuousStates(a->m, x, nx);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetContinuousStates failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetContinuousStates;

    function  fmiCompletedIntegratorStep
    input fmiModel fmi;
    input Real dummyTime;
    output Real crossing;
      external"C" crossing = hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiCompletedIntegratorStep2(fmi);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_CompletedIntegratorStep_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_CompletedIntegratorStep_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiCompletedIntegratorStep2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status = fmi2Fatal;
  fmi2Boolean enterEventMode = fmi2False;
  fmi2Boolean terminateSimulation = fmi2False;
  if (a) {
    if (a->dyTime>a->dyLastTime) {
      status=a->dyFmiCompletedIntegratorStep(a->m, fmi2True, &enterEventMode, &terminateSimulation);
      if(terminateSimulation == fmi2True) terminate(\"Terminate signaled by FMU after call to fmiCompletedIntegratorStep\");
      a->dyLastTime=a->dyTime;
      if (enterEventMode == fmi2True) a->dyTriggered=1;
    } else status=fmi2OK;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"CompletedIntegratorStep failed\");
  return a->dyTriggered && a->dyTime>=a->dyLastTime;
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiCompletedIntegratorStep;

    function  fmiEnterModelInitialization
    input fmiModel fmi;
    input Real startTime;
    external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiEnterModelInitialization2(fmi, startTime);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiEnterModelInitialization_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiEnterModelInitialization_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiEnterModelInitialization2(void*m, double startTime) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  fmi2Boolean toleranceControlled=fmi2False;
  fmi2Real tolerance=0;
  if (a) {
    if(a->currentMode==dyfmi2InstantiationMode){
      a->dyTime=startTime;
      status=a->dyFmiSetupExperiment(a->m, fmi2False, 0, a->dyTime, fmi2False, 0);
      status=a->dyFmiEnterInitializationMode(a->m);
      a->currentMode=dyfmi2InitializationMode;
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
    }else{
      status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"Initialize failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiEnterModelInitialization;

    function  fmiExitModelInitializationMode
    input fmiModel fmi;
    output Real dummy=1.0;
    external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiExitModelInitializationMode2(fmi);
    annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiExitModelInitializationMode_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiExitModelInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiExitModelInitializationMode2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiExitInitializationMode(a->m);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
    a->currentMode = dyfmi2EventMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiExitModelInitialization failed!\");
  return;
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiExitModelInitializationMode;

    function  fmiUpdateDiscreteStates
    input fmiModel fmi;
    output Integer nextMode;
    output Real tNext;
    output Boolean stateValuesChanged;
    external"C" nextMode = hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiUpdateDiscreteStates2(fmi, tNext, stateValuesChanged);
      annotation(Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_UpdateDiscreteStates_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_UpdateDiscreteStates_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
int hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiUpdateDiscreteStates2(void*m, double* tNext, int* stateValuesChanged){
  struct dy_fmi2Extended*a=m;
  fmi2EventInfo ev;
  fmi2Status status=fmi2Fatal;
  ev.nextEventTime=1e37;
  ev.newDiscreteStatesNeeded=fmi2False;
  ev.valuesOfContinuousStatesChanged=fmi2False;
  ev.nextEventTimeDefined=fmi2False;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
  status=a->dyFmiNewDiscreteStates(a->m, &ev);
  a->dyTriggered=0;
  a->dyLastTime=a->dyTime;
  a->discreteInputChanged=0;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"EventUpdate failed\");
  if (ev.terminateSimulation){
    terminate(\"Terminate signaled by FMU\");
  }
  if(ev.nextEventTimeDefined==fmi2True){
    *tNext=ev.nextEventTime;
  }else{
    *tNext=1e37;
  }
  *stateValuesChanged = ev.valuesOfContinuousStatesChanged;
  return ev.newDiscreteStatesNeeded;
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiUpdateDiscreteStates;

    function  fmiGetDerivatives
    input fmiModel fmi;
    input Integer nx;
    output Real dx[nx];
    external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetDerivatives2(
    fmi,
      dx,
      nx);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetDerivatives_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetDerivatives_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetDerivatives2(void*m,double*dx,int nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetDerivatives(a->m, dx, nx);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetDerivatives failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetDerivatives;

    function  fmiGetEventIndicators
    input fmiModel fmi;
    input Integer nz;
    output Real z[nz];
    external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetEventIndicators2(
      fmi,
      z,
      nz);
    annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetEventIndicators_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetEventIndicators_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetEventIndicators2(void*m,double*z,int nz) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode || a->currentMode == dyfmi2EventMode){
      status=a->dyFmiGetEventIndicators(a->m, z, nz);
    }else{
      status=fmi2OK;    }
;  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetEventIndicators failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetEventIndicators;

    function fmiReset
      input fmiModel fmi;
      output Boolean resetOK;
      external"C" resetOK = hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiReset2(fmi);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_Reset_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_Reset_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiReset2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiReset(a->m);
    a->currentMode=dyfmi2InstantiationMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiReset failed\");
    return 1.0;
  }
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiReset;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetReal_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetReal;

    function fmiGetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real preAvailable;
      output Real vals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetReal_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetRealwf;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      external"C"
                 hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetReal_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      input Real preAvailable;
      output Real postAvailable=preAvailable;
      external"C"
                 hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetReal_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealwf;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetInteger_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetInteger;

    function fmiGetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Integer vals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetInteger_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetInteger_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetIntegerwf;

    function fmiSetInteger
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetInteger_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed in SetInteger\");
      for( i = 0; i < nrefs; ++i){
        if(oldVals[i] != vals[i]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetBoolean_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetBoolean;

    function fmiGetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Boolean vals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetBoolean_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetBooleanwf;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetBoolean_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals, int* dummy, int* oldVals) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(oldVals));
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed in SetBoolean\");
      for(j=nr-1;j>=0;j--){
        oldVals[j]=((fmi2Boolean*)(oldVals))[j];
        if(oldVals[j] != dummy[j]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetString
      input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetString_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_SetString_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSetString2(void*m, const int*refs, size_t nrefs,const fmi2String vals[]) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    a->discreteInputChanged = fmi2True;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetString failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiGetDirectionalDerivative
      input fmiModel fmi;
      input Integer z_refs[:];
      input Integer v_refs[:];
      input Real dv[size(v_refs, 1)];
      output Real dz[size(z_refs, 1)];
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetDirectionalDerivative2(
        fmi,
        z_refs,
        size(z_refs, 1),
        v_refs,
        size(v_refs, 1),
        dv,
        dz);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetDirectionalDerivative2_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetDirectionalDerivative2_C 1
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_GetDirectionalDerivative2(void*m, const int* zref, size_t nzr, const int* vrefs, size_t nvr, const double *dv, double *dz) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetDirectionalDerivative(a->m, zref, nzr, vrefs, nvr, dv, dz);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetDirectionalDerivative failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiGetDirectionalDerivative;

    function CheckIfDiscreteValueSet
      input fmiModel fmi;
      input Real dummyTime;
      input Real realInputs[:];
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      input Integer realInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Real dummyRealOutputs[:];
      input Boolean dummyBooleanOutputs[:];
      input Integer dummyIntegerOutputs[:];
      output Real DiscreteInputSet;
    algorithm
      fmiSetReal(fmi, realInputValueReferences, realInputs);
      fmiSetBoolean(fmi, booleanInputValueReferences, booleanInputs);
      fmiSetInteger(fmi, integerInputValueReferences, integerInputs);
      DiscreteInputSet := fmiCheckIfDiscreteValueSet(fmi);
      annotation(LateInline=true);
    end CheckIfDiscreteValueSet;

    function fmiCheckIfDiscreteValueSet
      input fmiModel fmi;
      output Real DiscreteInputSet;
      external "C" DiscreteInputSet = hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiCheckIfDiscreteValueSet2(fmi);
      annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiCheckIfDiscreteValueSet_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiCheckIfDiscreteValueSet_C 1
#include \"FMI/fmi2Import.h\"
double hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiCheckIfDiscreteValueSet2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    return a->discreteInputChanged;
  }
  ModelicaError(\"fmiCheckIfDiscreteValueSet2 failed!\");
  return 0;
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiCheckIfDiscreteValueSet;

    function GetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      input Real dummyTime;
      input Real realInputs[:];
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputVariableReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      z := fmiGetEventIndicators(fmi, nz);
      annotation(LateInline=true);
    end GetEventIndicators;

    function noHysteresis
      input Real x;
      output Real y;
    algorithm
      y:=x+(if (x < 0) then -1 else 1);
    end noHysteresis;

    function GetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1]);
      annotation(derivative(noDerivative=realLinearDependentInputs,noDerivative=linearDependentStates)=derGetRealVariable, LateInline=true);
    end GetRealVariable;

    function derGetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      input Real derRealInputs[:];
      input Real derStates[:];
      input Real derLinearOffsets;
      output Real derOutputVariable;
    protected
      Real dummy[1];
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //setString(fmi,stringInputValueReferences,stringInputs);
      dummy:=fmiGetDirectionalDerivative(fmi, outputValueReference,  cat(1,realInputValueReferences,statesValueRefernces), cat(1,derRealInputs,derStates));
      derOutputVariable:=dummy[1]+derLinearOffsets;
      annotation(LateInline=true);
    end derGetRealVariable;

    function fmiSaveFMUState
      input fmiModel fmi;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSaveFMUState2(fmi);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSaveFMUState_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSaveFMUState_C 1
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSaveFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiSaveFMUState;

    function fmiRestoreFMUState
      input fmiModel fmi;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiRestoreFMUState2(fmi);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiRestoreFMUState_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiRestoreFMUState_C 1
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiRestoreFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiRestoreFMUState;

    function fmiSerializeFMUstate
      input fmiModel fmi;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSerializeFMUstate2(fmi);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSerializeFMUstate_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
    status = a->dyFmiSerializedFMUstateSize(a->m, a->dyFMUstate, &a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializedFMUstateSize failed\");
    if( a->dySerializeFMUstate) free(a->dySerializeFMUstate); a->dySerializeFMUstate = NULL;
    a->dySerializeFMUstate = malloc(a->dyFMUStateSize);
    if(!a->dySerializeFMUstate)  ModelicaError(\"malloc call to allocate SerializeFMUstate failed\");
    status = a->dyFmiSerializeFMUstate(a->m, a->dyFMUstate, a->dySerializeFMUstate, a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializeFMUstate failed\");
  }
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiSerializeFMUstate;

    function fmiDeSerializeFMUstate
      input fmiModel fmi;
      external"C" hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiDeSerializeFMUstate2(fmi);
        annotation (Header="
#ifndef hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiDeSerializeFMUstate_C
#define hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiDeSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU7863243766325149_fmiDeSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(!a->dySerializeFMUstate) ModelicaError(\"serializedFmuState is not allocated!!!\");
    if(a->dyFMUstate){
      a->dyFmiFreeFMUstate(a->m, a->dyFMUstate);
      a->dyFMUstate = NULL;    }
    status = a->dyFmiDeSerializeFMUstate(a->m, a->dySerializeFMUstate, a->dyFMUStateSize, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiDeSerializeFMUstate failed\");
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
  }
}
#endif", Library="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU", LibraryDirectory="modelica://hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu/Resources/Library/FMU/hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU");
    end fmiDeSerializeFMUstate;

    function  setTimeAndStates
      input fmiModel fmu;
      input Real Time;
      input Real States[:];
      input Real dummy;
      output Real tOut=Time;
    algorithm
      fmiSetTime(fmu, Time);
      fmiSetContinuousStates(fmu,States);
      annotation(derivative(noDerivative=dummy,noDerivative=States)=dTS);
    end setTimeAndStates;

    function  dTS
      input fmiModel fmu;
      input Real Time;
      input Real States[:];
      input Real dummy;
      input Real dTime;
      output Real dt;
    algorithm
      dt:=1;
      annotation(derivative(order=2)=ddTS);
    end dTS;

    function  ddTS
      input fmiModel fmu;
      input Real Time;
      input Real States[:];
      input Real dummy;
      input Real dTime;
      input Real ddTime;
      output Real ddt;
    algorithm
      ddt:=0;
    end ddTS;

    function  from_degC
      input Real degC;
      output Real BaseUnit(unit="K");
    algorithm
      BaseUnit := degC + 273.15;
    end from_degC;

    function  to_degC
      input Real BaseUnit(unit="K");
      output Real degC;
    algorithm
      degC := BaseUnit - 273.15;
    end to_degC;
end fmi_Functions;
algorithm
  when initial() then
    if _first then
      _first := false;
      fmi := fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn, fmi_resourceLocation);
    end if;
  end when;
initial algorithm
  if _startValuesNotSet then
  fmi_Functions.fmiSetReal(fmi, {16777216, 16777217, 16777218, 16777219, 16777220, 16777221, 16777222, 16777223, 16777224, 16777225, 16777226, 16777227, 16777228, 16777229, 16777230, 16777231, 16777232, 16777233, 16777234, 16777309, 16777310, 16777311, 16777312, 16777313, 16777314, 16777315, 16777316, 16777235, 16777236, 16777237, 16777238, 16777239, 16777240, 16777241, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 16777251, 16777252, 16777253, 16777254, 16777255, 16777256, 16777257, 16777258, 16777259, 16777260, 16777261, 16777262, 16777263, 16777264, 16777265, 16777266, 16777267, 16777268, 16777269, 16777270, 16777271, 16777272, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 16777282, 16777283, 16777284, 16777285, 16777286, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777293, 16777294, 16777295, 16777296, 16777297, 16777298, 16777299, 16777300, 16777301, 16777302, 16777303, 16777304, 16777305, 16777306, 16777336}, {k_hea, Ti_hea, maxSAT, uLowSta1, uUppSta1, uLowSta2, uUppSta2, kSta1, kSta2, banSta1, banSta2, rtuHP.inSou.'X[1]', rtuHP.inSou.'X[2]', rtuHP.inSou.m_flow, rtuHP.inSou.T, rtuHP.outSou.'X[1]', rtuHP.outSou.'X[2]', rtuHP.outSou.p, rtuHP.outSou.T, rtuHP.heaPum.TAmbEva_nominal, rtuHP.heaPum.TAmbCon_nominal, rtuHP.heaPum.TConCap_start, rtuHP.heaPum.TEvaCap_start, rtuHP.heaPum.'x_start[1]', rtuHP.heaPum.'x_start[2]', rtuHP.heaPum.'x_start[3]', rtuHP.heaPum.yRefIne_start, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.k1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.k2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.mFlow_conNom, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.mFlow_evaNom, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[2,2]', rtuHP.nSetGai.k});
  fmi_Functions.fmiSetReal(fmi, {16777337, 16777338, 16777339, 16777340, 16777341, 16777342, 16777343, 16777344, 16777345, 16777346, 16777347, 16777348, 16777349, 16777350, 16777352, 16777354, 16777355, 16777357, 16777358, 16777359, 16777360, 16777361, 16777362, 16777363, 16777364, 16777367, 16777369, 16777370, 16777371}, {supFan.'X[1]', supFan.'X[2]', supFan.m_flow, supFan.T, roo.'X[1]', roo.'X[2]', roo.p, roo.T, rtuConFMU.conHea.Td, rtuConFMU.conHea.wp, rtuConFMU.conHea.wd, rtuConFMU.conHea.Ni, rtuConFMU.conHea.Nd, rtuConFMU.conHea.xd_start, rtuConFMU.conHea.P.k, rtuConFMU.offHea.k, rtuConFMU.onOffConSupHeatSetPoi.bandwidth, rtuConFMU.heatStage.realToBoolean1.threshold, rtuConFMU.heatStage.add.k1, rtuConFMU.heatStage.add.k2, rtuConFMU.heatStage.const7.k, rtuConFMU.heatStage.booleanToReal.realTrue, rtuConFMU.heatStage.booleanToReal.realFalse, rtuConFMU.heatStage.booleanToReal1.realTrue, rtuConFMU.heatStage.booleanToReal1.realFalse, rtuConFMU.onOffConHea.bandwidth, rtuConFMU.onDelay.delayTime, rtuConFMU.realToBoolean.threshold, rtuConFMU.realToBoolean1.threshold});
  fmi_Functions.fmiSetBoolean(fmi, {16777317, 16777307, 16777308, 16777335, 16777351, 16777356, 16777365, 16777366, 16777368}, {rtuHP.heaPum.linearized, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.verboseRead, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.verboseRead, rtuHP.heaOn.k, rtuConFMU.conHea.reverseAction, rtuConFMU.onOffConSupHeatSetPoi.pre_y_start, rtuConFMU.heatStage.onOffSta1.pre_y_start, rtuConFMU.heatStage.onOffSta2.pre_y_start, rtuConFMU.onOffConHea.pre_y_start});
  fmi_Functions.fmiSetReal(fmi, {352321536, 352321537, 352321538, 352321539, 352321540}, {_u_m_flow_start, _u_TDryBul_start, _u_TRoo_start, _u_TRooSetPoi_start, _u_TMix_start});
  fmi_Functions.fmiEnterModelInitialization(fmi, time);
  _startValuesNotSet :=false;
  end if;
  myTimeStart := time;
equation
  when not initial() then
    fmi_dummy = fmi_Functions.fmiExitModelInitializationMode(fmi);
  {rtuHP.inSou.'ports[1]'.p, rtuHP.outSou.'ports[1]'.m_flow, rtuHP.outSou.'ports[1]'.h_outflow, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_min[1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_min[2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_max[1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_max[2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,5]'} = fmi_Functions.fmiGetRealwf(fmi, {234881041, 234881037, 100663313, 100663372, 100663373, 100663374, 100663375, 100663376, 100663377, 100663378, 100663379, 100663380, 100663381, 100663382, 100663383, 100663384, 100663385, 100663386, 100663387, 100663388, 100663389, 100663390, 100663391, 100663392, 100663393, 100663394, 100663395, 100663396, 100663397, 100663398, 100663399, 100663400, 100663401, 100663402, 100663403, 100663406, 100663407, 100663408, 100663409, 100663410, 100663411, 100663412, 100663413, 100663414, 100663415, 100663416, 100663417, 100663418, 100663419, 100663420, 100663421, 100663422, 100663423, 100663424, 100663425, 100663426, 100663427, 100663428, 100663429, 100663430, 100663431, 100663432, 100663433, 100663434, 100663435, 100663436, 100663437, 100663441, 100663442, 100663443, 100663444, 100663449, 100663450, 100663451, 100663452, 100663453, 100663454, 100663455, 100663456, 100663457, 100663458, 100663459, 100663460, 100663461, 100663462, 100663463, 100663464, 100663465, 100663466, 100663467, 100663468, 100663469, 100663470, 100663471, 100663472, 100663473, 100663474, 100663475, 100663476, 100663477}, fmi_dummy);
  {rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_min[1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_min[2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_max[1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_max[2]', rtuHP.heaPum.con.V, rtuHP.heaPum.con.TCap_start, rtuHP.heaPum.con.vol.V, rtuHP.heaPum.eva.V, rtuHP.heaPum.eva.TCap_start, rtuHP.heaPum.eva.vol.V, rtuHP.heaPum.heatFlowIneEva.'x_start[1]', rtuHP.heaPum.heatFlowIneEva.'x_start[2]', rtuHP.heaPum.heatFlowIneEva.'x_start[3]', rtuHP.heaPum.heatFlowIneEva.y_start, rtuHP.heaPum.heatFlowIneCon.'x_start[1]', rtuHP.heaPum.heatFlowIneCon.'x_start[2]', rtuHP.heaPum.heatFlowIneCon.'x_start[3]', rtuHP.heaPum.heatFlowIneCon.y_start, rtuHP.heaPum.senT_a2.TAmb, rtuHP.heaPum.senT_b2.TAmb, rtuHP.heaPum.senT_b1.TAmb, rtuHP.heaPum.senT_a1.TAmb, rtuHP.port_a.p, roo.'ports[1]'.h_outflow, rtuConFMU.k_hea, rtuConFMU.Ti_hea, rtuConFMU.maxSAT, rtuConFMU.uLowSta1, rtuConFMU.uUppSta1, rtuConFMU.uLowSta2, rtuConFMU.uUppSta2, rtuConFMU.kSta1, rtuConFMU.kSta2, rtuConFMU.banSta1, rtuConFMU.banSta2, rtuConFMU.conHea.k, rtuConFMU.conHea.Ti, rtuConFMU.conHea.addP.k1, rtuConFMU.conHea.addP.k2, rtuConFMU.conHea.I.k, rtuConFMU.UpperLimSup.k, rtuConFMU.heatStage.uLowSta1, rtuConFMU.heatStage.uUppSta1, rtuConFMU.heatStage.uLowSta2, rtuConFMU.heatStage.uUppSta2, rtuConFMU.heatStage.kSta1, rtuConFMU.heatStage.kSta2, rtuConFMU.heatStage.banSta1, rtuConFMU.heatStage.banSta2, rtuConFMU.heatStage.const1.k, rtuConFMU.heatStage.onOffSta1.bandwidth, rtuConFMU.heatStage.const2.k, rtuConFMU.heatStage.onOffSta2.bandwidth} = fmi_Functions.fmiGetRealwf(fmi, {100663478, 100663479, 100663480, 100663485, 100663486, 100663487, 100663488, 100663489, 100663490, 100663491, 100663492, 100663493, 100663494, 100663495, 100663496, 100663497, 100663498, 100663499, 100663500, 100663501, 100663502, 100663503, 100663504, 100663505, 100663506, 100663507, 100663508, 100663509, 100663510, 100663511, 100663512, 100663513, 100663514, 100663515, 100663516, 100663520, 100663521, 100663522, 100663523, 100663712, 100663715, 100663619, 100663850, 100663853, 100663757, 100663863, 100663864, 100663865, 100663866, 100663874, 100663875, 100663876, 100663877, 100663892, 100663910, 100663931, 100663949, 234881151, 100664009, 100664022, 100664023, 100664024, 100664025, 100664026, 100664027, 100664028, 100664029, 100664030, 100664031, 100664032, 100664035, 100664036, 100664046, 100664047, 100664077, 100664086, 100664087, 100664088, 100664089, 100664090, 100664091, 100664092, 100664093, 100664094, 100664101, 100664103, 100664104, 100664106}, fmi_dummy);
  end when;
  myTime = fmi_Functions.setTimeAndStates(fmi, time, {rtuHP.heaPum.con.vol.dynBal.U, rtuHP.heaPum.con.vol.dynBal.'mXi[1]', rtuHP.heaPum.eva.vol.dynBal.U, rtuHP.heaPum.eva.vol.dynBal.'mXi[1]', rtuHP.heaPum.heatFlowIneEva.'x[1]', rtuHP.heaPum.heatFlowIneEva.'x[2]', rtuHP.heaPum.heatFlowIneEva.'x[3]', rtuHP.heaPum.heatFlowIneCon.'x[1]', rtuHP.heaPum.heatFlowIneCon.'x[2]', rtuHP.heaPum.heatFlowIneCon.'x[3]', rtuHP.heaPum.senT_a2.T, rtuHP.heaPum.senT_b2.T, rtuHP.heaPum.senT_b1.T, rtuHP.heaPum.senT_a1.T, rtuHP.senTAct.T, rtuConFMU.conHea.I.y}, fmi_dummy);
  fmi_StepEvent = fmi_Functions.fmiCompletedIntegratorStep(fmi, myTime)>0.5;
  fmi_DiscreteInputChanged= fmi_Functions.CheckIfDiscreteValueSet(fmi, myTime, {u_m_flow, u_TDryBul, u_TRoo, u_TRooSetPoi, u_TMix}, fill(false,0), fill(0,0), {352321536, 352321537, 352321538, 352321539, 352321540}, fill(0,0), fill(0,0), {y_TSup, y_PEleHP, y_PI}, {y_HeaCal}, fill(0,0))  > 0.5;
  fmi_flip = ( if ( fmi_DiscreteInputChanged or not pre(fmi_iterationConverged)) then not pre(fmi_flip) else pre(fmi_flip));
  fmi_z  = fmi_Functions.GetEventIndicators(fmi, fmi_NumberOfEventIndicators, myTime, {u_m_flow, u_TDryBul, u_TRoo, u_TRooSetPoi, u_TMix}, fill(false,0), fill(0,0), {352321536, 352321537, 352321538, 352321539, 352321540}, fill(0,0), fill(0,0));
  for i in 1:size(fmi_z,1) loop
    fmi_z_positive[i] = fmi_Functions.noHysteresis(fmi_z[i]) > 0;
  end for;
  when cat(1, change(fmi_z_positive), {time>=pre(fmi_TNext), fmi_flip, not fmi_flip, fmi_StepEvent}) then
    (fmi_NextMode, fmi_TNext, fmi_NewStates) =  fmi_Functions.fmiUpdateDiscreteStates(fmi);
    fmi_iterationConverged = if fmi_NextMode == 0 then true else false;
{rtuHP.heaPum.innerCycle.sigBus.modeSet, rtuHP.heaPum.innerCycle.sigBus.onOffMea, rtuConFMU.conHea.trigger, rtuConFMU.onOffConSupHeatSetPoi.y, rtuConFMU.heatStage.realToBoolean1.y, rtuConFMU.heatStage.booleanToReal.u, rtuConFMU.heatStage.booleanToReal1.u, rtuConFMU.heatStage.onOffSta1.y, rtuConFMU.heatStage.onOffSta2.y, rtuConFMU.swiTim.u2, rtuConFMU.UppLimSwi.u2, rtuConFMU.onDelay.u} = fmi_Functions.fmiGetBooleanwf(fmi, {234881143, 905970358, 369099565, 369099541, 369099551, 369099555, 369099556, 369099558, 369099561, 369099564, 369099566, 369099567}, if initial() then integer(myTimeStart) else integer(myTime));
    fmi_NewStates2 = if fmi_NewStates then not pre(fmi_NewStates2) else pre(fmi_NewStates2);
  end when;
  when {fmi_NewStates2,not fmi_NewStates2} then
    reinit(rtuConFMU.conHea.I.y, fmi_Functions.fmiGetRealScalar(fmi,33554447));
  end when;
initial equation
  rtuHP.heaPum.con.vol.dynBal.U = fmi_Functions.GetRealVariable(fmi, myTimeStart, {roo.p}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777343}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554432});
  rtuHP.heaPum.con.vol.dynBal.'mXi[1]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {roo.p}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777343}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554433});
  rtuHP.heaPum.eva.vol.dynBal.U = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.outSou.p}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777233}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554434});
  rtuHP.heaPum.eva.vol.dynBal.'mXi[1]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.outSou.p}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777233}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554435});
  rtuHP.heaPum.heatFlowIneEva.'x[1]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[1]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777313}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554436});
  rtuHP.heaPum.heatFlowIneEva.'x[2]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[2]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777314}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554437});
  rtuHP.heaPum.heatFlowIneEva.'x[3]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[3]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777315}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554438});
  rtuHP.heaPum.heatFlowIneCon.'x[1]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[1]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777313}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554439});
  rtuHP.heaPum.heatFlowIneCon.'x[2]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[2]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777314}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554440});
  rtuHP.heaPum.heatFlowIneCon.'x[3]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[3]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777315}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554441});
  rtuHP.heaPum.senT_a2.T = fmi_Functions.GetRealVariable(fmi, myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554442});
  rtuHP.heaPum.senT_b2.T = fmi_Functions.GetRealVariable(fmi, myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554443});
  rtuHP.heaPum.senT_b1.T = fmi_Functions.GetRealVariable(fmi, myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554444});
  rtuHP.heaPum.senT_a1.T = fmi_Functions.GetRealVariable(fmi, myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554445});
  rtuHP.senTAct.T = fmi_Functions.GetRealVariable(fmi, myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554446});
  rtuConFMU.conHea.I.y = fmi_Functions.GetRealVariable(fmi, myTimeStart, {k_hea, rtuConFMU.conHea.wp, rtuConFMU.conHea.P.k, u_TRoo, u_TRooSetPoi}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {rtuConFMU.conHea.reverseAction}, fill(0,0), {16777216, 16777346, 16777352, 352321538, 352321539}, fill(0,0), fill(0,0), {16777351}, fill(0,0), {33554447});
equation
  if initial() then
    der(rtuHP.heaPum.con.vol.dynBal.U) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[3]', supFan.'X[1]', u_m_flow, roo.'X[1]', roo.T, u_TMix}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777315, 16777337, 352321536, 16777341, 16777344, 352321540}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202560});
  else
    der(rtuHP.heaPum.con.vol.dynBal.U) = fmi_Functions.GetRealVariable(fmi, myTime, {u_m_flow, u_TMix}, fill(0.0,0), {rtuHP.heaPum.con.vol.dynBal.U, rtuHP.heaPum.heatFlowIneCon.'x[3]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536, 352321540}, fill(0,0), {33554432, 33554441}, fill(0,0), fill(0,0), {587202560});
  end if;
  if initial() then
    der(rtuHP.heaPum.con.vol.dynBal.'mXi[1]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {supFan.'X[1]', u_m_flow, roo.'X[1]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777337, 352321536, 16777341}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202561});
  else
    der(rtuHP.heaPum.con.vol.dynBal.'mXi[1]') = fmi_Functions.GetRealVariable(fmi, myTime, {u_m_flow}, fill(0.0,0), {rtuHP.heaPum.con.vol.dynBal.'mXi[1]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536}, fill(0,0), {33554433}, fill(0,0), fill(0,0), {587202561});
  end if;
  if initial() then
    der(rtuHP.heaPum.eva.vol.dynBal.U) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.inSou.'X[1]', rtuHP.inSou.m_flow, rtuHP.outSou.'X[1]', rtuHP.outSou.T, rtuHP.heaPum.'x_start[3]', u_TDryBul}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777227, 16777229, 16777231, 16777234, 16777315, 352321537}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202562});
  else
    der(rtuHP.heaPum.eva.vol.dynBal.U) = fmi_Functions.GetRealVariable(fmi, myTime, {u_TDryBul}, fill(0.0,0), {rtuHP.heaPum.eva.vol.dynBal.U, rtuHP.heaPum.heatFlowIneEva.'x[3]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321537}, fill(0,0), {33554434, 33554438}, fill(0,0), fill(0,0), {587202562});
  end if;
  if initial() then
    der(rtuHP.heaPum.eva.vol.dynBal.'mXi[1]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.inSou.'X[1]', rtuHP.inSou.m_flow, rtuHP.outSou.'X[1]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777227, 16777229, 16777231}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202563});
  else
    der(rtuHP.heaPum.eva.vol.dynBal.'mXi[1]') = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {rtuHP.heaPum.eva.vol.dynBal.'mXi[1]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554435}, fill(0,0), fill(0,0), {587202563});
  end if;
  if initial() then
    der(rtuHP.heaPum.heatFlowIneEva.'x[1]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {maxSAT, kSta1, kSta2, banSta1, banSta2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,8]', rtuHP.heaPum.'x_start[1]', rtuHP.nSetGai.k, rtuConFMU.offHea.k, rtuConFMU.onOffConSupHeatSetPoi.bandwidth, rtuConFMU.heatStage.realToBoolean1.threshold, rtuConFMU.heatStage.add.k1, rtuConFMU.heatStage.add.k2, rtuConFMU.heatStage.const7.k, rtuConFMU.heatStage.booleanToReal.realTrue, rtuConFMU.heatStage.booleanToReal.realFalse, rtuConFMU.heatStage.booleanToReal1.realTrue, rtuConFMU.heatStage.booleanToReal1.realFalse, rtuConFMU.onOffConHea.bandwidth, rtuConFMU.realToBoolean.threshold, u_TRoo, u_TRooSetPoi}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.verboseRead, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.verboseRead, rtuHP.heaOn.k, rtuConFMU.onOffConSupHeatSetPoi.pre_y_start, rtuConFMU.heatStage.onOffSta1.pre_y_start, rtuConFMU.heatStage.onOffSta2.pre_y_start, rtuConFMU.onOffConHea.pre_y_start}, fill(0,0), {16777218, 16777223, 16777224, 16777225, 16777226, 16777237, 16777238, 16777239, 16777240, 16777241, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 16777251, 16777252, 16777253, 16777254, 16777255, 16777256, 16777257, 16777258, 16777259, 16777260, 16777261, 16777262, 16777263, 16777264, 16777265, 16777266, 16777267, 16777268, 16777269, 16777270, 16777271, 16777272, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 16777282, 16777283, 16777284, 16777285, 16777286, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777293, 16777294, 16777295, 16777296, 16777297, 16777298, 16777299, 16777300, 16777313, 16777336, 16777354, 16777355, 16777357, 16777358, 16777359, 16777360, 16777361, 16777362, 16777363, 16777364, 16777367, 16777370, 352321538, 352321539}, fill(0,0), fill(0,0), {16777307, 16777308, 16777335, 16777356, 16777365, 16777366, 16777368}, fill(0,0), {587202564});
  else
    der(rtuHP.heaPum.heatFlowIneEva.'x[1]') = fmi_Functions.GetRealVariable(fmi, myTime, {u_TRoo, u_TRooSetPoi}, fill(0.0,0), {rtuHP.heaPum.heatFlowIneEva.'x[1]', rtuHP.heaPum.senT_a2.T, rtuHP.heaPum.senT_b1.T, rtuHP.senTAct.T, rtuConFMU.conHea.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321538, 352321539}, fill(0,0), {33554436, 33554442, 33554444, 33554446, 33554447}, fill(0,0), fill(0,0), {587202564});
  end if;
  if initial() then
    der(rtuHP.heaPum.heatFlowIneEva.'x[2]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[1]', rtuHP.heaPum.'x_start[2]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777313, 16777314}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202565});
  else
    der(rtuHP.heaPum.heatFlowIneEva.'x[2]') = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {rtuHP.heaPum.heatFlowIneEva.'x[1]', rtuHP.heaPum.heatFlowIneEva.'x[2]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554436, 33554437}, fill(0,0), fill(0,0), {587202565});
  end if;
  if initial() then
    der(rtuHP.heaPum.heatFlowIneEva.'x[3]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[2]', rtuHP.heaPum.'x_start[3]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777314, 16777315}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202566});
  else
    der(rtuHP.heaPum.heatFlowIneEva.'x[3]') = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {rtuHP.heaPum.heatFlowIneEva.'x[2]', rtuHP.heaPum.heatFlowIneEva.'x[3]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554437, 33554438}, fill(0,0), fill(0,0), {587202566});
  end if;
  if initial() then
    der(rtuHP.heaPum.heatFlowIneCon.'x[1]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {maxSAT, kSta1, kSta2, banSta1, banSta2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.k1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.k2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,8]', rtuHP.heaPum.'x_start[1]', rtuHP.nSetGai.k, rtuConFMU.offHea.k, rtuConFMU.onOffConSupHeatSetPoi.bandwidth, rtuConFMU.heatStage.realToBoolean1.threshold, rtuConFMU.heatStage.add.k1, rtuConFMU.heatStage.add.k2, rtuConFMU.heatStage.const7.k, rtuConFMU.heatStage.booleanToReal.realTrue, rtuConFMU.heatStage.booleanToReal.realFalse, rtuConFMU.heatStage.booleanToReal1.realTrue, rtuConFMU.heatStage.booleanToReal1.realFalse, rtuConFMU.onOffConHea.bandwidth, rtuConFMU.realToBoolean.threshold, u_TRoo, u_TRooSetPoi}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.verboseRead, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.verboseRead, rtuHP.heaOn.k, rtuConFMU.onOffConSupHeatSetPoi.pre_y_start, rtuConFMU.heatStage.onOffSta1.pre_y_start, rtuConFMU.heatStage.onOffSta2.pre_y_start, rtuConFMU.onOffConHea.pre_y_start}, fill(0,0), {16777218, 16777223, 16777224, 16777225, 16777226, 16777235, 16777236, 16777237, 16777238, 16777239, 16777240, 16777241, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 16777251, 16777252, 16777253, 16777254, 16777255, 16777256, 16777257, 16777258, 16777259, 16777260, 16777261, 16777262, 16777263, 16777264, 16777265, 16777266, 16777267, 16777268, 16777269, 16777270, 16777271, 16777272, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 16777282, 16777283, 16777284, 16777285, 16777286, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777293, 16777294, 16777295, 16777296, 16777297, 16777298, 16777299, 16777300, 16777313, 16777336, 16777354, 16777355, 16777357, 16777358, 16777359, 16777360, 16777361, 16777362, 16777363, 16777364, 16777367, 16777370, 352321538, 352321539}, fill(0,0), fill(0,0), {16777307, 16777308, 16777335, 16777356, 16777365, 16777366, 16777368}, fill(0,0), {587202567});
  else
    der(rtuHP.heaPum.heatFlowIneCon.'x[1]') = fmi_Functions.GetRealVariable(fmi, myTime, {u_TRoo, u_TRooSetPoi}, fill(0.0,0), {rtuHP.heaPum.heatFlowIneCon.'x[1]', rtuHP.heaPum.senT_a2.T, rtuHP.heaPum.senT_b1.T, rtuHP.senTAct.T, rtuConFMU.conHea.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321538, 352321539}, fill(0,0), {33554439, 33554442, 33554444, 33554446, 33554447}, fill(0,0), fill(0,0), {587202567});
  end if;
  if initial() then
    der(rtuHP.heaPum.heatFlowIneCon.'x[2]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[1]', rtuHP.heaPum.'x_start[2]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777313, 16777314}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202568});
  else
    der(rtuHP.heaPum.heatFlowIneCon.'x[2]') = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {rtuHP.heaPum.heatFlowIneCon.'x[1]', rtuHP.heaPum.heatFlowIneCon.'x[2]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554439, 33554440}, fill(0,0), fill(0,0), {587202568});
  end if;
  if initial() then
    der(rtuHP.heaPum.heatFlowIneCon.'x[3]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.'x_start[2]', rtuHP.heaPum.'x_start[3]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777314, 16777315}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202569});
  else
    der(rtuHP.heaPum.heatFlowIneCon.'x[3]') = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {rtuHP.heaPum.heatFlowIneCon.'x[2]', rtuHP.heaPum.heatFlowIneCon.'x[3]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554440, 33554441}, fill(0,0), fill(0,0), {587202569});
  end if;
  if initial() then
    der(rtuHP.heaPum.senT_a2.T) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.inSou.'X[1]', rtuHP.inSou.m_flow, rtuHP.heaPum.TAmbEva_nominal, u_TDryBul}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777227, 16777229, 16777309, 352321537}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202570});
  else
    der(rtuHP.heaPum.senT_a2.T) = fmi_Functions.GetRealVariable(fmi, myTime, {u_TDryBul}, fill(0.0,0), {rtuHP.heaPum.eva.vol.dynBal.U, rtuHP.heaPum.eva.vol.dynBal.'mXi[1]', rtuHP.heaPum.senT_a2.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321537}, fill(0,0), {33554434, 33554435, 33554442}, fill(0,0), fill(0,0), {587202570});
  end if;
  if initial() then
    der(rtuHP.heaPum.senT_b2.T) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.inSou.m_flow, rtuHP.outSou.'X[1]', rtuHP.outSou.T, rtuHP.heaPum.TAmbEva_nominal}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777229, 16777231, 16777234, 16777309}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202571});
  else
    der(rtuHP.heaPum.senT_b2.T) = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {rtuHP.heaPum.eva.vol.dynBal.U, rtuHP.heaPum.eva.vol.dynBal.'mXi[1]', rtuHP.heaPum.senT_b2.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554434, 33554435, 33554443}, fill(0,0), fill(0,0), {587202571});
  end if;
  if initial() then
    der(rtuHP.heaPum.senT_b1.T) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.TAmbCon_nominal, u_m_flow, roo.'X[1]', roo.T}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777310, 352321536, 16777341, 16777344}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202572});
  else
    der(rtuHP.heaPum.senT_b1.T) = fmi_Functions.GetRealVariable(fmi, myTime, {u_m_flow}, fill(0.0,0), {rtuHP.heaPum.con.vol.dynBal.U, rtuHP.heaPum.con.vol.dynBal.'mXi[1]', rtuHP.heaPum.senT_b1.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536}, fill(0,0), {33554432, 33554433, 33554444}, fill(0,0), fill(0,0), {587202572});
  end if;
  if initial() then
    der(rtuHP.heaPum.senT_a1.T) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {rtuHP.heaPum.TAmbCon_nominal, supFan.'X[1]', u_m_flow, u_TMix}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777310, 16777337, 352321536, 352321540}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202573});
  else
    der(rtuHP.heaPum.senT_a1.T) = fmi_Functions.GetRealVariable(fmi, myTime, {u_m_flow, u_TMix}, fill(0.0,0), {rtuHP.heaPum.con.vol.dynBal.U, rtuHP.heaPum.con.vol.dynBal.'mXi[1]', rtuHP.heaPum.senT_a1.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536, 352321540}, fill(0,0), {33554432, 33554433, 33554445}, fill(0,0), fill(0,0), {587202573});
  end if;
  if initial() then
    der(rtuHP.senTAct.T) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {u_m_flow, roo.'X[1]', roo.T}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536, 16777341, 16777344}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202574});
  else
    der(rtuHP.senTAct.T) = fmi_Functions.GetRealVariable(fmi, myTime, {u_m_flow}, fill(0.0,0), {rtuHP.heaPum.con.vol.dynBal.U, rtuHP.heaPum.con.vol.dynBal.'mXi[1]', rtuHP.senTAct.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536}, fill(0,0), {33554432, 33554433, 33554446}, fill(0,0), fill(0,0), {587202574});
  end if;
  if initial() then
    der(rtuConFMU.conHea.I.y) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {Ti_hea, u_TRoo, u_TRooSetPoi}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {rtuConFMU.conHea.reverseAction}, fill(0,0), {16777217, 352321538, 352321539}, fill(0,0), fill(0,0), {16777351}, fill(0,0), {587202575});
  else
    der(rtuConFMU.conHea.I.y) = fmi_Functions.GetRealVariable(fmi, myTime, {u_TRoo, u_TRooSetPoi}, fill(0.0,0), {rtuConFMU.conHea.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321538, 352321539}, fill(0,0), {33554447}, fill(0,0), fill(0,0), {587202575});
  end if;
  if initial() then
    y_TSup = fmi_Functions.GetRealVariable(fmi, myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544320});
  else
    y_TSup = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {rtuHP.senTAct.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554446}, fill(0,0), fill(0,0), {335544320});
  end if;
  if initial() then
    y_PEleHP = fmi_Functions.GetRealVariable(fmi, myTimeStart, {maxSAT, kSta1, kSta2, banSta1, banSta2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,8]', rtuHP.nSetGai.k, rtuConFMU.offHea.k, rtuConFMU.onOffConSupHeatSetPoi.bandwidth, rtuConFMU.heatStage.realToBoolean1.threshold, rtuConFMU.heatStage.add.k1, rtuConFMU.heatStage.add.k2, rtuConFMU.heatStage.const7.k, rtuConFMU.heatStage.booleanToReal.realTrue, rtuConFMU.heatStage.booleanToReal.realFalse, rtuConFMU.heatStage.booleanToReal1.realTrue, rtuConFMU.heatStage.booleanToReal1.realFalse, rtuConFMU.onOffConHea.bandwidth, rtuConFMU.realToBoolean.threshold, u_TRoo, u_TRooSetPoi}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.verboseRead, rtuHP.heaOn.k, rtuConFMU.onOffConSupHeatSetPoi.pre_y_start, rtuConFMU.heatStage.onOffSta1.pre_y_start, rtuConFMU.heatStage.onOffSta2.pre_y_start, rtuConFMU.onOffConHea.pre_y_start}, fill(0,0), {16777218, 16777223, 16777224, 16777225, 16777226, 16777269, 16777270, 16777271, 16777272, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 16777282, 16777283, 16777284, 16777285, 16777286, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777293, 16777294, 16777295, 16777296, 16777297, 16777298, 16777299, 16777300, 16777336, 16777354, 16777355, 16777357, 16777358, 16777359, 16777360, 16777361, 16777362, 16777363, 16777364, 16777367, 16777370, 352321538, 352321539}, fill(0,0), fill(0,0), {16777308, 16777335, 16777356, 16777365, 16777366, 16777368}, fill(0,0), {335544321});
  else
    y_PEleHP = fmi_Functions.GetRealVariable(fmi, myTime, {u_TRoo, u_TRooSetPoi}, fill(0.0,0), {rtuHP.heaPum.senT_a2.T, rtuHP.heaPum.senT_b1.T, rtuHP.senTAct.T, rtuConFMU.conHea.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321538, 352321539}, fill(0,0), {33554442, 33554444, 33554446, 33554447}, fill(0,0), fill(0,0), {335544321});
  end if;
algorithm
  if initial() then
      fmi_Functions.fmiSetTime(fmi, myTimeStart);
    fmi_Functions.fmiSetReal(fmi, {16777371}, {rtuConFMU.realToBoolean1.threshold});
    y_HeaCal := fmi_Functions.fmiGetBooleanScalar(fmi, 335544322);
  else
      fmi_Functions.fmiSetTime(fmi, myTime);
    fmi_Functions.fmiSetReal(fmi, {352321538, 352321539}, {u_TRoo, u_TRooSetPoi});
    y_HeaCal := fmi_Functions.fmiGetBooleanScalar(fmi, 335544322);
  end if;
  if initial() then
    y_PI :=fmi_Functions.GetRealVariable(
      fmi,
      myTimeStart,
      fill(0.0, 0),
      fill(0.0, 0),
      fill(0.0, 0),
      fill(0.0, 0),
      zeroOffset,
      fill(false, 0),
      fill(0, 0),
      fill(0, 0),
      fill(0, 0),
      fill(0, 0),
      fill(0, 0),
      fill(0, 0),
      {335544323});
  else
    y_PI :=fmi_Functions.GetRealVariable(
      fmi,
      myTime,
      {u_TRoo,u_TRooSetPoi},
      fill(0.0, 0),
      {rtuConFMU.conHea.I.y},
      fill(0.0, 0),
      zeroOffset,
      fill(false, 0),
      fill(0, 0),
      {352321538,352321539},
      fill(0, 0),
      {33554447},
      fill(0, 0),
      fill(0, 0),
      {335544323});
  end if;
equation
{rtuHP.TEvaIn, rtuHP.sta, rtuHP.inSou.'ports[1]'.m_flow, rtuHP.inSou.'ports[1]'.h_outflow, rtuHP.inSou.'ports[1]'.'Xi_outflow[1]', rtuHP.outSou.'ports[1]'.'Xi_outflow[1]', rtuHP.heaPum.m1_flow, rtuHP.heaPum.port_a1.h_outflow, rtuHP.heaPum.port_a1.'Xi_outflow[1]', rtuHP.heaPum.port_b1.m_flow, rtuHP.heaPum.port_a2.h_outflow, rtuHP.heaPum.port_a2.'Xi_outflow[1]', rtuHP.heaPum.innerCycle.QCon, rtuHP.heaPum.innerCycle.QEva, rtuHP.heaPum.innerCycle.Pel, rtuHP.heaPum.innerCycle.sigBus.nSet, rtuHP.heaPum.innerCycle.switchQEva.u1, rtuHP.heaPum.innerCycle.switchQCon.u1, rtuHP.heaPum.innerCycle.switchPel.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QEva, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.y, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesQCon.y, rtuHP.heaPum.innerCycle.gainEva.y, rtuHP.heaPum.con.vol.T, rtuHP.heaPum.con.vol.m, rtuHP.heaPum.con.vol.'Xi[1]', rtuHP.heaPum.con.preDro.port_b.h_outflow, rtuHP.heaPum.con.preDro.port_b.'Xi_outflow[1]', rtuHP.heaPum.eva.vol.T, rtuHP.heaPum.eva.vol.m, rtuHP.heaPum.eva.vol.'Xi[1]', rtuHP.heaPum.heatFlowIneEva.u, rtuHP.heaPum.heatFlowIneCon.u, rtuHP.heaPum.senT_b1.port_a.'Xi_outflow[1]', supFan.T_in, rtuConFMU.TSetRooHea, rtuConFMU.TRoo, rtuConFMU.conHea.u_s, rtuConFMU.conHea.u_m, rtuConFMU.conHea.controlError, rtuConFMU.conHea.addP.y, rtuConFMU.conHea.P.y, rtuConFMU.conHea.addPID.y, rtuConFMU.conHea.I.u, rtuConFMU.conHea.I.y_reset_in, rtuConFMU.swiHea.u1, rtuConFMU.swiHea.u3, rtuConFMU.swiHea.y, rtuConFMU.heatStage.add.u1, rtuConFMU.heatStage.add.u2, rtuConFMU.heatStage.add.y, rtuConFMU.heatStage.switch4.u3, rtuConFMU.swiTim.u1} = fmi_Functions.fmiGetRealwf(fmi, {436207617, 369099448, 905970089, 637534212, 234881035, 234881039, 436207616, 637534905, 637534906, 905969951, 637534239, 637534240, 637534259, 637534260, 369098809, 369099445, 637534261, 637534263, 369098810, 637534269, 637534270, 369098815, 637534272, 369098823, 369098824, 637534281, 369098937, 369098938, 637534316, 369098902, 369098939, 369098981, 637534275, 637534446, 905969988, 100663664, 637534533, 637534909, 234881145, 905970126, 100663802, 637534671, 637534770, 637534781, 234881149, 436207620, 436207619, 436207618, 905970431, 905970432, 905970401, 369099501, 369099504, 369099509, 637534978, 369099538, 369099539, 234881162, 369099540, 369099552, 369099553, 369099554, 234881168, 369099563}, if initial() then myTimeStart else myTime);
//alias Declarations
  rtuHP.heaPum.senT_b2.port_a.h_outflow = rtuHP.outSou.'ports[1]'.h_outflow;
  rtuHP.heaPum.senT_b1.port_a.h_outflow = roo.'ports[1]'.h_outflow;
  rtuHP.senTAct.port_a.h_outflow = roo.'ports[1]'.h_outflow;
  rtuConFMU.onOffConSupHeatSetPoi.reference = rtuConFMU.UpperLimSup.k;
  rtuConFMU.UpperLimSup.y = rtuConFMU.UpperLimSup.k;
  rtuConFMU.heatStage.const1.y = rtuConFMU.heatStage.const1.k;
  rtuConFMU.heatStage.onOffSta1.reference = rtuConFMU.heatStage.const1.k;
  rtuConFMU.heatStage.const2.y = rtuConFMU.heatStage.const2.k;
  rtuConFMU.heatStage.onOffSta2.reference = rtuConFMU.heatStage.const2.k;
  rtuHP.heaPum.eva.preDro.port_b.'Xi_outflow[1]' = rtuHP.inSou.'ports[1]'.'Xi_outflow[1]';
  rtuHP.heaPum.senT_a2.port_b.'Xi_outflow[1]' = rtuHP.inSou.'ports[1]'.'Xi_outflow[1]';
  rtuHP.heaPum.mFlow_eva.port_b.'Xi_outflow[1]' = rtuHP.inSou.'ports[1]'.'Xi_outflow[1]';
  rtuHP.heaPum.m2_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.port_a2.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.innerCycle.sigBus.m_flowEvaMea = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.m_flowEvaMea = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.vol.'ports[1]'.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.preDro.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.preDro.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.sigBus.m_flowEvaMea = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_a2.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_b2.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.mFlow_eva.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.mFlow_eva.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.sigBus1.m_flowEvaMea = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_b2.port_a.'Xi_outflow[1]' = rtuHP.outSou.'ports[1]'.'Xi_outflow[1]';
  rtuHP.outSou.'ports[1]'.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.port_a2.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.port_b2.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.vol.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.vol.'ports[1]'.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.vol.'ports[2]'.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.preDro.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.preDro.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_a2.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_a2.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_b2.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_b2.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.mFlow_eva.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.mFlow_eva.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_a1.port_b.'Xi_outflow[1]' = rtuHP.heaPum.con.preDro.port_b.'Xi_outflow[1]';
  rtuHP.heaPum.mFlow_con.port_b.'Xi_outflow[1]' = rtuHP.heaPum.con.preDro.port_b.'Xi_outflow[1]';
  supFan.'ports[1]'.'Xi_outflow[1]' = rtuHP.heaPum.con.preDro.port_b.'Xi_outflow[1]';
  rtuHP.senTAct.port_a.'Xi_outflow[1]' = rtuHP.heaPum.senT_b1.port_a.'Xi_outflow[1]';
  roo.'ports[1]'.'Xi_outflow[1]' = rtuHP.heaPum.senT_b1.port_a.'Xi_outflow[1]';
  rtuHP.heaPum.port_a1.p = rtuHP.port_a.p;
  rtuHP.heaPum.port_b1.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.port_b.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.vol.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.vol.'ports[1]'.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.vol.'ports[2]'.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.preDro.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.preDro.port_b.p = rtuHP.port_a.p;
  rtuHP.heaPum.senT_b1.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.senT_b1.port_b.p = rtuHP.port_a.p;
  rtuHP.heaPum.senT_a1.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.senT_a1.port_b.p = rtuHP.port_a.p;
  rtuHP.heaPum.mFlow_con.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.mFlow_con.port_b.p = rtuHP.port_a.p;
  rtuHP.senTAct.port_a.p = rtuHP.port_a.p;
  rtuHP.senTAct.port_b.p = rtuHP.port_a.p;
  rtuHP.port_b.p = rtuHP.port_a.p;
  supFan.'ports[1]'.p = rtuHP.port_a.p;
  roo.'ports[1]'.p = rtuHP.port_a.p;
  rtuConFMU.offHea.y = rtuConFMU.swiHea.u3;
  rtuConFMU.swiTim.u3 = rtuConFMU.swiHea.u3;
  rtuConFMU.UppLimSwi.u1 = rtuConFMU.swiHea.u3;
  rtuConFMU.heatStage.const7.y = rtuConFMU.heatStage.switch4.u3;
  rtuHP.heaPum.con.vol.U = rtuHP.heaPum.con.vol.dynBal.U;
  rtuHP.PEle = y_PEleHP;
  rtuHP.heaPum.innerCycle.sigBus.PelMea = y_PEleHP;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.PelMea = y_PEleHP;
  rtuHP.heaPum.sigBus.PelMea = y_PEleHP;
  rtuHP.sigBus1.PelMea = y_PEleHP;
  rtuConFMU.PI_y = y_PI;
  rtuConFMU.conHea.y = y_PI;
  rtuConFMU.heatStage.uHea = y_PI;
  rtuConFMU.heatStage.realToBoolean1.u = y_PI;
  rtuConFMU.heatStage.onOffSta1.u = y_PI;
  rtuConFMU.heatStage.onOffSta2.u = y_PI;
  rtuConFMU.realToBoolean1.u = y_PI;
  rtuHP.heaPum.con.vol.'mXi[1]' = rtuHP.heaPum.con.vol.dynBal.'mXi[1]';
  rtuHP.heaPum.eva.vol.U = rtuHP.heaPum.eva.vol.dynBal.U;
  rtuHP.heaPum.eva.vol.'mXi[1]' = rtuHP.heaPum.eva.vol.dynBal.'mXi[1]';
  rtuHP.heaPum.eva.QFlow_in = rtuHP.heaPum.heatFlowIneEva.'x[3]';
  rtuHP.heaPum.heatFlowIneEva.y = rtuHP.heaPum.heatFlowIneEva.'x[3]';
  rtuHP.heaPum.con.QFlow_in = rtuHP.heaPum.heatFlowIneCon.'x[3]';
  rtuHP.heaPum.heatFlowIneCon.y = rtuHP.heaPum.heatFlowIneCon.'x[3]';
  rtuHP.heaPum.innerCycle.sigBus.TEvaInMea = rtuHP.heaPum.senT_a2.T;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TEvaInMea = rtuHP.heaPum.senT_a2.T;
  rtuHP.heaPum.sigBus.TEvaInMea = rtuHP.heaPum.senT_a2.T;
  rtuHP.sigBus1.TEvaInMea = rtuHP.heaPum.senT_a2.T;
  rtuHP.heaPum.innerCycle.sigBus.TEvaOutMea = rtuHP.heaPum.senT_b2.T;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TEvaOutMea = rtuHP.heaPum.senT_b2.T;
  rtuHP.heaPum.sigBus.TEvaOutMea = rtuHP.heaPum.senT_b2.T;
  rtuHP.sigBus1.TEvaOutMea = rtuHP.heaPum.senT_b2.T;
  rtuHP.heaPum.innerCycle.sigBus.TConOutMea = rtuHP.heaPum.senT_b1.T;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TConOutMea = rtuHP.heaPum.senT_b1.T;
  rtuHP.heaPum.sigBus.TConOutMea = rtuHP.heaPum.senT_b1.T;
  rtuHP.sigBus1.TConOutMea = rtuHP.heaPum.senT_b1.T;
  rtuHP.heaPum.innerCycle.sigBus.TConInMea = rtuHP.heaPum.senT_a1.T;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TConInMea = rtuHP.heaPum.senT_a1.T;
  rtuHP.heaPum.sigBus.TConInMea = rtuHP.heaPum.senT_a1.T;
  rtuHP.sigBus1.TConInMea = rtuHP.heaPum.senT_a1.T;
  rtuHP.TSup = rtuHP.senTAct.T;
  rtuConFMU.TSup = rtuHP.senTAct.T;
  rtuConFMU.conHea.addPID.u3 = rtuConFMU.conHea.I.y;
  rtuHP.heaPum.innerCycle.switchPel.y = rtuHP.heaPum.innerCycle.Pel;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Pel = rtuHP.heaPum.innerCycle.switchPel.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.u1 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.t_Co_ou.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.t_Ev_in.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough1.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough1.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.u1 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough1.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough1.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough2.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough2.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough2.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough2.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.y;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesQCon.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesSF.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.nSet = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesSF.u1 = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.heaPum.sigBus.nSet = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.heaPum.greaterThreshold.u = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.nSetGai.y = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.sigBus1.nSet = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.nSetGai.u = rtuHP.sta;
  rtuConFMU.heaSta = rtuHP.sta;
  rtuConFMU.swiTim.y = rtuHP.sta;
  rtuConFMU.conHea.P.u = rtuConFMU.conHea.addP.y;
  rtuConFMU.conHea.addPID.u1 = rtuConFMU.conHea.P.y;
  rtuConFMU.heatStage.y_Sta = rtuConFMU.swiHea.u1;
  rtuConFMU.heatStage.switch4.y = rtuConFMU.swiHea.u1;
  rtuConFMU.UppLimSwi.u3 = rtuConFMU.swiHea.y;
  rtuConFMU.heatStage.booleanToReal1.y = rtuConFMU.heatStage.add.u1;
  rtuConFMU.heatStage.booleanToReal.y = rtuConFMU.heatStage.add.u2;
  rtuConFMU.heatStage.switch4.u1 = rtuConFMU.heatStage.add.y;
  rtuConFMU.UppLimSwi.y = rtuConFMU.swiTim.u1;
  rtuConFMU.realToBoolean.u = rtuConFMU.swiTim.u1;
  rtuHP.heaPum.port_a1.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.innerCycle.sigBus.m_flowConMea = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.m_flowConMea = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.vol.'ports[1]'.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.preDro.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.preDro.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.sigBus.m_flowConMea = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.senT_b1.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.senT_a1.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.mFlow_con.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.mFlow_con.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.senTAct.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.sigBus1.m_flowConMea = rtuHP.heaPum.m1_flow;
  rtuHP.port_a.m_flow = rtuHP.heaPum.m1_flow;
  supFan.m_flow_in = rtuHP.heaPum.m1_flow;
  roo.'ports[1]'.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.inSou.T_in = rtuHP.TEvaIn;
  rtuHP.heaPum.eva.preDro.port_b.h_outflow = rtuHP.inSou.'ports[1]'.h_outflow;
  rtuHP.heaPum.senT_a2.port_b.h_outflow = rtuHP.inSou.'ports[1]'.h_outflow;
  rtuHP.heaPum.mFlow_eva.port_b.h_outflow = rtuHP.inSou.'ports[1]'.h_outflow;
  rtuHP.heaPum.port_b2.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.port_a.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.port_b.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.vol.'ports[1]'.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.vol.'ports[2]'.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.preDro.port_a.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.senT_a2.port_a.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.senT_b2.port_b.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.mFlow_eva.port_a.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.port_b2.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.vol.'ports[1]'.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.vol.'ports[2]'.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.preDro.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.senT_a2.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.senT_b2.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.mFlow_eva.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.innerCycle.switchQCon.y = rtuHP.heaPum.innerCycle.QCon;
  rtuHP.heaPum.innerCycle.switchQEva.y = rtuHP.heaPum.innerCycle.QEva;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QCon = rtuHP.heaPum.innerCycle.switchQCon.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.proRedQEva.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.proRedQEva.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u1;
  rtuHP.heaPum.innerCycle.gainEva.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesQCon.u1 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.y;
  rtuHP.heaPum.port_b1.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.port_b.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.vol.'ports[1]'.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.vol.'ports[2]'.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.preDro.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.senT_b1.port_b.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.senT_a1.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.mFlow_con.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.senTAct.port_b.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.port_b.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.port_b1.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.vol.'ports[1]'.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.vol.'ports[2]'.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.preDro.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.senT_b1.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.senT_a1.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.mFlow_con.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.senTAct.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.senT_a1.port_b.h_outflow = rtuHP.heaPum.con.preDro.port_b.h_outflow;
  rtuHP.heaPum.mFlow_con.port_b.h_outflow = rtuHP.heaPum.con.preDro.port_b.h_outflow;
  supFan.'ports[1]'.h_outflow = rtuHP.heaPum.con.preDro.port_b.h_outflow;
  rtuHP.heaPum.con.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.con.vol.'ports[2]'.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.con.preDro.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.senT_b1.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.senT_a1.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.mFlow_con.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.senTAct.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  supFan.'ports[1]'.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.con.vol.heatPort.T = rtuHP.heaPum.con.vol.T;
  rtuHP.heaPum.con.preHea.port.T = rtuHP.heaPum.con.vol.T;
  rtuHP.heaPum.port_b2.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.vol.'ports[2]'.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.preDro.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_a2.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_b2.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.mFlow_eva.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.vol.heatPort.T = rtuHP.heaPum.eva.vol.T;
  rtuHP.heaPum.eva.preHea.port.T = rtuHP.heaPum.eva.vol.T;
  rtuConFMU.conHea.addP.u1 = rtuConFMU.conHea.u_s;
  rtuConFMU.onOffConHea.reference = rtuConFMU.conHea.u_s;
  rtuConFMU.conHea.addP.u2 = rtuConFMU.conHea.u_m;
  rtuConFMU.onOffConHea.u = rtuConFMU.conHea.u_m;
  rtuHP.heaPum.innerCycle.switchQEva.u2 = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaPum.innerCycle.switchQCon.u2 = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaPum.innerCycle.switchPel.u2 = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.modeSet = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaPum.sigBus.modeSet = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaOn.y = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.sigBus1.modeSet = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuConFMU.heaCal = y_HeaCal;
  rtuConFMU.realToBoolean1.y = y_HeaCal;
  rtuConFMU.NotLim.u = rtuConFMU.onOffConSupHeatSetPoi.y;
  rtuConFMU.heatStage.switch4.u2 = rtuConFMU.heatStage.realToBoolean1.y;
  rtuConFMU.heatStage.not1.y = rtuConFMU.heatStage.booleanToReal.u;
  rtuConFMU.heatStage.not2.y = rtuConFMU.heatStage.booleanToReal1.u;
  rtuConFMU.heatStage.not1.u = rtuConFMU.heatStage.onOffSta1.y;
  rtuConFMU.heatStage.not2.u = rtuConFMU.heatStage.onOffSta2.y;
  rtuConFMU.onDelay.y = rtuConFMU.swiTim.u2;
  rtuConFMU.conHea.I.trigger = rtuConFMU.conHea.trigger;
  rtuConFMU.swiHea.u2 = rtuConFMU.conHea.trigger;
  rtuConFMU.onOffConHea.y = rtuConFMU.conHea.trigger;
  rtuConFMU.NotLim.y = rtuConFMU.UppLimSwi.u2;
  rtuConFMU.realToBoolean.y = rtuConFMU.onDelay.u;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.onOffMea = rtuHP.heaPum.innerCycle.sigBus.onOffMea;
  rtuHP.heaPum.sigBus.onOffMea = rtuHP.heaPum.innerCycle.sigBus.onOffMea;
  rtuHP.heaPum.greaterThreshold.y = rtuHP.heaPum.innerCycle.sigBus.onOffMea;
  rtuHP.sigBus1.onOffMea = rtuHP.heaPum.innerCycle.sigBus.onOffMea;
  annotation (__Dymola_FMUImportVersion="Dymola 2020x", experiment(StartTime=19872000.0, StopTime=19958400.0, Tolerance=1E-06),
    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 2.0 ME")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 2.0</li>
<li>modelName = hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU</li>
<li>generationTool = Dymola Version 2020x (64-bit), 2019-10-10 (requires license to execute)</li>
<li>generationDateAndTime = 2022-03-23T22:10:15Z</li>
</ul>
<p><br><b>Model Exchange Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>completedIntegratorStepNotNeeded = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = false</li>
<li>canGetAndSetFMUstate = true</li>
<li>canSerializeFMUstate = true</li>
<li>providesDirectionalDerivative = true</li>
</ul>
<p><br><b>Co-Simulation Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>canHandleVariableCommunicationStepSize = true</li>
<li>canInterpolateInputs = true</li>
<li>maxOutputDerivativeOrder = 1</li>
<li>canRunAsynchronuously = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = false</li>
<li>canGetAndSetFMUstate = true</li>
<li>canSerializeFMUstate = true</li>
<li>providesDirectionalDerivative = true</li>
</ul>
</html>"));
end hil_flexlab_model_Fluid_Aachen_HP_02stage_FMU_fmu;
