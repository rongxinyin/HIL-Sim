within ;
model HiLWinterTestsRTUHPFMUv2_fmu
  "Air supply unit model with heatpump heating and cooling and auxiliary electric heater for heating"
extends fmuIcon;
// Model automatically generated by Dymola from FMI model description
public
  type Modelica_Blocks_Interfaces_BooleanInput = Boolean;
  type Modelica_Blocks_Interfaces_BooleanOutput = Boolean;
  type Modelica_Blocks_Interfaces_RealInput = Real;
  type Modelica_Blocks_Interfaces_RealOutput = Real;
  type Buildings_Types_Reset = enumeration(
      Disabled                                      "Disabled",
      Parameter "Use parameter value",
      Input "Use input signal");
  constant Real refIneFre = 0.015 "refrigerant inertia parameter";
  parameter Real k_hea = 0.18 "Proportional gain of heating controller";
  parameter Modelica.SIunits.Time Ti_hea = 2400 "Integral time constant of heating controller";
  parameter Modelica.SIunits.ThermodynamicTemperature maxSAT = 310 "max supply air temperature";
  parameter Real uLowSta1 = 0.05 "PI lower bound to activate stage 1";
  parameter Real uUppSta1 = 0.15 "PI upper bound to activate stage 1";
  parameter Real uLowSta2 = 0.35 "PI lower bound to activate stage 2";
  parameter Real uUppSta2 = 0.45 "PI upper bound to activate stage 2";
  parameter Real kSta1 = 0.05 "PI center line to activate stage 1";
  parameter Real kSta2 = 0.35 "PI center line to activate stage 2";
  parameter Real banSta1 = 0.01 "PI band to activate stage 1";
  parameter Real banSta2 = 0.01 "PI band to activate stage 2";
protected
  record rtuHP_rec
    constant Real refIneFre = 0.015 "refrigerant inertia parameter";
    Modelica_Blocks_Interfaces_RealOutput PEle(unit = "W", quantity = "Power") "Electrical power consumed by the unit";
    Modelica_Blocks_Interfaces_RealInput TEvaIn(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature") "Outside air dry bulb temperature";
    Modelica_Blocks_Interfaces_RealInput sta "Heating stage";
    Modelica_Blocks_Interfaces_RealOutput TSup(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature") "Electrical power consumed by the unit";
  protected
    record inSou_rec
      constant Integer nPorts = 1 "Number of ports";
      constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
      parameter Real 'X[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Fixed value of composition";
      parameter Real 'X[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Fixed value of composition";
      parameter Modelica.SIunits.MassFlowRate m_flow(nominal = 0.405, min = -100000.0, max = 100000.0) = 1 "Fixed mass flow rate going out of the fluid port";
      parameter Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 293.15 "Fixed value of temperature";
      Modelica_Blocks_Interfaces_RealInput T_in(unit = "K", displayUnit = "degC") "Prescribed boundary temperature";
    protected
      record 'ports[1]_rec'
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end 'ports[1]_rec';
    public
      'ports[1]_rec' 'ports[1]';
    end inSou_rec;
  public
    inSou_rec inSou annotation(Dialog);
  protected
    record outSou_rec
      constant Integer nPorts = 1 "Number of ports";
      constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
      parameter Real 'X[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Fixed value of composition";
      parameter Real 'X[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Fixed value of composition";
      parameter Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325 "Fixed value of pressure";
      parameter Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 293.15 "Fixed value of temperature";
    protected
      record 'ports[1]_rec'
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end 'ports[1]_rec';
    public
      'ports[1]_rec' 'ports[1]';
    end outSou_rec;
  public
    outSou_rec outSou annotation(Dialog);
  protected
    record heaPum_rec
      constant Boolean allowFlowReversal1 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1";
      constant Boolean allowFlowReversal2 = true "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2";
      constant Modelica.SIunits.MassFlowRate m1_flow_nominal(min = 0.0) = 0.3 "Nominal mass flow rate";
      constant Modelica.SIunits.MassFlowRate m2_flow_nominal(min = 0.0) = 0.3 "Nominal mass flow rate";
      constant Real m1_flow_small(unit = "kg/s", quantity = "MassFlowRate.Air", min = 0.0, max = 100000.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
      constant Real m2_flow_small(unit = "kg/s", quantity = "MassFlowRate.Air", min = 0.0, max = 100000.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
      Real m1_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
      constant Modelica.SIunits.PressureDifference dp1(displayUnit = "Pa") = 0.0 "Pressure difference between port_a1 and port_b1";
      Real m2_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
      constant Modelica.SIunits.PressureDifference dp2(displayUnit = "Pa") = 0.0 "Pressure difference between port_a2 and port_b2";
      constant Boolean use_rev = false "Is the vapour compression machine reversible?";
      constant Boolean use_autoCalc = true "Enable automatic estimation of volumes and mass flows?";
      constant Modelica.SIunits.Power Q_useNominal = 6535 "Nominal usable heat flow of the vapour compression machine (HP: Heating; Chiller: Cooling)";
      constant Real scalingFactor = 1.35 "Scaling-factor of vapour compression machine";
      constant Boolean use_refIne = true "Consider the inertia of the refrigerant cycle";
      constant Modelica.SIunits.Frequency refIneFre_constant = 0.015 "Cut off frequency for inertia of refrigerant cycle";
      constant Integer nthOrder = 3 "Order of refrigerant cycle interia";
      constant Boolean useBusConnectorOnly = true "Set true to use bus connector for modeSet, nSet and iceFac input";
      constant Modelica.SIunits.MassFlowRate mFlow_conNominal = 0.5 "Manual input of the nominal mass flow rate (if not automatically calculated)";
      constant Modelica.SIunits.Volume VCon = 0.4 "Manual input of the condenser volume (if not automatically calculated)";
      constant Modelica.SIunits.PressureDifference dpCon_nominal = 0 "Pressure drop at nominal mass flow rate";
      constant Real deltaM_con = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
      constant Boolean use_conCap = false "If heat losses at capacitor side are considered or not";
      constant Modelica.SIunits.HeatCapacity CCon = 100 "Heat capacity of Condenser (= cp*m). If you want to neglace the dry mass of the condenser, you can set this value to zero";
      constant Modelica.SIunits.ThermalConductance GConOut = 5 "Constant parameter for heat transfer to the ambient. Represents a sum of thermal resistances such as conductance, insulation and natural convection. If you want to simulate a condenser with additional dry mass but without external heat losses, set the value to zero";
      constant Modelica.SIunits.ThermalConductance GConIns = 0.0 "Constant parameter for heat transfer to heat exchangers capacity. Represents a sum of thermal resistances such as forced convection and conduction inside of the capacity";
      constant Modelica.SIunits.MassFlowRate mFlow_evaNominal = 0.5 "Manual input of the nominal mass flow rate (if not automatically calculated)";
      constant Modelica.SIunits.Volume VEva = 0.04 "Manual input of the evaporator volume (if not automatically calculated)";
      constant Modelica.SIunits.PressureDifference dpEva_nominal = 0 "Pressure drop at nominal mass flow rate";
      constant Real deltaM_eva = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
      constant Boolean use_evaCap = false "If heat losses at capacitor side are considered or not";
      constant Modelica.SIunits.HeatCapacity CEva = 100 "Heat capacity of Evaporator (= cp*m). If you want to neglace the dry mass of the evaporator, you can set this value to zero";
      constant Modelica.SIunits.ThermalConductance GEvaOut = 5 "Constant parameter for heat transfer to the ambient. Represents a sum of thermal resistances such as conductance, insulation and natural convection. If you want to simulate a evaporator with additional dry mass but without external heat losses, set the value to zero";
      constant Modelica.SIunits.ThermalConductance GEvaIns = 0.0 "Constant parameter for heat transfer to heat exchangers capacity. Represents a sum of thermal resistances such as forced convection and conduction inside of the capacity";
      constant Modelica.SIunits.Time tauSenT = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
      constant Boolean transferHeat = true "If true, temperature T converges towards TAmb when no flow";
      constant Boolean allowFlowReversalEva = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
      constant Boolean allowFlowReversalCon = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
      constant Modelica.SIunits.Time tauHeaTraEva = 1200 "Time constant for heat transfer in temperature sensors in evaporator, default 20 minutes";
      parameter Modelica.SIunits.Temperature TAmbEva_nominal = 273.15 "Fixed ambient temperature for heat transfer of sensors at the evaporator side";
      constant Modelica.SIunits.Time tauHeaTraCon = 1200 "Time constant for heat transfer in temperature sensors in condenser, default 20 minutes";
      parameter Modelica.SIunits.Temperature TAmbCon_nominal = 288.15 "Fixed ambient temperature for heat transfer of sensors at the condenser side";
      constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
      constant Modelica.Media.Interfaces.Types.AbsolutePressure pCon_start = 101325 "Start value of pressure";
      constant Modelica.Media.Interfaces.Types.Temperature TCon_start = 290.15 "Start value of temperature";
      parameter Modelica.SIunits.Temperature TConCap_start = 293.15 "Initial temperature of heat capacity of condenser";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XCon_start[1]' = 0.01 "Start value of mass fractions m_i/m";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XCon_start[2]' = 0.99 "Start value of mass fractions m_i/m";
      constant Modelica.Media.Interfaces.Types.AbsolutePressure pEva_start = 101325 "Start value of pressure";
      constant Modelica.Media.Interfaces.Types.Temperature TEva_start = 281.15 "Start value of temperature";
      parameter Modelica.SIunits.Temperature TEvaCap_start = 293.15 "Initial temperature of heat capacity at evaporator";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XEva_start[1]' = 0.01 "Start value of mass fractions m_i/m";
      constant Modelica.Media.Interfaces.Types.MassFraction 'XEva_start[2]' = 0.99 "Start value of mass fractions m_i/m";
      parameter Real 'x_start[1]' = 0 "Initial or guess values of states";
      parameter Real 'x_start[2]' = 0 "Initial or guess values of states";
      parameter Real 'x_start[3]' = 0 "Initial or guess values of states";
      parameter Real yRefIne_start = 0 "Initial or guess value of output (= state)";
      constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state (only affects fluid-models)";
      constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state (only affects fluid-models)";
      constant Boolean machineType = true "=true if heat pump; =false if chiller";
      constant Boolean show_TPort = false "= true, if actual temperature at port is computed";
      constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
      constant Boolean homotopyInitialization = false "= true, use homotopy method";
      parameter Boolean linearized = false "= true, use linear relation between m_flow and dp for any flow rate";
    protected
      record port_a1_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_a1_rec;
    public
      port_a1_rec port_a1;
    protected
      record port_b1_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_b1_rec;
    public
      port_b1_rec port_b1;
    protected
      record port_a2_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_a2_rec;
    public
      port_a2_rec port_a2;
    protected
      record port_b2_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_b2_rec;
    public
      port_b2_rec port_b2;
    protected
      record innerCycle_rec
        constant Boolean use_rev = false "True if the vapour compression machine is reversible";
        constant Real scalingFactor = 1.35 "Scaling factor of vapour compression machine";
        Modelica_Blocks_Interfaces_RealOutput QCon(unit = "W", displayUnit = "kW") "Heat Flow to condenser";
        Modelica_Blocks_Interfaces_RealOutput QEva(unit = "W", displayUnit = "kW") "Heat flow from evaporator";
        Modelica_Blocks_Interfaces_RealOutput Pel(unit = "W", displayUnit = "kW") "Electrical power consumed by compressor";
      protected
        record sigBus_rec
          Real nSet "Relative rotational speed of compressor between 0 and 1";
          Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
          Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
          Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
          Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
          Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
          Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
          Modelica.SIunits.Power PelMea "Total electrical active power";
          Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
          Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
          constant Real iceFacMea = 1.0 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
        end sigBus_rec;
      public
        sigBus_rec sigBus;
      protected
        record switchQEva_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W", displayUnit = "kW") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          constant Modelica_Blocks_Interfaces_RealInput u3(unit = "W", displayUnit = "kW") = 0 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
        end switchQEva_rec;
      public
        switchQEva_rec switchQEva;
      protected
        record switchQCon_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W", displayUnit = "kW") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          constant Modelica_Blocks_Interfaces_RealInput u3(unit = "W", displayUnit = "kW") = 0.0 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
        end switchQCon_rec;
      public
        switchQCon_rec switchQCon;
      protected
        record switchPel_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W", displayUnit = "kW") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          constant Modelica_Blocks_Interfaces_RealInput u3(unit = "W", displayUnit = "kW") = 0.0 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
        end switchPel_rec;
      public
        switchPel_rec switchPel;
      protected
        record PerformanceDataHPHeating_rec
          Modelica_Blocks_Interfaces_RealOutput Pel(unit = "W", displayUnit = "kW") "Electrical Power consumed by HP";
          Modelica_Blocks_Interfaces_RealOutput QCon(unit = "W", displayUnit = "kW") "Heat flow rate through Condenser";
          Modelica_Blocks_Interfaces_RealOutput QEva(unit = "W", displayUnit = "kW") "Heat flow rate through Evaporator";
          constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
          constant Boolean extrapolation = true "False to hold last value";
          constant Boolean printAsserts = false "WARNING: This will lead to a lot of state-events if extrapolation occurs frequently! If extrapolation is enabled, the user will get warnings when extrapolation occurs.";
        protected
          record sigBus_rec
            Real nSet "Relative rotational speed of compressor between 0 and 1";
            Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
            Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
            Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
            Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
            Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
            Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
            Modelica.SIunits.Power PelMea "Total electrical active power";
            Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
            Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
            constant Real iceFacMea = 1.0 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
          end sigBus_rec;
        public
          sigBus_rec sigBus;
        protected
          record calcRedQCon_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = 1 "Gain of input signal 2";
          end calcRedQCon_rec;
        public
          calcRedQCon_rec calcRedQCon annotation(Dialog);
        protected
          record proRedQEva_rec
            constant Modelica_Blocks_Interfaces_RealInput u1 = 1.0 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end proRedQEva_rec;
        public
          proRedQEva_rec proRedQEva;
        protected
          record dataTable_rec
            parameter Real 'tableQdot_con[1,1]' = 0.0 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,2]' = -13.9 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,3]' = -8.3 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,4]' = -2.8 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,5]' = 2.8 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,6]' = 8.3 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,7]' = 13.9 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[1,8]' = 19.4 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,1]' = 18 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,2]' = 1800 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,3]' = 2640 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,4]' = 3430 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,5]' = 4330 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,6]' = 5370 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,7]' = 6540 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[2,8]' = 7850 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,1]' = 21 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,2]' = 1610 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,3]' = 2380 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,4]' = 3260 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,5]' = 4130 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,6]' = 5140 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,7]' = 6280 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[3,8]' = 7570 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,1]' = 24 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,2]' = 1390 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,3]' = 2150 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,4]' = 3080 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,5]' = 3940 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,6]' = 4910 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,7]' = 6030 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableQdot_con[4,8]' = 7910 "Heating power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,1]' = 0.0 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,2]' = -13.9 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,3]' = -8.3 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,4]' = -2.8 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,5]' = 2.8 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,6]' = 8.3 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,7]' = 13.9 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[1,8]' = 19.4 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,1]' = 18 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,2]' = 850 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,3]' = 930 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,4]' = 1010 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,5]' = 1110 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,6]' = 1220 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,7]' = 1370 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[2,8]' = 1570 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,1]' = 21 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,2]' = 980 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,3]' = 1060 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,4]' = 1160 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,5]' = 1250 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,6]' = 1370 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,7]' = 1530 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[3,8]' = 1730 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,1]' = 24 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,2]' = 1110 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,3]' = 1210 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,4]' = 1310 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,5]' = 1420 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,6]' = 1540 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,7]' = 1710 "Electrical power table; T in degC; Q_flow in W";
            parameter Real 'tableP_ele[4,8]' = 1920 "Electrical power table; T in degC; Q_flow in W";
            parameter Modelica.SIunits.MassFlowRate mFlow_conNom = 0.1894736842105263 "Nominal mass flow rate in condenser";
            parameter Modelica.SIunits.MassFlowRate mFlow_evaNom = 0.75 "Nominal mass flow rate in evaporator";
            parameter Real 'tableUppBou[1,1]' = -15.0 "Points to define upper boundary for sink temperature";
            parameter Real 'tableUppBou[1,2]' = 25.0 "Points to define upper boundary for sink temperature";
            parameter Real 'tableUppBou[2,1]' = 20.0 "Points to define upper boundary for sink temperature";
            parameter Real 'tableUppBou[2,2]' = 25.0 "Points to define upper boundary for sink temperature";
          end dataTable_rec;
        public
          dataTable_rec dataTable annotation(Dialog);
        protected
          record Qdot_ConTable_rec
            Real u1_inBaseUnit(unit = "K") = fmi_Functions.from_degC(u1);
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Real u2_inBaseUnit(unit = "K") = fmi_Functions.from_degC(u2);
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
            constant Boolean extrapolation = true "False to hold last value";
            constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
            Real 'table[1,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
          protected
            record combiTable2D_rec
              Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
              Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
              constant Boolean tableOnFile = false "= true, if table is defined on file or in function usertab";
              Real 'table[1,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Boolean verboseRead = true "= true, if info message that file is loading is to be printed";
              constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
              constant Modelica.Blocks.Types.Extrapolation extrapolation = Modelica.Blocks.Types.Extrapolation.LastTwoPoints "Extrapolation of data outside the definition range";
              constant Boolean verboseExtrapolation = false "= true, if warning messages are to be printed if table input is outside the definition range";
              Real 'u_min[1]' "Minimum abscissa value defined in table";
              Real 'u_min[2]' "Minimum abscissa value defined in table";
              Real 'u_max[1]' "Maximum abscissa value defined in table";
              Real 'u_max[2]' "Maximum abscissa value defined in table";
            end combiTable2D_rec;
          public
            combiTable2D_rec combiTable2D annotation(Dialog);
          protected
            record realPassThrough2_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough2_rec;
          public
            realPassThrough2_rec realPassThrough2;
          protected
            record realPassThrough1_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough1_rec;
          public
            realPassThrough1_rec realPassThrough1;
          end Qdot_ConTable_rec;
        public
          Qdot_ConTable_rec Qdot_ConTable annotation(Dialog);
        protected
          record P_eleTable_rec
            Real u1_inBaseUnit(unit = "K") = fmi_Functions.from_degC(u1);
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Real u2_inBaseUnit(unit = "K") = fmi_Functions.from_degC(u2);
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "W", displayUnit = "kW") "Connector of Real output signal";
            constant Boolean extrapolation = true "False to hold last value";
            constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
            Real 'table[1,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[1,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[2,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[3,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
            Real 'table[4,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0,0;0,1])";
          protected
            record combiTable2D_rec
              Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
              Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
              constant Boolean tableOnFile = false "= true, if table is defined on file or in function usertab";
              Real 'table[1,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[1,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[2,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[3,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,1]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,2]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,3]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,4]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,5]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,6]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,7]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              Real 'table[4,8]' "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])";
              parameter Boolean verboseRead = true "= true, if info message that file is loading is to be printed";
              constant Modelica.Blocks.Types.Smoothness smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
              constant Modelica.Blocks.Types.Extrapolation extrapolation = Modelica.Blocks.Types.Extrapolation.LastTwoPoints "Extrapolation of data outside the definition range";
              constant Boolean verboseExtrapolation = false "= true, if warning messages are to be printed if table input is outside the definition range";
              Real 'u_min[1]' "Minimum abscissa value defined in table";
              Real 'u_min[2]' "Minimum abscissa value defined in table";
              Real 'u_max[1]' "Maximum abscissa value defined in table";
              Real 'u_max[2]' "Maximum abscissa value defined in table";
            end combiTable2D_rec;
          public
            combiTable2D_rec combiTable2D annotation(Dialog);
          protected
            record realPassThrough2_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough2_rec;
          public
            realPassThrough2_rec realPassThrough2;
          protected
            record realPassThrough1_rec
              Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
              Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            end realPassThrough1_rec;
          public
            realPassThrough1_rec realPassThrough1;
          end P_eleTable_rec;
        public
          P_eleTable_rec P_eleTable annotation(Dialog);
        protected
          record t_Ev_in_rec
            Modelica_Blocks_Interfaces_RealInput u(unit = "K") "Connector of Real input signal to be converted";
            Real y_inBaseUnit(unit = "K") = fmi_Functions.from_degC(y);
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal containing input signal u in another unit";
          end t_Ev_in_rec;
        public
          t_Ev_in_rec t_Ev_in;
        protected
          record t_Co_ou_rec
            Modelica_Blocks_Interfaces_RealInput u(unit = "K") "Connector of Real input signal to be converted";
            Real y_inBaseUnit(unit = "K") = fmi_Functions.from_degC(y);
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal containing input signal u in another unit";
          end t_Co_ou_rec;
        public
          t_Co_ou_rec t_Co_ou;
        protected
          record nTimesPel_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end nTimesPel_rec;
        public
          nTimesPel_rec nTimesPel;
        protected
          record nTimesQCon_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end nTimesQCon_rec;
        public
          nTimesQCon_rec nTimesQCon;
        protected
          record nTimesSF_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            constant Modelica_Blocks_Interfaces_RealInput u2 = 1.35 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end nTimesSF_rec;
        public
          nTimesSF_rec nTimesSF;
        end PerformanceDataHPHeating_rec;
      public
        PerformanceDataHPHeating_rec PerformanceDataHPHeating annotation(Dialog);
      protected
        record gainEva_rec
          constant Real k = -1 "Gain value multiplied with input signal";
          Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
          Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
        end gainEva_rec;
      public
        gainEva_rec gainEva;
      protected
        record constZero_rec
          constant Real k = 0 "Constant output value";
          constant Modelica_Blocks_Interfaces_RealOutput y = 0.0 "Connector of Real output signal";
        end constZero_rec;
      public
        constZero_rec constZero;
      end innerCycle_rec;
    public
      innerCycle_rec innerCycle annotation(Dialog);
    protected
      record con_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
        Modelica.SIunits.MassFlowRate m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa") = 0.0 "Pressure difference between port_a and port_b";
        constant Boolean computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction";
        constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
        constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa", min = 0.0) = 0.0 "Pressure difference";
        constant Boolean linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate";
        constant Real deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar";
        constant Modelica.SIunits.Time tau = 30 "Time constant at nominal flow (if energyDynamics <> SteadyState)";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
        constant Real p_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325.0 "Start value of pressure";
        constant Real T_start(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 290.15 "Start value of temperature";
        constant Real 'X_start[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Start value of mass fractions m_i/m";
        constant Real 'X_start[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Start value of mass fractions m_i/m";
        constant Boolean is_con = true "Type of heat exchanger";
        Modelica.SIunits.Volume V "Volume in condenser";
        constant Boolean use_cap = false "False if capacity and heat losses are neglected";
        constant Modelica.SIunits.HeatCapacity C = 135.0 "Capacity of heat exchanger. If you want to neglace the dry mass of the heat exchanger, you can set this value to zero";
        Modelica.SIunits.Temperature TCap_start "Initial temperature of heat capacity";
        constant Modelica.SIunits.ThermalConductance GOut = 6.75 "Formular for calculation of heat transfer coefficient on the outside. If you want to simulate a heat exchanger with additional dry mass but without external heat losses, set the value to zero";
        constant Modelica_Blocks_Interfaces_RealOutput GInn = 0.0 "Formular for calculation of heat transfer coefficient on the inside";
        Modelica_Blocks_Interfaces_RealInput QFlow_in "Heat flow rate to the medium";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record vol_rec
          constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state";
          constant Real p_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325.0 "Start value of pressure";
          constant Real T_start(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 290.15 "Start value of temperature";
          constant Real 'X_start[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Start value of mass fractions m_i/m";
          constant Real 'X_start[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Start value of mass fractions m_i/m";
          constant Real mSenFac(min = 1.0) = 1 "Factor for scaling the sensible thermal mass of the volume";
          constant Boolean prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
          constant Boolean simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate";
          constant Integer nPorts = 2 "Number of ports";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports.";
          Modelica.SIunits.Volume V "Volume";
          Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) "Temperature of the fluid";
          Modelica_Blocks_Interfaces_RealOutput U(unit = "J") "Internal energy of the component";
          Modelica.SIunits.Pressure p "Pressure of the fluid";
          Modelica_Blocks_Interfaces_RealOutput m(unit = "kg") "Mass of the component";
          Modelica.SIunits.MassFraction 'Xi[1]' "Species concentration of the fluid";
          Modelica_Blocks_Interfaces_RealOutput 'mXi[1]'(unit = "kg", min = 0.0) "Species mass of the component";
          constant Boolean use_C_flow = false "Set to true to enable input connector for trace substance";
        protected
          record 'ports[1]_rec'
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[1]_rec';
        public
          'ports[1]_rec' 'ports[1]';
        protected
          record 'ports[2]_rec'
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[2]_rec';
        public
          'ports[2]_rec' 'ports[2]';
        protected
          record heatPort_rec
            Modelica.SIunits.Temperature T "Port temperature";
            Modelica.SIunits.HeatFlowRate Q_flow "Heat flow rate (positive if flowing from outside into the component)";
          end heatPort_rec;
        public
          heatPort_rec heatPort;
        protected
          record dynBal_rec
            Modelica.SIunits.Energy U(nominal = 100000.0) "Internal energy of fluid";
            Real _U_der(unit = "W") "der(Internal energy of fluid)";
            Modelica.SIunits.Mass 'mXi[1]' "Masses of independent components in the fluid";
            Real '_mXi[1]_der'(unit = "kg/s") "der(Masses of independent components in the fluid)";
          end dynBal_rec;
        public
          dynBal_rec dynBal;
        end vol_rec;
      public
        vol_rec vol;
      protected
        record preDro_rec
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          Modelica.SIunits.MassFlowRate m_flow(nominal = 0.405) "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
          constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa", nominal = 1.0) = 0 "Pressure difference between port_a and port_b";
          constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
          constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa") = 0.0 "Pressure drop at nominal mass flow rate";
          constant Boolean linearized = false "= true, use linear relation between m_flow and dp for any flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_turbulent(min = 0.0) = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent";
          constant Real deltaM(min = 1E-06) = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
          constant Real k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
        protected
          record port_a_rec
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_a_rec;
        public
          port_a_rec port_a;
        protected
          record port_b_rec
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_b_rec;
        public
          port_b_rec port_b;
        end preDro_rec;
      public
        preDro_rec preDro;
      protected
        record preHea_rec
          constant Modelica.SIunits.Temperature T_ref = 293.15 "Reference temperature";
          constant Modelica.SIunits.LinearTemperatureCoefficient alpha = 0 "Temperature coefficient of heat flow rate";
          Modelica_Blocks_Interfaces_RealInput Q_flow(unit = "W");
        protected
          record port_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end port_rec;
        public
          port_rec port;
        end preHea_rec;
      public
        preHea_rec preHea;
      end con_rec;
    public
      con_rec con;
    protected
      record eva_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "Small mass flow rate for regularization of zero flow";
        Modelica.SIunits.MassFlowRate m_flow "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa") = 0.0 "Pressure difference between port_a and port_b";
        constant Boolean computeFlowResistance = true "=true, compute flow resistance. Set to false to assume no friction";
        constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
        constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa", min = 0.0) = 0.0 "Pressure difference";
        constant Boolean linearizeFlowResistance = false "= true, use linear relation between m_flow and dp for any flow rate";
        constant Real deltaM = 0.1 "Fraction of nominal flow rate where flow transitions to laminar";
        constant Modelica.SIunits.Time tau = 30 "Time constant at nominal flow (if energyDynamics <> SteadyState)";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
        constant Real p_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325.0 "Start value of pressure";
        constant Real T_start(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 281.15 "Start value of temperature";
        constant Real 'X_start[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Start value of mass fractions m_i/m";
        constant Real 'X_start[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Start value of mass fractions m_i/m";
        constant Boolean is_con = false "Type of heat exchanger";
        Modelica.SIunits.Volume V "Volume in condenser";
        constant Boolean use_cap = false "False if capacity and heat losses are neglected";
        constant Modelica.SIunits.HeatCapacity C = 135.0 "Capacity of heat exchanger. If you want to neglace the dry mass of the heat exchanger, you can set this value to zero";
        Modelica.SIunits.Temperature TCap_start "Initial temperature of heat capacity";
        constant Modelica.SIunits.ThermalConductance GOut = 6.75 "Formular for calculation of heat transfer coefficient on the outside. If you want to simulate a heat exchanger with additional dry mass but without external heat losses, set the value to zero";
        constant Modelica_Blocks_Interfaces_RealOutput GInn = 0.0 "Formular for calculation of heat transfer coefficient on the inside";
        Modelica_Blocks_Interfaces_RealInput QFlow_in "Heat flow rate to the medium";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record vol_rec
          constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of energy balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Type of mass balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state";
          constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial "Type of trace substance balance: dynamic (3 initialization options) or steady state";
          constant Real p_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325.0 "Start value of pressure";
          constant Real T_start(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 281.15 "Start value of temperature";
          constant Real 'X_start[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Start value of mass fractions m_i/m";
          constant Real 'X_start[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Start value of mass fractions m_i/m";
          constant Real mSenFac(min = 1.0) = 1 "Factor for scaling the sensible thermal mass of the volume";
          constant Boolean prescribedHeatFlowRate = true "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
          constant Boolean simplify_mWat_flow = true "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate";
          constant Integer nPorts = 2 "Number of ports";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports.";
          Modelica.SIunits.Volume V "Volume";
          Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) "Temperature of the fluid";
          Modelica_Blocks_Interfaces_RealOutput U(unit = "J") "Internal energy of the component";
          Modelica.SIunits.Pressure p "Pressure of the fluid";
          Modelica_Blocks_Interfaces_RealOutput m(unit = "kg") "Mass of the component";
          Modelica.SIunits.MassFraction 'Xi[1]' "Species concentration of the fluid";
          Modelica_Blocks_Interfaces_RealOutput 'mXi[1]'(unit = "kg", min = 0.0) "Species mass of the component";
          constant Boolean use_C_flow = false "Set to true to enable input connector for trace substance";
        protected
          record 'ports[1]_rec'
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[1]_rec';
        public
          'ports[1]_rec' 'ports[1]';
        protected
          record 'ports[2]_rec'
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end 'ports[2]_rec';
        public
          'ports[2]_rec' 'ports[2]';
        protected
          record heatPort_rec
            Modelica.SIunits.Temperature T "Port temperature";
            Modelica.SIunits.HeatFlowRate Q_flow "Heat flow rate (positive if flowing from outside into the component)";
          end heatPort_rec;
        public
          heatPort_rec heatPort;
        protected
          record dynBal_rec
            Modelica.SIunits.Energy U(nominal = 100000.0) "Internal energy of fluid";
            Real _U_der(unit = "W") "der(Internal energy of fluid)";
            Modelica.SIunits.Mass 'mXi[1]' "Masses of independent components in the fluid";
            Real '_mXi[1]_der'(unit = "kg/s") "der(Masses of independent components in the fluid)";
          end dynBal_rec;
        public
          dynBal_rec dynBal;
        end vol_rec;
      public
        vol_rec vol;
      protected
        record preDro_rec
          constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
          constant Modelica.SIunits.MassFlowRate m_flow_nominal = 0.405 "Nominal mass flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 4.05E-05 "Small mass flow rate for regularization of zero flow";
          Modelica.SIunits.MassFlowRate m_flow(nominal = 0.405) "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
          constant Modelica.SIunits.PressureDifference dp(displayUnit = "Pa", nominal = 1.0) = 0 "Pressure difference between port_a and port_b";
          constant Boolean from_dp = false "= true, use m_flow = f(dp) else dp = f(m_flow)";
          constant Modelica.SIunits.PressureDifference dp_nominal(displayUnit = "Pa") = 0.0 "Pressure drop at nominal mass flow rate";
          constant Boolean linearized = false "= true, use linear relation between m_flow and dp for any flow rate";
          constant Modelica.SIunits.MassFlowRate m_flow_turbulent(min = 0.0) = 0 "Turbulent flow if |m_flow| >= m_flow_turbulent";
          constant Real deltaM(min = 1E-06) = 0.1 "Fraction of nominal mass flow rate where transition to turbulent occurs";
          constant Real k = 0 "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
        protected
          record port_a_rec
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_a_rec;
        public
          port_a_rec port_a;
        protected
          record port_b_rec
            Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
            Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
            Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
          end port_b_rec;
        public
          port_b_rec port_b;
        end preDro_rec;
      public
        preDro_rec preDro;
      protected
        record preHea_rec
          constant Modelica.SIunits.Temperature T_ref = 293.15 "Reference temperature";
          constant Modelica.SIunits.LinearTemperatureCoefficient alpha = 0 "Temperature coefficient of heat flow rate";
          Modelica_Blocks_Interfaces_RealInput Q_flow(unit = "W");
        protected
          record port_rec
            Modelica.SIunits.Temperature T "Port temperature";
          end port_rec;
        public
          port_rec port;
        end preHea_rec;
      public
        preHea_rec preHea;
      end eva_rec;
    public
      eva_rec eva;
    protected
      record heatFlowIneEva_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        constant Integer n = 3 "Order of filter";
        constant Modelica.SIunits.Frequency f = 0.015 "Cut-off frequency";
        constant Boolean normalized = true "= true, if amplitude at f_cut is 3 dB, otherwise unmodified filter";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
        Real 'x_start[1]' "Initial or guess values of states";
        Real 'x_start[2]' "Initial or guess values of states";
        Real 'x_start[3]' "Initial or guess values of states";
        Real y_start "Initial value of output (remaining states are in steady state)";
        Real 'x[1]' "Filter states";
        Real '_x[1]_der' "der(Filter states)";
        Real 'x[2]' "Filter states";
        Real '_x[2]_der' "der(Filter states)";
        Real 'x[3]' "Filter states";
        Real '_x[3]_der' "der(Filter states)";
      end heatFlowIneEva_rec;
    public
      heatFlowIneEva_rec heatFlowIneEva;
    protected
      record heatFlowIneCon_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        constant Integer n = 3 "Order of filter";
        constant Modelica.SIunits.Frequency f = 0.015 "Cut-off frequency";
        constant Boolean normalized = true "= true, if amplitude at f_cut is 3 dB, otherwise unmodified filter";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
        Real 'x_start[1]' "Initial or guess values of states";
        Real 'x_start[2]' "Initial or guess values of states";
        Real 'x_start[3]' "Initial or guess values of states";
        Real y_start "Initial value of output (remaining states are in steady state)";
        Real 'x[1]' "Filter states";
        Real '_x[1]_der' "der(Filter states)";
        Real 'x[2]' "Filter states";
        Real '_x[2]_der' "der(Filter states)";
        Real 'x[3]' "Filter states";
        Real '_x[3]_der' "der(Filter states)";
      end heatFlowIneCon_rec;
    public
      heatFlowIneCon_rec heatFlowIneCon;
    protected
      record sigBus_rec
        Real nSet "Relative rotational speed of compressor between 0 and 1";
        Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
        Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
        Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
        Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
        Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
        Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
        Modelica.SIunits.Power PelMea "Total electrical active power";
        Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
        Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
        constant Real iceFacMea = 1.0 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
      end sigBus_rec;
    public
      sigBus_rec sigBus;
    protected
      record senT_a2_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
        Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
        constant Modelica.SIunits.Temperature T_start = 281.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        Modelica.SIunits.Temperature TAmb "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_a2_rec;
    public
      senT_a2_rec senT_a2;
    protected
      record senT_b2_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
        Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
        constant Modelica.SIunits.Temperature T_start = 281.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        Modelica.SIunits.Temperature TAmb "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_b2_rec;
    public
      senT_b2_rec senT_b2;
    protected
      record mFlow_eva_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        Modelica_Blocks_Interfaces_RealOutput m_flow(unit = "kg/s", quantity = "MassFlowRate") "Mass flow rate from port_a to port_b";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end mFlow_eva_rec;
    public
      mFlow_eva_rec mFlow_eva;
    protected
      record senT_b1_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
        Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
        constant Modelica.SIunits.Temperature T_start = 290.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        Modelica.SIunits.Temperature TAmb "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_b1_rec;
    public
      senT_b1_rec senT_b1;
    protected
      record senT_a1_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.405 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        constant Modelica.SIunits.Time tau(min = 0.0) = 1.0 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
        Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
        constant Modelica.SIunits.Temperature T_start = 290.15 "Initial or guess value of output (= state)";
        constant Boolean transferHeat = true "if true, temperature T converges towards TAmb when no flow";
        Modelica.SIunits.Temperature TAmb "Fixed ambient temperature for heat transfer";
        constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200.0 "Time constant for heat transfer, default 20 minutes";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end senT_a1_rec;
    public
      senT_a1_rec senT_a1;
    protected
      record mFlow_con_rec
        constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
        constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0 "Nominal mass flow rate, used for regularization near zero flow";
        constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 0 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
        Modelica_Blocks_Interfaces_RealOutput m_flow(unit = "kg/s", quantity = "MassFlowRate") "Mass flow rate from port_a to port_b";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end mFlow_con_rec;
    public
      mFlow_con_rec mFlow_con;
    protected
      record greaterThreshold_rec
        constant Real threshold = 1E-15 "Comparison with respect to threshold";
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
      end greaterThreshold_rec;
    public
      greaterThreshold_rec greaterThreshold;
    end heaPum_rec;
  public
    heaPum_rec heaPum annotation(Dialog);
  protected
    record heaOn_rec
      parameter Boolean k = true "Constant output value";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
    end heaOn_rec;
  public
    heaOn_rec heaOn annotation(Dialog);
  protected
    record senTAct_rec
      constant Boolean allowFlowReversal = true "= false to simplify equations, assuming, but not enforcing, no flow reversal";
      constant Modelica.SIunits.MassFlowRate m_flow_nominal(min = 0.0) = 0.3 "Nominal mass flow rate, used for regularization near zero flow";
      constant Modelica.SIunits.MassFlowRate m_flow_small(min = 0.0) = 3E-05 "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
      constant Modelica.SIunits.Time tau(min = 0.0) = 1 "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
      constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState "Type of initialization (InitialState and InitialOutput are identical)";
      Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature", min = 0.0) "Temperature of the passing fluid";
      Real _T_der(unit = "K/s") "der(Temperature of the passing fluid)";
      constant Modelica.SIunits.Temperature T_start = 303.15 "Initial or guess value of output (= state)";
      constant Boolean transferHeat = false "if true, temperature T converges towards TAmb when no flow";
      constant Modelica.SIunits.Temperature TAmb = 291.15 "Fixed ambient temperature for heat transfer";
      constant Modelica.SIunits.Time tauHeaTra(min = 1.0) = 1200 "Time constant for heat transfer, default 20 minutes";
    protected
      record port_a_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_a_rec;
    public
      port_a_rec port_a;
    protected
      record port_b_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 45300.945, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      end port_b_rec;
    public
      port_b_rec port_b;
    end senTAct_rec;
  public
    senTAct_rec senTAct;
  protected
    record iceFac_rec
      constant Real k = 1 "Constant output value";
      constant Modelica_Blocks_Interfaces_RealOutput y = 1.0 "Connector of Real output signal";
    end iceFac_rec;
  public
    iceFac_rec iceFac;
  protected
    record nSetGai_rec
      parameter Real k = 0.5 "Gain value multiplied with input signal";
      Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
      Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
    end nSetGai_rec;
  public
    nSetGai_rec nSetGai annotation(Dialog);
  protected
    record sigBus1_rec
      Real nSet "Relative rotational speed of compressor between 0 and 1";
      Boolean modeSet "Current operation mode: true: main operation mode, false: reversible operation mode";
      Boolean onOffMea "Measured value of device being on or off (relative speed greater than 0)";
      Modelica.SIunits.ThermodynamicTemperature TEvaInMea "Temperature of flow into evaporator";
      Modelica.SIunits.ThermodynamicTemperature TConInMea "Temperature of flow into condenser";
      Modelica.SIunits.ThermodynamicTemperature TEvaOutMea "temperature of flow out of evaporator";
      Modelica.SIunits.ThermodynamicTemperature TConOutMea "Temperature of flow out of condenser";
      Modelica.SIunits.Power PelMea "Total electrical active power";
      Modelica.SIunits.MassFlowRate m_flowEvaMea "Mass flow rate through evaporator";
      Modelica.SIunits.MassFlowRate m_flowConMea "Mass flow rate through condenser";
      constant Real iceFacMea = 1 "Efficiency factor (0..1) to estimate influence of icing. 0 means no heat is transferred through heat exchanger (fully frozen). 1 means no icing/frosting.";
    end sigBus1_rec;
  public
    sigBus1_rec sigBus1;
  protected
    record port_a_rec
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end port_a_rec;
  public
    port_a_rec port_a;
  protected
    record port_b_rec
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end port_b_rec;
  public
    port_b_rec port_b;
  end rtuHP_rec;
public
  rtuHP_rec rtuHP annotation(Dialog);
protected
  record supFan_rec
    constant Integer nPorts = 1 "Number of ports";
    constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
    parameter Real 'X[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Fixed value of composition";
    parameter Real 'X[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Fixed value of composition";
    parameter Modelica.SIunits.MassFlowRate m_flow = 0 "Fixed mass flow rate going out of the fluid port";
    parameter Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 293.15 "Fixed value of temperature";
    Modelica_Blocks_Interfaces_RealInput m_flow_in(unit = "kg/s") "Prescribed mass flow rate";
    Modelica_Blocks_Interfaces_RealInput T_in(unit = "K", displayUnit = "degC") "Prescribed boundary temperature";
  protected
    record 'ports[1]_rec'
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end 'ports[1]_rec';
  public
    'ports[1]_rec' 'ports[1]';
  end supFan_rec;
public
  supFan_rec supFan annotation(Dialog);
protected
  record roo_rec
    constant Integer nPorts = 1 "Number of ports";
    constant Boolean verifyInputs = false "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range";
    parameter Real 'X[1]'(nominal = 0.1, quantity = "water", min = 0.0, max = 1.0) = 0.01 "Fixed value of composition";
    parameter Real 'X[2]'(nominal = 0.1, quantity = "air", min = 0.0, max = 1.0) = 0.99 "Fixed value of composition";
    parameter Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325 "Fixed value of pressure";
    parameter Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 1.0, max = 10000.0) = 293.15 "Fixed value of temperature";
  protected
    record 'ports[1]_rec'
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Air", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
    end 'ports[1]_rec';
  public
    'ports[1]_rec' 'ports[1]';
  end roo_rec;
public
  roo_rec roo annotation(Dialog);
protected
  record rtuConFMU_rec
    Real k_hea "Proportional gain of heating controller";
    Modelica.SIunits.Time Ti_hea "Integral time constant of heating controller";
    Modelica.SIunits.ThermodynamicTemperature maxSAT "max supply air temperature";
    Real uLowSta1 "PI lower bound to activate stage 1";
    Real uUppSta1 "PI upper bound to activate stage 1";
    Real uLowSta2 "PI lower bound to activate stage 2";
    Real uUppSta2 "PI upper bound to activate stage 2";
    Real kSta1 "PI center line to activate stage 1";
    Real kSta2 "PI center line to activate stage 2";
    Real banSta1 "PI band to activate stage 1";
    Real banSta2 "PI band to activate stage 2";
    Modelica_Blocks_Interfaces_RealInput TSetRooHea(unit = "K", displayUnit = "degC") "Zone heating setpoint temperature";
    Modelica_Blocks_Interfaces_RealInput TRoo(unit = "K", displayUnit = "degC") "Zone temperature measurement";
    Modelica_Blocks_Interfaces_RealOutput heaSta "Control signal for heating";
    Modelica_Blocks_Interfaces_RealInput TSup(unit = "K", displayUnit = "degC") "Supply air temperature";
    Modelica_Blocks_Interfaces_BooleanOutput heaCal "Control signal for heating";
  protected
    record conHea_rec
      Modelica_Blocks_Interfaces_RealInput u_s "Connector of setpoint input signal";
      Modelica_Blocks_Interfaces_RealInput u_m "Connector of measurement input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of actuator output signal";
      Real controlError "Control error (set point - measurement)";
      constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
      Real k(min = 0.0) "Gain of controller";
      Modelica.SIunits.Time Ti(min = 1E-60) "Time constant of Integrator block";
      parameter Modelica.SIunits.Time Td(min = 0.0) = 0.1 "Time constant of Derivative block";
      constant Real yMax = 1 "Upper limit of output";
      constant Real yMin = 0 "Lower limit of output";
      parameter Real wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
      parameter Real wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
      parameter Real Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
      parameter Real Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
      constant Modelica.Blocks.Types.InitPID initType = Modelica.Blocks.Types.InitPID.InitialOutput "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
      constant Real xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
      parameter Real xd_start = 0 "Initial or guess value for state of derivative block";
      constant Real y_start = 0 "Initial value of output";
      constant Boolean strict = true "= true, if strict limits with noEvent(..)";
      parameter Boolean reverseActing = true "Set to true for reverse acting, or false for direct acting control action";
      constant Buildings_Types_Reset reset = Buildings_Types_Reset.Parameter "Type of controller output reset";
      constant Real y_reset = 0.0 "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == Buildings.Types.Reset.Parameter";
      Modelica_Blocks_Interfaces_BooleanInput trigger "Resets the controller output when trigger becomes true";
    protected
      record addP_rec
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
        Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        Real k1 "Gain of input signal 1";
        Real k2 "Gain of input signal 2";
      end addP_rec;
    public
      addP_rec addP;
    protected
      record P_rec
        parameter Real k = 1 "Gain value multiplied with input signal";
        Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
        Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
      end P_rec;
    public
      P_rec P annotation(Dialog);
    protected
      record addPID_rec
        constant Real k1 = 1 "Gain of input signal 1";
        constant Real k2 = 1 "Gain of input signal 2";
        constant Real k3 = 1 "Gain of input signal 3";
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
        constant Modelica_Blocks_Interfaces_RealInput u2 = 0 "Connector of Real input signal 2";
        Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end addPID_rec;
    public
      addPID_rec addPID;
    protected
      record I_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        Real _y_der "der(Connector of Real output signal)";
        Real k "Integrator gain";
        constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
        constant Real y_start = 0.0 "Initial or guess value of output (= state)";
        constant Buildings_Types_Reset reset = Buildings_Types_Reset.Input "Type of integrator reset";
        constant Real y_reset = 0.0 "Value to which integrator is reset, used if reset = Buildings.Types.Reset.Parameter";
        Modelica_Blocks_Interfaces_RealInput y_reset_in "Input signal for state to which integrator is reset, enabled if reset = Buildings.Types.Reset.Input";
        Modelica_Blocks_Interfaces_BooleanInput trigger "Resets the integrator output when trigger becomes true";
      end I_rec;
    public
      I_rec I;
    end conHea_rec;
  public
    conHea_rec conHea annotation(Dialog);
  protected
    record swiHea_rec
      Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
      Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end swiHea_rec;
  public
    swiHea_rec swiHea;
  protected
    record offHea_rec
      parameter Real k = 0 "Constant output value";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end offHea_rec;
  public
    offHea_rec offHea annotation(Dialog);
  protected
    record onOffConSupHeatSetPoi_rec
      Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
      Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
      parameter Real bandwidth = 0.5 "Bandwidth around reference signal";
      parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
    end onOffConSupHeatSetPoi_rec;
  public
    onOffConSupHeatSetPoi_rec onOffConSupHeatSetPoi annotation(Dialog);
  protected
    record UpperLimSup_rec
      Real k "Constant output value";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end UpperLimSup_rec;
  public
    UpperLimSup_rec UpperLimSup;
  protected
    record heatStage_rec
      Real uLowSta1 "PI lower bound to activate stage 1";
      Real uUppSta1 "PI upper bound to activate stage 1";
      Real uLowSta2 "PI lower bound to activate stage 2";
      Real uUppSta2 "PI upper bound to activate stage 2";
      Real kSta1 "PI center line to activate stage 1";
      Real kSta2 "PI center line to activate stage 2";
      Real banSta1 "PI band to activate stage 1";
      Real banSta2 "PI band to activate stage 2";
      Modelica_Blocks_Interfaces_RealInput uHea "Zone temperature measurement";
      Modelica_Blocks_Interfaces_RealOutput y_Sta "Zone temperature measurement";
    protected
      record realToBoolean1_rec
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
        parameter Real threshold = 0.001 "Output signal y is true, if input u >= threshold";
      end realToBoolean1_rec;
    public
      realToBoolean1_rec realToBoolean1 annotation(Dialog);
    protected
      record add_rec
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
        Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        parameter Real k1 = 1 "Gain of input signal 1";
        parameter Real k2 = 1 "Gain of input signal 2";
      end add_rec;
    public
      add_rec add annotation(Dialog);
    protected
      record switch4_rec
        Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
        Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
        Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end switch4_rec;
    public
      switch4_rec switch4;
    protected
      record const7_rec
        parameter Real k = 0 "Constant output value";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end const7_rec;
    public
      const7_rec const7 annotation(Dialog);
    protected
      record booleanToReal_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Connector of Boolean input signal";
        parameter Real realTrue = 1.0 "Output signal for true Boolean input";
        parameter Real realFalse = 0.0 "Output signal for false Boolean input";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end booleanToReal_rec;
    public
      booleanToReal_rec booleanToReal annotation(Dialog);
    protected
      record booleanToReal1_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Connector of Boolean input signal";
        parameter Real realTrue = 1.0 "Output signal for true Boolean input";
        parameter Real realFalse = 0.0 "Output signal for false Boolean input";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end booleanToReal1_rec;
    public
      booleanToReal1_rec booleanToReal1 annotation(Dialog);
    protected
      record const1_rec
        Real k "Constant output value";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end const1_rec;
    public
      const1_rec const1;
    protected
      record onOffSta1_rec
        Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
        Real bandwidth "Bandwidth around reference signal";
        parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
      end onOffSta1_rec;
    public
      onOffSta1_rec onOffSta1 annotation(Dialog);
    protected
      record const2_rec
        Real k "Constant output value";
        Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
      end const2_rec;
    public
      const2_rec const2;
    protected
      record onOffSta2_rec
        Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
        Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
        Real bandwidth "Bandwidth around reference signal";
        parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
      end onOffSta2_rec;
    public
      onOffSta2_rec onOffSta2 annotation(Dialog);
    protected
      record not1_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Boolean input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Boolean output signal";
      end not1_rec;
    public
      not1_rec not1;
    protected
      record not2_rec
        Modelica_Blocks_Interfaces_BooleanInput u "Boolean input signal";
        Modelica_Blocks_Interfaces_BooleanOutput y "Boolean output signal";
      end not2_rec;
    public
      not2_rec not2;
    end heatStage_rec;
  public
    heatStage_rec heatStage annotation(Dialog);
  protected
    record swiTim_rec
      Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
      Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end swiTim_rec;
  public
    swiTim_rec swiTim;
  protected
    record onOffConHea_rec
      Modelica_Blocks_Interfaces_RealInput reference "Connector of Real input signal used as reference signal";
      Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal used as measurement signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Real output signal used as actuator signal";
      parameter Real bandwidth = 1 "Bandwidth around reference signal";
      parameter Boolean pre_y_start = false "Value of pre(y) at initial time";
    end onOffConHea_rec;
  public
    onOffConHea_rec onOffConHea annotation(Dialog);
  protected
    record UppLimSwi_rec
      Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
      Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
      Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
    end UppLimSwi_rec;
  public
    UppLimSwi_rec UppLimSwi;
  protected
    record NotLim_rec
      Modelica_Blocks_Interfaces_BooleanInput u "Connector of Boolean input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
    end NotLim_rec;
  public
    NotLim_rec NotLim;
  protected
    record onDelay_rec
      Modelica_Blocks_Interfaces_BooleanInput u "Boolean input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Boolean output signal";
      parameter Modelica.SIunits.Time delayTime = 120 "Delay time";
    end onDelay_rec;
  public
    onDelay_rec onDelay annotation(Dialog);
  protected
    record realToBoolean_rec
      Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
      Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
      parameter Real threshold = 0.5 "Output signal y is true, if input u >= threshold";
    end realToBoolean_rec;
  public
    realToBoolean_rec realToBoolean annotation(Dialog);
  end rtuConFMU_rec;
public
  rtuConFMU_rec rtuConFMU annotation(Dialog);
  parameter Real _u_m_flow_start = 0
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _u_m_flow_old;
public
  Modelica.Blocks.Interfaces.RealInput u_m_flow(unit = "kg/s", nominal = 0.405, min = -100000.0, max = 100000.0, start = _u_m_flow_start)
  annotation (Placement(transformation(extent={{-124,47},{-84,87}})));
  parameter Real _u_TDryBul_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _u_TDryBul_old;
public
  Modelica.Blocks.Interfaces.RealInput u_TDryBul(unit = "K", displayUnit = "degC", start = _u_TDryBul_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,14},{-84,54}})));
  parameter Real _u_TRoo_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _u_TRoo_old;
public
  Modelica.Blocks.Interfaces.RealInput u_TRoo(unit = "K", displayUnit = "degC", start = _u_TRoo_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,-20},{-84,20}})));
  parameter Real _u_TRooSetPoi_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _u_TRooSetPoi_old;
public
  Modelica.Blocks.Interfaces.RealInput u_TRooSetPoi(unit = "K", displayUnit = "degC", start = _u_TRooSetPoi_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,-53},{-84,-13}})));
  parameter Real _u_TMix_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _u_TMix_old;
public
  Modelica.Blocks.Interfaces.RealInput u_TMix(unit = "K", displayUnit = "degC", start = _u_TMix_start) "Zone temperature measurement"
  annotation (Placement(transformation(extent={{-124,-86},{-84,-46}})));
  Modelica.Blocks.Interfaces.RealOutput y_TSup(unit = "K", displayUnit = "degC", min = 0.0)
  annotation (Placement(transformation(extent={{100,30},{140,70}})));
  Modelica.Blocks.Interfaces.RealOutput y_PEleHP(unit = "W")
  annotation (Placement(transformation(extent={{100,-20},{140,20}})));
  Modelica.Blocks.Interfaces.BooleanOutput y_HeaCal
  annotation (Placement(transformation(extent={{100,-70},{140,-30}})));
public
  parameter String fmi_instanceName="HiLWinterTestsRTUHPFMUv2_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  parameter Boolean fmi_InputTime=false
  "Time point of input used when calling doStep."
  annotation (Evaluate=true,Dialog(tab="FMI", group="Input Handling"),choices(choice= false "StepEnd", choice= true "StepStart"));
  parameter Boolean fmi_UsePreOnInputSignals=true
  annotation (Evaluate=true,Dialog(tab="FMI", group="Input Handling"));
  parameter Real fmi_StartTime = 19872000.0
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_StopTime = 19958400.0
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_NumberOfSteps = 500
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_CommunicationStepSize=(fmi_StopTime-fmi_StartTime)/fmi_NumberOfSteps
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Integer stepSizeScaleFactor = 1 "Number of doSteps called between two CommunicationStepSize"
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Boolean fmi_forceShutDownAtStopTime=false
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_rTol=1e-6 "relative tolerance for the internal solver of the fmu"
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter String fmi_resourceLocation="file:///"+ModelicaServices.ExternalReferences.loadResource("modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/resources")
  annotation (Dialog(tab="FMI", group="Instantiation"));
protected
  fmi_Functions.fmiModel fmi;
  Boolean fmi_exitInit(start=false,fixed=true);
  Boolean fmi_flip(start=false,fixed=true);
  parameter Real fmi_rdum(start=0,fixed=false);
  parameter Integer fmi_idum(start=0,fixed=false);
  Boolean fmi_StepOK;
  parameter Real zeroOffset = 0;
  parameter Real myTimeStart(fixed=false);
  Real y_TSup_internal;
  Real y_PEleHP_internal;
  Boolean y_HeaCal_internal;
Real RealVariables[82];
Real RealFixedLocal1[100];
Real RealFixedLocal2[88];
Boolean BooleanVariables[12];
package fmi_Functions
    class fmiModel
      extends ExternalObject;
      function constructor "Initialize FMI model"
        extends Modelica.Icons.Function;
        input String instanceName;
        input Boolean loggingOn;
        input String resourceLocation;
        output fmiModel fmi;
        external"C" fmi = HiLWinterTestsRTUHPFMUv288659024529653197286_fmiInstantiateModel2(instanceName, loggingOn, resourceLocation)
        annotation(Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_Instantiate_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_Instantiate_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void HiLWinterTestsRTUHPFMUv288659024529653197286Logger(fmi2ComponentEnvironment componentEnvironment, fmi2String instanceName, fmi2Status status,
  fmi2String category, fmi2String message, ...) {
  char msg[4096];
  char buf[4096];
  va_list ap;
  int len;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len < 4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmi2Fatal:
      ModelicaMessage(\"[fmi2Fatal]: \");
      break;
    case fmi2Error:
      ModelicaMessage(\"[fmi2Error]: \");
      break;
    case fmi2Discard:
      ModelicaMessage(\"[fmi2Discard]: \");
      break;
    case fmi2Warning:
      ModelicaMessage(\"[fmi2Warning]: \");
      break;
    case fmi2OK:
      ModelicaMessage(\"[fmi2OK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * HiLWinterTestsRTUHPFMUv288659024529653197286_fmiInstantiateModel2(const char*instanceName, fmi2Boolean loggingOn, fmi2String resourceLocation) {
  static fmi2CallbackFunctions funcs = {&HiLWinterTestsRTUHPFMUv288659024529653197286Logger, &calloc, &free, NULL, NULL};
  struct dy_fmi2Extended* res;
  res = calloc(1, sizeof(struct dy_fmi2Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibrary(\"HiLWinterTestsRTUHPFMUv2.so\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (HiLWinterTestsRTUHPFMUv2.so) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiate=(fmi2InstantiateFunc)GetProcAddress(res->hInst,\"fmi2Instantiate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Instantiate!\");
      return 0;
    }
    if (!(res->dyFmiFreeInstance=(fmi2FreeInstanceFunc)GetProcAddress(res->hInst,\"fmi2FreeInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeInstance!\");
      return 0;
    }
    if (!(res->dyFmiSetupExperiment=(fmi2SetupExperimentFunc)GetProcAddress(res->hInst,\"fmi2SetupExperiment\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetupExperiment!\");
      return 0;
    }
    if (!(res->dyFmiEnterInitializationMode=(fmi2EnterInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2EnterInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiExitInitializationMode=(fmi2ExitInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2ExitInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2ExitInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmi2TerminateFunc)GetProcAddress(res->hInst,\"fmi2Terminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Terminate!\");
      return 0;
    }
    if (!(res->dyFmiReset=(fmi2ResetFunc)GetProcAddress(res->hInst,\"fmi2Reset\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Reset!\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmi2SetRealFunc)GetProcAddress(res->hInst,\"fmi2SetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmi2GetRealFunc)GetProcAddress(res->hInst,\"fmi2GetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmi2SetIntegerFunc)GetProcAddress(res->hInst,\"fmi2SetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmi2GetIntegerFunc)GetProcAddress(res->hInst,\"fmi2GetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmi2SetBooleanFunc)GetProcAddress(res->hInst,\"fmi2SetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmi2GetBooleanFunc)GetProcAddress(res->hInst,\"fmi2GetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmi2SetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmi2SetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetDebugLogging!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmi2SetStringFunc)GetProcAddress(res->hInst,\"fmi2SetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmi2GetStringFunc)GetProcAddress(res->hInst,\"fmi2GetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetString!\");
      return 0;
    }
    if(!(res->dyFmiDoStep=(fmi2DoStepFunc)GetProcAddress(res->hInst,\"fmi2DoStep\"))){
      ModelicaError(\"GetProcAddress failed for fmi2DoStep!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiDoStep\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiGetBooleanStatus=(fmi2GetBooleanStatusFunc)GetProcAddress(res->hInst,\"fmi2GetBooleanStatus\"))){
      ModelicaError(\"GetProcAddress failed for fmi2GetBooleanStatus!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiGetBooleanStatus\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if (!(res->dyFmiGetDirectionalDerivative=(fmi2GetDirectionalDerivativeFunc)GetProcAddress(res->hInst,\"fmi2GetDirectionalDerivative\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetDirectionalDerivative!\");
      return 0;
    }
    if (!(res->dyFmiGetFMUstate=(fmi2GetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2GetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSetFMUstate=(fmi2SetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiFreeFMUstate=(fmi2FreeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2FreeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSerializedFMUstateSize=(fmi2SerializedFMUstateSizeFunc)GetProcAddress(res->hInst,\"fmi2SerializedFMUstateSize\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializedFMUstateSize!\");
      return 0;
    }
    if (!(res->dyFmiSerializeFMUstate=(fmi2SerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiDeSerializeFMUstate=(fmi2DeSerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2DeSerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2DeSerializeFMUstate!\");
      return 0;
    }
    res->m=res->dyFmiInstantiate(instanceName, fmi2CoSimulation, \"{f8f865ae-90e2-45be-b296-c53b19d72e86}\",resourceLocation, &funcs, fmi2False, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->discreteInputChanged=1;res->currentMode=dyfmi2InstantiationMode;res->dyLastStepTime=0;res->dyFMUstate=NULL;}
  }
  return res;
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
      end constructor;

      function destructor "Release storage of FMI model"
        extends Modelica.Icons.Function;
        input fmiModel fmi;
        external"C"
                   HiLWinterTestsRTUHPFMUv288659024529653197286_fmiFreeModelInstance2(fmi);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_Free_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_Free_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiFreeModelInstance2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    if(a->dyFMUstate)
    a->dyFmiFreeFMUstate(a->m, &a->dyFMUstate);
    /*a->dyFmiSetDebugLogging(a->m,fmi2True,0,NULL);*/
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
      end destructor;
    end fmiModel;

    function  fmiDoStep
    input fmiModel fmi;
    input Real currentTime;
    input Real stepSize;
    input Real preAvailable;
    output Boolean stepOK;
    output Real postAvailable=preAvailable;
    external"C" stepOK= HiLWinterTestsRTUHPFMUv288659024529653197286_fmiDoStep2(fmi, currentTime, stepSize);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_DoStep_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_DoStep_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double HiLWinterTestsRTUHPFMUv288659024529653197286_fmiDoStep2(void*m, double currentTime, double stepSize) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  fmi2Boolean value=fmi2False;
  if (a) {
    status=a->dyFmiDoStep(a->m, currentTime, stepSize, fmi2True);
    if(status==fmi2Discard){
      status = a->dyFmiGetBooleanStatus(a->m, fmi2Terminated, &value);
      if(value==fmi2True){
        terminate(\"Terminate signaled by the FMU\");
      }
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"DoStep failed\");
  return 1.0;
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiDoStep;

    function fmiReset
      input fmiModel fmi;
      output Boolean resetOK;
      external"C" resetOK = HiLWinterTestsRTUHPFMUv288659024529653197286_fmiReset2(fmi);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_Reset_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_Reset_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double HiLWinterTestsRTUHPFMUv288659024529653197286_fmiReset2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiReset(a->m);
    a->currentMode=dyfmi2InstantiationMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiReset failed\");
    return 1.0;
  }
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiReset;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_GetReal_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiGetReal;

    function fmiGetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real preAvailable;
      output Real vals[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_GetReal_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiGetRealwf;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      external"C"
                 HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_SetReal_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      input Real preAvailable;
      output Real postAvailable=preAvailable;
      external"C"
                 HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_SetReal_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealwf;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_GetInteger_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiGetInteger;

    function fmiGetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Integer vals[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_GetInteger_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_GetInteger_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiGetIntegerwf;

    function fmiSetInteger
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_SetInteger_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed in SetInteger\");
      for( i = 0; i < nrefs; ++i){
        if(oldVals[i] != vals[i]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiSetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
      input Integer preAvailable;
      output Integer postAvailable=preAvailable;
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetInteger2wf(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_SetIntegerwf_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_SetIntegerwf_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetInteger2wf(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetIntegerwf;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_GetBoolean_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiGetBoolean;

    function fmiGetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Boolean vals[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_GetBoolean_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiGetBooleanwf;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_SetBoolean_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_SetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals, int* dummy, int* oldVals) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(oldVals));
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed in SetBoolean\");
      for(j=nr-1;j>=0;j--){
        oldVals[j]=((fmi2Boolean*)(oldVals))[j];
        if(oldVals[j] != dummy[j]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetString
      input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_SetString_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_SetString_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetString2(void*m, const int*refs, size_t nrefs,const fmi2String vals[]) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    a->discreteInputChanged = fmi2True;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetString failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiSetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
      input Integer preAvailable;
      output Integer postAvailable=preAvailable;
    protected
      Boolean dummy[size(refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetBoolean2wf(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_SetBooleanwf_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_SetBooleanwf_C 1
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSetBoolean2wf(void*m, const int* refs, size_t nr, const int* vals, int* dummy) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBooleanwf;

    function fmiGetDirectionalDerivative
      input fmiModel fmi;
      input Integer z_refs[:];
      input Integer v_refs[:];
      input Real dv[size(v_refs, 1)];
      output Real dz[size(z_refs, 1)];
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_GetDirectionalDerivative2(
        fmi,
        z_refs,
        size(z_refs, 1),
        v_refs,
        size(v_refs, 1),
        dv,
        dz);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_GetDirectionalDerivative2_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_GetDirectionalDerivative2_C 1
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_GetDirectionalDerivative2(void*m, const int* zref, size_t nzr, const int* vrefs, size_t nvr, const double *dv, double *dz) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetDirectionalDerivative(a->m, zref, nzr, vrefs, nvr, dv, dz);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetDirectionalDerivative failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiGetDirectionalDerivative;

    function GetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1]);
      annotation(derivative(noDerivative=realLinearDependentInputs,noDerivative=linearDependentStates)=derGetRealVariable, LateInline=true);
    end GetRealVariable;

    function derGetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      input Real derRealInputs[:];
      input Real derStates[:];
      input Real derLinearOffsets;
      output Real derOutputVariable;
    protected
      Real dummy[1];
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //setString(fmi,stringInputValueReferences,stringInputs);
      dummy:=fmiGetDirectionalDerivative(fmi, outputValueReference,  cat(1,realInputValueReferences,statesValueRefernces), cat(1,derRealInputs,derStates));
      derOutputVariable:=dummy[1]+derLinearOffsets;
      annotation(LateInline=true);
    end derGetRealVariable;

    function fmiSaveFMUState
      input fmiModel fmi;
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSaveFMUState2(fmi);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSaveFMUState_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSaveFMUState_C 1
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSaveFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiSaveFMUState;

    function fmiRestoreFMUState
      input fmiModel fmi;
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiRestoreFMUState2(fmi);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_fmiRestoreFMUState_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_fmiRestoreFMUState_C 1
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiRestoreFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiRestoreFMUState;

    function fmiSerializeFMUstate
      input fmiModel fmi;
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSerializeFMUstate2(fmi);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSerializeFMUstate_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
    status = a->dyFmiSerializedFMUstateSize(a->m, a->dyFMUstate, &a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializedFMUstateSize failed\");
    if( a->dySerializeFMUstate) free(a->dySerializeFMUstate); a->dySerializeFMUstate = NULL;
    a->dySerializeFMUstate = malloc(a->dyFMUStateSize);
    if(!a->dySerializeFMUstate)  ModelicaError(\"malloc call to allocate SerializeFMUstate failed\");
    status = a->dyFmiSerializeFMUstate(a->m, a->dyFMUstate, a->dySerializeFMUstate, a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializeFMUstate failed\");
  }
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiSerializeFMUstate;

    function fmiDeSerializeFMUstate
      input fmiModel fmi;
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiDeSerializeFMUstate2(fmi);
        annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_fmiDeSerializeFMUstate_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_fmiDeSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiDeSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(!a->dySerializeFMUstate) ModelicaError(\"serializedFmuState is not allocated!!!\");
    if(a->dyFMUstate){
      a->dyFmiFreeFMUstate(a->m, a->dyFMUstate);
      a->dyFMUstate = NULL;    }
    status = a->dyFmiDeSerializeFMUstate(a->m, a->dySerializeFMUstate, a->dyFMUStateSize, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiDeSerializeFMUstate failed\");
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
  }
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiDeSerializeFMUstate;

    function fmiEnterSlaveInitializationMode
      input fmiModel fmi;
      input Real relativeTolerance;
      input Real tStart;
      input Boolean forceShutDownAtTStop;
      input Real tStop;
      input Real preAvailable;
      output Real postAvailable = preAvailable;
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiEnterSlaveInitializationMode2(fmi, relativeTolerance, tStart, forceShutDownAtTStop, tStop);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_fmiEnterSlaveInitializationMode_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_fmiEnterSlaveInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiEnterSlaveInitializationMode2(void*m, double relativeTolerance, double tStart, int forceShutDownAtTStop, double tStop) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode==dyfmi2InstantiationMode){
      status=a->dyFmiSetupExperiment(a->m, fmi2True, relativeTolerance, tStart, forceShutDownAtTStop, tStop);
      status=a->dyFmiEnterInitializationMode(a->m);
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->currentMode=dyfmi2InitializationMode;
    }else{
      status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"InitializeSlave failed\");
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiEnterSlaveInitializationMode;

    function fmiExitSlaveInitializationMode
      input fmiModel fmi;
      input Real preAvailable;
      output Real postAvailable = preAvailable;
      external"C" HiLWinterTestsRTUHPFMUv288659024529653197286_fmiExitSlaveInitializationMode2(fmi);
      annotation (Header="
#ifndef HiLWinterTestsRTUHPFMUv288659024529653197286_fmiExitSlaveInitializationMode_C
#define HiLWinterTestsRTUHPFMUv288659024529653197286_fmiExitSlaveInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void HiLWinterTestsRTUHPFMUv288659024529653197286_fmiExitSlaveInitializationMode2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiExitInitializationMode(a->m);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
    a->currentMode = dyfmi2EventMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiExitModelInitialization failed!\");
  return;
}
#endif", Library="HiLWinterTestsRTUHPFMUv2", LibraryDirectory="modelica://HiLWinterTestsRTUHPFMUv2_fmu/Resources/Library/FMU/HiLWinterTestsRTUHPFMUv2/binaries",__Dymola_doNotLinkSharedObject=true, __Dymola_CriticalRegion="HiLWinterTestsRTUHPFMUv2");
    end fmiExitSlaveInitializationMode;

    function  from_degC
      input Real degC;
      output Real BaseUnit(unit="K");
    algorithm
      BaseUnit := degC + 273.15;
    end from_degC;

    function  to_degC
      input Real BaseUnit(unit="K");
      output Real degC;
    algorithm
      degC := BaseUnit - 273.15;
    end to_degC;
end fmi_Functions;
initial equation
equation
  when initial() then
    fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn, fmi_resourceLocation);
  end when;
initial algorithm
  fmi_Functions.fmiSetReal(fmi, {16777216, 16777217, 16777218, 16777219, 16777220, 16777221, 16777222, 16777223, 16777224, 16777225, 16777226, 16777227, 16777228, 16777229, 16777230, 16777231, 16777232, 16777233, 16777234, 16777309, 16777310, 16777311, 16777312, 16777313, 16777314, 16777315, 16777316, 16777235, 16777236, 16777237, 16777238, 16777239, 16777240, 16777241, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 16777251, 16777252, 16777253, 16777254, 16777255, 16777256, 16777257, 16777258, 16777259, 16777260, 16777261, 16777262, 16777263, 16777264, 16777265, 16777266, 16777267, 16777268, 16777269, 16777270, 16777271, 16777272, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 16777282, 16777283, 16777284, 16777285, 16777286, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777293, 16777294, 16777295, 16777296, 16777297, 16777298, 16777299, 16777300, 16777301, 16777302, 16777303, 16777304, 16777305, 16777306, 16777336}, {k_hea, Ti_hea, maxSAT, uLowSta1, uUppSta1, uLowSta2, uUppSta2, kSta1, kSta2, banSta1, banSta2, rtuHP.inSou.'X[1]', rtuHP.inSou.'X[2]', rtuHP.inSou.m_flow, rtuHP.inSou.T, rtuHP.outSou.'X[1]', rtuHP.outSou.'X[2]', rtuHP.outSou.p, rtuHP.outSou.T, rtuHP.heaPum.TAmbEva_nominal, rtuHP.heaPum.TAmbCon_nominal, rtuHP.heaPum.TConCap_start, rtuHP.heaPum.TEvaCap_start, rtuHP.heaPum.'x_start[1]', rtuHP.heaPum.'x_start[2]', rtuHP.heaPum.'x_start[3]', rtuHP.heaPum.yRefIne_start, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.k1, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.k2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableQdot_con[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.mFlow_conNom, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.mFlow_evaNom, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableUppBou[2,2]', rtuHP.nSetGai.k});
  fmi_Functions.fmiSetReal(fmi, {16777337, 16777338, 16777339, 16777340, 16777341, 16777342, 16777343, 16777344, 16777345, 16777346, 16777347, 16777348, 16777349, 16777350, 16777352, 16777354, 16777355, 16777357, 16777358, 16777359, 16777360, 16777361, 16777362, 16777363, 16777364, 16777367, 16777369, 16777370}, {supFan.'X[1]', supFan.'X[2]', supFan.m_flow, supFan.T, roo.'X[1]', roo.'X[2]', roo.p, roo.T, rtuConFMU.conHea.Td, rtuConFMU.conHea.wp, rtuConFMU.conHea.wd, rtuConFMU.conHea.Ni, rtuConFMU.conHea.Nd, rtuConFMU.conHea.xd_start, rtuConFMU.conHea.P.k, rtuConFMU.offHea.k, rtuConFMU.onOffConSupHeatSetPoi.bandwidth, rtuConFMU.heatStage.realToBoolean1.threshold, rtuConFMU.heatStage.add.k1, rtuConFMU.heatStage.add.k2, rtuConFMU.heatStage.const7.k, rtuConFMU.heatStage.booleanToReal.realTrue, rtuConFMU.heatStage.booleanToReal.realFalse, rtuConFMU.heatStage.booleanToReal1.realTrue, rtuConFMU.heatStage.booleanToReal1.realFalse, rtuConFMU.onOffConHea.bandwidth, rtuConFMU.onDelay.delayTime, rtuConFMU.realToBoolean.threshold});
  fmi_Functions.fmiSetBoolean(fmi, {16777317, 16777307, 16777308, 16777335, 16777351, 16777356, 16777365, 16777366, 16777368}, {rtuHP.heaPum.linearized, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.verboseRead, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.verboseRead, rtuHP.heaOn.k, rtuConFMU.conHea.reverseActing, rtuConFMU.onOffConSupHeatSetPoi.pre_y_start, rtuConFMU.heatStage.onOffSta1.pre_y_start, rtuConFMU.heatStage.onOffSta2.pre_y_start, rtuConFMU.onOffConHea.pre_y_start});
    fmi_Functions.fmiSetReal(fmi, {352321536}, {_u_m_flow_start});
    fmi_Functions.fmiSetReal(fmi, {352321537}, {_u_TDryBul_start});
    fmi_Functions.fmiSetReal(fmi, {352321538}, {_u_TRoo_start});
    fmi_Functions.fmiSetReal(fmi, {352321539}, {_u_TRooSetPoi_start});
    fmi_Functions.fmiSetReal(fmi, {352321540}, {_u_TMix_start});
    fmi_Functions.fmiEnterSlaveInitializationMode(fmi, fmi_rTol, fmi_StartTime, fmi_forceShutDownAtStopTime, fmi_StopTime, 1);
  fmi_rdum := 1;
  fmi_idum := 1;
  myTimeStart :=time;
algorithm
assert(fmi_CommunicationStepSize > 0.0,"The parameter fmi_CommunicationStepSize has an invalid value, please set a positive value larger than 0.0");
  when {initial(), sample(fmi_StartTime, fmi_CommunicationStepSize)} then
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {352321536}, {_u_m_flow_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(fmi, {352321536}, {pre(u_m_flow)});
      else
        fmi_Functions.fmiSetReal(fmi, {352321536}, {u_m_flow});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {352321537}, {_u_TDryBul_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(fmi, {352321537}, {pre(u_TDryBul)});
      else
        fmi_Functions.fmiSetReal(fmi, {352321537}, {u_TDryBul});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {352321538}, {_u_TRoo_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(fmi, {352321538}, {pre(u_TRoo)});
      else
        fmi_Functions.fmiSetReal(fmi, {352321538}, {u_TRoo});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {352321539}, {_u_TRooSetPoi_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(fmi, {352321539}, {pre(u_TRooSetPoi)});
      else
        fmi_Functions.fmiSetReal(fmi, {352321539}, {u_TRooSetPoi});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {352321540}, {_u_TMix_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(fmi, {352321540}, {pre(u_TMix)});
      else
        fmi_Functions.fmiSetReal(fmi, {352321540}, {u_TMix});
      end if;
    end if;
      if fmi_rdum >= 0  and fmi_idum >= 0 and not fmi_exitInit and not initial() then
        fmi_Functions.fmiExitSlaveInitializationMode(fmi, 1);
        fmi_exitInit:=true;
RealFixedLocal1 :=fmi_Functions.fmiGetRealwf(
        fmi,
        {234881041,234881037,100663311,100663365,100663366,100663367,100663368,
          100663369,100663370,100663371,100663372,100663373,100663374,100663375,
          100663376,100663377,100663378,100663379,100663380,100663381,100663382,
          100663383,100663384,100663385,100663386,100663387,100663388,100663389,
          100663390,100663391,100663392,100663393,100663394,100663395,100663396,
          100663398,100663399,100663400,100663401,100663402,100663403,100663404,
          100663405,100663406,100663407,100663408,100663409,100663410,100663411,
          100663412,100663413,100663414,100663415,100663416,100663417,100663418,
          100663419,100663420,100663421,100663422,100663423,100663424,100663425,
          100663426,100663427,100663428,100663429,100663433,100663434,100663435,
          100663436,100663441,100663442,100663443,100663444,100663445,100663446,
          100663447,100663448,100663449,100663450,100663451,100663452,100663453,
          100663454,100663455,100663456,100663457,100663458,100663459,100663460,
          100663461,100663462,100663463,100663464,100663465,100663466,100663467,
          100663468,100663469},
        fmi_rdum);
RealFixedLocal2 :=fmi_Functions.fmiGetRealwf(
        fmi,
        {100663470,100663471,100663472,100663474,100663475,100663476,100663477,
          100663478,100663479,100663480,100663481,100663482,100663483,100663484,
          100663485,100663486,100663487,100663488,100663489,100663490,100663491,
          100663492,100663493,100663494,100663495,100663496,100663497,100663498,
          100663499,100663500,100663501,100663502,100663503,100663504,100663505,
          100663509,100663510,100663511,100663512,100663697,100663700,100663607,
          100663832,100663835,100663742,100663844,100663845,100663846,100663847,
          100663854,100663855,100663856,100663857,100663872,100663890,100663911,
          100663929,234881151,100663988,100663999,100664000,100664001,100664002,
          100664003,100664004,100664005,100664006,100664007,100664008,100664009,
          100664013,100664014,100664024,100664025,100664053,100664062,100664063,
          100664064,100664065,100664066,100664067,100664068,100664069,100664070,
          100664077,100664079,100664080,100664082},
        fmi_rdum);
      end if;
    if time>=fmi_CommunicationStepSize +fmi_StartTime then
      for stepSizeIndex in 1:stepSizeScaleFactor loop
        fmi_StepOK :=fmi_Functions.fmiDoStep(
          fmi,
          time + (stepSizeIndex - 1 - stepSizeScaleFactor)*
            fmi_CommunicationStepSize/stepSizeScaleFactor,
          fmi_CommunicationStepSize/stepSizeScaleFactor,
          1);
      end for;
      fmi_flip :=not pre(fmi_flip);
    end if;
    if not initial() then
      y_TSup_internal :=fmi_Functions.fmiGetRealScalar(fmi, 335544320);
      y_PEleHP_internal :=fmi_Functions.fmiGetRealScalar(fmi, 335544321);
      y_HeaCal_internal :=fmi_Functions.fmiGetBooleanScalar(fmi, 335544322);
    end if;
RealVariables :=fmi_Functions.fmiGetReal(fmi, {436207617,369099428,33554446,
      905970074,637534212,234881035,234881039,436207616,637534885,637534886,
      905969939,637534236,637534237,637534256,637534257,369099425,33554442,
      33554445,33554443,33554444,637534258,637534260,369098806,637534265,
      369098816,369098817,637534274,369098894,369098970,637534268,33554441,
      905969976,33554432,100663649,33554433,587202560,587202561,637534889,
      234881145,33554438,905970111,33554434,100663784,33554435,587202562,
      587202563,33554436,587202564,33554437,587202565,587202566,33554439,
      587202567,33554440,587202568,587202569,587202570,587202571,587202572,
      234881149,587202573,587202574,436207620,436207619,436207618,369099466,
      905970379,369099479,369099482,33554447,369099487,637534954,587202575,
      369099514,369099515,234881162,369099516,369099528,369099529,369099530,
      234881168,369099539});
BooleanVariables :=fmi_Functions.fmiGetBoolean(fmi, {234881143,905970338,
      369099517,369099527,369099531,369099532,369099534,369099537,369099540,
      369099541,369099542,369099543});
  end when;
  when {pre(fmi_flip), not pre(fmi_flip)} then
    _u_m_flow_old := pre(u_m_flow);
    _u_TDryBul_old := pre(u_TDryBul);
    _u_TRoo_old := pre(u_TRoo);
    _u_TRooSetPoi_old := pre(u_TRooSetPoi);
    _u_TMix_old := pre(u_TMix);
  end when;
equation
  if initial() then
    y_TSup = fmi_Functions.GetRealVariable(fmi,myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544320});
  else
    y_TSup = y_TSup_internal;
  end if;
  if initial() then
    y_PEleHP = fmi_Functions.GetRealVariable(fmi,myTimeStart, {maxSAT, kSta1, kSta2, banSta1, banSta2, rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[1,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[2,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[3,8]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,1]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,2]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,3]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,4]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,5]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,6]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,7]', rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.dataTable.'tableP_ele[4,8]', rtuHP.nSetGai.k, rtuConFMU.offHea.k, rtuConFMU.onOffConSupHeatSetPoi.bandwidth, rtuConFMU.heatStage.realToBoolean1.threshold, rtuConFMU.heatStage.add.k1, rtuConFMU.heatStage.add.k2, rtuConFMU.heatStage.const7.k, rtuConFMU.heatStage.booleanToReal.realTrue, rtuConFMU.heatStage.booleanToReal.realFalse, rtuConFMU.heatStage.booleanToReal1.realTrue, rtuConFMU.heatStage.booleanToReal1.realFalse, rtuConFMU.onOffConHea.bandwidth, rtuConFMU.realToBoolean.threshold, u_TRoo, u_TRooSetPoi}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.verboseRead, rtuHP.heaOn.k, rtuConFMU.onOffConSupHeatSetPoi.pre_y_start, rtuConFMU.heatStage.onOffSta1.pre_y_start, rtuConFMU.heatStage.onOffSta2.pre_y_start, rtuConFMU.onOffConHea.pre_y_start}, fill(0,0), {16777218, 16777223, 16777224, 16777225, 16777226, 16777269, 16777270, 16777271, 16777272, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 16777282, 16777283, 16777284, 16777285, 16777286, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777293, 16777294, 16777295, 16777296, 16777297, 16777298, 16777299, 16777300, 16777336, 16777354, 16777355, 16777357, 16777358, 16777359, 16777360, 16777361, 16777362, 16777363, 16777364, 16777367, 16777370, 352321538, 352321539}, fill(0,0), fill(0,0), {16777308, 16777335, 16777356, 16777365, 16777366, 16777368}, fill(0,0), {335544321});
  else
    y_PEleHP = y_PEleHP_internal;
  end if;
algorithm
  if initial() then
    fmi_Functions.fmiSetReal(fmi, {16777367, 352321538, 352321539}, {rtuConFMU.onOffConHea.bandwidth, u_TRoo, u_TRooSetPoi});
    fmi_Functions.fmiSetBoolean(fmi, {16777368}, {rtuConFMU.onOffConHea.pre_y_start});
    y_HeaCal := fmi_Functions.fmiGetBooleanScalar(fmi, 335544322);
  else
    y_HeaCal :=y_HeaCal_internal;
  end if;
equation
  rtuHP.TEvaIn = RealVariables[1];
  rtuHP.sta = RealVariables[2];
  rtuHP.TSup = RealVariables[3];
  rtuHP.inSou.'ports[1]'.m_flow = RealVariables[4];
  rtuHP.inSou.'ports[1]'.h_outflow = RealVariables[5];
  rtuHP.inSou.'ports[1]'.'Xi_outflow[1]' = RealVariables[6];
  rtuHP.outSou.'ports[1]'.'Xi_outflow[1]' = RealVariables[7];
  rtuHP.heaPum.m1_flow = RealVariables[8];
  rtuHP.heaPum.port_a1.h_outflow = RealVariables[9];
  rtuHP.heaPum.port_a1.'Xi_outflow[1]' = RealVariables[10];
  rtuHP.heaPum.port_b1.m_flow = RealVariables[11];
  rtuHP.heaPum.port_a2.h_outflow = RealVariables[12];
  rtuHP.heaPum.port_a2.'Xi_outflow[1]' = RealVariables[13];
  rtuHP.heaPum.innerCycle.QCon = RealVariables[14];
  rtuHP.heaPum.innerCycle.QEva = RealVariables[15];
  rtuHP.heaPum.innerCycle.sigBus.nSet = RealVariables[16];
  rtuHP.heaPum.innerCycle.sigBus.TEvaInMea = RealVariables[17];
  rtuHP.heaPum.innerCycle.sigBus.TConInMea = RealVariables[18];
  rtuHP.heaPum.innerCycle.sigBus.TEvaOutMea = RealVariables[19];
  rtuHP.heaPum.innerCycle.sigBus.TConOutMea = RealVariables[20];
  rtuHP.heaPum.innerCycle.switchQEva.u1 = RealVariables[21];
  rtuHP.heaPum.innerCycle.switchQCon.u1 = RealVariables[22];
  rtuHP.heaPum.innerCycle.switchPel.u1 = RealVariables[23];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QEva = RealVariables[24];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1 = RealVariables[25];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2 = RealVariables[26];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.y = RealVariables[27];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.y = RealVariables[28];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u1 = RealVariables[29];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesQCon.y = RealVariables[30];
  rtuHP.heaPum.con.QFlow_in = RealVariables[31];
  rtuHP.heaPum.con.vol.T = RealVariables[32];
  rtuHP.heaPum.con.vol.U = RealVariables[33];
  rtuHP.heaPum.con.vol.m = RealVariables[34];
  rtuHP.heaPum.con.vol.'mXi[1]' = RealVariables[35];
  rtuHP.heaPum.con.vol.dynBal._U_der = RealVariables[36];
  rtuHP.heaPum.con.vol.dynBal.'_mXi[1]_der' = RealVariables[37];
  rtuHP.heaPum.con.preDro.port_b.h_outflow = RealVariables[38];
  rtuHP.heaPum.con.preDro.port_b.'Xi_outflow[1]' = RealVariables[39];
  rtuHP.heaPum.eva.QFlow_in = RealVariables[40];
  rtuHP.heaPum.eva.vol.T = RealVariables[41];
  rtuHP.heaPum.eva.vol.U = RealVariables[42];
  rtuHP.heaPum.eva.vol.m = RealVariables[43];
  rtuHP.heaPum.eva.vol.'mXi[1]' = RealVariables[44];
  rtuHP.heaPum.eva.vol.dynBal._U_der = RealVariables[45];
  rtuHP.heaPum.eva.vol.dynBal.'_mXi[1]_der' = RealVariables[46];
  rtuHP.heaPum.heatFlowIneEva.'x[1]' = RealVariables[47];
  rtuHP.heaPum.heatFlowIneEva.'_x[1]_der' = RealVariables[48];
  rtuHP.heaPum.heatFlowIneEva.'x[2]' = RealVariables[49];
  rtuHP.heaPum.heatFlowIneEva.'_x[2]_der' = RealVariables[50];
  rtuHP.heaPum.heatFlowIneEva.'_x[3]_der' = RealVariables[51];
  rtuHP.heaPum.heatFlowIneCon.'x[1]' = RealVariables[52];
  rtuHP.heaPum.heatFlowIneCon.'_x[1]_der' = RealVariables[53];
  rtuHP.heaPum.heatFlowIneCon.'x[2]' = RealVariables[54];
  rtuHP.heaPum.heatFlowIneCon.'_x[2]_der' = RealVariables[55];
  rtuHP.heaPum.heatFlowIneCon.'_x[3]_der' = RealVariables[56];
  rtuHP.heaPum.senT_a2._T_der = RealVariables[57];
  rtuHP.heaPum.senT_b2._T_der = RealVariables[58];
  rtuHP.heaPum.senT_b1._T_der = RealVariables[59];
  rtuHP.heaPum.senT_b1.port_a.'Xi_outflow[1]' = RealVariables[60];
  rtuHP.heaPum.senT_a1._T_der = RealVariables[61];
  rtuHP.senTAct._T_der = RealVariables[62];
  supFan.T_in = RealVariables[63];
  rtuConFMU.TSetRooHea = RealVariables[64];
  rtuConFMU.TRoo = RealVariables[65];
  rtuConFMU.conHea.y = RealVariables[66];
  rtuConFMU.conHea.controlError = RealVariables[67];
  rtuConFMU.conHea.addP.y = RealVariables[68];
  rtuConFMU.conHea.P.y = RealVariables[69];
  rtuConFMU.conHea.addPID.u3 = RealVariables[70];
  rtuConFMU.conHea.addPID.y = RealVariables[71];
  rtuConFMU.conHea.I.u = RealVariables[72];
  rtuConFMU.conHea.I._y_der = RealVariables[73];
  rtuConFMU.conHea.I.y_reset_in = RealVariables[74];
  rtuConFMU.swiHea.u1 = RealVariables[75];
  rtuConFMU.swiHea.u3 = RealVariables[76];
  rtuConFMU.swiHea.y = RealVariables[77];
  rtuConFMU.heatStage.add.u1 = RealVariables[78];
  rtuConFMU.heatStage.add.u2 = RealVariables[79];
  rtuConFMU.heatStage.add.y = RealVariables[80];
  rtuConFMU.heatStage.switch4.u3 = RealVariables[81];
  rtuConFMU.swiTim.u1 = RealVariables[82];
  rtuHP.inSou.'ports[1]'.p = RealFixedLocal1[1];
  rtuHP.outSou.'ports[1]'.m_flow = RealFixedLocal1[2];
  rtuHP.outSou.'ports[1]'.h_outflow = RealFixedLocal1[3];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,1]' = RealFixedLocal1[4];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,2]' = RealFixedLocal1[5];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,3]' = RealFixedLocal1[6];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,4]' = RealFixedLocal1[7];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,5]' = RealFixedLocal1[8];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,6]' = RealFixedLocal1[9];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,7]' = RealFixedLocal1[10];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[1,8]' = RealFixedLocal1[11];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,1]' = RealFixedLocal1[12];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,2]' = RealFixedLocal1[13];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,3]' = RealFixedLocal1[14];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,4]' = RealFixedLocal1[15];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,5]' = RealFixedLocal1[16];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,6]' = RealFixedLocal1[17];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,7]' = RealFixedLocal1[18];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[2,8]' = RealFixedLocal1[19];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,1]' = RealFixedLocal1[20];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,2]' = RealFixedLocal1[21];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,3]' = RealFixedLocal1[22];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,4]' = RealFixedLocal1[23];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,5]' = RealFixedLocal1[24];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,6]' = RealFixedLocal1[25];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,7]' = RealFixedLocal1[26];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[3,8]' = RealFixedLocal1[27];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,1]' = RealFixedLocal1[28];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,2]' = RealFixedLocal1[29];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,3]' = RealFixedLocal1[30];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,4]' = RealFixedLocal1[31];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,5]' = RealFixedLocal1[32];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,6]' = RealFixedLocal1[33];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,7]' = RealFixedLocal1[34];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.'table[4,8]' = RealFixedLocal1[35];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,1]' = RealFixedLocal1[36];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,2]' = RealFixedLocal1[37];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,3]' = RealFixedLocal1[38];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,4]' = RealFixedLocal1[39];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,5]' = RealFixedLocal1[40];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,6]' = RealFixedLocal1[41];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,7]' = RealFixedLocal1[42];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[1,8]' = RealFixedLocal1[43];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,1]' = RealFixedLocal1[44];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,2]' = RealFixedLocal1[45];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,3]' = RealFixedLocal1[46];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,4]' = RealFixedLocal1[47];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,5]' = RealFixedLocal1[48];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,6]' = RealFixedLocal1[49];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,7]' = RealFixedLocal1[50];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[2,8]' = RealFixedLocal1[51];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,1]' = RealFixedLocal1[52];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,2]' = RealFixedLocal1[53];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,3]' = RealFixedLocal1[54];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,4]' = RealFixedLocal1[55];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,5]' = RealFixedLocal1[56];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,6]' = RealFixedLocal1[57];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,7]' = RealFixedLocal1[58];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[3,8]' = RealFixedLocal1[59];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,1]' = RealFixedLocal1[60];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,2]' = RealFixedLocal1[61];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,3]' = RealFixedLocal1[62];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,4]' = RealFixedLocal1[63];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,5]' = RealFixedLocal1[64];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,6]' = RealFixedLocal1[65];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,7]' = RealFixedLocal1[66];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'table[4,8]' = RealFixedLocal1[67];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_min[1]' = RealFixedLocal1[68];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_min[2]' = RealFixedLocal1[69];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_max[1]' = RealFixedLocal1[70];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.'u_max[2]' = RealFixedLocal1[71];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,1]' = RealFixedLocal1[72];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,2]' = RealFixedLocal1[73];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,3]' = RealFixedLocal1[74];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,4]' = RealFixedLocal1[75];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,5]' = RealFixedLocal1[76];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,6]' = RealFixedLocal1[77];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,7]' = RealFixedLocal1[78];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[1,8]' = RealFixedLocal1[79];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,1]' = RealFixedLocal1[80];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,2]' = RealFixedLocal1[81];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,3]' = RealFixedLocal1[82];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,4]' = RealFixedLocal1[83];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,5]' = RealFixedLocal1[84];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,6]' = RealFixedLocal1[85];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,7]' = RealFixedLocal1[86];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[2,8]' = RealFixedLocal1[87];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,1]' = RealFixedLocal1[88];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,2]' = RealFixedLocal1[89];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,3]' = RealFixedLocal1[90];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,4]' = RealFixedLocal1[91];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,5]' = RealFixedLocal1[92];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,6]' = RealFixedLocal1[93];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,7]' = RealFixedLocal1[94];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[3,8]' = RealFixedLocal1[95];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,1]' = RealFixedLocal1[96];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,2]' = RealFixedLocal1[97];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,3]' = RealFixedLocal1[98];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,4]' = RealFixedLocal1[99];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,5]' = RealFixedLocal1[100];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,6]' = RealFixedLocal2[1];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,7]' = RealFixedLocal2[2];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.'table[4,8]' = RealFixedLocal2[3];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,1]' = RealFixedLocal2[4];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,2]' = RealFixedLocal2[5];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,3]' = RealFixedLocal2[6];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,4]' = RealFixedLocal2[7];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,5]' = RealFixedLocal2[8];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,6]' = RealFixedLocal2[9];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,7]' = RealFixedLocal2[10];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[1,8]' = RealFixedLocal2[11];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,1]' = RealFixedLocal2[12];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,2]' = RealFixedLocal2[13];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,3]' = RealFixedLocal2[14];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,4]' = RealFixedLocal2[15];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,5]' = RealFixedLocal2[16];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,6]' = RealFixedLocal2[17];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,7]' = RealFixedLocal2[18];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[2,8]' = RealFixedLocal2[19];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,1]' = RealFixedLocal2[20];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,2]' = RealFixedLocal2[21];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,3]' = RealFixedLocal2[22];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,4]' = RealFixedLocal2[23];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,5]' = RealFixedLocal2[24];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,6]' = RealFixedLocal2[25];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,7]' = RealFixedLocal2[26];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[3,8]' = RealFixedLocal2[27];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,1]' = RealFixedLocal2[28];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,2]' = RealFixedLocal2[29];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,3]' = RealFixedLocal2[30];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,4]' = RealFixedLocal2[31];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,5]' = RealFixedLocal2[32];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,6]' = RealFixedLocal2[33];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,7]' = RealFixedLocal2[34];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'table[4,8]' = RealFixedLocal2[35];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_min[1]' = RealFixedLocal2[36];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_min[2]' = RealFixedLocal2[37];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_max[1]' = RealFixedLocal2[38];
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.'u_max[2]' = RealFixedLocal2[39];
  rtuHP.heaPum.con.V = RealFixedLocal2[40];
  rtuHP.heaPum.con.TCap_start = RealFixedLocal2[41];
  rtuHP.heaPum.con.vol.V = RealFixedLocal2[42];
  rtuHP.heaPum.eva.V = RealFixedLocal2[43];
  rtuHP.heaPum.eva.TCap_start = RealFixedLocal2[44];
  rtuHP.heaPum.eva.vol.V = RealFixedLocal2[45];
  rtuHP.heaPum.heatFlowIneEva.'x_start[1]' = RealFixedLocal2[46];
  rtuHP.heaPum.heatFlowIneEva.'x_start[2]' = RealFixedLocal2[47];
  rtuHP.heaPum.heatFlowIneEva.'x_start[3]' = RealFixedLocal2[48];
  rtuHP.heaPum.heatFlowIneEva.y_start = RealFixedLocal2[49];
  rtuHP.heaPum.heatFlowIneCon.'x_start[1]' = RealFixedLocal2[50];
  rtuHP.heaPum.heatFlowIneCon.'x_start[2]' = RealFixedLocal2[51];
  rtuHP.heaPum.heatFlowIneCon.'x_start[3]' = RealFixedLocal2[52];
  rtuHP.heaPum.heatFlowIneCon.y_start = RealFixedLocal2[53];
  rtuHP.heaPum.senT_a2.TAmb = RealFixedLocal2[54];
  rtuHP.heaPum.senT_b2.TAmb = RealFixedLocal2[55];
  rtuHP.heaPum.senT_b1.TAmb = RealFixedLocal2[56];
  rtuHP.heaPum.senT_a1.TAmb = RealFixedLocal2[57];
  rtuHP.port_a.p = RealFixedLocal2[58];
  roo.'ports[1]'.h_outflow = RealFixedLocal2[59];
  rtuConFMU.k_hea = RealFixedLocal2[60];
  rtuConFMU.Ti_hea = RealFixedLocal2[61];
  rtuConFMU.maxSAT = RealFixedLocal2[62];
  rtuConFMU.uLowSta1 = RealFixedLocal2[63];
  rtuConFMU.uUppSta1 = RealFixedLocal2[64];
  rtuConFMU.uLowSta2 = RealFixedLocal2[65];
  rtuConFMU.uUppSta2 = RealFixedLocal2[66];
  rtuConFMU.kSta1 = RealFixedLocal2[67];
  rtuConFMU.kSta2 = RealFixedLocal2[68];
  rtuConFMU.banSta1 = RealFixedLocal2[69];
  rtuConFMU.banSta2 = RealFixedLocal2[70];
  rtuConFMU.conHea.k = RealFixedLocal2[71];
  rtuConFMU.conHea.Ti = RealFixedLocal2[72];
  rtuConFMU.conHea.addP.k1 = RealFixedLocal2[73];
  rtuConFMU.conHea.addP.k2 = RealFixedLocal2[74];
  rtuConFMU.conHea.I.k = RealFixedLocal2[75];
  rtuConFMU.UpperLimSup.k = RealFixedLocal2[76];
  rtuConFMU.heatStage.uLowSta1 = RealFixedLocal2[77];
  rtuConFMU.heatStage.uUppSta1 = RealFixedLocal2[78];
  rtuConFMU.heatStage.uLowSta2 = RealFixedLocal2[79];
  rtuConFMU.heatStage.uUppSta2 = RealFixedLocal2[80];
  rtuConFMU.heatStage.kSta1 = RealFixedLocal2[81];
  rtuConFMU.heatStage.kSta2 = RealFixedLocal2[82];
  rtuConFMU.heatStage.banSta1 = RealFixedLocal2[83];
  rtuConFMU.heatStage.banSta2 = RealFixedLocal2[84];
  rtuConFMU.heatStage.const1.k = RealFixedLocal2[85];
  rtuConFMU.heatStage.onOffSta1.bandwidth = RealFixedLocal2[86];
  rtuConFMU.heatStage.const2.k = RealFixedLocal2[87];
  rtuConFMU.heatStage.onOffSta2.bandwidth = RealFixedLocal2[88];
  rtuHP.heaPum.innerCycle.sigBus.modeSet = BooleanVariables[1];
  rtuHP.heaPum.innerCycle.sigBus.onOffMea = BooleanVariables[2];
  rtuConFMU.onOffConSupHeatSetPoi.y = BooleanVariables[3];
  rtuConFMU.heatStage.realToBoolean1.y = BooleanVariables[4];
  rtuConFMU.heatStage.booleanToReal.u = BooleanVariables[5];
  rtuConFMU.heatStage.booleanToReal1.u = BooleanVariables[6];
  rtuConFMU.heatStage.onOffSta1.y = BooleanVariables[7];
  rtuConFMU.heatStage.onOffSta2.y = BooleanVariables[8];
  rtuConFMU.swiTim.u2 = BooleanVariables[9];
  rtuConFMU.onOffConHea.y = BooleanVariables[10];
  rtuConFMU.UppLimSwi.u2 = BooleanVariables[11];
  rtuConFMU.onDelay.u = BooleanVariables[12];
//alias Declarations
  rtuHP.heaPum.senT_b2.port_a.h_outflow = rtuHP.outSou.'ports[1]'.h_outflow;
  rtuHP.heaPum.senT_b1.port_a.h_outflow = roo.'ports[1]'.h_outflow;
  rtuHP.senTAct.port_a.h_outflow = roo.'ports[1]'.h_outflow;
  rtuConFMU.onOffConSupHeatSetPoi.reference = rtuConFMU.UpperLimSup.k;
  rtuConFMU.UpperLimSup.y = rtuConFMU.UpperLimSup.k;
  rtuConFMU.heatStage.const1.y = rtuConFMU.heatStage.const1.k;
  rtuConFMU.heatStage.onOffSta1.reference = rtuConFMU.heatStage.const1.k;
  rtuConFMU.heatStage.const2.y = rtuConFMU.heatStage.const2.k;
  rtuConFMU.heatStage.onOffSta2.reference = rtuConFMU.heatStage.const2.k;
  rtuHP.heaPum.eva.preDro.port_b.'Xi_outflow[1]' = rtuHP.inSou.'ports[1]'.'Xi_outflow[1]';
  rtuHP.heaPum.senT_a2.port_b.'Xi_outflow[1]' = rtuHP.inSou.'ports[1]'.'Xi_outflow[1]';
  rtuHP.heaPum.mFlow_eva.port_b.'Xi_outflow[1]' = rtuHP.inSou.'ports[1]'.'Xi_outflow[1]';
  rtuHP.heaPum.m2_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.port_a2.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.innerCycle.sigBus.m_flowEvaMea = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.m_flowEvaMea = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.vol.'ports[1]'.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.preDro.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.preDro.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.sigBus.m_flowEvaMea = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_a2.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_b2.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.mFlow_eva.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.mFlow_eva.port_a.m_flow = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.sigBus1.m_flowEvaMea = rtuHP.outSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_b2.port_a.'Xi_outflow[1]' = rtuHP.outSou.'ports[1]'.'Xi_outflow[1]';
  rtuHP.outSou.'ports[1]'.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.port_a2.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.port_b2.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.vol.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.vol.'ports[1]'.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.vol.'ports[2]'.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.preDro.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.eva.preDro.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_a2.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_a2.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_b2.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_b2.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.mFlow_eva.port_a.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.mFlow_eva.port_b.p = rtuHP.inSou.'ports[1]'.p;
  rtuHP.heaPum.senT_a1.port_b.'Xi_outflow[1]' = rtuHP.heaPum.con.preDro.port_b.'Xi_outflow[1]';
  rtuHP.heaPum.mFlow_con.port_b.'Xi_outflow[1]' = rtuHP.heaPum.con.preDro.port_b.'Xi_outflow[1]';
  supFan.'ports[1]'.'Xi_outflow[1]' = rtuHP.heaPum.con.preDro.port_b.'Xi_outflow[1]';
  rtuHP.senTAct.port_a.'Xi_outflow[1]' = rtuHP.heaPum.senT_b1.port_a.'Xi_outflow[1]';
  roo.'ports[1]'.'Xi_outflow[1]' = rtuHP.heaPum.senT_b1.port_a.'Xi_outflow[1]';
  rtuHP.heaPum.port_a1.p = rtuHP.port_a.p;
  rtuHP.heaPum.port_b1.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.port_b.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.vol.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.vol.'ports[1]'.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.vol.'ports[2]'.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.preDro.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.con.preDro.port_b.p = rtuHP.port_a.p;
  rtuHP.heaPum.senT_b1.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.senT_b1.port_b.p = rtuHP.port_a.p;
  rtuHP.heaPum.senT_a1.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.senT_a1.port_b.p = rtuHP.port_a.p;
  rtuHP.heaPum.mFlow_con.port_a.p = rtuHP.port_a.p;
  rtuHP.heaPum.mFlow_con.port_b.p = rtuHP.port_a.p;
  rtuHP.senTAct.port_a.p = rtuHP.port_a.p;
  rtuHP.senTAct.port_b.p = rtuHP.port_a.p;
  rtuHP.port_b.p = rtuHP.port_a.p;
  supFan.'ports[1]'.p = rtuHP.port_a.p;
  roo.'ports[1]'.p = rtuHP.port_a.p;
  rtuConFMU.offHea.y = rtuConFMU.swiHea.u3;
  rtuConFMU.swiTim.u3 = rtuConFMU.swiHea.u3;
  rtuConFMU.UppLimSwi.u1 = rtuConFMU.swiHea.u3;
  rtuConFMU.heatStage.const7.y = rtuConFMU.heatStage.switch4.u3;
  rtuHP.heaPum.con.vol.dynBal.U = rtuHP.heaPum.con.vol.U;
  rtuHP.PEle = y_PEleHP;
  rtuHP.heaPum.innerCycle.Pel = y_PEleHP;
  rtuHP.heaPum.innerCycle.sigBus.PelMea = y_PEleHP;
  rtuHP.heaPum.innerCycle.switchPel.y = y_PEleHP;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.PelMea = y_PEleHP;
  rtuHP.heaPum.sigBus.PelMea = y_PEleHP;
  rtuHP.sigBus1.PelMea = y_PEleHP;
  rtuHP.heaPum.con.vol.dynBal.'mXi[1]' = rtuHP.heaPum.con.vol.'mXi[1]';
  rtuHP.heaPum.eva.vol.dynBal.U = rtuHP.heaPum.eva.vol.U;
  rtuHP.heaPum.eva.vol.dynBal.'mXi[1]' = rtuHP.heaPum.eva.vol.'mXi[1]';
  rtuHP.heaPum.eva.vol.heatPort.Q_flow = rtuHP.heaPum.eva.QFlow_in;
  rtuHP.heaPum.eva.preHea.Q_flow = rtuHP.heaPum.eva.QFlow_in;
  rtuHP.heaPum.heatFlowIneEva.y = rtuHP.heaPum.eva.QFlow_in;
  rtuHP.heaPum.heatFlowIneEva.'x[3]' = rtuHP.heaPum.eva.QFlow_in;
  rtuHP.heaPum.con.vol.heatPort.Q_flow = rtuHP.heaPum.con.QFlow_in;
  rtuHP.heaPum.con.preHea.Q_flow = rtuHP.heaPum.con.QFlow_in;
  rtuHP.heaPum.heatFlowIneCon.y = rtuHP.heaPum.con.QFlow_in;
  rtuHP.heaPum.heatFlowIneCon.'x[3]' = rtuHP.heaPum.con.QFlow_in;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TEvaInMea = rtuHP.heaPum.innerCycle.sigBus.TEvaInMea;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.t_Ev_in.u = rtuHP.heaPum.innerCycle.sigBus.TEvaInMea;
  rtuHP.heaPum.sigBus.TEvaInMea = rtuHP.heaPum.innerCycle.sigBus.TEvaInMea;
  rtuHP.heaPum.senT_a2.T = rtuHP.heaPum.innerCycle.sigBus.TEvaInMea;
  rtuHP.sigBus1.TEvaInMea = rtuHP.heaPum.innerCycle.sigBus.TEvaInMea;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TEvaOutMea = rtuHP.heaPum.innerCycle.sigBus.TEvaOutMea;
  rtuHP.heaPum.sigBus.TEvaOutMea = rtuHP.heaPum.innerCycle.sigBus.TEvaOutMea;
  rtuHP.heaPum.senT_b2.T = rtuHP.heaPum.innerCycle.sigBus.TEvaOutMea;
  rtuHP.sigBus1.TEvaOutMea = rtuHP.heaPum.innerCycle.sigBus.TEvaOutMea;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TConOutMea = rtuHP.heaPum.innerCycle.sigBus.TConOutMea;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.t_Co_ou.u = rtuHP.heaPum.innerCycle.sigBus.TConOutMea;
  rtuHP.heaPum.sigBus.TConOutMea = rtuHP.heaPum.innerCycle.sigBus.TConOutMea;
  rtuHP.heaPum.senT_b1.T = rtuHP.heaPum.innerCycle.sigBus.TConOutMea;
  rtuHP.sigBus1.TConOutMea = rtuHP.heaPum.innerCycle.sigBus.TConOutMea;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.TConInMea = rtuHP.heaPum.innerCycle.sigBus.TConInMea;
  rtuHP.heaPum.sigBus.TConInMea = rtuHP.heaPum.innerCycle.sigBus.TConInMea;
  rtuHP.heaPum.senT_a1.T = rtuHP.heaPum.innerCycle.sigBus.TConInMea;
  rtuHP.sigBus1.TConInMea = rtuHP.heaPum.innerCycle.sigBus.TConInMea;
  rtuHP.senTAct.T = rtuHP.TSup;
  rtuConFMU.TSup = rtuHP.TSup;
  rtuConFMU.onOffConSupHeatSetPoi.u = rtuHP.TSup;
  rtuConFMU.conHea.I.y = rtuConFMU.conHea.addPID.u3;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Pel = rtuHP.heaPum.innerCycle.switchPel.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u2 = rtuHP.heaPum.innerCycle.switchPel.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.y = rtuHP.heaPum.innerCycle.switchPel.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u1 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough1.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough1.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.u1 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.u1 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough1.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough1.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.t_Co_ou.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough2.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.realPassThrough2.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough2.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.realPassThrough2.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.t_Ev_in.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.u2;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.combiTable2D.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.y;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.P_eleTable.y;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesQCon.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesSF.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesPel.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.nSet = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesSF.u1 = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.heaPum.sigBus.nSet = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.heaPum.greaterThreshold.u = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.nSetGai.y = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.sigBus1.nSet = rtuHP.heaPum.innerCycle.sigBus.nSet;
  rtuHP.nSetGai.u = rtuHP.sta;
  rtuConFMU.heaSta = rtuHP.sta;
  rtuConFMU.swiTim.y = rtuHP.sta;
  rtuConFMU.heatStage.uHea = rtuConFMU.conHea.y;
  rtuConFMU.heatStage.realToBoolean1.u = rtuConFMU.conHea.y;
  rtuConFMU.heatStage.onOffSta1.u = rtuConFMU.conHea.y;
  rtuConFMU.heatStage.onOffSta2.u = rtuConFMU.conHea.y;
  rtuConFMU.conHea.P.u = rtuConFMU.conHea.addP.y;
  rtuConFMU.conHea.addPID.u1 = rtuConFMU.conHea.P.y;
  rtuConFMU.heatStage.y_Sta = rtuConFMU.swiHea.u1;
  rtuConFMU.heatStage.switch4.y = rtuConFMU.swiHea.u1;
  rtuConFMU.UppLimSwi.u3 = rtuConFMU.swiHea.y;
  rtuConFMU.heatStage.booleanToReal1.y = rtuConFMU.heatStage.add.u1;
  rtuConFMU.heatStage.booleanToReal.y = rtuConFMU.heatStage.add.u2;
  rtuConFMU.heatStage.switch4.u1 = rtuConFMU.heatStage.add.y;
  rtuConFMU.UppLimSwi.y = rtuConFMU.swiTim.u1;
  rtuConFMU.realToBoolean.u = rtuConFMU.swiTim.u1;
  rtuHP.heaPum.port_a1.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.innerCycle.sigBus.m_flowConMea = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.m_flowConMea = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.vol.'ports[1]'.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.preDro.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.con.preDro.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.sigBus.m_flowConMea = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.senT_b1.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.senT_a1.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.mFlow_con.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.heaPum.mFlow_con.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.senTAct.port_a.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.sigBus1.m_flowConMea = rtuHP.heaPum.m1_flow;
  rtuHP.port_a.m_flow = rtuHP.heaPum.m1_flow;
  supFan.m_flow_in = rtuHP.heaPum.m1_flow;
  roo.'ports[1]'.m_flow = rtuHP.heaPum.m1_flow;
  rtuHP.inSou.T_in = rtuHP.TEvaIn;
  rtuConFMU.conHea.u_m = rtuConFMU.TRoo;
  rtuConFMU.conHea.addP.u2 = rtuConFMU.TRoo;
  rtuConFMU.onOffConHea.u = rtuConFMU.TRoo;
  rtuConFMU.conHea.u_s = rtuConFMU.TSetRooHea;
  rtuConFMU.conHea.addP.u1 = rtuConFMU.TSetRooHea;
  rtuConFMU.onOffConHea.reference = rtuConFMU.TSetRooHea;
  rtuHP.heaPum.eva.preDro.port_b.h_outflow = rtuHP.inSou.'ports[1]'.h_outflow;
  rtuHP.heaPum.senT_a2.port_b.h_outflow = rtuHP.inSou.'ports[1]'.h_outflow;
  rtuHP.heaPum.mFlow_eva.port_b.h_outflow = rtuHP.inSou.'ports[1]'.h_outflow;
  rtuHP.heaPum.port_b2.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.port_a.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.port_b.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.vol.'ports[1]'.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.vol.'ports[2]'.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.eva.preDro.port_a.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.senT_a2.port_a.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.senT_b2.port_b.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.mFlow_eva.port_a.h_outflow = rtuHP.heaPum.port_a2.h_outflow;
  rtuHP.heaPum.port_b2.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.vol.'Xi[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.vol.'ports[1]'.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.vol.'ports[2]'.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.eva.preDro.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.senT_a2.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.senT_b2.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.mFlow_eva.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a2.'Xi_outflow[1]';
  rtuHP.heaPum.innerCycle.switchQCon.y = rtuHP.heaPum.innerCycle.QCon;
  rtuHP.heaPum.heatFlowIneCon.u = rtuHP.heaPum.innerCycle.QCon;
  rtuHP.heaPum.innerCycle.switchQEva.y = rtuHP.heaPum.innerCycle.QEva;
  rtuHP.heaPum.heatFlowIneEva.u = rtuHP.heaPum.innerCycle.QEva;
  rtuHP.heaPum.innerCycle.gainEva.y = rtuHP.heaPum.innerCycle.switchQEva.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QCon = rtuHP.heaPum.innerCycle.switchQCon.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.y = rtuHP.heaPum.innerCycle.switchQCon.u1;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.calcRedQCon.u1 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QEva;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.proRedQEva.u2 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QEva;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.proRedQEva.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QEva;
  rtuHP.heaPum.innerCycle.gainEva.u = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.QEva;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.combiTable2D.y = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.y;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.nTimesQCon.u1 = rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.Qdot_ConTable.y;
  rtuHP.heaPum.port_b1.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.port_b.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.vol.'ports[1]'.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.vol.'ports[2]'.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.con.preDro.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.senT_b1.port_b.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.senT_a1.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.mFlow_con.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.senTAct.port_b.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.port_a.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.port_b.h_outflow = rtuHP.heaPum.port_a1.h_outflow;
  rtuHP.heaPum.port_b1.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.vol.'Xi[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.vol.'ports[1]'.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.vol.'ports[2]'.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.con.preDro.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.senT_b1.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.senT_a1.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.mFlow_con.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.senTAct.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.port_a.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.port_b.'Xi_outflow[1]' = rtuHP.heaPum.port_a1.'Xi_outflow[1]';
  rtuHP.heaPum.senT_a1.port_b.h_outflow = rtuHP.heaPum.con.preDro.port_b.h_outflow;
  rtuHP.heaPum.mFlow_con.port_b.h_outflow = rtuHP.heaPum.con.preDro.port_b.h_outflow;
  supFan.'ports[1]'.h_outflow = rtuHP.heaPum.con.preDro.port_b.h_outflow;
  rtuHP.heaPum.con.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.con.vol.'ports[2]'.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.con.preDro.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.senT_b1.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.senT_a1.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.mFlow_con.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.senTAct.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.port_b.m_flow = rtuHP.heaPum.port_b1.m_flow;
  supFan.'ports[1]'.m_flow = rtuHP.heaPum.port_b1.m_flow;
  rtuHP.heaPum.con.vol.heatPort.T = rtuHP.heaPum.con.vol.T;
  rtuHP.heaPum.con.preHea.port.T = rtuHP.heaPum.con.vol.T;
  rtuHP.heaPum.port_b2.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.vol.'ports[2]'.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.preDro.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_a2.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.senT_b2.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.mFlow_eva.port_b.m_flow = rtuHP.inSou.'ports[1]'.m_flow;
  rtuHP.heaPum.eva.vol.heatPort.T = rtuHP.heaPum.eva.vol.T;
  rtuHP.heaPum.eva.preHea.port.T = rtuHP.heaPum.eva.vol.T;
  rtuHP.heaPum.innerCycle.switchQEva.u2 = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaPum.innerCycle.switchQCon.u2 = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaPum.innerCycle.switchPel.u2 = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.modeSet = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaPum.sigBus.modeSet = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.heaOn.y = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuHP.sigBus1.modeSet = rtuHP.heaPum.innerCycle.sigBus.modeSet;
  rtuConFMU.heaCal = y_HeaCal;
  rtuConFMU.conHea.trigger = y_HeaCal;
  rtuConFMU.conHea.I.trigger = y_HeaCal;
  rtuConFMU.swiHea.u2 = y_HeaCal;
  rtuConFMU.NotLim.u = rtuConFMU.onOffConSupHeatSetPoi.y;
  rtuConFMU.heatStage.switch4.u2 = rtuConFMU.heatStage.realToBoolean1.y;
  rtuConFMU.heatStage.not1.y = rtuConFMU.heatStage.booleanToReal.u;
  rtuConFMU.heatStage.not2.y = rtuConFMU.heatStage.booleanToReal1.u;
  rtuConFMU.heatStage.not1.u = rtuConFMU.heatStage.onOffSta1.y;
  rtuConFMU.heatStage.not2.u = rtuConFMU.heatStage.onOffSta2.y;
  rtuConFMU.onDelay.y = rtuConFMU.swiTim.u2;
  rtuConFMU.NotLim.y = rtuConFMU.UppLimSwi.u2;
  rtuConFMU.realToBoolean.y = rtuConFMU.onDelay.u;
  rtuHP.heaPum.innerCycle.PerformanceDataHPHeating.sigBus.onOffMea = rtuHP.heaPum.innerCycle.sigBus.onOffMea;
  rtuHP.heaPum.sigBus.onOffMea = rtuHP.heaPum.innerCycle.sigBus.onOffMea;
  rtuHP.heaPum.greaterThreshold.y = rtuHP.heaPum.innerCycle.sigBus.onOffMea;
  rtuHP.sigBus1.onOffMea = rtuHP.heaPum.innerCycle.sigBus.onOffMea;
  annotation (__Dymola_FMUImportVersion="Dymola 2020x", experiment(StartTime=19872000.0, StopTime=19958400.0, Tolerance=1E-06),
    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 2.0 CS")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 2.0</li>
<li>modelName = HiLWinterTestsRTUHPFMUv2</li>
<li>generationTool = Dymola Version 2020 (64-bit), 2019-04-10 (requires license to execute)</li>
<li>generationDateAndTime = 2022-02-19T01:39:17Z</li>
</ul>
<p><br><b>Model Exchange Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>completedIntegratorStepNotNeeded = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = false</li>
<li>canGetAndSetFMUstate = true</li>
<li>canSerializeFMUstate = true</li>
<li>providesDirectionalDerivative = true</li>
</ul>
<p><br><b>Co-Simulation Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>canHandleVariableCommunicationStepSize = true</li>
<li>canInterpolateInputs = true</li>
<li>maxOutputDerivativeOrder = 1</li>
<li>canRunAsynchronuously = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = false</li>
<li>canGetAndSetFMUstate = true</li>
<li>canSerializeFMUstate = true</li>
<li>providesDirectionalDerivative = true</li>
</ul>
</html>"));
end HiLWinterTestsRTUHPFMUv2_fmu;
