within hil_flexlab_model;
package Controls_HIL "Package with models for controls"
  extends Modelica.Icons.Package;
  package OBC "Blocks and preconfigured control sequences"
    extends Modelica.Icons.VariantsPackage;

    package ASHRAE "Package with control sequences from ASHRAE projects"

      package G36_PR1 "Package with control sequences from ASHRAE Guideline 36"

        package AHUs "AHU Sequences as defined in guideline G36"

          package MultiZone "Sequences for multi zone AHU control"

            package VAV "Sequences for multi zone VAV AHU control"

              block Controller
                "Multizone AHU controller that composes subsequences for controlling fan speed, dampers, and supply air temperature"

                parameter Real samplePeriod(
                  final unit="s",
                  final quantity="Time")=120
                  "Sample period of component, set to the same value to the trim and respond sequence";

                parameter Boolean have_perZonRehBox=true
                  "Check if there is any VAV-reheat boxes on perimeter zones"
                  annotation (Dialog(group="System and building parameters"));

                parameter Boolean have_duaDucBox=false
                  "Check if the AHU serves dual duct boxes"
                  annotation (Dialog(group="System and building parameters"));

                parameter Boolean have_airFloMeaSta=false
                  "Check if the AHU has AFMS (Airflow measurement station)"
                  annotation (Dialog(group="System and building parameters"));

                // ----------- Parameters for economizer control -----------
                parameter Boolean use_enthalpy=false
                  "Set to true if enthalpy measurement is used in addition to temperature measurement"
                  annotation (Dialog(tab="Economizer"));

                parameter Real delta(
                  final unit="s",
                  final quantity="Time")=5
                  "Time horizon over which the outdoor air flow measurment is averaged"
                  annotation (Dialog(tab="Economizer"));

                parameter Real delTOutHis(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=1
                  "Delta between the temperature hysteresis high and low limit"
                  annotation (Dialog(tab="Economizer"));

                parameter Real delEntHis(
                  final unit="J/kg",
                  final quantity="SpecificEnergy")=1000
                  "Delta between the enthalpy hysteresis high and low limits"
                  annotation (Dialog(tab="Economizer", enable=use_enthalpy));

                parameter Real retDamPhyPosMax(
                  final min=0,
                  final max=1,
                  final unit="1") = 1
                  "Physically fixed maximum position of the return air damper"
                  annotation (Dialog(tab="Economizer", group="Damper limits"));

                parameter Real retDamPhyPosMin(
                  final min=0,
                  final max=1,
                  final unit="1") = 0
                  "Physically fixed minimum position of the return air damper"
                  annotation (Dialog(tab="Economizer", group="Damper limits"));

                parameter Real outDamPhyPosMax(
                  final min=0,
                  final max=1,
                  final unit="1") = 1
                  "Physically fixed maximum position of the outdoor air damper"
                  annotation (Dialog(tab="Economizer", group="Damper limits"));

                parameter Real outDamPhyPosMin(
                  final min=0,
                  final max=1,
                  final unit="1") = 0
                  "Physically fixed minimum position of the outdoor air damper"
                  annotation (Dialog(tab="Economizer", group="Damper limits"));

                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeMinOut=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                  "Type of controller"
                  annotation (Dialog(group="Economizer PID controller"));

                parameter Real kMinOut(final unit="1")=0.05
                  "Gain of controller for minimum outdoor air intake"
                  annotation (Dialog(group="Economizer PID controller"));

                parameter Real TiMinOut(
                  final unit="s",
                  final quantity="Time")=1200
                  "Time constant of controller for minimum outdoor air intake"
                  annotation (Dialog(group="Economizer PID controller",
                    enable=controllerTypeMinOut == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeMinOut == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                parameter Real TdMinOut(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of derivative block for minimum outdoor air intake"
                  annotation (Dialog(group="Economizer PID controller",
                    enable=controllerTypeMinOut == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeMinOut == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                parameter Boolean use_TMix=true
                  "Set to true if mixed air temperature measurement is enabled"
                   annotation(Dialog(group="Economizer freeze protection"));

                parameter Boolean use_G36FrePro=false
                  "Set to true to use G36 freeze protection"
                  annotation(Dialog(group="Economizer freeze protection"));

                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeFre=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                  "Type of controller" annotation (Dialog(group=
                        "Economizer freeze protection", enable=use_TMix));

                parameter Real kFre(final unit="1/K") = 0.1
                  "Gain for mixed air temperature tracking for freeze protection, used if use_TMix=true"
                   annotation(Dialog(group="Economizer freeze protection", enable=use_TMix));

                parameter Real TiFre(
                  final unit="s",
                  final quantity="Time",
                  final max=TiMinOut)=120
                  "Time constant of controller for mixed air temperature tracking for freeze protection. Require TiFre < TiMinOut"
                   annotation(Dialog(group="Economizer freeze protection",
                     enable=use_TMix and (controllerTypeFre ==
                        hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeFre == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID)));

                parameter Real TdFre(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of derivative block for freeze protection"
                  annotation (Dialog(group="Economizer freeze protection",
                    enable=use_TMix and (controllerTypeFre == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeFre == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID)));

                parameter Real TFreSet(
                   final unit="K",
                   final displayUnit="degC",
                   final quantity="ThermodynamicTemperature")= 279.15
                  "Lower limit for mixed air temperature for freeze protection, used if use_TMix=true"
                   annotation(Dialog(group="Economizer freeze protection", enable=use_TMix));

                parameter Real yMinDamLim=0
                  "Lower limit of damper position limits control signal output"
                  annotation (Dialog(tab="Economizer", group="Damper limits"));

                parameter Real yMaxDamLim=1
                  "Upper limit of damper position limits control signal output"
                  annotation (Dialog(tab="Economizer", group="Damper limits"));

                parameter Real retDamFulOpeTim(
                  final unit="s",
                  final quantity="Time")=180
                  "Time period to keep RA damper fully open before releasing it for minimum outdoor airflow control
    at disable to avoid pressure fluctuations"
                  annotation (Dialog(tab="Economizer", group="Economizer delays at disable"));

                parameter Real disDel(
                  final unit="s",
                  final quantity="Time")=15
                  "Short time delay before closing the OA damper at disable to avoid pressure fluctuations"
                  annotation (Dialog(tab="Economizer", group="Economizer delays at disable"));

                // ----------- parameters for fan speed control  -----------
                parameter Real pIniSet(
                  final unit="Pa",
                  final displayUnit="Pa",
                  final quantity="PressureDifference")=60
                  "Initial pressure setpoint for fan speed control"
                  annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                parameter Real pMinSet(
                  final unit="Pa",
                  final displayUnit="Pa",
                  final quantity="PressureDifference")=25
                  "Minimum pressure setpoint for fan speed control"
                  annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                parameter Real pMaxSet(
                  final unit="Pa",
                  final displayUnit="Pa",
                  final quantity="PressureDifference")=400
                  "Maximum pressure setpoint for fan speed control"
                  annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                parameter Real pDelTim(
                  final unit="s",
                  final quantity="Time")=600
                  "Delay time after which trim and respond is activated"
                  annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                parameter Integer pNumIgnReq=2
                  "Number of ignored requests for fan speed control"
                  annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                parameter Real pTriAmo(
                  final unit="Pa",
                  final displayUnit="Pa",
                  final quantity="PressureDifference")=-12.0
                  "Trim amount for fan speed control"
                  annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                parameter Real pResAmo(
                  final unit="Pa",
                  final displayUnit="Pa",
                  final quantity="PressureDifference")=15
                  "Respond amount (must be opposite in to triAmo) for fan speed control"
                  annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                parameter Real pMaxRes(
                  final unit="Pa",
                  final displayUnit="Pa",
                  final quantity="PressureDifference")=32
                  "Maximum response per time interval (same sign as resAmo) for fan speed control"
                  annotation (Dialog(tab="Fan speed", group="Trim and respond for reseting duct static pressure setpoint"));

                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeFanSpe=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                  "Type of controller"
                  annotation (Dialog(group="Fan speed PID controller"));

                parameter Real kFanSpe(final unit="1")=0.1
                  "Gain of fan fan speed controller, normalized using pMaxSet"
                  annotation (Dialog(group="Fan speed PID controller"));

                parameter Real TiFanSpe(
                  final unit="s",
                  final quantity="Time")=60
                  "Time constant of integrator block for fan speed"
                  annotation (Dialog(group="Fan speed PID controller",
                    enable=controllerTypeFanSpe == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeFanSpe == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                parameter Real TdFanSpe(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of derivative block for fan speed"
                  annotation (Dialog(group="Fan speed PID controller",
                    enable=controllerTypeFanSpe == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeFanSpe == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                parameter Real yFanMax=1 "Maximum allowed fan speed"
                  annotation (Dialog(group="Fan speed PID controller"));

                parameter Real yFanMin=0.1 "Lowest allowed fan speed if fan is on"
                  annotation (Dialog(group="Fan speed PID controller"));

                // ----------- parameters for minimum outdoor airflow setting  -----------
                parameter Real VPriSysMax_flow(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Maximum expected system primary airflow at design stage"
                  annotation (Dialog(tab="Minimum outdoor airflow rate", group="Nominal conditions"));

                parameter Real peaSysPop "Peak system population"
                  annotation (Dialog(tab="Minimum outdoor airflow rate", group="Nominal conditions"));

                // ----------- parameters for supply air temperature control  -----------
                parameter Real TSupSetMin(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=285.15
                  "Lowest cooling supply air temperature setpoint"
                  annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                parameter Real TSupSetMax(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=291.15
                  "Highest cooling supply air temperature setpoint. It is typically 18 degC (65 degF) in mild and dry climates, 16 degC (60 degF) or lower in humid climates"
                  annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                parameter Real TSupSetDes(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=286.15
                  "Nominal supply air temperature setpoint"
                  annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                parameter Real TOutMin(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=289.15
                  "Lower value of the outdoor air temperature reset range. Typically value is 16 degC (60 degF)"
                  annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                parameter Real TOutMax(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=294.15
                  "Higher value of the outdoor air temperature reset range. Typically value is 21 degC (70 degF)"
                  annotation (Dialog(tab="Supply air temperature", group="Temperature limits"));

                parameter Real iniSetSupTem(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=supTemSetPoi.maxSet
                  "Initial setpoint for supply temperature control"
                  annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                parameter Real maxSetSupTem(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=supTemSetPoi.TSupSetMax
                  "Maximum setpoint for supply temperature control"
                  annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                parameter Real minSetSupTem(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=supTemSetPoi.TSupSetDes
                  "Minimum setpoint for supply temperature control"
                  annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                parameter Real delTimSupTem(
                  final unit="s",
                  final quantity="Time")=600
                  "Delay timer for supply temperature control"
                  annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                parameter Integer numIgnReqSupTem=2
                  "Number of ignorable requests for supply temperature control"
                  annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                parameter Real triAmoSupTem(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=0.1
                  "Trim amount for supply temperature control"
                  annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                parameter Real resAmoSupTem(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=-0.2
                  "Response amount for supply temperature control"
                  annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                parameter Real maxResSupTem(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=-0.6
                  "Maximum response per time interval for supply temperature control"
                  annotation (Dialog(tab="Supply air temperature", group="Trim and respond for reseting TSup setpoint"));

                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeTSup=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                  "Type of controller for supply air temperature signal"
                  annotation (Dialog(group="Supply air temperature"));

                parameter Real kTSup(final unit="1/K")=0.05
                  "Gain of controller for supply air temperature signal"
                  annotation (Dialog(group="Supply air temperature"));

                parameter Real TiTSup(
                  final unit="s",
                  final quantity="Time")=600
                  "Time constant of integrator block for supply air temperature control signal"
                  annotation (Dialog(group="Supply air temperature",
                    enable=controllerTypeTSup == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeTSup == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                parameter Real TdTSup(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of integrator block for supply air temperature control signal"
                  annotation (Dialog(group="Supply air temperature",
                    enable=controllerTypeTSup == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeTSup == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                parameter Real uHeaMax(min=-0.9)=-0.25
                  "Upper limit of controller signal when heating coil is off. Require -1 < uHeaMax < uCooMin < 1."
                  annotation (Dialog(group="Supply air temperature"));

                parameter Real uCooMin(max=0.9)=0.25
                  "Lower limit of controller signal when cooling coil is off. Require -1 < uHeaMax < uCooMin < 1."
                  annotation (Dialog(group="Supply air temperature"));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonHeaSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Zone air temperature heating setpoint" annotation (Placement(
                      transformation(extent={{-240,280},{-200,320}}),
                      iconTransformation(extent={{-240,320},{-200,360}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonCooSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Zone air temperature cooling setpoint" annotation (Placement(
                      transformation(extent={{-240,250},{-200,290}}),
                      iconTransformation(extent={{-240,290},{-200,330}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TOut(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Outdoor air temperature" annotation (Placement(
                      transformation(extent={{-240,220},{-200,260}}),
                      iconTransformation(extent={{-240,260},{-200,300}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput ducStaPre(final
                    unit="Pa", final displayUnit="Pa")
                  "Measured duct static pressure" annotation (Placement(
                      transformation(extent={{-240,190},{-200,230}}),
                      iconTransformation(extent={{-240,230},{-200,270}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput sumDesZonPop(final min
                    =0, final unit="1")
                  "Sum of the design population of the zones in the group"
                  annotation (Placement(transformation(extent={{-240,160},{-200,
                          200}}), iconTransformation(extent={{-240,170},{-200,
                          210}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VSumDesPopBreZon_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Sum of the population component design breathing zone flow rate"
                  annotation (Placement(transformation(extent={{-240,130},{-200,
                          170}}), iconTransformation(extent={{-240,140},{-200,
                          180}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VSumDesAreBreZon_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Sum of the area component design breathing zone flow rate"
                  annotation (Placement(transformation(extent={{-240,100},{-200,
                          140}}), iconTransformation(extent={{-240,110},{-200,
                          150}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uDesSysVenEff(final min
                    =0, final unit="1")
                  "Design system ventilation efficiency, equals to the minimum of all zones ventilation efficiency"
                  annotation (Placement(transformation(extent={{-240,70},{-200,
                          110}}), iconTransformation(extent={{-240,80},{-200,
                          120}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VSumUncOutAir_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Sum of all zones required uncorrected outdoor airflow rate"
                  annotation (Placement(transformation(extent={{-240,40},{-200,
                          80}}), iconTransformation(extent={{-240,50},{-200,90}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VSumSysPriAir_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "System primary airflow rate, equals to the sum of the measured discharged flow rate of all terminal units"
                  annotation (Placement(transformation(extent={{-240,10},{-200,
                          50}}), iconTransformation(extent={{-240,20},{-200,60}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uOutAirFra_max(final min
                    =0, final unit="1")
                  "Maximum zone outdoor air fraction, equals to the maximum of primary outdoor air fraction of all zones"
                  annotation (Placement(transformation(extent={{-240,-20},{-200,
                          20}}), iconTransformation(extent={{-240,-10},{-200,30}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSup(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Measured supply air temperature" annotation (Placement(
                      transformation(extent={{-240,-50},{-200,-10}}),
                      iconTransformation(extent={{-240,-70},{-200,-30}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TOutCut(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "OA temperature high limit cutoff. For differential dry bulb temeprature condition use return air temperature measurement"
                  annotation (Placement(transformation(extent={{-240,-80},{-200,
                          -40}}), iconTransformation(extent={{-240,-100},{-200,
                          -60}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput hOut(final
                    unit="J/kg", final quantity="SpecificEnergy") if
                  use_enthalpy "Outdoor air enthalpy" annotation (Placement(
                      transformation(extent={{-240,-110},{-200,-70}}),
                      iconTransformation(extent={{-240,-130},{-200,-90}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput hOutCut(final
                    unit="J/kg", final quantity="SpecificEnergy") if
                  use_enthalpy
                  "OA enthalpy high limit cutoff. For differential enthalpy use return air enthalpy measurement"
                  annotation (Placement(transformation(extent={{-240,-140},{-200,
                          -100}}), iconTransformation(extent={{-240,-160},{-200,
                          -120}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VOut_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Measured outdoor volumetric airflow rate" annotation (
                    Placement(transformation(extent={{-240,-170},{-200,-130}}),
                      iconTransformation(extent={{-240,-190},{-200,-150}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TMix(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature") if use_TMix
                  "Measured mixed air temperature, used for freeze protection if use_TMix=true"
                  annotation (Placement(transformation(extent={{-240,-200},{-200,
                          -160}}), iconTransformation(extent={{-240,-230},{-200,
                          -190}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uOpeMod
                  "AHU operation mode status signal" annotation (Placement(
                      transformation(extent={{-240,-230},{-200,-190}}),
                      iconTransformation(extent={{-240,-270},{-200,-230}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uZonTemResReq
                  "Zone cooling supply air temperature reset request"
                  annotation (Placement(transformation(extent={{-240,-260},{-200,
                          -220}}), iconTransformation(extent={{-240,-300},{-200,
                          -260}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uZonPreResReq
                  "Zone static pressure reset requests" annotation (Placement(
                      transformation(extent={{-240,-290},{-200,-250}}),
                      iconTransformation(extent={{-240,-330},{-200,-290}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uFreProSta if
                  use_G36FrePro
                  "Freeze protection status, used if use_G36FrePro=true"
                  annotation (Placement(transformation(extent={{-240,-320},{-200,
                          -280}}), iconTransformation(extent={{-240,-360},{-200,
                          -320}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput
                  ySupFan "Supply fan status, true if fan should be on"
                  annotation (Placement(transformation(extent={{200,260},{240,
                          300}}), iconTransformation(extent={{200,280},{240,320}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput ySupFanSpe(
                  final min=0,
                  final max=1,
                  final unit="1") "Supply fan speed" annotation (Placement(
                      transformation(extent={{200,190},{240,230}}),
                      iconTransformation(extent={{200,220},{240,260}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TSupSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Setpoint for supply air temperature" annotation (Placement(
                      transformation(extent={{200,160},{240,200}}),
                      iconTransformation(extent={{200,160},{240,200}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VDesUncOutAir_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Design uncorrected minimum outdoor airflow rate" annotation
                  (Placement(transformation(extent={{200,120},{240,160}}),
                      iconTransformation(extent={{200,100},{240,140}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yAveOutAirFraPlu(final min
                    =0, final unit="1")
                  "Average outdoor air flow fraction plus 1" annotation (
                    Placement(transformation(extent={{200,80},{240,120}}),
                      iconTransformation(extent={{200,40},{240,80}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VEffOutAir_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Effective minimum outdoor airflow setpoint" annotation (
                    Placement(transformation(extent={{200,40},{240,80}}),
                      iconTransformation(extent={{200,-20},{240,20}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput
                  yReqOutAir
                  "True if the AHU supply fan is on and the zone is in occupied mode"
                  annotation (Placement(transformation(extent={{200,0},{240,40}}),
                      iconTransformation(extent={{200,-80},{240,-40}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yHea(
                  final min=0,
                  final max=1,
                  final unit="1") "Control signal for heating" annotation (
                    Placement(transformation(extent={{200,-50},{240,-10}}),
                      iconTransformation(extent={{200,-140},{240,-100}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yCoo(
                  final min=0,
                  final max=1,
                  final unit="1") "Control signal for cooling" annotation (
                    Placement(transformation(extent={{200,-110},{240,-70}}),
                      iconTransformation(extent={{200,-200},{240,-160}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yRetDamPos(
                  final min=0,
                  final max=1,
                  final unit="1") "Return air damper position" annotation (
                    Placement(transformation(extent={{200,-170},{240,-130}}),
                      iconTransformation(extent={{200,-260},{240,-220}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yOutDamPos(
                  final min=0,
                  final max=1,
                  final unit="1") "Outdoor air damper position" annotation (
                    Placement(transformation(extent={{200,-210},{240,-170}}),
                      iconTransformation(extent={{200,-320},{240,-280}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Average TZonSetPoiAve
                  "Average of all zone set points" annotation (Placement(
                      transformation(extent={{-160,270},{-140,290}})));

                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan
                  supFan(
                  final samplePeriod=samplePeriod,
                  final have_perZonRehBox=have_perZonRehBox,
                  final have_duaDucBox=have_duaDucBox,
                  final have_airFloMeaSta=have_airFloMeaSta,
                  final iniSet=pIniSet,
                  final minSet=pMinSet,
                  final maxSet=pMaxSet,
                  final delTim=pDelTim,
                  final numIgnReq=pNumIgnReq,
                  final triAmo=pTriAmo,
                  final resAmo=pResAmo,
                  final maxRes=pMaxRes,
                  final controllerType=controllerTypeFanSpe,
                  final k=kFanSpe,
                  final Ti=TiFanSpe,
                  final Td=TdFanSpe,
                  final yFanMax=yFanMax,
                  final yFanMin=yFanMin) "Supply fan controller" annotation (
                    Placement(transformation(extent={{-160,200},{-140,220}})));

                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyTemperature
                  supTemSetPoi(
                  final samplePeriod=samplePeriod,
                  final TSupSetMin=TSupSetMin,
                  final TSupSetMax=TSupSetMax,
                  final TSupSetDes=TSupSetDes,
                  final TOutMin=TOutMin,
                  final TOutMax=TOutMax,
                  final iniSet=iniSetSupTem,
                  final maxSet=maxSetSupTem,
                  final minSet=minSetSupTem,
                  final delTim=delTimSupTem,
                  final numIgnReq=numIgnReqSupTem,
                  final triAmo=triAmoSupTem,
                  final resAmo=resAmoSupTem,
                  final maxRes=maxResSupTem) "Setpoint for supply temperature"
                  annotation (Placement(transformation(extent={{0,170},{20,190}})));

                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.AHU
                  sysOutAirSet(final VPriSysMax_flow=VPriSysMax_flow, final
                    peaSysPop=peaSysPop) "Minimum outdoor airflow setpoint"
                  annotation (Placement(transformation(extent={{-40,70},{-20,90}})));

                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller
                  eco(
                  final use_enthalpy=use_enthalpy,
                  final delTOutHis=delTOutHis,
                  final delEntHis=delEntHis,
                  final retDamFulOpeTim=retDamFulOpeTim,
                  final disDel=disDel,
                  final controllerTypeMinOut=controllerTypeMinOut,
                  final kMinOut=kMinOut,
                  final TiMinOut=TiMinOut,
                  final TdMinOut=TdMinOut,
                  final retDamPhyPosMax=retDamPhyPosMax,
                  final retDamPhyPosMin=retDamPhyPosMin,
                  final outDamPhyPosMax=outDamPhyPosMax,
                  final outDamPhyPosMin=outDamPhyPosMin,
                  final uHeaMax=uHeaMax,
                  final uCooMin=uCooMin,
                  final uOutDamMax=(uHeaMax + uCooMin)/2,
                  final uRetDamMin=(uHeaMax + uCooMin)/2,
                  final TFreSet=TFreSet,
                  final controllerTypeFre=controllerTypeFre,
                  final kFre=kFre,
                  final TiFre=TiFre,
                  final TdFre=TdFre,
                  final delta=delta,
                  final use_TMix=use_TMix,
                  final use_G36FrePro=use_G36FrePro) "Economizer controller"
                  annotation (Placement(transformation(extent={{140,-170},{160,
                          -150}})));

                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals
                  val(
                  final controllerType=controllerTypeTSup,
                  final kTSup=kTSup,
                  final TiTSup=TiTSup,
                  final TdTSup=TdTSup,
                  final uHeaMax=uHeaMax,
                  final uCooMin=uCooMin) "AHU coil valve control" annotation (
                    Placement(transformation(extent={{80,-70},{100,-50}})));

              protected
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division VOut_flow_normalized(
                  u1(final unit="m3/s"),
                  u2(final unit="m3/s"),
                  y(final unit="1"))
                  "Normalization of outdoor air flow intake by design minimum outdoor air intake"
                  annotation (Placement(transformation(extent={{20,-130},{40,-110}})));

              equation
                connect(eco.yRetDamPos, yRetDamPos)
                  annotation (Line(points={{161.25,-157.5},{180,-157.5},{180,-150},{220,-150}},
                    color={0,0,127}));
                connect(eco.yOutDamPos, yOutDamPos)
                  annotation (Line(points={{161.25,-162.5},{180,-162.5},{180,-190},{220,-190}},
                    color={0,0,127}));
                connect(eco.uSupFan, supFan.ySupFan)
                  annotation (Line(points={{138.75,-165},{-84,-165},{-84,217},{-138,217}},
                    color={255,0,255}));
                connect(supFan.ySupFanSpe, ySupFanSpe)
                  annotation (Line(points={{-138,210},{220,210}},
                    color={0,0,127}));
                connect(TOut, eco.TOut)
                  annotation (Line(points={{-220,240},{-60,240},{-60,-150.625},{138.75,-150.625}},
                    color={0,0,127}));
                connect(eco.TOutCut, TOutCut)
                  annotation (Line(points={{138.75,-152.5},{-74,-152.5},{-74,-60},{-220,-60}},
                    color={0,0,127}));
                connect(eco.hOut, hOut)
                  annotation (Line(points={{138.75,-154.375},{-78,-154.375},{-78,-90},{-220,-90}},
                    color={0,0,127}));
                connect(eco.hOutCut, hOutCut)
                  annotation (Line(points={{138.75,-155.625},{-94,-155.625},{-94,-120},{-220,-120}},
                    color={0,0,127}));
                connect(eco.uOpeMod, uOpeMod)
                  annotation (Line(points={{138.75,-166.875},{60,-166.875},{60,-210},{-220,-210}},
                    color={255,127,0}));
                connect(supTemSetPoi.TSupSet, TSupSet)
                  annotation (Line(points={{22,180},{220,180}}, color={0,0,127}));
                connect(supTemSetPoi.TOut, TOut)
                  annotation (Line(points={{-2,184},{-60,184},{-60,240},{-220,240}},
                    color={0,0,127}));
                connect(supTemSetPoi.uSupFan, supFan.ySupFan)
                  annotation (Line(points={{-2,176},{-84,176},{-84,217},{-138,217}},
                    color={255,0,255}));
                connect(supTemSetPoi.uZonTemResReq, uZonTemResReq)
                  annotation (Line(points={{-2,180},{-52,180},{-52,-240},{-220,-240}},
                    color={255,127,0}));
                connect(supTemSetPoi.uOpeMod, uOpeMod)
                  annotation (Line(points={{-2,172},{-48,172},{-48,-210},{-220,-210}},
                    color={255,127,0}));
                connect(supFan.uOpeMod, uOpeMod)
                  annotation (Line(points={{-162,218},{-180,218},{-180,-210},{-220,-210}},
                    color={255,127,0}));
                connect(supFan.uZonPreResReq, uZonPreResReq)
                  annotation (Line(points={{-162,207},{-176,207},{-176,-270},{-220,-270}},
                    color={255,127,0}));
                connect(supFan.ducStaPre, ducStaPre)
                  annotation (Line(points={{-162,202},{-192,202},{-192,210},{-220,210}},
                    color={0,0,127}));
                connect(supTemSetPoi.TZonSetAve, TZonSetPoiAve.y)
                  annotation (Line(points={{-2,188},{-20,188},{-20,280},{-138,280}},
                    color={0,0,127}));
                connect(supFan.ySupFan, ySupFan)
                  annotation (Line(points={{-138,217},{60,217},{60,280},{220,280}},
                    color={255,0,255}));
                connect(TZonSetPoiAve.u2, TZonCooSet)
                  annotation (Line(points={{-162,274},{-180,274},{-180,270},{-220,270}},
                    color={0,0,127}));
                connect(eco.TMix, TMix)
                  annotation (Line(points={{138.75,-163.125},{-12,-163.125},{-12,-180},{-220,-180}},
                    color={0,0,127}));
                connect(TSup, val.TSup)
                  annotation (Line(points={{-220,-30},{-66,-30},{-66,-65},{78,-65}},
                    color={0,0,127}));
                connect(supFan.ySupFan, val.uSupFan)
                  annotation (Line(points={{-138,217},{-84,217},{-84,-55},{78,-55}},
                    color={255,0,255}));
                connect(val.uTSup, eco.uTSup)
                  annotation (Line(points={{102,-56},{120,-56},{120,-157.5},{138.75,-157.5}},
                    color={0,0,127}));
                connect(val.yHea, yHea)
                  annotation (Line(points={{102,-60},{180,-60},{180,-30},{220,-30}},
                    color={0,0,127}));
                connect(val.yCoo, yCoo)
                  annotation (Line(points={{102,-64},{180,-64},{180,-90},{220,-90}},
                    color={0,0,127}));
                connect(supTemSetPoi.TSupSet, val.TSupSet)
                  annotation (Line(points={{22,180},{60,180},{60,-60},{78,-60}},
                    color={0,0,127}));
                connect(TZonHeaSet, TZonSetPoiAve.u1)
                  annotation (Line(points={{-220,300},{-180,300},{-180,286},{-162,286}},
                    color={0,0,127}));
                connect(eco.uFreProSta, uFreProSta)
                  annotation (Line(points={{138.75,-169.375},{66,-169.375},{66,-300},{-220,-300}},
                    color={255,127,0}));
                connect(eco.VOut_flow_normalized, VOut_flow_normalized.y)
                  annotation (Line(points={{138.75,-159.375},{60,-159.375},{60,-120},{42,-120}},
                    color={0,0,127}));
                connect(VOut_flow_normalized.u1, VOut_flow)
                  annotation (Line(points={{18,-114},{-160,-114},{-160,-150},{-220,-150}},
                    color={0,0,127}));
                connect(sysOutAirSet.VDesUncOutAir_flow, VDesUncOutAir_flow) annotation (Line(
                      points={{-18,88},{0,88},{0,140},{220,140}}, color={0,0,127}));
                connect(sysOutAirSet.VDesOutAir_flow, VOut_flow_normalized.u2) annotation (
                    Line(points={{-18,82},{0,82},{0,-126},{18,-126}}, color={0,0,127}));
                connect(sysOutAirSet.effOutAir_normalized, eco.VOutMinSet_flow_normalized)
                  annotation (Line(points={{-18,75},{-4,75},{-4,-161.25},{138.75,-161.25}},
                      color={0,0,127}));
                connect(supFan.ySupFan, sysOutAirSet.uSupFan) annotation (Line(points={{-138,217},
                        {-84,217},{-84,73},{-42,73}}, color={255,0,255}));
                connect(uOpeMod, sysOutAirSet.uOpeMod) annotation (Line(points={{-220,-210},{-48,
                        -210},{-48,71},{-42,71}}, color={255,127,0}));
                connect(sysOutAirSet.yAveOutAirFraPlu, yAveOutAirFraPlu) annotation (Line(
                      points={{-18,85},{20,85},{20,100},{220,100}}, color={0,0,127}));
                connect(sysOutAirSet.VEffOutAir_flow, VEffOutAir_flow) annotation (Line(
                      points={{-18,78},{20,78},{20,60},{220,60}}, color={0,0,127}));
                connect(sysOutAirSet.yReqOutAir, yReqOutAir) annotation (Line(points={{-18,
                        72},{16,72},{16,20},{220,20}}, color={255,0,255}));
                connect(sysOutAirSet.sumDesZonPop, sumDesZonPop) annotation (Line(points={{-42,
                        89},{-120,89},{-120,180},{-220,180}}, color={0,0,127}));
                connect(sysOutAirSet.VSumDesPopBreZon_flow, VSumDesPopBreZon_flow)
                  annotation (Line(points={{-42,87},{-126,87},{-126,150},{-220,150}}, color={0,
                        0,127}));
                connect(sysOutAirSet.VSumDesAreBreZon_flow, VSumDesAreBreZon_flow)
                  annotation (Line(points={{-42,85},{-132,85},{-132,120},{-220,120}}, color={0,
                        0,127}));
                connect(sysOutAirSet.uDesSysVenEff, uDesSysVenEff) annotation (Line(points={{-42,
                        83},{-138,83},{-138,90},{-220,90}}, color={0,0,127}));
                connect(sysOutAirSet.VSumUncOutAir_flow, VSumUncOutAir_flow) annotation (Line(
                      points={{-42,81},{-138,81},{-138,60},{-220,60}}, color={0,0,127}));
                connect(sysOutAirSet.VSumSysPriAir_flow, VSumSysPriAir_flow) annotation (Line(
                      points={{-42,79},{-132,79},{-132,30},{-220,30}}, color={0,0,127}));
                connect(uOutAirFra_max, sysOutAirSet.uOutAirFra_max) annotation (Line(points={
                        {-220,0},{-126,0},{-126,77},{-42,77}}, color={0,0,127}));

              annotation (defaultComponentName="conAHU",
                  Diagram(coordinateSystem(extent={{-200,-320},{200,320}}, initialScale=0.2)),
                  Icon(coordinateSystem(extent={{-200,-360},{200,360}}, initialScale=0.2),
                      graphics={Rectangle(
                        extent={{200,360},{-200,-360}},
                        lineColor={0,0,0},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid), Text(
                        extent={{-200,450},{200,372}},
                        textString="%name",
                        lineColor={0,0,255}),           Text(
                        extent={{-200,348},{-116,332}},
                        lineColor={0,0,0},
                        textString="TZonHeaSet"),       Text(
                        extent={{102,-48},{202,-68}},
                        lineColor={255,0,255},
                        textString="yReqOutAir"),       Text(
                        extent={{-196,-238},{-122,-258}},
                        lineColor={255,127,0},
                        textString="uOpeMod"),          Text(
                        extent={{-200,318},{-114,302}},
                        lineColor={0,0,0},
                        textString="TZonCooSet"),       Text(
                        extent={{-198,260},{-120,242}},
                        lineColor={0,0,0},
                        textString="ducStaPre"),        Text(
                        extent={{-198,288},{-162,272}},
                        lineColor={0,0,0},
                        textString="TOut"),             Text(
                        extent={{-196,110},{-90,88}},
                        lineColor={0,0,0},
                        textString="uDesSysVenEff"),    Text(
                        extent={{-196,140},{-22,118}},
                        lineColor={0,0,0},
                        textString="VSumDesAreBreZon_flow"),
                                                        Text(
                        extent={{-196,170},{-20,148}},
                        lineColor={0,0,0},
                        textString="VSumDesPopBreZon_flow"),
                                                        Text(
                        extent={{-196,200},{-88,182}},
                        lineColor={0,0,0},
                        textString="sumDesZonPop"),     Text(
                        extent={{-200,-42},{-154,-62}},
                        lineColor={0,0,0},
                        textString="TSup"),             Text(
                        extent={{-200,18},{-84,0}},
                        lineColor={0,0,0},
                        textString="uOutAirFra_max"),   Text(
                        extent={{-196,48},{-62,30}},
                        lineColor={0,0,0},
                        textString="VSumSysPriAir_flow"),
                                                        Text(
                        extent={{-196,80},{-42,58}},
                        lineColor={0,0,0},
                        textString="VSumUncOutAir_flow"),
                                                        Text(
                        extent={{-200,-162},{-126,-180}},
                        lineColor={0,0,0},
                        textString="VOut_flow"),        Text(
                        visible=use_enthalpy,
                        extent={{-200,-130},{-134,-148}},
                        lineColor={0,0,0},
                        textString="hOutCut"),          Text(
                        visible=use_enthalpy,
                        extent={{-200,-100},{-160,-118}},
                        lineColor={0,0,0},
                        textString="hOut"),             Text(
                        extent={{-198,-70},{-146,-86}},
                        lineColor={0,0,0},
                        textString="TOutCut"),          Text(
                        visible=use_TMix,
                        extent={{-200,-200},{-154,-218}},
                        lineColor={0,0,0},
                        textString="TMix"),             Text(
                        extent={{-194,-270},{-68,-290}},
                        lineColor={255,127,0},
                        textString="uZonTemResReq"),    Text(
                        extent={{-192,-300},{-74,-320}},
                        lineColor={255,127,0},
                        textString="uZonPreResReq"),    Text(
                        visible=use_G36FrePro,
                        extent={{-200,-330},{-110,-348}},
                        lineColor={255,127,0},
                        textString="uFreProSta"),       Text(
                        extent={{106,252},{198,230}},
                        lineColor={0,0,0},
                        textString="ySupFanSpe"),       Text(
                        extent={{122,192},{202,172}},
                        lineColor={0,0,0},
                        textString="TSupSet"),          Text(
                        extent={{68,72},{196,52}},
                        lineColor={0,0,0},
                        textString="yAveOutAirFraPlu"), Text(
                        extent={{48,132},{196,110}},
                        lineColor={0,0,0},
                        textString="VDesUncOutAir_flow"),
                                                        Text(
                        extent={{150,-104},{200,-126}},
                        lineColor={0,0,0},
                        textString="yHea"),             Text(
                        extent={{94,-288},{200,-308}},
                        lineColor={0,0,0},
                        textString="yOutDamPos"),       Text(
                        extent={{98,-228},{198,-248}},
                        lineColor={0,0,0},
                        textString="yRetDamPos"),       Text(
                        extent={{78,14},{196,-6}},
                        lineColor={0,0,0},
                        textString="VEffOutAir_flow"),  Text(
                        extent={{120,312},{202,292}},
                        lineColor={255,0,255},
                        textString="ySupFan"),          Text(
                        extent={{150,-166},{200,-188}},
                        lineColor={0,0,0},
                        textString="yCoo")}),
              Documentation(info="<html>
<p>
Block that is applied for multizone VAV AHU control. It outputs the supply fan status
and the operation speed, outdoor and return air damper position, supply air
temperature setpoint and the valve position of the cooling and heating coils.
It is implemented according to the ASHRAE Guideline 36, PART 5.N.
</p>
<p>
The sequence consists of five subsequences.
</p>
<h4>Supply fan speed control</h4>
<p>
The fan speed control is implemented according to PART 5.N.1. It outputs
the boolean signal <code>ySupFan</code> to turn on or off the supply fan.
In addition, based on the pressure reset request <code>uZonPreResReq</code>
from the VAV zones controller, the
sequence resets the duct pressure setpoint, and uses this setpoint
to modulate the fan speed <code>ySupFanSpe</code> using a PI controller.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan</a>
for more detailed description.
</p>
<h4>Minimum outdoor airflow setting</h4>
<p>
According to current occupany, supply operation status <code>ySupFan</code>,
zone temperatures and the discharge air temperature, the sequence computes the
minimum outdoor airflow rate setpoint, which is used as input for the economizer control.
More detailed information can be found in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow</a>.
</p>
<h4>Economizer control</h4>
<p>
The block outputs outdoor and return air damper position, <code>yOutDamPos</code> and
<code>yRetDamPos</code>. First, it computes the position limits to satisfy the minimum
outdoor airflow requirement. Second, it determines the availability of the economizer based
on the outdoor condition. The dampers are modulated to track the supply air temperature
loop signal, which is calculated from the sequence below, subject to the minimum outdoor airflow
requirement and economizer availability. Optionally, there is also an override for freeze protection.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller</a>
for more detailed description.
</p>
<h4>Supply air temperature setpoint</h4>
<p>
Based on PART 5.N.2, the sequence first sets the maximum supply air temperature
based on reset requests collected from each zone <code>uZonTemResReq</code>. The
outdoor temperature <code>TOut</code> and operation mode <code>uOpeMod</code> are used
along with the maximum supply air temperature, for computing the supply air temperature
setpoint. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyTemperature\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyTemperature</a>
for more detailed description.
</p>
<h4>Coil valve control</h4>
<p>
The subsequence retrieves supply air temperature setpoint from previous sequence.
Along with the measured supply air temperature and the supply fan status, it
generates coil valve positions. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals</a>
</p>
</html>",     revisions="<html>
<ul>
<li>
March 16, 2020, by Jianjun Hu:<br/>
Reimplemented to add new block for specifying the minimum outdoor airfow setpoint.
This new block avoids vector-valued calculations.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
October 27, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
              end Controller;

              package Economizers "Economizer control of multi zone VAV AHU"

                block Controller "Multi zone VAV AHU economizer control sequence"

                  parameter Boolean use_enthalpy=false
                    "Set to true if enthalpy measurement is used in addition to temperature measurement";
                  parameter Boolean use_TMix=true
                    "Set to true if mixed air temperature measurement is enabled";
                  parameter Boolean use_G36FrePro=false
                    "Set to true to use G36 freeze protection";
                  parameter Real delTOutHis(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference")=1
                    "Delta between the temperature hysteresis high and low limit"
                    annotation (Dialog(tab="Advanced", group="Hysteresis"));
                  parameter Real delEntHis(
                    final unit="J/kg",
                    final quantity="SpecificEnergy")=1000
                    "Delta between the enthalpy hysteresis high and low limits"
                    annotation (Dialog(tab="Advanced",group="Hysteresis",enable=use_enthalpy));
                  parameter Real retDamFulOpeTim(
                    final unit="s",
                    final quantity="Time")=180
                    "Time period to keep RA damper fully open before releasing it for minimum outdoor airflow control at disable to avoid pressure fluctuations"
                    annotation (Dialog(tab="Advanced", group="Delays at disable"));
                  parameter Real disDel(
                    final unit="s",
                    final quantity="Time")=15
                    "Short time delay before closing the OA damper at disable to avoid pressure fluctuations"
                    annotation (Dialog(tab="Advanced", group="Delays at disable"));

                  parameter
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                    controllerTypeMinOut=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                    "Type of controller"
                    annotation (Dialog(group="Minimum outdoor air"));

                  parameter Real kMinOut(final unit="1")=0.05
                    "Gain of controller for minimum outdoor air"
                    annotation (Dialog(group="Minimum outdoor air"));
                  parameter Real TiMinOut(
                    final unit="s",
                    final quantity="Time")=1200
                    "Time constant of controller for minimum outdoor air intake"
                    annotation (Dialog(group="Minimum outdoor air",
                      enable=controllerTypeMinOut == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                           or controllerTypeMinOut == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                  parameter Real TdMinOut(
                    final unit="s",
                    final quantity="Time")=0.1
                    "Time constant of derivative block for minimum outdoor air intake"
                    annotation (Dialog(group="Minimum outdoor air",
                      enable=controllerTypeMinOut == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                           or controllerTypeMinOut == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                  parameter
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                    controllerTypeFre=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                    "Type of controller" annotation (Dialog(group=
                          "Freeze protection", enable=use_TMix));

                  parameter Real TFreSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")= 279.15
                    "Lower limit for mixed air temperature for freeze protection, used if use_TMix=true"
                     annotation(Dialog(group="Freeze protection", enable=use_TMix));
                  parameter Real kFre(final unit="1/K") = 0.1
                    "Gain for mixed air temperature tracking for freeze protection, used if use_TMix=true"
                     annotation(Dialog(group="Freeze protection", enable=use_TMix));

                  parameter Real TiFre(
                    final unit="s",
                    final quantity="Time",
                    final max=TiMinOut)=120
                    "Time constant of controller for mixed air temperature tracking for freeze protection. Require TiFre < TiMinOut"
                    annotation(Dialog(group="Freeze protection",
                      enable=use_TMix and (controllerTypeFre ==
                          hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                           or controllerTypeFre == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID)));

                  parameter Real TdFre(
                    final unit="s",
                    final quantity="Time")=0.1
                    "Time constant of derivative block for freeze protection"
                    annotation (Dialog(group="Economizer freeze protection",
                      enable=use_TMix and (controllerTypeFre ==
                          hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                           or controllerTypeFre == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID)));

                  parameter Real delta(
                    final unit="s",
                    final quantity="Time")=5
                    "Time horizon over which the outdoor air flow measurment is averaged";
                  parameter Real uHeaMax=-0.25
                    "Lower limit of controller input when outdoor damper opens for modulation control. Require -1 < uHeaMax < uCooMin < 1."
                    annotation (Dialog(tab="Commissioning", group="Controller"));
                  parameter Real uCooMin=+0.25
                    "Upper limit of controller input when return damper is closed for modulation control. Require -1 < uHeaMax < uCooMin < 1."
                    annotation (Dialog(tab="Commissioning", group="Controller"));

                  parameter Real uOutDamMax(
                    final min=-1,
                    final max=1,
                    final unit="1") = (uHeaMax + uCooMin)/2
                    "Maximum loop signal for the OA damper to be fully open. Require -1 < uHeaMax < uOutDamMax <= uRetDamMin < uCooMin < 1."
                    annotation (Dialog(tab="Commissioning", group="Controller"));
                  parameter Real uRetDamMin(
                    final min=-1,
                    final max=1,
                    final unit="1") = (uHeaMax + uCooMin)/2
                    "Minimum loop signal for the RA damper to be fully open. Require -1 < uHeaMax < uOutDamMax <= uRetDamMin < uCooMin < 1."
                    annotation (Dialog(tab="Commissioning", group="Controller"));

                  parameter Real retDamPhyPosMax(
                    final min=0,
                    final max=1,
                    final unit="1") = 1
                    "Physically fixed maximum position of the return air damper"
                    annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                  parameter Real retDamPhyPosMin(
                    final min=0,
                    final max=1,
                    final unit="1") = 0
                    "Physically fixed minimum position of the return air damper"
                    annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                  parameter Real outDamPhyPosMax(
                    final min=0,
                    final max=1,
                    final unit="1") = 1
                    "Physically fixed maximum position of the outdoor air damper"
                    annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                  parameter Real outDamPhyPosMin(
                    final min=0,
                    final max=1,
                    final unit="1") = 0
                    "Physically fixed minimum position of the outdoor air damper"
                    annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uTSup(final
                      unit="1")
                    "Signal for supply air temperature control (T Sup Control Loop Signal in diagram)"
                    annotation (Placement(transformation(extent={{-200,20},{-160,
                            60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TOut(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Outdoor air (OA) temperature" annotation (Placement(
                        transformation(extent={{-200,130},{-160,170}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TOutCut(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "OA temperature high limit cutoff. For differential dry bulb temeprature condition use return air temperature measurement"
                    annotation (Placement(transformation(extent={{-200,100},{-160,
                            140}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput hOut(final
                      unit="J/kg", final quantity="SpecificEnergy") if
                    use_enthalpy "Outdoor air enthalpy" annotation (Placement(
                        transformation(extent={{-200,70},{-160,110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput hOutCut(final
                      unit="J/kg", final quantity="SpecificEnergy") if
                    use_enthalpy
                    "OA enthalpy high limit cutoff. For differential enthalpy use return air enthalpy measurement"
                    annotation (Placement(transformation(extent={{-200,50},{-160,
                            90}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TMix(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") if use_TMix
                    "Measured mixed air temperature, used for freeze protection"
                    annotation (Placement(transformation(extent={{-200,-70},{-160,
                            -30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VOut_flow_normalized(final
                      unit="1")
                    "Measured outdoor volumetric airflow rate, normalized by design minimum outdoor airflow rate"
                    annotation (Placement(transformation(extent={{-200,-10},{-160,
                            30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VOutMinSet_flow_normalized(final
                      unit="1")
                    "Effective minimum outdoor airflow setpoint, normalized by design minimum outdoor airflow rate"
                    annotation (Placement(transformation(extent={{-200,-40},{-160,
                            0}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uFreProSta if use_G36FrePro "Freeze protection status"
                    annotation (Placement(transformation(extent={{-200,-170},{-160,
                            -130}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uOpeMod "AHU operation mode status signal" annotation (
                      Placement(transformation(extent={{-200,-130},{-160,-90}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                    uSupFan "Supply fan status" annotation (Placement(
                        transformation(extent={{-200,-100},{-160,-60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yRetDamPos(
                    final min=0,
                    final max=1,
                    final unit="1") "Return air damper position" annotation (
                      Placement(transformation(extent={{160,20},{200,60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yOutDamPos(
                    final min=0,
                    final max=1,
                    final unit="1") "Outdoor air damper position" annotation (
                      Placement(transformation(extent={{160,-60},{200,-20}})));

                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable
                    enaDis(
                    final use_enthalpy=use_enthalpy,
                    final delTOutHis=delTOutHis,
                    final delEntHis=delEntHis,
                    final retDamFulOpeTim=retDamFulOpeTim,
                    final disDel=disDel)
                    "Multi zone VAV AHU economizer enable/disable sequence"
                    annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits
                    damLim(
                    final retDamPhyPosMax=retDamPhyPosMax,
                    final retDamPhyPosMin=retDamPhyPosMin,
                    final outDamPhyPosMax=outDamPhyPosMax,
                    final outDamPhyPosMin=outDamPhyPosMin,
                    final k=kMinOut,
                    final Ti=TiMinOut,
                    final Td=TdMinOut,
                    final uRetDamMin=uRetDamMin,
                    final controllerType=controllerTypeMinOut)
                    "Multi zone VAV AHU economizer minimum outdoor air requirement damper limit sequence"
                    annotation (Placement(transformation(extent={{-80,0},{-60,
                            20}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation
                    mod(
                    final uRetDamMin=uRetDamMin,
                    final uMin=uHeaMax,
                    final uMax=uCooMin,
                    final uOutDamMax=uOutDamMax)
                    "Multi zone VAV AHU economizer damper modulation sequence"
                    annotation (Placement(transformation(extent={{40,0},{60,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.FreezeProtectionMixedAir
                    freProTMix(
                    final controllerType=controllerTypeFre,
                    final TFreSet=TFreSet,
                    final k=kFre,
                    final Ti=TiFre,
                    final Td=TdFre) if use_TMix
                    "Block that tracks TMix against a freeze protection setpoint"
                    annotation (Placement(transformation(extent={{80,-20},{100,
                            0}})));

                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movAve(final
                      delta=delta)
                    "Moving average of outdoor air flow measurement, normalized by design minimum outdoor airflow rate"
                    annotation (Placement(transformation(extent={{-140,10},{-120,
                            30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min outDamMaxFre
                    "Maximum control signal for outdoor air damper due to freeze protection"
                    annotation (Placement(transformation(extent={{120,-50},{140,
                            -30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Max retDamMinFre
                    "Minimum position for return air damper due to freeze protection"
                    annotation (Placement(transformation(extent={{120,30},{140,
                            50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    noTMix(k=0) if not use_TMix
                    "Ignore max evaluation if there is no mixed air temperature sensor"
                    annotation (Placement(transformation(extent={{76,36},{96,56}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    noTMix1(k=1) if not use_TMix
                    "Ignore min evaluation if there is no mixed air temperature sensor"
                    annotation (Placement(transformation(extent={{80,-56},{100,
                            -36}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                    if not use_G36FrePro
                    "Freeze protection status is 0. Use if G36 freeze protection is not implemented"
                    annotation (Placement(transformation(extent={{-140,-140},{-120,
                            -120}})));

                equation
                  connect(uSupFan, enaDis.uSupFan)
                    annotation (Line(points={{-180,-80},{-80,-80},{-80,-28},{-2,-28}}, color={255,0,255}));
                  connect(uFreProSta, enaDis.uFreProSta)
                    annotation (Line(points={{-180,-150},{-60,-150},{-60,-30},{-2,-30}}, color={255,127,0}));
                  connect(hOutCut, enaDis.hOutCut)
                    annotation (Line(points={{-180,70},{-46,70},{-46,-26},{-2,-26}}, color={0,0,127}));
                  connect(hOut, enaDis.hOut)
                    annotation (Line(points={{-180,90},{-44,90},{-44,-24},{-2,-24}},   color={0,0,127}));
                  connect(TOutCut, enaDis.TOutCut)
                    annotation (Line(points={{-180,120},{-42,120},{-42,-22},{-2,-22}}, color={0,0,127}));
                  connect(TOut, enaDis.TOut)
                    annotation (Line(points={{-180,150},{-40,150},{-40,-20},{-2,-20}}, color={0,0,127}));
                  connect(VOutMinSet_flow_normalized, damLim.VOutMinSet_flow_normalized)
                    annotation (Line(points={{-180,-20},{-110,-20},{-110,18},{-82,18}}, color={0,0,127}));
                  connect(uSupFan, damLim.uSupFan)
                    annotation (Line(points={{-180,-80},{-104,-80},{-104,10},{-82,10}}, color={255,0,255}));
                  connect(uOpeMod, damLim.uOpeMod)
                    annotation (Line(points={{-180,-110},{-102,-110},{-102,2},{-82,2}}, color={255,127,0}));
                  connect(uFreProSta, damLim.uFreProSta)
                    annotation (Line(points={{-180,-150},{-100,-150},{-100,6},{-82,6}}, color={255,127,0}));
                  connect(damLim.yOutDamPosMax, enaDis.uOutDamPosMax)
                    annotation (Line(points={{-58,14},{-24,14},{-24,-32},{-2,-32}}, color={0,0,127}));
                  connect(damLim.yOutDamPosMin, enaDis.uOutDamPosMin)
                    annotation (Line(points={{-58,18},{-26,18},{-26,12},{-26,-34},{-2,-34}}, color={0,0,127}));
                  connect(damLim.yRetDamPosMin, enaDis.uRetDamPosMin)
                    annotation (Line(points={{-58,10},{-28,10},{-28,-40},{-2,-40}}, color={0,0,127}));
                  connect(damLim.yRetDamPhyPosMax, enaDis.uRetDamPhyPosMax)
                    annotation (Line(points={{-58,2},{-32,2},{-32,-36},{-2,-36}}, color={0,0,127}));
                  connect(damLim.yRetDamPosMax, enaDis.uRetDamPosMax)
                    annotation (Line(points={{-58,6},{-30,6},{-30,-38},{-2,-38}}, color={0,0,127}));
                  connect(enaDis.yOutDamPosMax, mod.uOutDamPosMax)
                    annotation (Line(points={{22,-24},{26,-24},{26,5},{38,5}}, color={0,0,127}));
                  connect(enaDis.yRetDamPosMax, mod.uRetDamPosMax)
                    annotation (Line(points={{22,-30},{28,-30},{28,19},{38,19}}, color={0,0,127}));
                  connect(damLim.yOutDamPosMin, mod.uOutDamPosMin)
                    annotation (Line(points={{-58,18},{0,18},{0,1},{38,1}}, color={0,0,127}));
                  connect(enaDis.yRetDamPosMin, mod.uRetDamPosMin)
                    annotation (Line(points={{22,-36},{30,-36},{30,15},{38,15}}, color={0,0,127}));
                  connect(uTSup, mod.uTSup)
                    annotation (Line(points={{-180,40},{10,40},{10,10},{38,10}}, color={0,0,127}));
                  connect(VOut_flow_normalized, movAve.u)
                    annotation (Line(points={{-180,10},{-150,10},{-150,20},{-142,20}}, color={0,0,127}));
                  connect(movAve.y, damLim.VOut_flow_normalized)
                    annotation (Line(points={{-118,20},{-100,20},{-100,14},{-82,14}}, color={0,0,127}));
                  connect(retDamMinFre.y, yRetDamPos)
                    annotation (Line(points={{142,40},{180,40}}, color={0,0,127}));
                  connect(mod.yOutDamPos, outDamMaxFre.u1)
                    annotation (Line(points={{62,4},{110,4},{110,-34},{118,-34}}, color={0,0,127}));
                  connect(outDamMaxFre.y, yOutDamPos)
                    annotation (Line(points={{142,-40},{180,-40}}, color={0,0,127}));
                  connect(outDamMaxFre.u2, noTMix1.y)
                    annotation (Line(points={{118,-46},{102,-46}}, color={0,0,127}));
                  connect(mod.yRetDamPos, retDamMinFre.u2)
                    annotation (Line(points={{62,16},{110,16},{110,34},{118,34}}, color={0,0,127}));
                  connect(retDamMinFre.u1, noTMix.y)
                    annotation (Line(points={{118,46},{98,46}}, color={0,0,127}));
                  connect(TMix, freProTMix.TMix)
                    annotation (Line(points={{-180,-50},{-120,-50},{-120,-60},{60,-60},{60,-10},
                      {78,-10}}, color={0,0,127}));
                  connect(freProTMix.yFrePro, retDamMinFre.u1)
                    annotation (Line(points={{102,-13},{104,-13},{104,46},{118,46}}, color={0,0,127}));
                  connect(freProTMix.yFreProInv, outDamMaxFre.u2)
                    annotation (Line(points={{102,-7},{104,-7},{104,-46},{118,-46}},
                      color={0,0,127}));
                  connect(freProSta.y, damLim.uFreProSta)
                    annotation (Line(points={{-118,-130},{-90,-130},{-90,6},{-82,6}}, color={255,127,0}));
                  connect(freProSta.y, enaDis.uFreProSta)
                    annotation (Line(points={{-118,-130},{-60,-130},{-60,-30},{-2,-30}}, color={255,127,0}));

                annotation (
                    defaultComponentName="conEco",
                    Icon(coordinateSystem(extent={{-160,-160},{160,160}}),
                         graphics={
                        Rectangle(
                          extent={{-160,-160},{160,162}},
                          lineColor={0,0,127},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid),
                        Line(
                          points={{-96,-40},{-18,-40},{20,62},{58,62}},
                          color={0,0,127},
                          thickness=0.5),
                        Line(
                          points={{-92,62},{-14,62},{24,-36},{88,-36}},
                          color={0,0,127},
                          pattern=LinePattern.Dash,
                          thickness=0.5),
                        Line(
                          points={{58,62},{58,-14},{58,-26},{90,-26}},
                          color={0,0,127},
                          thickness=0.5),
                        Text(
                          extent={{-176,216},{152,178}},
                          lineColor={0,0,127},
                          textString="%name")}),
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-160,-160},{
                            160,160}}), graphics={Text(
                          extent={{-140,22},{-110,6}},
                          lineColor={95,95,95},
                          textString="Not included
in G36",                  horizontalAlignment=TextAlignment.Left),
                        Rectangle(
                          extent={{70,100},{150,-100}},
                          lineColor={0,0,127},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid),
                                                  Text(
                          extent={{76,-86},{154,-96}},
                          lineColor={95,95,95},
                          textString="Freeze protection based on TMix,
not a part of G36",       horizontalAlignment=TextAlignment.Left)}),
                    Documentation(info="<html>
<p>
Multi zone VAV AHU economizer control sequence that calculates
outdoor and return air damper positions based on ASHRAE
Guidline 36, PART 5 sections: N.2.c, N.5, N.6.c, N.7, A.17, N.12.
</p>
<p>
The sequence consists of three subsequences.
</p>
<ul>
<li>
First, the block <code>damLim</code> computes the damper position limits to satisfy
outdoor air requirements. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits</a>
for a description.
</li>
<li>
Second, the block <code>enaDis</code> enables or disables the economizer based on
outdoor temperature and optionally enthalpy, and based on the supply fan status,
freeze protection stage and zone state.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable</a>
for a description.
</li>
<li>
Third, the block <code>mod</code> modulates the outdoor and return damper position
to track the supply air temperature setpoint, subject to the limits of the damper positions
that were computed in the above two blocks.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation</a>
for a description.
</li>
</ul>
<p>
To enable freeze protection control logic that closes the outdoor air damper based
on the mixed air temperature <code>TMix</code>, set <code>use_TMix=true</code>.
This part of the control logic is not in Guideline 36, public review draft 1.
</p>
<p>
To enable the freeze protection according to Guideline 36, public review draft 1,
which may be revised in future versions, set
<code>use_G36FrePro=true</code>.
</p>
</html>",                 revisions="<html>
<ul>
<li>
October 11, 2017, by Michael Wetter:<br/>
Corrected implementation to use control loop signal as input.
</li>
<li>
June 28, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                end Controller;

                package Subsequences "Subsequences for economizer control"

                  block Enable
                    "Multi zone VAV AHU economizer enable/disable switch"

                    parameter Boolean use_enthalpy = true
                      "Set to true to evaluate outdoor air enthalpy in addition to temperature"
                      annotation(Dialog(group="Conditional"));
                    parameter Real delTOutHis(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="TemperatureDifference")=1
                      "Delta between the temperature hysteresis high and low limit"
                      annotation(Dialog(tab="Advanced", group="Hysteresis"));
                    parameter Real delEntHis(
                      final unit="J/kg",
                      final quantity="SpecificEnergy")=1000
                      "Delta between the enthalpy hysteresis high and low limits"
                      annotation(Dialog(tab="Advanced", group="Hysteresis", enable = use_enthalpy));
                    parameter Real retDamFulOpeTim(
                      final unit="s",
                      final quantity="Time")=180
                      "Time period to keep RA damper fully open before releasing it for minimum outdoor airflow control
    at disable to avoid pressure fluctuations"
                      annotation(Dialog(tab="Advanced", group="Delays at disable"));
                    parameter Real disDel(
                      final unit="s",
                      final quantity="Time")=15
                      "Short time delay before closing the OA damper at disable to avoid pressure fluctuations"
                      annotation(Dialog(tab="Advanced", group="Delays at disable"));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      TOut(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Outdoor air temperature" annotation (Placement(
                          transformation(extent={{-320,250},{-280,290}}),
                          iconTransformation(extent={{-140,80},{-100,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      hOut(final unit="J/kg", final quantity="SpecificEnergy")
                      if use_enthalpy "Outdoor air enthalpy" annotation (
                        Placement(transformation(extent={{-320,170},{-280,210}}),
                          iconTransformation(extent={{-140,40},{-100,80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      TOutCut(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "OA temperature high limit cutoff. For differential dry bulb temeprature condition use return air temperature measurement"
                      annotation (Placement(transformation(extent={{-320,210},{
                              -280,250}}), iconTransformation(extent={{-140,60},
                              {-100,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      hOutCut(final unit="J/kg", final quantity=
                          "SpecificEnergy") if use_enthalpy
                      "OA enthalpy high limit cutoff. For differential enthalpy use return air enthalpy measurement"
                      annotation (Placement(transformation(extent={{-320,130},{
                              -280,170}}), iconTransformation(extent={{-140,20},
                              {-100,60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uOutDamPosMin(
                      final unit="1",
                      final min=0,
                      final max=1)
                      "Minimum outdoor air damper position, output from damper position limits sequence"
                      annotation (Placement(transformation(extent={{-320,-80},{
                              -280,-40}}), iconTransformation(extent={{-140,-60},
                              {-100,-20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uOutDamPosMax(
                      final unit="1",
                      final min=0,
                      final max=1)
                      "Maximum outdoor air damper position, output from damper position limits sequence"
                      annotation (Placement(transformation(extent={{-320,-40},{
                              -280,0}}), iconTransformation(extent={{-140,-40},
                              {-100,0}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uRetDamPosMax(
                      final unit="1",
                      final min=0,
                      final max=1)
                      "Maximum return air damper position, output from damper position limits sequence"
                      annotation (Placement(transformation(extent={{-320,-160},
                              {-280,-120}}), iconTransformation(extent={{-140,-100},
                              {-100,-60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uRetDamPosMin(
                      final unit="1",
                      final min=0,
                      final max=1)
                      "Minimum return air damper position, output from damper position limits sequence"
                      annotation (Placement(transformation(extent={{-320,-200},
                              {-280,-160}}), iconTransformation(extent={{-140,-120},
                              {-100,-80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uRetDamPhyPosMax(
                      final unit="1",
                      final min=0,
                      final max=1)
                      "Physical maximum return air damper position, output from damper position limits sequence"
                      annotation (Placement(transformation(extent={{-320,-120},
                              {-280,-80}}), iconTransformation(extent={{-140,-80},
                              {-100,-40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                      uSupFan "Supply fan on/off status signal" annotation (
                        Placement(transformation(extent={{-320,80},{-280,120}}),
                          iconTransformation(extent={{-140,0},{-100,40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                      uFreProSta "Freeze protection stage status signal"
                      annotation (Placement(transformation(extent={{-320,30},{-280,
                              70}}), iconTransformation(extent={{-140,-20},{-100,
                              20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yOutDamPosMax(
                      final unit="1",
                      final min=0,
                      final max=1) "Maximum outdoor air damper position"
                      annotation (Placement(transformation(extent={{220,40},{
                              260,80}}), iconTransformation(extent={{100,40},{
                              140,80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yRetDamPosMin(
                      final unit="1",
                      final min=0,
                      final max=1) "Minimum return air damper position"
                      annotation (Placement(transformation(extent={{220,-80},{
                              260,-40}}), iconTransformation(extent={{100,-80},
                              {140,-40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yRetDamPosMax(
                      final unit="1",
                      final min=0,
                      final max=1) "Maximum return air damper position"
                      annotation (Placement(transformation(extent={{220,-20},{
                              260,20}}), iconTransformation(extent={{100,-20},{
                              140,20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold
                      truFalHol(trueHoldDuration=600) "10 min on/off delay"
                      annotation (Placement(transformation(extent={{0,200},{20,
                              220}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And andEnaDis
                      "Logical and that checks freeze protection stage and zone state"
                      annotation (Placement(transformation(extent={{40,30},{60,
                              50}})));

                  protected
                    final parameter Real TOutHigLimCutHig(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="TemperatureDifference")= 0
                      "Hysteresis high limit cutoff";
                    final parameter Real TOutHigLimCutLow = TOutHigLimCutHig - delTOutHis
                      "Hysteresis low limit cutoff";
                    final parameter Real hOutHigLimCutHig(
                      final unit="J/kg",
                      final quantity="SpecificEnergy")= 0
                      "Hysteresis block high limit cutoff";
                    final parameter Real hOutHigLimCutLow = hOutHigLimCutHig - delEntHis
                      "Hysteresis block low limit cutoff";

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      entSubst(final k=false) if not use_enthalpy
                      "Deactivates outdoor air enthalpy condition if there is no enthalpy sensor"
                      annotation (Placement(transformation(extent={{-100,190},{
                              -80,210}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2(final k2=
                          -1) if use_enthalpy
                      "Add block determines difference between hOut and hOutCut"
                      annotation (Placement(transformation(extent={{-140,160},{
                              -120,180}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(final k2=
                          -1)
                      "Add block determines difference between TOut and TOutCut"
                      annotation (Placement(transformation(extent={{-140,240},{
                              -120,260}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis
                      hysOutTem(final uLow=TOutHigLimCutLow, final uHigh=
                          TOutHigLimCutHig)
                      "Outdoor air temperature hysteresis for both fixed and differential dry bulb temperature cutoff conditions"
                      annotation (Placement(transformation(extent={{-100,240},{
                              -80,260}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis
                      hysOutEnt(final uLow=hOutHigLimCutLow, final uHigh=
                          hOutHigLimCutHig) if use_enthalpy
                      "Outdoor air enthalpy hysteresis for both fixed and differential enthalpy cutoff conditions"
                      annotation (Placement(transformation(extent={{-100,160},{
                              -80,180}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch outDamSwitch
                      "Set maximum OA damper position to minimum at disable (after a given time delay)"
                      annotation (Placement(transformation(extent={{62,-60},{82,
                              -40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch retDamSwitch
                      "Set minimum RA damper position to maximum at disable"
                      annotation (Placement(transformation(extent={{-40,-162},{
                              -20,-142}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch maxRetDamSwitch
                      "Keep maximum RA damper position at physical maximum for a short time period after disable signal"
                      annotation (Placement(transformation(extent={{40,-120},{
                              60,-100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch minRetDamSwitch
                      "Keep minimum RA damper position at physical maximum for a short time period after disable"
                      annotation (Placement(transformation(extent={{40,-160},{
                              60,-140}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Nor nor1
                      "Logical nor" annotation (Placement(transformation(extent
                            ={{-40,200},{-20,220}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not2
                      "Logical not that starts the timer at disable signal "
                      annotation (Placement(transformation(extent={{-80,-40},{-60,
                              -20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2
                      "Logical and" annotation (Placement(transformation(extent
                            ={{140,-80},{160,-60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1
                      "Logical and checks supply fan status" annotation (
                        Placement(transformation(extent={{0,100},{20,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and3
                      "Logical and which checks supply fan status" annotation (
                        Placement(transformation(extent={{20,-36},{40,-16}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu
                      "Logical block to check if the freeze protection is deactivated"
                      annotation (Placement(transformation(extent={{-98,50},{-78,
                              70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay delOutDamOsc(final
                        delayTime=disDel)
                      "Small delay before closing the outdoor air damper to avoid pressure fluctuations"
                      annotation (Placement(transformation(extent={{-40,-40},{-20,
                              -20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay delRetDam(final
                        delayTime=retDamFulOpeTim)
                      "Keep return damper open to its physical maximum for a short period of time before closing the outdoor air damper and resuming the maximum return air damper position, per G36 Part N7"
                      annotation (Placement(transformation(extent={{-40,-90},{-20,
                              -70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                      "Logical not" annotation (Placement(transformation(extent
                            ={{0,-90},{20,-70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      conInt(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                      "Integer constant, stage 0" annotation (Placement(
                          transformation(extent={{-138,30},{-118,50}})));

                  equation
                    connect(TOut, add1.u1)
                      annotation (Line(points={{-300,270},{-270,270},{-270,256},{-142,256}},color={0,0,127}));
                    connect(TOutCut, add1.u2)
                      annotation (Line(points={{-300,230},{-252,230},{-252,244},{-142,244}},color={0,0,127}));
                    connect(add1.y, hysOutTem.u)
                      annotation (Line(points={{-118,250},{-102,250}}, color={0,0,127}));
                    connect(hOut, add2.u1)
                      annotation (Line(points={{-300,190},{-252,190},{-252,176},{-142,176}},color={0,0,127}));
                    connect(hOutCut, add2.u2)
                      annotation (Line(points={{-300,150},{-252,150},{-252,164},{-142,164}}, color={0,0,127}));
                    connect(add2.y, hysOutEnt.u)
                      annotation (Line(points={{-118,170},{-102,170}}, color={0,0,127}));
                    connect(hysOutTem.y, nor1.u1)
                      annotation (Line(points={{-78,250},{-60,250},{-60,210},{-42,210}},color={255,0,255}));
                    connect(hysOutEnt.y, nor1.u2)
                      annotation (Line(points={{-78,170},{-60,170},{-60,202},{-42,202}},color={255,0,255}));
                    connect(entSubst.y, nor1.u2)
                      annotation (Line(points={{-78,200},{-60,200},{-60,202},{-42,202}},color={255,0,255}));
                    connect(uOutDamPosMin, outDamSwitch.u1)
                      annotation (Line(points={{-300,-60},{-10,-60},{-10,-42},{60,-42}},color={0,0,127}));
                    connect(uOutDamPosMax, outDamSwitch.u3)
                      annotation (Line(points={{-300,-20},{-240,-20},{-240,-58},{60,-58}},color={0,0,127}));
                    connect(uRetDamPhyPosMax, maxRetDamSwitch.u1)
                      annotation (Line(points={{-300,-100},{-178,-100},{-178,-102},{38,-102}},color={0,0,127}));
                    connect(uRetDamPosMax, maxRetDamSwitch.u3)
                      annotation (Line(points={{-300,-140},{-178,-140},{-178,-118},{38,-118}},color={0,0,127}));
                    connect(nor1.y, truFalHol.u)
                      annotation (Line(points={{-18,210},{-2,210}}, color={255,0,255}));
                    connect(andEnaDis.y, not2.u)
                      annotation (Line(points={{62,40},{72,40},{72,10},{-100,10},{-100,-30},{-82,-30}},
                        color={255,0,255}));
                    connect(maxRetDamSwitch.y, yRetDamPosMax)
                      annotation (Line(points={{62,-110},{180,-110},{180,0},{240,0}},color={0,0,127}));
                    connect(and2.y, maxRetDamSwitch.u2)
                      annotation (Line(points={{162,-70},{170,-70},{170,-130},{20,-130},{20,-110},
                        {38,-110}}, color={255,0,255}));
                    connect(and2.y, minRetDamSwitch.u2)
                      annotation (Line(points={{162,-70},{170,-70},{170,-130},{20,-130},{20,-150},
                        {38,-150}}, color={255,0,255}));
                    connect(not2.y, retDamSwitch.u2)
                      annotation (Line(points={{-58,-30},{-50,-30},{-50,-152},{-42,-152}},color={255,0,255}));
                    connect(uRetDamPosMax, retDamSwitch.u1)
                      annotation (Line(points={{-300,-140},{-240,-140},{-240,-144},{-42,-144}},color={0,0,127}));
                    connect(uRetDamPosMin, retDamSwitch.u3)
                      annotation (Line(points={{-300,-180},{-172,-180},{-172,-160},{-42,-160}},color={0,0,127}));
                    connect(retDamSwitch.y, minRetDamSwitch.u3)
                      annotation (Line(points={{-18,-152},{0,-152},{0,-158},{38,-158}},color={0,0,127}));
                    connect(uRetDamPhyPosMax, minRetDamSwitch.u1)
                      annotation (Line(points={{-300,-100},{-220,-100},{-220,-130},{0,-130},{0,-142},{38,-142}},
                        color={0,0,127}));
                    connect(truFalHol.y, and1.u1)
                      annotation (Line(points={{22,210},{30,210},{30,130},{-10,130},{-10,110},
                        {-2,110}}, color={255,0,255}));
                    connect(and1.y, andEnaDis.u1)
                      annotation (Line(points={{22,110},{22,110},{30,110},{30,40},{38,40}},color={255,0,255}));
                    connect(uSupFan, and1.u2)
                      annotation (Line(points={{-300,100},{-152,100},{-152,102},{-2,102}},color={255,0,255}));
                    connect(outDamSwitch.u2, and3.y)
                      annotation (Line(points={{60,-50},{50,-50},{50,-26},{42,-26}},color={255,0,255}));
                    connect(not2.y, and3.u1)
                      annotation (Line(points={{-58,-30},{-50,-30},{-50,-4},{8,-4},{8,-26},{18,-26}},
                      color={255,0,255}));
                    connect(and2.u1, not2.y)
                      annotation (Line(points={{138,-70},{106,-70},{106,-4},{-50,-4},{-50,-30},
                        {-58,-30}}, color={255,0,255}));
                    connect(and3.u2, delOutDamOsc.y)
                      annotation (Line(points={{18,-34},{0,-34},{0,-30},{-18,-30}},color={255,0,255}));
                    connect(delOutDamOsc.u, not2.y)
                      annotation (Line(points={{-42,-30},{-46,-30},{-46,-30},{-50,-30},{-50,-30},
                        {-58,-30}}, color={255,0,255}));
                    connect(not2.y, delRetDam.u)
                      annotation (Line(points={{-58,-30},{-50,-30},{-50,-80},{-42,-80}},color={255,0,255}));
                    connect(delRetDam.y, not1.u)
                      annotation (Line(points={{-18,-80},{-14,-80},{-14,-80},{-10,-80},{-10,-80},
                        {-2,-80}}, color={255,0,255}));
                    connect(not1.y, and2.u2)
                      annotation (Line(points={{22,-80},{80,-80},{80,-78},{138,-78}},color={255,0,255}));
                    connect(uFreProSta, intEqu.u1)
                      annotation (Line(points={{-300,50},{-240,50},{-240,60},{-100,60}},color={255,127,0}));
                    connect(conInt.y, intEqu.u2)
                      annotation (Line(points={{-116,40},{-110,40},{-110,52},{-100,52}},color={255,127,0}));
                    connect(intEqu.y, andEnaDis.u2)
                      annotation (Line(points={{-76,60},{20,60},{20,32},{38,32}},color={255,0,255}));
                    connect(outDamSwitch.y, yOutDamPosMax)
                      annotation (Line(points={{84,-50},{170,-50},{170,60},{240,60}}, color={0,0,127}));
                    connect(minRetDamSwitch.y, yRetDamPosMin)
                      annotation (Line(points={{62,-150},{190,-150},{190,-60},{240,-60}}, color={0,0,127}));

                  annotation (
                      defaultComponentName = "enaDis",
                      Icon(graphics={
                          Rectangle(
                            extent={{-100,-100},{100,100}},
                            lineColor={0,0,127},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-174,142},{154,104}},
                            lineColor={0,0,127},
                            textString="%name"),
                          Line(
                            points={{0,60},{80,60}},
                            color={0,0,127},
                            thickness=0.5),
                          Line(
                            points={{-80,-60},{0,-60},{0,60}},
                            color={0,0,127},
                            thickness=0.5)}),
                      Diagram(coordinateSystem(
                          preserveAspectRatio=false,
                          extent={{-280,-240},{220,280}},
                          initialScale=0.05),              graphics={
                          Rectangle(
                            extent={{-260,16},{200,-232}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-260,76},{200,24}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-260,136},{200,84}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-260,272},{200,144}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                                                       Text(
                            extent={{102,168},{184,156}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Outdoor air
conditions"),                                          Text(
                            extent={{100,70},{278,36}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Freeze protection -
disable if stage1
and above"),                                           Text(
                            extent={{100,-180},{268,-228}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Damper position
limit assignments
with delays"),                                     Text(
                            extent={{100,102},{194,92}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Supply fan status")}),
                  Documentation(info="<html>
<p>
This is a multi zone VAV AHU economizer enable/disable sequence
based on ASHRAE G36 PART 5.N.7 and PART 5.A.17. Additional
conditions included in the sequence are: freeze protection (freeze protection
stage 0-3, see PART 5.N.12), supply fan status (on or off, see PART 5.N.5).
</p>
<p>
The economizer is disabled whenever the outdoor air conditions
exceed the economizer high limit setpoint.
This sequence allows for all device types listed in
ASHRAE 90.1-2013 and Title 24-2013.
</p>
<p>
In addition, the economizer gets disabled without a delay whenever any of the
following is <code>true</code>:
</p>
<ul>
<li>
The supply fan is off (<code>uSupFan = false</code>),
</li>
<li>
the freeze protection stage
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages</a>
is not <code>stage0</code>.
</li>
</ul>
<p>
The following state machine chart illustrates the transitions between enabling and disabling:
</p>
<p align=\"center\">
<img alt=\"Image of economizer enable-disable state machine chart\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconEnableDisableStateMachineChart.png\"/>
</p>
<p>
After the disable signal is activated, the following procedure is applied, per PART 5.N.7.d, in order to
prevent pressure fluctuations in the HVAC system:
</p>
<ul>
<li>
The return damper gets fully opened (<code>yRetDamPosMax = uRetDamPhyPosMax</code> and
<code>yRetDamPosMin = uRetDamPhyPosMax</code>) for <code>retDamFulOpeTim</code>
time period, after which the return damper gets released to its minimum outdoor airflow control position
(<code>yRetDamPosMax = uRetDamPosMax</code> and <code>yRetDamPosMin = uRetDamPosMax</code>).
</li>
<li>
The outdoor air damper is closed to its minimum outoor airflow control limit (<code>yOutDamPosMax = uOutDamPosMin</code>)
after a <code>disDel</code> time delay.
</li>
</ul>
<p>
This sequence also has an overwrite of the damper positions to track
a minimum mixed air temperature of <code>TFreSet</code>, which is
by default set to <i>4</i>&deg;C (<i>39.2</i> F).
This is implemented using a proportional controller with a default deadband of
<i>1</i> K, which can be adjusted using the parameter <code>kPFrePro</code>.
</p>
</html>",                   revisions="<html>
<ul>
<li>
October 13, 2017, by Michael Wetter:<br/>
Added freeze protection that tracks mixed air temperature.
</li>
<li>
August 3, 2017, by Michael Wetter:<br/>
Removed unrequired input into block <code>and2</code> as this input
was always <code>true</code> if <code>and2.u2 = true</code>.
</li>
<li>
June 27, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Enable;

                  block Limits
                    "Multi zone VAV AHU minimum outdoor air control - damper position limits"

                    constant Real yMin=-1 "Lower limit of control loop signal"
                      annotation (Dialog(tab="Commissioning", group="Controller"));
                    constant Real yMax=1 "Upper limit of control loop signal"
                      annotation (Dialog(tab="Commissioning", group="Controller"));
                    parameter Real uRetDamMin(
                      final min=yMin,
                      final max=yMax,
                      final unit="1") = 0.5
                      "Minimum control signal for the return air damper position limit"
                      annotation (Dialog(tab="Commissioning", group="Controller"));

                    parameter
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                      controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                      "Type of controller"
                      annotation (Dialog(group="Controller"));

                    parameter Real k(
                      final unit="1")=0.05 "Gain of damper limit controller"
                      annotation (Dialog(group="Controller"));

                    parameter Real Ti(
                      final unit="s",
                      final quantity="Time")=1200
                      "Time constant of damper limit controller integrator block"
                      annotation (Dialog(group="Controller",
                      enable=controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                             or controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                    parameter Real Td(
                      final unit="s",
                      final quantity="Time")=0.1
                    "Time constant of damper limit controller derivative block"
                      annotation (Dialog(group="Controller",
                      enable=controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                             or controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                    parameter Real retDamPhyPosMax(
                      final min=0,
                      final max=1,
                      final unit="1") = 1 "Physically fixed maximum position of the return air damper"
                      annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                    parameter Real retDamPhyPosMin(
                      final min=0,
                      final max=1,
                      final unit="1") = 0
                      "Physically fixed minimum position of the return air damper"
                      annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                    parameter Real outDamPhyPosMax(
                      final min=0,
                      final max=1,
                      final unit="1") = 1
                      "Physically fixed maximum position of the outdoor air damper"
                      annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));
                    parameter Real outDamPhyPosMin(
                      final min=0,
                      final max=1,
                      final unit="1") = 0
                      "Physically fixed minimum position of the outdoor air damper"
                      annotation (Dialog(tab="Commissioning", group="Physical damper position limits"));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VOut_flow_normalized(final unit="1")
                      "Measured outdoor volumetric airflow rate, normalized by design minimum outdoor airflow rate"
                      annotation (Placement(transformation(extent={{-220,150},{
                              -180,190}}), iconTransformation(extent={{-140,20},
                              {-100,60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VOutMinSet_flow_normalized(final unit="1")
                      "Effective minimum outdoor airflow setpoint, normalized by design minimum outdoor airflow rate"
                      annotation (Placement(transformation(extent={{-220,200},{
                              -180,240}}), iconTransformation(extent={{-140,60},
                              {-100,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                      uOpeMod "AHU operation mode status signal" annotation (
                        Placement(transformation(extent={{-220,-200},{-180,-160}}),
                          iconTransformation(extent={{-140,-100},{-100,-60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                      uFreProSta "Freeze protection status signal" annotation (
                        Placement(transformation(extent={{-220,-160},{-180,-120}}),
                          iconTransformation(extent={{-140,-60},{-100,-20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                      uSupFan "Supply fan status signal" annotation (Placement(
                          transformation(extent={{-220,-120},{-180,-80}}),
                          iconTransformation(extent={{-140,-20},{-100,20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yOutDamPosMin(
                      final min=outDamPhyPosMin,
                      final max=outDamPhyPosMax,
                      final unit="1")
                      "Minimum outdoor air damper position limit" annotation (
                        Placement(transformation(extent={{180,80},{220,120}}),
                          iconTransformation(extent={{100,60},{140,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yOutDamPosMax(
                      final min=outDamPhyPosMin,
                      final max=outDamPhyPosMax,
                      final unit="1")
                      "Maximum outdoor air damper position limit" annotation (
                        Placement(transformation(extent={{180,30},{220,70}}),
                          iconTransformation(extent={{100,20},{140,60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yRetDamPosMin(
                      final min=retDamPhyPosMin,
                      final max=retDamPhyPosMax,
                      final unit="1")
                      "Minimum return air damper position limit" annotation (
                        Placement(transformation(extent={{180,-20},{220,20}}),
                          iconTransformation(extent={{100,-20},{140,20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yRetDamPosMax(
                      final min=retDamPhyPosMin,
                      final max=retDamPhyPosMax,
                      final unit="1")
                      "Maximum return air damper position limit" annotation (
                        Placement(transformation(extent={{180,-70},{220,-30}}),
                          iconTransformation(extent={{100,-60},{140,-20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yRetDamPhyPosMax(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Physical maximum return air damper position limit. Required as an input for the economizer enable disable sequence"
                      annotation (Placement(transformation(extent={{180,-110},{
                              220,-70}}), iconTransformation(extent={{100,-100},
                              {140,-60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID damLimCon(
                      final controllerType=controllerType,
                      final k=k,
                      final Ti=Ti,
                      final Td=Td,
                      final yMax=yMax,
                      final yMin=yMin,
                      reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter)
                      "Damper position limit controller" annotation (Placement(
                          transformation(extent={{-140,180},{-120,200}})));

                  protected
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      outDamPhyPosMinSig(final k=outDamPhyPosMin)
                      "Physically fixed minimum position of the outdoor air damper. This is the initial position of the economizer damper"
                      annotation (Placement(transformation(extent={{-160,70},{-140,
                              90}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      outDamPhyPosMaxSig(final k=outDamPhyPosMax)
                      "Physically fixed maximum position of the outdoor air damper."
                      annotation (Placement(transformation(extent={{-160,30},{-140,
                              50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      retDamPhyPosMinSig(final k=retDamPhyPosMin)
                      "Physically fixed minimum position of the return air damper"
                      annotation (Placement(transformation(extent={{-160,-10},{
                              -140,10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      retDamPhyPosMaxSig(final k=retDamPhyPosMax)
                      "Physically fixed maximum position of the return air damper. This is the initial condition of the return air damper"
                      annotation (Placement(transformation(extent={{-160,-50},{
                              -140,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      minSigLim(final k=yMin)
                      "Equals minimum controller output signal" annotation (
                        Placement(transformation(extent={{-100,200},{-80,220}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      maxSigLim(final k=yMax)
                      "Equals maximum controller output signal" annotation (
                        Placement(transformation(extent={{-20,200},{0,220}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      sigFraForOutDam(final k=uRetDamMin) "Equals the fraction of the control loop signal below which the outdoor air damper
    limit gets modulated and above which the return air damper limit gets modulated"
                      annotation (Placement(transformation(extent={{-60,200},{-40,
                              220}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line minOutDam(final
                        limitBelow=true, final limitAbove=true)
                      "Linear mapping of the outdoor air damper position to the control signal"
                      annotation (Placement(transformation(extent={{120,140},{
                              140,160}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line minRetDam(final
                        limitBelow=true, final limitAbove=true)
                      "Linear mapping of the return air damper position to the control signal"
                      annotation (Placement(transformation(extent={{120,100},{
                              140,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch retDamPosMinSwitch
                      "A switch to deactivate the return air damper minimal outdoor airflow control"
                      annotation (Placement(transformation(extent={{40,-30},{60,
                              -10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch outDamPosMaxSwitch
                      "A switch to deactivate the outdoor air damper minimal outdoor airflow control"
                      annotation (Placement(transformation(extent={{40,10},{60,
                              30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                      "Logical not block" annotation (Placement(transformation(
                            extent={{-8,-110},{12,-90}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      conInt(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                      "Freeze protection stage 1" annotation (Placement(
                          transformation(extent={{-160,-170},{-140,-150}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      conInt1(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "Occupied mode index" annotation (Placement(
                          transformation(extent={{-160,-210},{-140,-190}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.LessEqual intLesEqu
                      "Check if freeze protection stage is stage 0" annotation
                      (Placement(transformation(extent={{-120,-150},{-100,-130}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu
                      "Check if operation mode is occupied" annotation (
                        Placement(transformation(extent={{-120,-190},{-100,-170}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2
                      "Logical and" annotation (Placement(transformation(extent
                            ={{-80,-110},{-60,-90}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and3
                      "Logical and" annotation (Placement(transformation(extent
                            ={{-40,-110},{-20,-90}})));

                  equation
                    connect(minRetDam.y, yRetDamPosMax) annotation (Line(points={{142,110},{150,110},
                            {150,-50},{200,-50}}, color={0,0,127}));
                    connect(retDamPosMinSwitch.y, minRetDam.f2) annotation (Line(points={{62,-20},
                            {62,-18},{62,-20},{100,-20},{100,102},{118,102}}, color={0,0,127}));
                    connect(sigFraForOutDam.y, minRetDam.x1) annotation (Line(points={{-38,210},{-30,
                            210},{-30,118},{118,118}}, color={0,0,127}));
                    connect(maxSigLim.y, minRetDam.x2) annotation (Line(points={{2,210},{8,210},{8,
                            106},{118,106}}, color={0,0,127}));
                    connect(VOut_flow_normalized, damLimCon.u_m) annotation (Line(points={{-200,170},
                            {-130,170},{-130,178}}, color={0,0,127}));
                    connect(VOutMinSet_flow_normalized, damLimCon.u_s) annotation (Line(points={{-200,
                            220},{-160,220},{-160,190},{-142,190}}, color={0,0,127}));
                    connect(damLimCon.y, minRetDam.u) annotation (Line(points={{-118,190},{-80,190},
                            {-80,110},{118,110}},      color={0,0,127}));
                    connect(outDamPosMaxSwitch.y, minOutDam.f2) annotation (Line(points={{62,20},{
                            110,20},{110,142},{118,142}}, color={0,0,127}));
                    connect(minSigLim.y, minOutDam.x1) annotation (Line(points={{-78,210},{-70,210},
                            {-70,182},{104,182},{104,158},{118,158}},      color={0,0,127}));
                    connect(sigFraForOutDam.y, minOutDam.x2) annotation (Line(points={{-38,210},{-38,
                            210},{-30,210},{-30,146},{118,146}},     color={0,0,127}));
                    connect(damLimCon.y, minOutDam.u) annotation (Line(points={{-118,190},{-80,190},
                            {-80,150},{118,150}},      color={0,0,127}));
                    connect(outDamPosMaxSwitch.y, yOutDamPosMax) annotation (Line(points={{62,20},
                            {110,20},{110,50},{200,50}}, color={0,0,127}));
                    connect(minOutDam.y, yOutDamPosMin) annotation (Line(points={{142,150},{160,150},
                            {160,100},{200,100}},    color={0,0,127}));
                    connect(retDamPhyPosMaxSig.y, retDamPosMinSwitch.u1) annotation (Line(points={{-138,
                            -40},{-60,-40},{-60,-12},{38,-12}},   color={0,0,127}));
                    connect(retDamPhyPosMaxSig.y, minRetDam.f1) annotation (Line(points={{-138,-40},
                            {-60,-40},{-60,114},{118,114}}, color={0,0,127}));
                    connect(retDamPhyPosMinSig.y, retDamPosMinSwitch.u3) annotation (Line(points={{-138,0},
                            {-120,0},{-120,-28},{38,-28}},          color={0,0,127}));
                    connect(outDamPhyPosMaxSig.y, outDamPosMaxSwitch.u3) annotation (Line(points={{-138,40},
                            {-120,40},{-120,12},{38,12}},           color={0,0,127}));
                    connect(outDamPhyPosMinSig.y, outDamPosMaxSwitch.u1) annotation (Line(points={{-138,80},
                            {0,80},{0,28},{38,28}},           color={0,0,127}));
                    connect(outDamPhyPosMinSig.y, minOutDam.f1) annotation (Line(points={{-138,80},
                            {0,80},{0,154},{118,154}}, color={0,0,127}));
                    connect(not1.y, retDamPosMinSwitch.u2) annotation (Line(points={{14,-100},{20,
                            -100},{20,-20},{38,-20}},color={255,0,255}));
                    connect(not1.y, outDamPosMaxSwitch.u2) annotation (Line(points={{14,-100},{20,
                            -100},{20,20},{38,20}},color={255,0,255}));
                    connect(retDamPosMinSwitch.y, yRetDamPosMin) annotation (Line(points={{62,-20},
                            {100,-20},{100,0},{200,0}}, color={0,0,127}));
                    connect(retDamPhyPosMaxSig.y, yRetDamPhyPosMax) annotation (Line(points={{-138,
                            -40},{40,-40},{40,-90},{200,-90}}, color={0,0,127}));
                    connect(uOpeMod, intEqu.u1)
                      annotation (Line(points={{-200,-180},{-122,-180}}, color={255,127,0}));
                    connect(conInt1.y, intEqu.u2)
                      annotation (Line(points={{-138,-200},{-130,-200},{-130,-188},{-122,-188}},
                        color={255,127,0}));
                    connect(conInt.y, intLesEqu.u2)
                      annotation (Line(points={{-138,-160},{-130,-160},{-130,-148},{-122,-148}},
                        color={255,127,0}));
                    connect(uFreProSta, intLesEqu.u1)
                      annotation (Line(points={{-200,-140},{-122,-140}}, color={255,127,0}));
                    connect(damLimCon.trigger, uSupFan)
                      annotation (Line(points={{-138,178},{-138,166},{-100,166},{-100,-100},{-200,
                            -100}},               color={255,0,255}));
                    connect(uSupFan, and2.u1) annotation (Line(points={{-200,-100},{-140,-100},{-140,
                            -100},{-82,-100}}, color={255,0,255}));
                    connect(intLesEqu.y, and2.u2) annotation (Line(points={{-98,-140},{-90,-140},{
                            -90,-108},{-82,-108}}, color={255,0,255}));
                    connect(and2.y, and3.u1)
                      annotation (Line(points={{-58,-100},{-42,-100}}, color={255,0,255}));
                    connect(and3.y, not1.u)
                      annotation (Line(points={{-18,-100},{-10,-100}}, color={255,0,255}));
                    connect(intEqu.y, and3.u2) annotation (Line(points={{-98,-180},{-50,-180},{-50,
                            -108},{-42,-108}}, color={255,0,255}));

                  annotation (
                      defaultComponentName="damLim",
                      Icon(graphics={
                          Rectangle(
                            extent={{-100,-100},{100,100}},
                            lineColor={0,0,127},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-88,138},{88,108}},
                            lineColor={0,0,127},
                            textString="%name"),
                          Line(
                            points={{-60,-60},{2,62},{2,62},{64,-60},{-60,-60}},
                            color={0,0,127},
                            thickness=0.5)}),
                      Diagram(coordinateSystem(extent={{-180,-240},{180,240}}), graphics={
                          Rectangle(
                            extent={{-172,-74},{16,-234}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-172,232},{16,128}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{24,232},{172,-232}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-172,124},{16,-68}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{26,230},{172,184}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Damper position limit
calculation and
assignments"),            Text(
                            extent={{-170,160},{-4,130}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Physical damper position
limits set at commissioning"),
                          Text(
                            extent={{28,78},{150,30}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Switches to deactivate
limit modulation"),       Text(
                            extent={{-80,-196},{124,-226}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Enable/disable conditions
for damper position limits
control loop"),           Text(
                            extent={{-170,126},{14,94}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Damper position limits
outdoor air volume flow
control loop")}),     Documentation(info="<html>
<p>
This block models the multi zone VAV AHU minimum outdoor air control with a single
common damper for minimum outdoor air and economizer functions based on outdoor airflow
measurement, designed in line with ASHRAE Guidline 36 (G36), PART 5.N.6.c.
</p>
<p>
The controller is enabled when the supply fan is proven on (<code>uSupFan=true</code>),
the AHU operation mode <a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.OperationModes</a> equals <code>occupied</code>,
and the freeze protection stage <a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages</a> is <code>stage1</code> or lower.
Otherwise the damper position limits are set to their corresponding maximum and minimum physical or at
commissioning fixed limits. The state machine chart below illustrates listed conditions:
</p>
<p align=\"center\">
<img alt=\"Image of damper position limits state machine chart\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconDamperLimitsStateMachineChart.png\"/>
</p>
<p>
The controller sets the outdoor and return damper position limits so
that the outdoor airflow rate <code>VOut_flow</code> stays equal or above the
minimum outdoor air setpoint <code>VOutMinSet_flow</code>. The fraction of the controller
output signal between <code>yMin</code> and <code>uRetDamMin</code> is
linearly mapped to the outdoor air damper minimal position <code>yOutDamPosMin</code>
while the fraction of the controller output between <code>uRetDamMin</code> and
<code>yMax</code> is linearly mapped to the return air damper maximum position
<code>yRetDamPosMax</code>. Thus the dampers are not interlocked.
</p>
<p>
The following control charts show the input/output structure and an expected damper position
limits for a well configured controller.
</p>
<p align=\"center\">
<img alt=\"Image of damper position limits control diagram\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconDamperLimitsControlDiagram.png\"/>
</p>
<p>
The expected damper position limits vs. the control loop signal are as follows:
</p>
<p align=\"center\">
<img alt=\"Image of damper position limits control chart\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconDamperLimitsControlChart.png\"/>
</p>
</html>",                   revisions="<html>
<ul>
<li>
March 14, 2020, by Jianjun Hu:<br/>
Replaced mulAnd by logic and block to avoid vector-valued calculation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
July 17, 2017, by Michael Wetter:<br/>
Replaced block that checks for equality of real values within a tolerance
by two inequality checks.
</li>
<li>
June 06, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Limits;

                  block Modulation
                    "Outdoor and return air damper position modulation sequence for multi zone VAV AHU"

                    parameter Real uMin(
                      final max=0,
                      final unit="1")=-0.25
                      "Lower limit of controller input when outdoor damper opens (see diagram)"
                      annotation (Dialog(tab="Commissioning", group="Controller"));
                    parameter Real uMax(
                      final min=0,
                      final unit="1")=+0.25
                      "Upper limit of controller input when return damper is closed (see diagram)"
                      annotation (Dialog(tab="Commissioning", group="Controller"));
                    parameter Real uOutDamMax(
                      final min=-1,
                      final max=1,
                      final unit="1") = (uMin + uMax)/2
                      "Maximum loop signal for the OA damper to be fully open"
                      annotation (Dialog(tab="Commissioning", group="Controller"));
                    parameter Real uRetDamMin(
                      final min=-1,
                      final max=1,
                      final unit="1") = (uMin + uMax)/2
                      "Minimum loop signal for the RA damper to be fully open"
                      annotation (Dialog(tab="Commissioning", group="Controller"));
                    parameter Real samplePeriod(
                       final unit="s",
                       final quantity="Time")= 300
                      "Sample period of component, used to limit the rate of change of the dampers (to avoid quick opening that can result in frost)";

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uTSup(final unit="1")
                      "Signal for supply air temperature control (T Sup Control Loop Signal in diagram)"
                      annotation (Placement(transformation(extent={{-160,-20},{
                              -120,20}}), iconTransformation(extent={{-140,-20},
                              {-100,20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uOutDamPosMin(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Minimum economizer damper position limit as returned by the damper position limits  sequence"
                      annotation (Placement(transformation(extent={{-160,-120},
                              {-120,-80}}), iconTransformation(extent={{-140,-110},
                              {-100,-70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uOutDamPosMax(
                      final min=0,
                      final max=1,
                      final unit="1") "Maximum economizer damper position limit as returned by the economizer enable-disable sequence.
    If the economizer is disabled, this value equals uOutDamPosMin" annotation
                      (Placement(transformation(extent={{-160,-70},{-120,-30}}),
                          iconTransformation(extent={{-140,-70},{-100,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uRetDamPosMin(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Minimum return air damper position limit as returned by the economizer enable-disable sequence"
                      annotation (Placement(transformation(extent={{-160,30},{-120,
                              70}}), iconTransformation(extent={{-140,30},{-100,
                              70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uRetDamPosMax(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Maximum return air damper position limit as returned by the economizer enable-disable sequence"
                      annotation (Placement(transformation(extent={{-160,80},{-120,
                              120}}), iconTransformation(extent={{-140,70},{-100,
                              110}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yOutDamPos(
                      final min=0,
                      final max=1,
                      final unit="1") "Economizer damper position" annotation (
                        Placement(transformation(extent={{120,-80},{160,-40}}),
                          iconTransformation(extent={{100,-80},{140,-40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yRetDamPos(
                      final min=0,
                      final max=1,
                      final unit="1") "Return air damper position" annotation (
                        Placement(transformation(extent={{120,40},{160,80}}),
                          iconTransformation(extent={{100,40},{140,80}})));

                  protected
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      outDamMinLimSig(final k=uMin)
                      "Minimal control loop signal for the outdoor air damper"
                      annotation (Placement(transformation(extent={{-60,-32},{-40,
                              -12}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      outDamMaxLimSig(final k=uOutDamMax)
                      "Maximum control loop signal for the outdoor air damper"
                      annotation (Placement(transformation(extent={{-100,-60},{
                              -80,-40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      retDamConMinLimSig(final k=uRetDamMin)
                      "Minimal control loop signal for the return air damper"
                      annotation (Placement(transformation(extent={{-80,68},{-60,
                              88}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      retDamMaxLimSig(final k=uMax)
                      "Maximal control loop signal for the return air damper"
                      annotation (Placement(transformation(extent={{-60,10},{-40,
                              30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line outDamPos(final
                        limitBelow=true, final limitAbove=true)
                      "Damper position is linearly proportional to the control signal between signal limits"
                      annotation (Placement(transformation(extent={{0,-40},{20,
                              -20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line retDamPos(final
                        limitBelow=true, final limitAbove=true)
                      "Damper position is linearly proportional to the control signal between signal limits"
                      annotation (Placement(transformation(extent={{0,60},{20,
                              80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min min
                      "Overwrite due to freeze protection" annotation (
                        Placement(transformation(extent={{60,-70},{80,-50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Max max
                      "Overwrite due to freeze protection" annotation (
                        Placement(transformation(extent={{60,50},{80,70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.FirstOrderHold
                      firOrdHolOutDam(final samplePeriod=samplePeriod)
                      "First order hold to avoid too fast opening/closing of damper (which may cause freeze protection to be too slow to compensate)"
                      annotation (Placement(transformation(extent={{92,-70},{
                              112,-50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.FirstOrderHold
                      firOrdHolRetDam(final samplePeriod=samplePeriod)
                      "First order hold to avoid too fast opening/closing of damper (which may cause freeze protection to be too slow to compensate)"
                      annotation (Placement(transformation(extent={{90,50},{110,
                              70}})));

                  equation
                    connect(outDamPos.x2, outDamMaxLimSig.y)
                      annotation (Line(points={{-2,-34},{-30,-34},{-30,-50},{-78,-50}},color={0,0,127}));
                    connect(outDamPos.x1, outDamMinLimSig.y)
                      annotation (Line(points={{-2,-22},{-38,-22}}, color={0,0,127}));
                    connect(outDamPos.f1, uOutDamPosMin)
                      annotation (Line(points={{-2,-26},{-24,-26},{-24,-100},{-140,-100}},color={0,0,127}));
                    connect(outDamPos.f2, uOutDamPosMax)
                      annotation (Line(points={{-2,-38},{-20,-38},{-20,-66},{-108,-66},{-108,-50},{-140,-50}},
                      color={0,0,127}));
                    connect(retDamPos.x2, retDamMaxLimSig.y)
                      annotation (Line(points={{-2,66},{-28,66},{-28,20},{-38,20}},color={0,0,127}));
                    connect(retDamPos.x1, retDamConMinLimSig.y)
                      annotation (Line(points={{-2,78},{-58,78}},color={0,0,127}));
                    connect(retDamPos.f1, uRetDamPosMax)
                      annotation (Line(points={{-2,74},{-48,74},{-48,100},{-140,100}},color={0,0,127}));
                    connect(retDamPos.f2, uRetDamPosMin)
                      annotation (Line(points={{-2,62},{-12,62},{-12,50},{-140,50}}, color={0,0,127}));
                    connect(min.u2, uOutDamPosMax)
                      annotation (Line(points={{58,-66},{-108,-66},{-108,-50},{-140,-50}},color={0,0,127}));
                    connect(min.u1, outDamPos.y)
                      annotation (Line(points={{58,-54},{28,-54},{28,-30},{22,-30}}, color={0,0,127}));
                    connect(max.u1, retDamPos.y)
                      annotation (Line(points={{58,66},{30,66},{30,70},{22,70}}, color={0,0,127}));
                    connect(uRetDamPosMin, max.u2)
                      annotation (Line(points={{-140,50},{-12,50},{-12,54},{58,54}}, color={0,0,127}));
                    connect(min.y, firOrdHolOutDam.u)
                      annotation (Line(points={{82,-60},{90,-60}}, color={0,0,127}));
                    connect(firOrdHolOutDam.y, yOutDamPos)
                      annotation (Line(points={{114,-60},{140,-60}}, color={0,0,127}));
                    connect(uTSup, retDamPos.u)
                      annotation (Line(points={{-140,0},{-22,0},{-22,70},{-2,70}}, color={0,0,127}));
                    connect(uTSup, outDamPos.u)
                      annotation (Line(points={{-140,0},{-22,0},{-22,-30},{-2,-30}}, color={0,0,127}));
                    connect(max.y, firOrdHolRetDam.u)
                      annotation (Line(points={{82,60},{88,60}}, color={0,0,127}));
                    connect(firOrdHolRetDam.y, yRetDamPos)
                      annotation (Line(points={{112,60},{140,60}}, color={0,0,127}));

                  annotation (
                      defaultComponentName="mod",
                      Icon(graphics={
                          Rectangle(
                            extent={{-100,-100},{100,100}},
                            lineColor={0,0,127},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid),
                          Line(points={{20,58}}, color={28,108,200}),
                          Line(
                            points={{-92,-84},{-50,-84},{12,70},{82,70}},
                            color={0,0,127},
                            thickness=0.5),
                          Line(
                            points={{-66,58},{12,58},{50,-76},{100,-76}},
                            color={0,0,127},
                            pattern=LinePattern.Dash,
                            thickness=0.5),
                          Text(
                            extent={{-108,138},{102,110}},
                            lineColor={0,0,127},
                            textString="%name")}),
                      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-120,-120},{
                              120,120}}), graphics={
                          Rectangle(
                            extent={{-26,118},{46,-118}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-118,118},{-34,-118}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-116,118},{-34,102}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Damper position supply
air temperature control loop"),
                          Text(
                            extent={{-24,118},{24,106}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Damper position
assignments"),            Rectangle(
                            extent={{52,118},{118,-118}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{54,118},{120,96}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Overwrite if the freeze protection
that tracks TFre at the measured
mixed air temperature limits the
damper position")}),  Documentation(info="<html>
<p>
This is a multi zone VAV AHU economizer modulation block. It calculates
the outdoor and return air damper positions based on the supply air temperature
control loop signal. The implementation is in line with ASHRAE
Guidline 36 (G36), PART 5.N.2.c. Damper positions are linearly mapped to
the supply air control loop signal. This is a final sequence in the
composite multi zone VAV AHU economizer control sequence. Damper position
limits, which are the inputs to the sequence, are the outputs of
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits</a> and
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable</a>
sequences.
</p>
<p>
When the economizer is enabled, the PI controller modulates the damper
positions. Return and outdoor damper are not interlocked. When the economizer is disabled,
the damper positions are set to the minimum outdoor air damper position limits.
</p>
<p>
The time rate of change of the damper signals is limited by a first order hold,
using the sample time <code>samplePeriod</code>.
This prevents a quick opening of the outdoor air damper, for example when the
outdoor airflow setpoint has a step change.
Slowing down the opening of the outdoor air damper allows the freeze protection
to componensate with its dynamics that is faster than the opening of the outdoor air damper.
To avoid that all dampers are closed, the return air damper has the same
time rate of change limitation.
</p>
<p>
The control charts below show the input-output structure and an economizer damper
modulation sequence assuming a well configured controller. Control diagram:
</p>
<p align=\"center\">
<img alt=\"Image of the multi zone AHU modulation sequence control diagram\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconModulationControlDiagram.png\"/>
</p>
<p>
Multi zone AHU economizer modulation control chart:
<br/>
</p>
<p align=\"center\">
<img alt=\"Image of the multi zone AHU modulation sequence expected performance\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/EconModulationControlChart.png\"/>
</p>
</html>",                   revisions="<html>
<ul>
<li>
October 13, 2017, by Michael Wetter:<br/>
Corrected implementation for when dampers are
such positioned that they prevent the mixed air temperature from being
below the freezing set point.
</li>
<li>
October 11, 2017, by Michael Wetter:<br/>
Corrected implementation to use control loop signal as input.
</li>
<li>
September 29, 2017, by Michael Wetter:<br/>
Corrected implementation by adding reverse action.
</li>
<li>
June 28, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Modulation;

                  package Validation "Collection of validation models"

                    model Enable_FreProSta
                      "Model validates economizer disable for heating zone state and activated freeze protection"
                      parameter Real TOutCutoff(
                        final unit="K",
                        final displayUnit="degC",
                        final quantity="ThermodynamicTemperature")=297.15
                        "Outdoor temperature high limit cutoff";
                      parameter Real hOutCutoff(
                        final unit="J/kg",
                        final quantity="SpecificEnergy")=65100
                        "Outdoor air enthalpy high limit cutoff";

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable
                        enaDis "Multi zone VAV AHU enable disable sequence"
                        annotation (Placement(transformation(extent={{60,-40},{
                                80,-20}})));

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutBelowCutoff(final k=TOutCutoff - 2)
                        "Outdoor air temperature is slightly below the cutoff"
                        annotation (Placement(transformation(extent={{-80,140},
                                {-60,160}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutCut(final k=TOutCutoff)
                        "OA temperature high limit cutoff" annotation (
                          Placement(transformation(extent={{-80,100},{-60,120}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutBelowCutoff(final k=hOutCutoff - 1000)
                        "Outdoor air enthalpy is slightly below the cutoff"
                        annotation (Placement(transformation(extent={{-140,80},
                                {-120,100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutCut(final k=hOutCutoff)
                        "Outdoor air enthalpy cutoff" annotation (Placement(
                            transformation(extent={{-140,40},{-120,60}})));

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMax(final k=0.9)
                        "Maximal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-110,-120},
                                {-90,-100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMin(final k=0.1)
                        "Minimal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-140,-150},
                                {-120,-130}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        retDamPhyPosMax(final k=1)
                        "Maximal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-140,0},{
                                -120,20}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        retDamPosMax(final k=0.8)
                        "Maximal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-110,-60},
                                {-90,-40}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        retDamPosMin(final k=0)
                        "Minimal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-110,-90},
                                {-90,-70}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        supFanSta(k=true) "Supply fan status" annotation (
                          Placement(transformation(extent={{-140,-40},{-120,-20}})));

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse
                        booPul1(period=1800)
                        "Boolean pulse for generating freeze protection stage"
                        annotation (Placement(transformation(extent={{-20,-160},
                                {0,-140}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                        freProSta1(integerTrue=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0,
                          integerFalse=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                        "Freeze protection stage changes from stage 0 to stage 1"
                        annotation (Placement(transformation(extent={{20,-160},
                                {40,-140}})));

                    equation
                      connect(TOutCut.y, enaDis.TOutCut)
                        annotation (Line(points={{-58,110},{-20,110},{-20,-22},{58,-22}},color={0,0,127}));
                      connect(TOutBelowCutoff.y, enaDis.TOut)
                        annotation (Line(points={{-58,150},{-10,150},{-10,-20},{58,-20}},color={0,0,127}));
                      connect(hOutBelowCutoff.y, enaDis.hOut)
                        annotation (Line(points={{-118,90},{-100,90},{-100,60},{-30,60},{-30,-24},{58,
                              -24}},
                        color={0,0,127}));
                      connect(hOutCut.y, enaDis.hOutCut)
                        annotation (Line(points={{-118,50},{-40,50},{-40,-26},{58,-26}},color={0,0,127}));
                      connect(outDamPosMin.y, enaDis.uOutDamPosMin)
                        annotation (Line(points={{-118,-140},{-30,-140},{-30,-34},{58,-34}},
                        color={0,0,127}));
                      connect(outDamPosMax.y, enaDis.uOutDamPosMax)
                        annotation (Line(points={{-88,-110},{-40,-110},{-40,-32},{58,-32}},color={0,0,127}));
                      connect(retDamPosMin.y, enaDis.uRetDamPosMin)
                        annotation (Line(points={{-88,-80},{48,-80},{48,-40},{58,-40}},color={0,0,127}));
                      connect(retDamPosMax.y, enaDis.uRetDamPosMax)
                        annotation (Line(points={{-88,-50},{-60,-50},{-60,-38},{58,-38}},
                        color={0,0,127}));
                      connect(retDamPhyPosMax.y, enaDis.uRetDamPhyPosMax)
                        annotation (Line(points={{-118,10},{-60,10},{-60,-36},{58,-36}},color={0,0,127}));
                      connect(supFanSta.y, enaDis.uSupFan)
                        annotation (Line(points={{-118,-30},{-70,-30},{-70,-28},{58,-28}},color={255,0,255}));
                      connect(booPul1.y, freProSta1.u)
                        annotation (Line(points={{2,-150},{4,-150},{4,-150},{8,-150},{8,-150},{18,-150}},
                        color={255,0,255}));
                      connect(freProSta1.y, enaDis.uFreProSta)
                        annotation (Line(points={{42,-150},{50,-150},{50,-120},{-20,-120},{-20,-30},
                              {58,-30}},
                        color={255,127,0}));
                      annotation (
                        experiment(StopTime=1800.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/Economizers/Subsequences/Validation/Enable_FreProSta.mos"
                        "Simulate and plot"),
                      Icon(graphics={
                            Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}),
                            Polygon(lineColor = {0,0,255},
                                    fillColor = {75,138,73},
                                    pattern = LinePattern.None,
                                    fillPattern = FillPattern.Solid,
                                    points={{-36,58},{64,-2},{-36,-62},{-36,58}})}), Diagram(
                            coordinateSystem(preserveAspectRatio=false, extent={{-180,-180},{180,180}}), graphics={
                            Text(
                              extent={{58,-38},{176,-64}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Tests freeze protection disable condition")}),
                    Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable</a>
for the following control signals: zone state, freeze protection stage.
</p>
</html>",                     revisions="<html>
<ul>
<li>
June 13, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Enable_FreProSta;

                    model Enable_TOut_hOut
                      "Model validates economizer disable in case outdoor air conditions are above cutoff"

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutCut(final k=TOutCutoff)
                        "Outdoor air temperature cutoff" annotation (Placement(
                            transformation(extent={{-160,80},{-140,100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutCut1(final k=hOutCutoff)
                        "Outdoor air enthalpy cutoff" annotation (Placement(
                            transformation(extent={{-40,40},{-20,60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TriggeredTrapezoid
                        TOut(
                        final rising=1000,
                        final falling=800,
                        final amplitude=4,
                        final offset=TOutCutoff - 2) "Outoor air temperature"
                        annotation (Placement(transformation(extent={{-160,150},
                                {-140,170}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TriggeredTrapezoid
                        hOut(
                        final amplitude=4000,
                        final offset=hOutCutoff - 2200,
                        final rising=1000,
                        final falling=800) "Outdoor air enthalpy" annotation (
                          Placement(transformation(extent={{-40,80},{-20,100}})));

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable
                        enaDis
                        "Multi zone VAV AHU economizer enable disable sequence"
                        annotation (Placement(transformation(extent={{-80,-40},
                                {-60,-20}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable
                        enaDis1
                        "Multi zone VAV AHU economizer enable disable sequence"
                        annotation (Placement(transformation(extent={{80,-40},{
                                100,-20}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable
                        enaDis2(final use_enthalpy=false)
                        "Multi zone VAV AHU economizer enable disable sequence"
                        annotation (Placement(transformation(extent={{220,-40},
                                {240,-20}})));

                    protected
                      final parameter Real TOutCutoff(
                        final unit="K",
                        final displayUnit="degC",
                        final quantity="ThermodynamicTemperature")=297.15
                        "Outdoor temperature high limit cutoff";
                      final parameter Real hOutCutoff(
                        final unit="J/kg",
                        final quantity="SpecificEnergy")=65100
                        "Outdoor air enthalpy high limit cutoff";

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutCut(final k=hOutCutoff)
                        "Outdoor air enthalpy cutoff" annotation (Placement(
                            transformation(extent={{-240,80},{-220,100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutCut1(final k=TOutCutoff)
                        "Outdoor air temperature cutoff" annotation (Placement(
                            transformation(extent={{0,80},{20,100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutBelowCutoff(final k=hOutCutoff - 1000)
                        "Outdoor air enthalpy is slightly below the cutoff"
                        annotation (Placement(transformation(extent={{-240,118},
                                {-220,138}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutBelowCutoff(final k=TOutCutoff - 2)
                        "Outdoor air temperature is slightly below the cutoff"
                        annotation (Placement(transformation(extent={{40,80},{
                                60,100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMax(final k=0.9)
                        "Maximal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-240,-80},
                                {-220,-60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMin(final k=0.1)
                        "Minimal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-240,-120},
                                {-220,-100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        retDamPosMax(final k=0.8)
                        "Maximal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-160,-160},
                                {-140,-140}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        retDamPosMin(final k=0)
                        "Minimal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-160,-200},
                                {-140,-180}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        retDamPhyPosMax(final k=1)
                        "Maximal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-160,-120},
                                {-140,-100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                        "Freeze Protection Status - Disabled" annotation (
                          Placement(transformation(extent={{-200,20},{-180,40}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        supFanSta(final k=true) "Supply fan status signal"
                        annotation (Placement(transformation(extent={{-200,-42},
                                {-180,-22}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse
                        booPul(final startTime=10, final period=2000)
                        "Boolean pulse signal" annotation (Placement(
                            transformation(extent={{-200,150},{-180,170}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse
                        booPul1(final startTime=10, final period=2000)
                        "Boolean pulse signal" annotation (Placement(
                            transformation(extent={{-80,80},{-60,100}})));

                    equation
                      connect(TOutCut.y, enaDis.TOutCut)
                        annotation (Line(points={{-138,90},{-112,90},{-112,-22},{-82,-22}}, color={0,0,127}));
                      connect(hOutCut.y, enaDis.hOutCut)
                        annotation (Line(points={{-218,90},{-186,90},{-186,58},{-138,58},{-138,-26},
                              {-82,-26}},
                          color={0,0,127}));
                      connect(freProSta.y, enaDis.uFreProSta)
                        annotation (Line(points={{-178,30},{-120,30},{-120,-30},{-82,-30}}, color={255,127,0}));
                      connect(outDamPosMax.y, enaDis.uOutDamPosMax)
                        annotation (Line(points={{-218,-70},{-150,-70},{-150,-32},{-82,-32}}, color={0,0,127}));
                      connect(outDamPosMin.y, enaDis.uOutDamPosMin)
                        annotation (Line(points={{-218,-110},{-210,-110},{-210,-60},{-140,-60},{-140,
                              -34},{-82,-34}},                                                                        color={0,0,127}));
                      connect(retDamPhyPosMax.y, enaDis.uRetDamPhyPosMax)
                        annotation (Line(points={{-138,-110},{-110,-110},{-110,-36},{-82,-36}}, color={0,0,127}));
                      connect(retDamPosMax.y, enaDis.uRetDamPosMax)
                        annotation (Line(points={{-138,-150},{-106,-150},{-106,-38},{-82,-38}}, color={0,0,127}));
                      connect(retDamPosMin.y, enaDis.uRetDamPosMin)
                        annotation (Line(points={{-138,-190},{-100,-190},{-100,-40},{-82,-40}}, color={0,0,127}));
                      connect(TOutCut1.y, enaDis1.TOutCut)
                        annotation (Line(points={{22,90},{30,90},{30,-22},{78,-22}}, color={0,0,127}));
                      connect(hOutCut1.y, enaDis1.hOutCut)
                        annotation (Line(points={{-18,50},{10,50},{10,-26},{78,-26}}, color={0,0,127}));
                      connect(hOutBelowCutoff.y, enaDis.hOut)
                        annotation (Line(points={{-218,128},{-180,128},{-180,66},{-130,66},{-130,-24},
                              {-82,-24}},
                        color={0,0,127}));
                      connect(TOutBelowCutoff.y, enaDis1.TOut)
                        annotation (Line(points={{62,90},{70,90},{70,-20},{78,-20},{78,-20}}, color={0,0,127}));
                      connect(booPul.y, TOut.u)
                        annotation (Line(points={{-178,160},{-162,160}}, color={255,0,255}));
                      connect(TOut.y, enaDis.TOut)
                        annotation (Line(points={{-138,160},{-110,160},{-110,-20},{-82,-20}}, color={0,0,127}));
                      connect(booPul1.y, hOut.u)
                        annotation (Line(points={{-58,90},{-58,90},{-42,90}}, color={255,0,255}));
                      connect(hOut.y, enaDis1.hOut)
                        annotation (Line(points={{-18,90},{-10,90},{-10,60},{20,60},{20,-24},{78,-24}}, color={0,0,127}));
                      connect(freProSta.y, enaDis1.uFreProSta)
                        annotation (Line(points={{-178,30},{-46,30},{-46,-30},{78,-30}}, color={255,127,0}));
                      connect(outDamPosMax.y, enaDis1.uOutDamPosMax)
                        annotation (Line(points={{-218,-70},{8,-70},{8,-32},{78,-32}}, color={0,0,127}));
                      connect(outDamPosMin.y, enaDis1.uOutDamPosMin)
                        annotation (Line(points={{-218,-110},{-190,-110},{-190,-64},{12,-64},{12,-34},
                              {78,-34}},
                          color={0,0,127}));
                      connect(retDamPhyPosMax.y, enaDis1.uRetDamPhyPosMax)
                        annotation (Line(points={{-138,-110},{16,-110},{16,-36},{78,-36}},color={0,0,127}));
                      connect(retDamPosMax.y, enaDis1.uRetDamPosMax)
                        annotation (Line(points={{-138,-150},{20,-150},{20,-38},{78,-38}},color={0,0,127}));
                      connect(retDamPosMin.y, enaDis1.uRetDamPosMin)
                        annotation (Line(points={{-138,-190},{30,-190},{30,-40},{78,-40}},color={0,0,127}));
                      connect(TOut.y, enaDis2.TOut)
                        annotation (Line(points={{-138,160},{200,160},{200,-20},{218,-20}},color={0,0,127}));
                      connect(TOutCut.y, enaDis2.TOutCut)
                        annotation (Line(points={{-138,90},{-120,90},{-120,120},{188,120},{188,-22},
                              {218,-22}},
                          color={0,0,127}));
                      connect(freProSta.y, enaDis2.uFreProSta)
                        annotation (Line(points={{-178,30},{170,30},{170,-30},{218,-30}}, color={255,127,0}));
                      connect(outDamPosMax.y, enaDis2.uOutDamPosMax)
                        annotation (Line(points={{-218,-70},{178,-70},{178,-32},{218,-32}}, color={0,0,127}));
                      connect(outDamPosMin.y, enaDis2.uOutDamPosMin)
                        annotation (Line(points={{-218,-110},{-180,-110},{-180,-70},{188,-70},{188,-34},
                              {218,-34}},       color={0,0,127}));
                      connect(retDamPhyPosMax.y, enaDis2.uRetDamPhyPosMax)
                        annotation (Line(points={{-138,-110},{192,-110},{192,-36},{218,-36}}, color={0,0,127}));
                      connect(retDamPosMax.y, enaDis2.uRetDamPosMax)
                        annotation (Line(points={{-138,-150},{196,-150},{196,-38},{218,-38}}, color={0,0,127}));
                      connect(retDamPosMin.y, enaDis2.uRetDamPosMin)
                        annotation (Line(points={{-138,-190},{198,-190},{198,-40},{218,-40}}, color={0,0,127}));
                      connect(supFanSta.y, enaDis.uSupFan)
                        annotation (Line(points={{-178,-32},{-160,-32},{-160,-28},{-80,-28},{-80,-28},
                              {-82,-28}},
                        color={255,0,255}));
                      connect(supFanSta.y, enaDis1.uSupFan)
                        annotation (Line(points={{-178,-32},{-160,-32},{-160,-12},{-20,-12},{-20,-28},
                              {78,-28}},
                        color={255,0,255}));
                      connect(supFanSta.y, enaDis2.uSupFan)
                        annotation (Line(points={{-178,-32},{-160,-32},{-160,-12},{140,-12},{140,-28},
                              {218,-28}},
                        color={255,0,255}));

                    annotation (
                      experiment(StopTime=1800.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/Economizers/Subsequences/Validation/Enable_TOut_hOut.mos"
                        "Simulate and plot"),
                      Icon(graphics={
                            Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}),
                            Polygon(lineColor = {0,0,255},
                                    fillColor = {75,138,73},
                                    pattern = LinePattern.None,
                                    fillPattern = FillPattern.Solid,
                                    points={{-36,58},{64,-2},{-36,-62},{-36,58}})}), Diagram(
                            coordinateSystem(preserveAspectRatio=false, extent={{-260,-220},{260,220}}),
                            graphics={Text(
                              extent={{-50,214},{530,162}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Example high limit cutoff conditions:
                      ASHRAE 90.1-2013:
                      Device Type: Fixed Enthalpy + Fixed Drybulb, Fixed Drybulb
                      TOut > 75 degF [24 degC]
                      hOut > 28 Btu/lb [65.1 kJ/kg]"),
                            Text(
                              extent={{-82,-40},{14,-66}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Tests temperature hysteresis"),
                            Text(
                              extent={{80,-40},{166,-66}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Tests enthalpy hysteresis"),
                            Text(
                              extent={{204,-46},{272,-68}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="No enthalpy
sensor")}),         Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Enable</a>
for the following control signals: <code>TOut</code>, <code>TOutCut</code>,
<code>hOut</code>, <code>hOutCut</code>.
</p>
</html>",                     revisions="<html>
<ul>
<li>
June 13, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Enable_TOut_hOut;

                    model Limits_LoopDisable
                      "Validation model for the multi zone VAV AHU minimum outdoor air control - damper position limits"

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        VOutMinSet_flow(final k=VOutSet_flow)
                        "Outdoor airflow rate setpoint, 15cfm/occupant and 100 occupants"
                        annotation (Placement(transformation(extent={{-200,20},
                                {-180,40}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        VOutMinSet1_flow(final k=VOutSet_flow)
                        "Outdoor airflow rate setpoint, 15cfm/occupant and 100 occupants"
                        annotation (Placement(transformation(extent={{-60,20},{
                                -40,40}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        VOutMinSet2_flow(final k=VOutSet_flow)
                        "Outdoor airflow rate setpoint, 15cfm/occupant and 100 occupants"
                        annotation (Placement(transformation(extent={{80,20},{
                                100,40}})));

                      // Fan Status
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        fanSta(final k=false) "Fan is off" annotation (
                          Placement(transformation(extent={{-200,-20},{-180,0}})));

                      // Operation Mode
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        opeMod1(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                        "AHU operation mode is NOT Occupied" annotation (
                          Placement(transformation(extent={{-60,-60},{-40,-40}})));

                      // Freeze Protection Stage
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta2(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage2)
                        "Freeze protection stage is 2" annotation (Placement(
                            transformation(extent={{80,-100},{100,-80}})));

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        VOut_flow(
                        final duration=1800,
                        final offset=minVOutSet_flow,
                        final height=incVOutSet_flow)
                        "Measured outdoor airflow rate" annotation (Placement(
                            transformation(extent={{-200,60},{-180,80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        VOut1_flow(
                        final duration=1800,
                        final offset=minVOutSet_flow,
                        final height=incVOutSet_flow)
                        "Measured outdoor airflow rate" annotation (Placement(
                            transformation(extent={{-60,60},{-40,80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        VOut2_flow(
                        final duration=1800,
                        final offset=minVOutSet_flow,
                        final height=incVOutSet_flow)
                        "Measured outdoor airflow rate" annotation (Placement(
                            transformation(extent={{80,60},{100,80}})));

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits
                        damLim
                        "Multi zone VAV AHU minimum outdoor air control - damper position limits"
                        annotation (Placement(transformation(extent={{-120,-20},
                                {-100,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits
                        damLim1
                        "Multi zone VAV AHU minimum outdoor air control - damper position limits"
                        annotation (Placement(transformation(extent={{20,-20},{
                                40,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits
                        damLim2
                        "Multi zone VAV AHU minimum outdoor air control - damper position limits"
                        annotation (Placement(transformation(extent={{160,-20},
                                {180,0}})));

                    protected
                      final parameter Real VOutSet_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=0.71
                        "Example volumetric airflow setpoint, 15cfm/occupant, 100 occupants";
                      final parameter Real minVOutSet_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=0.61
                        "Volumetric airflow sensor output, minimum value in the example";
                      final parameter Real incVOutSet_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=0.2
                        "Maximum increase in airflow volume during the example simulation";

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                        "Freeze protection stage is 1" annotation (Placement(
                            transformation(extent={{-200,-100},{-180,-80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        opeMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                        "AHU operation mode is Occupied" annotation (Placement(
                            transformation(extent={{-200,-60},{-180,-40}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        fanStatus1(final k=true) "Fan is on" annotation (
                          Placement(transformation(extent={{-60,-20},{-40,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta1(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                        "Freeze protection stage is 1" annotation (Placement(
                            transformation(extent={{-60,-100},{-40,-80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        fanStatus2(final k=true) "Fan is on" annotation (
                          Placement(transformation(extent={{80,-20},{100,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        opeMod2(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                        "AHU operation mode is Occupied" annotation (Placement(
                            transformation(extent={{80,-60},{100,-40}})));

                    equation
                      connect(VOut_flow.y, damLim.VOut_flow_normalized) annotation (Line(points={{-178,70},
                              {-140,70},{-140,-6},{-122,-6}},     color={0,0,127}));
                      connect(VOutMinSet_flow.y, damLim.VOutMinSet_flow_normalized) annotation (
                          Line(points={{-178,30},{-150,30},{-150,-2},{-122,-2}}, color={0,0,127}));
                      connect(fanSta.y, damLim.uSupFan)
                        annotation (Line(points={{-178,-10},{-178,-10},{-122,-10}}, color={255,0,255}));
                      connect(freProSta.y, damLim.uFreProSta)
                        annotation (Line(points={{-178,-90},{-140,-90},{-140,-14},{-122,-14}}, color={255,127,0}));
                      connect(VOut1_flow.y, damLim1.VOut_flow_normalized) annotation (Line(points={{-38,70},
                              {0,70},{0,-6},{18,-6}},          color={0,0,127}));
                      connect(VOutMinSet1_flow.y, damLim1.VOutMinSet_flow_normalized) annotation (
                          Line(points={{-38,30},{-10,30},{-10,-2},{18,-2}}, color={0,0,127}));
                      connect(fanStatus1.y, damLim1.uSupFan)
                        annotation (Line(points={{-38,-10},{18,-10}}, color={255,0,255}));
                      connect(freProSta1.y, damLim1.uFreProSta)
                        annotation (Line(points={{-38,-90},{0,-90},{0,-14},{18,-14}}, color={255,127,0}));
                      connect(VOut2_flow.y, damLim2.VOut_flow_normalized)
                        annotation (Line(points={{102,70},{140,70},{140,-6},{158,-6}}, color={0,0,127}));
                      connect(VOutMinSet2_flow.y, damLim2.VOutMinSet_flow_normalized)
                        annotation (Line(points={{102,30},{130,30},{130,-2},{158,-2}}, color={0,0,127}));
                      connect(fanStatus2.y, damLim2.uSupFan)
                        annotation (Line(points={{102,-10},{158,-10}}, color={255,0,255}));
                      connect(freProSta2.y, damLim2.uFreProSta)
                        annotation (Line(points={{102,-90},{140,-90},{140,-14},{158,-14}},color={255,127,0}));
                      connect(opeMod.y, damLim.uOpeMod)
                        annotation (Line(points={{-178,-50},{-150,-50},{-150,-18},{-122,-18}}, color={255,127,0}));
                      connect(opeMod1.y, damLim1.uOpeMod)
                        annotation (Line(points={{-38,-50},{-10,-50},{-10,-18},{18,-18}}, color={255,127,0}));
                      connect(opeMod2.y, damLim2.uOpeMod)
                        annotation (Line(points={{102,-50},{130,-50},{130,-18},{158,-18}}, color={255,127,0}));

                    annotation (
                      experiment(StopTime=1800.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/Economizers/Subsequences/Validation/Limits_LoopDisable.mos"
                        "Simulate and plot"),
                        Icon(graphics={Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}), Polygon(
                              lineColor={0,0,255},
                              fillColor={75,138,73},
                              pattern=LinePattern.None,
                              fillPattern=FillPattern.Solid,
                              points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-220,-120},{
                                220,120}}), graphics={
                            Text(
                              extent={{-200,110},{-174,100}},
                              lineColor={0,0,0},
                              lineThickness=0.5,
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              horizontalAlignment=TextAlignment.Left,
                              textString="Fan is off"),
                            Text(
                              extent={{-60,114},{34,100}},
                              lineColor={0,0,0},
                              lineThickness=0.5,
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              horizontalAlignment=TextAlignment.Left,
                              textString="Operation mode is other than occupied"),
                            Text(
                              extent={{80,114},{172,100}},
                              lineColor={0,0,0},
                              lineThickness=0.5,
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              horizontalAlignment=TextAlignment.Left,
                              textString="Freeze protection status is higher than 1")}),
                    Documentation(info="<html>
<p>
This example validates enable/disable conditions for
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits</a>
for the following input signals: <code>uSupFan</code>, <code>uFreProSta</code>, <code>uOpeMod</code>.
</p>
</html>",                     revisions="<html>
<ul>
<li>
June 06, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Limits_LoopDisable;

                    model Limits_VOut_flow
                      "Validation model for the multi zone VAV AHU minimum outdoor air control - damper position limits"

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        VOutMinSet_flow(k=minVOutSet_flow)
                        "Outdoor volumetric airflow rate setpoint, 15cfm/occupant and 100 occupants"
                        annotation (Placement(transformation(extent={{-60,30},{
                                -40,50}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        VOut_flow(
                        duration=1800,
                        offset=VOutMin_flow,
                        height=incVOutSet_flow) "Measured outdoor airflow rate"
                        annotation (Placement(transformation(extent={{-60,70},{
                                -40,90}})));

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits
                        damLim
                        "Multi zone VAV AHU minimum outdoor air control - damper position limits"
                        annotation (Placement(transformation(extent={{20,-10},{
                                40,10}})));

                    protected
                      parameter Real minVOutSet_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=0.71
                        "Example volumetric airflow setpoint, 15cfm/occupant, 100 occupants";
                      parameter Real VOutMin_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=0.61
                        "Minimal measured volumetric airflow";
                      parameter Real incVOutSet_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=(minVOutSet_flow-VOutMin_flow)*2
                        "Maximum volumetric airflow increase during the example simulation";

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        fanStatus(k=true) "Fan is on" annotation (Placement(
                            transformation(extent={{-60,-10},{-40,10}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta(k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                        "Freeze protection status 0 - disabled" annotation (
                          Placement(transformation(extent={{-60,-90},{-40,-70}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        operationMode(k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                        "Operation mode is Occupied" annotation (Placement(
                            transformation(extent={{-60,-50},{-40,-30}})));

                    equation
                      connect(VOut_flow.y, damLim.VOut_flow_normalized)
                        annotation (Line(points={{-38,80},{0,80},{0,4},{18,4}}, color={0,0,127}));
                      connect(VOutMinSet_flow.y, damLim.VOutMinSet_flow_normalized) annotation (
                          Line(points={{-38,40},{-10,40},{-10,8},{18,8}}, color={0,0,127}));
                      connect(fanStatus.y, damLim.uSupFan)
                        annotation (Line(points={{-38,0},{18,0}},  color={255,0,255}));
                      connect(freProSta.y, damLim.uFreProSta)
                        annotation (Line(points={{-38,-80},{0,-80},{0,-4},{18,-4}},    color={255,127,0}));
                      connect(operationMode.y, damLim.uOpeMod)
                        annotation (Line(points={{-38,-40},{-10,-40},{-10,-8},{18,-8}}, color={255,127,0}));
                      annotation (
                      experiment(StopTime=1800.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/Economizers/Subsequences/Validation/Limits_VOut_flow.mos"
                        "Simulate and plot"),
                        Icon(graphics={Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}), Polygon(
                              lineColor={0,0,255},
                              fillColor={75,138,73},
                              pattern=LinePattern.None,
                              fillPattern=FillPattern.Solid,
                              points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-80,-100},{80,100}})),
                    Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Limits</a>
for the following control signals: <code>VOut_flow</code>, <code>VOutMinSet_flow</code>. The control loop is always enabled in this
example.
</p>
</html>",                     revisions="<html>
<ul>
<li>
June 06, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Limits_VOut_flow;

                    model Modulation_TSup
                      "Validation model for multi zone VAV AHU outdoor and return air damper position modulation sequence"

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation
                        mod "Economizer modulation sequence" annotation (
                          Placement(transformation(extent={{40,20},{60,40}})));

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        uTSup(
                        final duration=900,
                        final height=2,
                        final offset=-1)
                        "Control signal for supply air temperature loop"
                        annotation (Placement(transformation(extent={{-60,60},{
                                -40,80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMin(final k=0.1)
                        "Outdoor air damper minimum position" annotation (
                          Placement(transformation(extent={{-80,-20},{-60,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMax(final k=0.8)
                        "Outdoor air damper maximum position" annotation (
                          Placement(transformation(extent={{-80,16},{-60,36}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        retDamPosMin(final k=0.2)
                        "Return air damper minimum position" annotation (
                          Placement(transformation(extent={{-80,-80},{-60,-60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        retDamPosMax(final k=0.6)
                        "Return air damper maximum position" annotation (
                          Placement(transformation(extent={{-80,-50},{-60,-30}})));

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation
                        modFre
                        "Economizer modulation sequence if the dampers positions prevent freezing at the mixed air"
                        annotation (Placement(transformation(extent={{40,-40},{
                                60,-20}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMaxFre(final k=0)
                        "Outdoor damper if freeze protection is on" annotation
                        (Placement(transformation(extent={{0,-80},{20,-60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        retDamPosMinFre(final k=1)
                        "Return damper position if freeze protection is on"
                        annotation (Placement(transformation(extent={{4,-10},{
                                24,10}})));

                    equation
                      connect(retDamPosMax.y, mod.uRetDamPosMax)
                        annotation (Line(points={{-58,-40},{-20,-40},{-20,39},{38,39}},color={0,0,127}));
                      connect(retDamPosMin.y, mod.uRetDamPosMin)
                        annotation (Line(points={{-58,-70},{-10,-70},{-10,35},{38,35}},color={0,0,127}));
                      connect(outDamPosMax.y, mod.uOutDamPosMax)
                        annotation (Line(points={{-58,26},{-10,26},{-10,25},{38,25}},
                                                                   color={0,0,127}));
                      connect(outDamPosMin.y, mod.uOutDamPosMin)
                        annotation (Line(points={{-58,-10},{-58,-10},{-24,-10},{-24,21},{38,21}}, color={0,0,127}));
                      connect(uTSup.y, mod.uTSup)
                        annotation (Line(points={{-38,70},{0,70},{0,30},{38,30}}, color={0,0,127}));
                      connect(retDamPosMax.y, modFre.uRetDamPosMax)
                        annotation (Line(points={{-58,-40},{-20,-40},{-20,-21},{38,-21}}, color={0,0,127}));
                      connect(outDamPosMin.y, modFre.uOutDamPosMin)
                        annotation (Line(points={{-58,-10},{-34,-10},{-34,-39},{38,-39}}, color={0,0,127}));
                      connect(uTSup.y, modFre.uTSup)
                        annotation (Line(points={{-38,70},{0,70},{0,-30},{38,-30}}, color={0,0,127}));
                      connect(outDamPosMaxFre.y, modFre.uOutDamPosMax)
                        annotation (Line(points={{22,-70},{30,-70},{30,-35},{38,-35}}, color={0,0,127}));
                      connect(retDamPosMinFre.y, modFre.uRetDamPosMin)
                        annotation (Line(points={{26,0},{32,0},{32,-25},{38,-25}}, color={0,0,127}));
                      annotation (
                      experiment(StopTime=900.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/Economizers/Subsequences/Validation/Modulation_TSup.mos"
                        "Simulate and plot"),
                        Icon(graphics={Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}), Polygon(
                              lineColor={0,0,255},
                              fillColor={75,138,73},
                              pattern=LinePattern.None,
                              fillPattern=FillPattern.Solid,
                              points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                    Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences.Modulation</a>
for a varying supply air temperature control loop signal.
The instance <code>mod</code> is in normal operation, whereas
for the instance <code>modFre</code>, the damper limits are
as if the mixed air temperature were below its freezing set point.
</p>
</html>",                     revisions="<html>
<ul>
<li>
October 13, 2017, by Michael Wetter:<br/>
Added additional instance to validate the behavior when dampers are
such positioned that they prevent the mixed air temperature from being
below the freezing set point.
</li>
<li>
June 30, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Modulation_TSup;
                  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Subsequences</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),            Icon(graphics={
                          Rectangle(
                            lineColor={200,200,200},
                            fillColor={248,248,248},
                            fillPattern=FillPattern.HorizontalCylinder,
                            extent={{-100.0,-100.0},{100.0,100.0}},
                            radius=25.0),
                          Rectangle(
                            lineColor={128,128,128},
                            extent={{-100.0,-100.0},{100.0,100.0}},
                            radius=25.0),
                          Polygon(
                            origin={8.0,14.0},
                            lineColor={78,138,73},
                            fillColor={78,138,73},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
                  end Validation;
                annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains subsequences for multi zone VAV AHU economizer control.
</p>
</html>"),        Icon(graphics={
                        Rectangle(
                          lineColor={200,200,200},
                          fillColor={248,248,248},
                          fillPattern=FillPattern.HorizontalCylinder,
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Rectangle(
                          lineColor={128,128,128},
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Ellipse(
                          origin={10.0,10.0},
                          lineColor={128,128,128},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid,
                          extent={{-80.0,0.0},{-20.0,60.0}}),
                        Ellipse(
                          origin={10.0,10.0},
                          fillColor={128,128,128},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{0.0,0.0},{60.0,60.0}}),
                        Ellipse(
                          origin={10.0,10.0},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{0.0,-80.0},{60.0,-20.0}}),
                        Ellipse(
                          origin={10.0,10.0},
                          fillColor={76,76,76},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{-80.0,-80.0},{-20.0,-20.0}})}));
                end Subsequences;

                package Validation "Collection of validation models"

                  model Controller_Disable
                    "Validation model for disabling the multi zone VAV AHU economizer modulation and damper position limit control loops"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller
                      economizer(
                      final use_enthalpy=true,
                      final retDamPhyPosMax=1,
                      final retDamPhyPosMin=0,
                      final outDamPhyPosMax=1,
                      final outDamPhyPosMin=0,
                      final use_TMix=false,
                      final use_G36FrePro=true)
                      "Multi zone VAV AHU economizer " annotation (Placement(
                          transformation(extent={{20,0},{40,20}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller
                      economizer1(
                      final use_enthalpy=true,
                      final retDamPhyPosMax=1,
                      final retDamPhyPosMin=0,
                      final outDamPhyPosMax=1,
                      final outDamPhyPosMin=0,
                      final use_TMix=false,
                      final use_G36FrePro=true) "Multi zone VAV AHU economizer"
                      annotation (Placement(transformation(extent={{100,-20},{
                              120,0}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller
                      economizer2(
                      final retDamPhyPosMax=1,
                      final retDamPhyPosMin=0,
                      final outDamPhyPosMax=1,
                      final outDamPhyPosMin=0,
                      final use_TMix=true,
                      final use_G36FrePro=false,
                      final use_enthalpy=false)
                      "Multi zone VAV AHU economizer with TMix freeze protection"
                      annotation (Placement(transformation(extent={{160,-60},{
                              180,-40}})));

                  protected
                    final parameter Real TOutCutoff(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")=297.15
                      "Outdoor temperature high limit cutoff";
                    final parameter Real hOutCutoff(
                      final unit="J/kg",
                      final quantity="SpecificEnergy")=65100
                      "Outdoor air enthalpy high limit cutoff";
                    final parameter Real minVOutSet_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")=0.71
                      "Example volumetric airflow setpoint, 15cfm/occupant, 100 occupants";
                    final parameter Real VOutMin_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")=0.61
                      "Minimal measured volumetric airflow";
                    final parameter Real incVOutSet_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")=(minVOutSet_flow - VOutMin_flow)*2.2
                      "Maximum volumetric airflow increase during the example simulation";

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      fanSta(final k=true) "Fan is on" annotation (Placement(
                          transformation(extent={{-40,-20},{-20,0}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                      "Freeze protection status is 0" annotation (Placement(
                          transformation(extent={{-80,-110},{-60,-90}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      freProSta2(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage2)
                      "Freeze protection stage is 2" annotation (Placement(
                          transformation(extent={{0,-100},{20,-80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      opeMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "AHU operation mode is Occupied" annotation (Placement(
                          transformation(extent={{-80,-80},{-60,-60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      hOutBelowCutoff(final k=hOutCutoff - 40000)
                      "Outdoor air enthalpy is below the cutoff" annotation (
                        Placement(transformation(extent={{-120,10},{-100,30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      hOutCut(final k=hOutCutoff) "Outdoor air enthalpy cutoff"
                      annotation (Placement(transformation(extent={{-120,-30},{
                              -100,-10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TOutBelowCutoff(final k=TOutCutoff - 30)
                      "Outdoor air temperature is below the cutoff" annotation
                      (Placement(transformation(extent={{-120,100},{-100,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TOutCut1(final k=TOutCutoff)
                      "Outdoor air temperature cutoff" annotation (Placement(
                          transformation(extent={{-120,60},{-100,80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      VOutMinSet_flow(final k=minVOutSet_flow)
                      "Outdoor airflow rate setpoint, example assumes 15cfm/occupant and 100 occupants"
                      annotation (Placement(transformation(extent={{-40,40},{-20,
                              60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      VOut_flow(
                      final height=incVOutSet_flow,
                      final offset=VOutMin_flow,
                      final duration=1800)
                      "Measured outdoor air volumetric airflow" annotation (
                        Placement(transformation(extent={{-40,80},{-20,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      uTSup(
                      final duration=1800,
                      final height=1,
                      final offset=0) "Supply air temperature control signal"
                      annotation (Placement(transformation(extent={{-80,80},{-60,
                              100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                      sin1(
                      amplitude=20,
                      freqHz=1/1800,
                      offset=272.15,
                      startTime=0) "Mixed air temerature" annotation (Placement(
                          transformation(extent={{90,-98},{110,-80}})));

                  equation
                    connect(fanSta.y, economizer.uSupFan) annotation (Line(points={{-18,-10},{0,-10},
                            {0,5},{18.75,5}},                 color={255,0,255}));
                    connect(freProSta.y, economizer.uFreProSta) annotation (Line(points={{-58,-100},
                            {-10,-100},{-10,0.625},{18.75,0.625}},                    color={255,
                            127,0}));
                    connect(TOutBelowCutoff.y, economizer.TOut) annotation (Line(points={{-98,110},
                            {0,110},{0,19.375},{18.75,19.375}},    color={0,0,127}));
                    connect(TOutCut1.y, economizer.TOutCut) annotation (Line(points={{-98,70},{-2,
                            70},{-2,17.5},{18.75,17.5}},              color={0,0,127}));
                    connect(hOutBelowCutoff.y, economizer.hOut) annotation (Line(points={{-98,20},
                            {-80,20},{-80,16},{18.75,16},{18.75,15.625}},   color={0,0,127}));
                    connect(hOutCut.y, economizer.hOutCut) annotation (Line(points={{-98,-20},{-90,
                            -20},{-90,14.375},{18.75,14.375}},          color={0,0,127}));
                    connect(VOut_flow.y, economizer.VOut_flow_normalized) annotation (Line(points={{-18,90},
                            {-8,90},{-8,10.625},{18.75,10.625}},         color={0,0,127}));
                    connect(VOutMinSet_flow.y, economizer.VOutMinSet_flow_normalized) annotation (
                       Line(points={{-18,50},{-10,50},{-10,8.75},{18.75,8.75}},
                                                                             color={0,0,127}));
                    connect(TOutCut1.y, economizer1.TOutCut) annotation (Line(points={{-98,70},{74,
                            70},{74,-2.5},{98.75,-2.5}},         color={0,0,127}));
                    connect(TOutBelowCutoff.y, economizer1.TOut) annotation (Line(points={{-98,110},
                            {80,110},{80,-0.625},{98.75,-0.625}},       color={0,0,127}));
                    connect(hOutCut.y, economizer1.hOutCut) annotation (Line(points={{-98,-20},{-90,
                            -20},{-90,-28},{76,-28},{76,-5.625},{98.75,-5.625}},  color={0,0,127}));
                    connect(hOutBelowCutoff.y, economizer1.hOut) annotation (Line(points={{-98,20},
                            {-80,20},{-80,-26},{74,-26},{74,-4.375},{98.75,-4.375}},  color={0,0,
                            127}));
                    connect(VOut_flow.y, economizer1.VOut_flow_normalized) annotation (Line(
                          points={{-18,90},{78,90},{78,-9.375},{98.75,-9.375}},color={0,0,127}));
                    connect(VOutMinSet_flow.y, economizer1.VOutMinSet_flow_normalized)
                      annotation (Line(points={{-18,50},{70,50},{70,-11.25},{98.75,-11.25}},
                                                                                        color={0,
                            0,127}));
                    connect(fanSta.y, economizer1.uSupFan) annotation (Line(points={{-18,-10},{0,-10},
                            {0,-15},{98.75,-15}},                color={255,0,255}));
                    connect(freProSta2.y, economizer1.uFreProSta) annotation (Line(points={{22,-90},
                            {40,-90},{40,-32},{80,-32},{80,-19.375},{98.75,-19.375}},  color={255,
                            127,0}));
                    connect(opeMod.y, economizer.uOpeMod) annotation (Line(points={{-58,-70},{-4,-70},
                            {-4,3.125},{18.75,3.125}},       color={255,127,0}));
                    connect(opeMod.y, economizer1.uOpeMod) annotation (Line(points={{-58,-70},{-4,
                            -70},{-4,-16.875},{98.75,-16.875}},  color={255,127,0}));
                    connect(uTSup.y, economizer.uTSup) annotation (Line(points={{-58,90},{-50,90},
                            {-50,12.5},{18.75,12.5}},     color={0,0,127}));
                    connect(uTSup.y, economizer1.uTSup) annotation (Line(points={{-58,90},{-50,90},
                            {-50,28},{60,28},{60,-7.5},{98.75,-7.5}},      color={0,0,127}));
                    connect(TOutBelowCutoff.y, economizer2.TOut) annotation (Line(points={{-98,110},
                            {152,110},{152,-40.625},{158.75,-40.625}},
                          color={0,0,127}));
                    connect(TOutCut1.y, economizer2.TOutCut) annotation (Line(points={{-98,70},{150,
                            70},{150,-42.5},{158.75,-42.5}},
                          color={0,0,127}));
                    connect(VOut_flow.y, economizer2.VOut_flow_normalized) annotation (Line(
                          points={{-18,90},{140,90},{140,-49.375},{158.75,-49.375}},
                          color={0,0,127}));
                    connect(VOutMinSet_flow.y, economizer2.VOutMinSet_flow_normalized)
                      annotation (Line(points={{-18,50},{136,50},{136,-51.25},{158.75,-51.25}},
                          color={0,0,127}));
                    connect(uTSup.y, economizer2.uTSup) annotation (Line(points={{-58,90},{-50,90},
                            {-50,106},{142,106},{142,-47.5},{158.75,-47.5}},      color={0,0,127}));
                    connect(fanSta.y, economizer2.uSupFan) annotation (Line(points={{-18,-10},{0,-10},
                            {0,-55},{158.75,-55}},                                 color={255,0,
                            255}));
                    connect(opeMod.y, economizer2.uOpeMod) annotation (Line(points={{-58,-70},{-4,
                            -70},{-4,-56.875},{158.75,-56.875}},  color={255,127,0}));
                    connect(sin1.y, economizer2.TMix) annotation (Line(points={{112,-89},{136,-89},
                            {136,-53.125},{158.75,-53.125}},  color={0,0,127}));

                    annotation (
                      experiment(StopTime=1800.0, Tolerance=1e-06),
                      __Dymola_Commands(file=
                            "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/Economizers/Validation/Controller_Disable.mos"
                          "Simulate and plot"),
                      Icon(graphics={Ellipse(
                            lineColor={75,138,73},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid,
                            extent={{-100,-100},{100,100}}), Polygon(
                            lineColor={0,0,255},
                            fillColor={75,138,73},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,-160},{
                              220,160}}), graphics={
                          Text(
                            extent={{20,140},{104,112}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Disable modulation
enable minimal
outdoor air control"),    Text(
                            extent={{100,140},{184,112}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Disable modulation
and minimal outdoor air control
(freeze protection is at stage2)"),
                          Text(
                            extent={{160,-12},{218,-40}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Overide damper positions
based on the TMix tracking
freeze protection ")}),
                      Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller</a>
for control signals which disable modulation control loop only (<code>economizer</code> block)
and both minimum outdoor airflow and modulation control loops (<code>economizer1</code> block).
</p>
</html>",                   revisions="<html>
<ul>
<li>
June 12, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Controller_Disable;

                  model Controller_Mod_DamLim
                    "Validation model for multi zone VAV AHU economizer operation: damper modulation and minimum ooutdoor air requirement damper position limits"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller
                      economizer(
                      final use_TMix=true,
                      final use_enthalpy=true,
                      final use_G36FrePro=true) "Multi zone VAV AHU economizer"
                      annotation (Placement(transformation(extent={{20,0},{40,
                              20}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller
                      economizer1(
                      final use_enthalpy=false,
                      final use_TMix=true,
                      final use_G36FrePro=true) "Multi zone VAV AHU economizer"
                      annotation (Placement(transformation(extent={{100,-40},{
                              120,-20}})));

                  protected
                    final parameter Real TOutCutoff(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")=297.15
                      "Outdoor temperature high limit cutoff";
                    final parameter Real hOutCutoff(
                      final unit="J/kg",
                      final quantity="SpecificEnergy")=65100
                      "Outdoor air enthalpy high limit cutoff";

                    final parameter Real minVOutSet_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")=0.71
                      "Example volumetric airflow setpoint, 15cfm/occupant, 100 occupants";
                    final parameter Real VOutMin_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")=0.61
                      "Minimal measured volumetric airflow";
                    final parameter Real incVOutSet_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")=(minVOutSet_flow - VOutMin_flow)*2.2
                      "Maximum volumetric airflow increase during the example simulation";

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      fanSta(final k=true) "Fan is on" annotation (Placement(
                          transformation(extent={{-80,-90},{-60,-70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                      "Freeze protection status is 0" annotation (Placement(
                          transformation(extent={{-80,-130},{-60,-110}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      opeMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "AHU operation mode is Occupied" annotation (Placement(
                          transformation(extent={{-120,-110},{-100,-90}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      hOutBelowCutoff(final k=hOutCutoff - 10000)
                      "Outdoor air enthalpy is slightly below the cutoff"
                      annotation (Placement(transformation(extent={{-120,10},{-100,
                              30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      hOutCut(final k=hOutCutoff) "Outdoor air enthalpy cutoff"
                      annotation (Placement(transformation(extent={{-120,-30},{
                              -100,-10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TOutBelowCutoff(final k=TOutCutoff - 5)
                      "Outdoor air temperature is slightly below the cutoff"
                      annotation (Placement(transformation(extent={{-120,100},{
                              -100,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TOutCut1(final k=TOutCutoff)
                      "OA temperature high limit cutoff" annotation (Placement(
                          transformation(extent={{-120,60},{-100,80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TMixMea(final k=303.15)
                      "Measured mixed air temperature above cutoff" annotation
                      (Placement(transformation(extent={{-80,-10},{-60,10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      VOutMinSet_flow(final k=minVOutSet_flow)
                      "Outdoor airflow rate setpoint, example assumes 15cfm/occupant and 100 occupants"
                      annotation (Placement(transformation(extent={{-40,40},{-20,
                              60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      VOut_flow(
                      final offset=VOutMin_flow,
                      final duration=900,
                      final height=incVOutSet_flow)
                      "Measured outdoor air volumetric airflow" annotation (
                        Placement(transformation(extent={{-40,80},{-20,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      uTSup(
                      final duration=1800,
                      final height=1,
                      final offset=0) "Supply air temperature control signal"
                      annotation (Placement(transformation(extent={{-80,80},{-60,
                              100}})));

                  equation
                    connect(fanSta.y, economizer.uSupFan) annotation (Line(points={{-58,-80},{-14,
                            -80},{-14,5},{18.75,5}},          color={255,0,255}));
                    connect(freProSta.y, economizer.uFreProSta) annotation (Line(points={{-58,-120},
                            {0,-120},{0,0.625},{18.75,0.625}},  color={255,127,0}));
                    connect(opeMod.y, economizer.uOpeMod) annotation (Line(points={{-98,-100},{-4,
                            -100},{-4,3.125},{18.75,3.125}},  color={255,127,0}));
                    connect(TOutBelowCutoff.y, economizer.TOut) annotation (Line(points={{-98,110},
                            {0,110},{0,19.375},{18.75,19.375}},    color={0,0,127}));
                    connect(TOutCut1.y, economizer.TOutCut) annotation (Line(points={{-98,70},{-10,
                            70},{-10,17.5},{18.75,17.5}},      color={0,0,127}));
                    connect(VOut_flow.y, economizer.VOut_flow_normalized) annotation (Line(points={{-18,90},
                            {-8,90},{-8,10.625},{18.75,10.625}},         color={0,0,127}));
                    connect(VOutMinSet_flow.y, economizer.VOutMinSet_flow_normalized) annotation (
                       Line(points={{-18,50},{-12,50},{-12,8.75},{18.75,8.75}},
                                                                             color={0,0,127}));
                    connect(TOutBelowCutoff.y, economizer1.TOut) annotation (Line(points={{-98,110},
                            {86,110},{86,-20.625},{98.75,-20.625}},       color={0,0,127}));
                    connect(TOutCut1.y, economizer1.TOutCut) annotation (Line(points={{-98,70},{80,
                            70},{80,-22.5},{98.75,-22.5}},         color={0,0,127}));
                    connect(VOutMinSet_flow.y, economizer1.VOutMinSet_flow_normalized)
                      annotation (Line(points={{-18,50},{-12,50},{-12,-31.25},{98.75,-31.25}},
                        color={0,0,127}));
                    connect(fanSta.y, economizer1.uSupFan) annotation (Line(points={{-58,-80},{-14,
                            -80},{-14,-35},{98.75,-35}},         color={255,0,255}));
                    connect(freProSta.y, economizer1.uFreProSta) annotation (Line(points={{-58,-120},
                            {0,-120},{0,-39.375},{98.75,-39.375}},    color={255,127,0}));
                    connect(opeMod.y, economizer1.uOpeMod) annotation (Line(points={{-98,-100},{-4,
                            -100},{-4,-36.875},{98.75,-36.875}},   color={255,127,0}));
                    connect(uTSup.y, economizer.uTSup) annotation (Line(points={{-58,90},{-50,90},
                            {-50,12.5},{18.75,12.5}},      color={0,0,127}));
                    connect(uTSup.y, economizer1.uTSup) annotation (Line(points={{-58,90},{-50,90},
                            {-50,-27.5},{98.75,-27.5}},      color={0,0,127}));
                    connect(economizer1.TMix, TMixMea.y) annotation (Line(points={{98.75,-33.125},
                            {-20,-33.125},{-20,0},{-58,0}},  color={0,0,127}));
                    connect(hOutCut.y, economizer.hOutCut) annotation (Line(points={{-98,-20},{-40,
                            -20},{-40,14.375},{18.75,14.375}},
                                                         color={0,0,127}));
                    connect(hOutBelowCutoff.y, economizer.hOut) annotation (Line(points={{-98,20},
                            {-40,20},{-40,15.625},{18.75,15.625}},  color={0,0,127}));
                    connect(TMixMea.y, economizer.TMix) annotation (Line(points={{-58,0},{-20,0},{
                            -20,6.875},{18.75,6.875}},   color={0,0,127}));
                    connect(VOut_flow.y, economizer1.VOut_flow_normalized) annotation (Line(
                          points={{-18,90},{-8,90},{-8,-29.375},{98.75,-29.375}},color={0,0,127}));

                    annotation (
                      experiment(StopTime=900.0, Tolerance=1e-06),
                      __Dymola_Commands(file=
                            "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/Economizers/Validation/Controller_Mod_DamLim.mos"
                          "Simulate and plot"),
                      Icon(graphics={Ellipse(
                            lineColor={75,138,73},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid,
                            extent={{-100,-100},{100,100}}), Polygon(
                            lineColor={0,0,255},
                            fillColor={75,138,73},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,-160},{
                              140,140}}), graphics={
                          Rectangle(
                            extent={{-136,-44},{-44,-156}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-128,-132},{-36,-152}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Enable both damper limit
and modulation control loops"),
                          Text(
                            extent={{92,14},{140,-10}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Economizer fully enabled -
validate damper position
and damper position limits
(example without
enthalpy measurement)"),  Text(
                            extent={{20,46},{70,24}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Economizer fully enabled -
validate damper position
and damper position limits")}),
                      Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers.Controller</a> control loops:
minimum outdoor air damper position limits control loop (<code>economizer</code> block) and modulation
control loop (<code>economizer1</code> block) for <code>VOut_flow</code> and <code>TSup</code> control signals.
Both control loops are enabled during the validation test.
</p>
</html>",                   revisions="<html>
<ul>
<li>
June 12, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Controller_Mod_DamLim;
                annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Economizers</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),        Icon(graphics={
                        Rectangle(
                          lineColor={200,200,200},
                          fillColor={248,248,248},
                          fillPattern=FillPattern.HorizontalCylinder,
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Rectangle(
                          lineColor={128,128,128},
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Polygon(
                          origin={8.0,14.0},
                          lineColor={78,138,73},
                          fillColor={78,138,73},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
                end Validation;
              annotation (preferredView="info", Documentation(info="<html>
<p>
The package contains a multi zone VAV AHU economizer control
sequence and the related economizer subsequences.
</p>
</html>"),      Icon(graphics={
                      Rectangle(
                        lineColor={200,200,200},
                        fillColor={248,248,248},
                        fillPattern=FillPattern.HorizontalCylinder,
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Rectangle(
                        lineColor={128,128,128},
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Ellipse(
                        origin={10.0,10.0},
                        lineColor={128,128,128},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid,
                        extent={{-80.0,0.0},{-20.0,60.0}}),
                      Ellipse(
                        origin={10.0,10.0},
                        fillColor={128,128,128},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        extent={{0.0,0.0},{60.0,60.0}}),
                      Ellipse(
                        origin={10.0,10.0},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        extent={{0.0,-80.0},{60.0,-20.0}}),
                      Ellipse(
                        origin={10.0,10.0},
                        fillColor={76,76,76},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        extent={{-80.0,-80.0},{-20.0,-20.0}})}));
              end Economizers;

              package SetPoints "Output setpoints for AHU control"

                block ExhaustDamper
                  "Control of actuated exhaust air dampers without fans"

                  parameter Real dpBuiSet(
                    final unit="Pa",
                    final quantity="PressureDifference",
                    max=30) = 12
                    "Building static pressure difference relative to ambient (positive to pressurize the building)";
                  parameter Real k(min=0, unit="1") = 0.5
                    "Gain, applied to building pressure control error normalized with dpBuiSet"
                    annotation(Dialog(group="Exhaust damper P-control parameter"));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput dpBui(final
                      unit="Pa", displayUnit="Pa")
                    "Building static pressure difference, relative to ambient (positive if pressurized)"
                    annotation (Placement(transformation(extent={{-120,40},{-80,
                            80}}), iconTransformation(extent={{-140,40},{-100,
                            80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                    uSupFan "Supply fan status" annotation (Placement(
                        transformation(extent={{-120,-50},{-80,-10}}),
                        iconTransformation(extent={{-140,-80},{-100,-40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yExhDamPos(
                    final unit="1",
                    min=0,
                    max=1) "Exhaust damper control signal (0: closed, 1: open)"
                    annotation (Placement(transformation(extent={{80,-20},{120,
                            20}}), iconTransformation(extent={{100,-20},{140,20}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movMea(delta=300)
                    "Average building static pressure measurement" annotation (
                      Placement(transformation(extent={{-60,50},{-40,70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Feedback conErr(
                    u1(final unit="Pa", displayUnit="Pa"),
                    u2(final unit="Pa", displayUnit="Pa"),
                    y(final unit="Pa", displayUnit="Pa")) "Control error"
                    annotation (Placement(transformation(extent={{-30,50},{-10,
                            70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conP(final
                      controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,
                      final k=k) "Building static pressure controller"
                    annotation (Placement(transformation(extent={{40,50},{60,70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                    "Check if exhaust damper should be activated" annotation (
                      Placement(transformation(extent={{40,-40},{60,-20}})));

                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    zerDam(final k=0) "Close damper when disabled" annotation (
                      Placement(transformation(extent={{-60,-70},{-40,-50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    dpBuiSetPoi1(final k=dpBuiSet) "Building pressure setpoint"
                    annotation (Placement(transformation(extent={{-60,10},{-40,
                            30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gaiNor(final k=1
                        /dpBuiSet) "Gain to normalize the control error"
                    annotation (Placement(transformation(extent={{0,50},{20,70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    zer1(final k=0) "Zero constant" annotation (Placement(
                        transformation(extent={{0,10},{20,30}})));

                equation
                  connect(uSupFan, swi.u2)
                    annotation (Line(points={{-100,-30},{38,-30}}, color={255,0,255}));
                  connect(zerDam.y, swi.u3)
                    annotation (Line(points={{-38,-60},{20,-60},{20,-38},{38,-38}},
                      color={0,0,127}));
                  connect(swi.y, yExhDamPos)
                    annotation (Line(points={{62,-30},{72,-30},{72,0},{100,0}},
                      color={0,0,127}));
                  connect(dpBui, movMea.u)
                    annotation (Line(points={{-100,60},{-62,60}}, color={0,0,127}));
                  connect(movMea.y, conErr.u1)
                    annotation (Line(points={{-38,60},{-32,60}}, color={0,0,127}));
                  connect(conErr.y, gaiNor.u)
                    annotation (Line(points={{-8,60},{-2,60}},color={0,0,127}));
                  connect(gaiNor.y, conP.u_s)
                    annotation (Line(points={{22,60},{38,60}}, color={0,0,127}));
                  connect(dpBuiSetPoi1.y, conErr.u2)
                    annotation (Line(points={{-38,20},{-20,20},{-20,48}}, color={0,0,127}));
                  connect(zer1.y, conP.u_m)
                    annotation (Line(points={{22,20},{50,20},{50,48}}, color={0,0,127}));
                  connect(conP.y, swi.u1)
                    annotation (Line(points={{62,60},{66,60},{66,0},{20,0},{20,-22},{38,-22}},
                      color={0,0,127}));

                annotation (
                  defaultComponentName = "exhDam",
                  Icon(graphics={
                        Rectangle(
                        extent={{-100,-100},{100,100}},
                        lineColor={0,0,127},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                        Text(
                          extent={{-94,74},{-64,46}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="dpBui"),
                        Text(
                          extent={{-94,-48},{-70,-70}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="uSupFan"),
                        Text(
                          extent={{52,16},{96,-18}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="yExhDamPos"),
                        Polygon(
                          points={{-80,92},{-88,70},{-72,70},{-80,92}},
                          lineColor={192,192,192},
                          fillColor={192,192,192},
                          fillPattern=FillPattern.Solid),
                        Line(points={{-80,80},{-80,-88}}, color={192,192,192}),
                        Line(points={{-90,-78},{82,-78}}, color={192,192,192}),
                        Polygon(
                          points={{90,-78},{68,-70},{68,-86},{90,-78}},
                          lineColor={192,192,192},
                          fillColor={192,192,192},
                          fillPattern=FillPattern.Solid),
                        Line(points={{-80,-78},{-80,-78},{14,62},{80,62}}, color={0,0,127}),
                        Text(
                          extent={{-100,140},{100,100}},
                          lineColor={0,0,255},
                          textString="%name")}),
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-80,-80},{80,80}})),
                 Documentation(info="<html>
<p>
Control sequence for actuated exhaust damper <code>yExhDamPos</code>
without fans. It is implemented according to ASHRAE Guidline 35 (G36), PART 5.N.8.
(for multi zone VAV AHU), PART 5.P.6 and PART3.2B.3 (for single zone VAV AHU).
</p>
<h4>Multi zone VAV AHU: Control of actuated exhaust dampers without fans (PART 5.N.8)</h4>
<ol>
<li>The exhaust damper is enabled when the associated supply fan is proven on
<code>uSupFan = true</code>, and disabled otherwise.</li>
<li>When enabled, a P-only control loop modulates the exhaust damper to maintain
a building static pressure of <code>dpBui</code>, which is by default <i>12</i> Pa (<i>0.05</i> inchWC).
</li>
<li>
When <code>uSupFan = false</code>, the damper is closed.
</li>
</ol>
</html>",                 revisions="<html>
<ul>
<li>
October 17, 2017, by Jianjun Hu:<br/>
Changed model name.
</li>
<li>
May 12, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                end ExhaustDamper;

                block ReturnFanDirectPressure
                  "Return fan control with direct building pressure control"

                  parameter Real dpBuiSet(
                    final unit="Pa",
                    final quantity="PressureDifference",
                    final max=30) = 12
                    "Building static pressure difference relative to ambient (positive to pressurize the building)";
                  parameter Real dpDisMin(
                    final unit="Pa",
                    final quantity="PressureDifference",
                    final min=0,
                    final max=1000) = 2.4
                    "Minimum return fan discharge static pressure difference setpoint";
                  parameter Real dpDisMax(
                    final unit="Pa",
                    final quantity="PressureDifference",
                    final min=0,
                    final max=1000) = 40
                    "Maximum return fan discharge static pressure setpoint";
                  parameter Real k(final unit="1") = 1
                    "Gain, normalized using dpBuiSet";

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput dpBui(final
                      unit="Pa", displayUnit="Pa")
                    "Building static pressure difference, relative to ambient (positive if pressurized)"
                    annotation (Placement(transformation(extent={{-180,60},{-140,
                            100}}), iconTransformation(extent={{-140,40},{-100,
                            80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                    uFan "Fan on/off signal, true if fan is on" annotation (
                      Placement(transformation(extent={{-180,-110},{-140,-70}}),
                        iconTransformation(extent={{-140,-80},{-100,-40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput dpDisSet(
                    final unit="Pa",
                    displayUnit="Pa",
                    min=0) "Return fan discharge static pressure setpoint"
                    annotation (Placement(transformation(extent={{120,-110},{
                            160,-70}}), iconTransformation(extent={{100,-80},{
                            140,-40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yExhDam(
                    final unit="1",
                    min=0,
                    max=1) "Exhaust damper control signal (0: closed, 1: open)"
                    annotation (Placement(transformation(extent={{120,0},{160,
                            40}}), iconTransformation(extent={{100,40},{140,80}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movMea(delta=300)
                    "Average building static pressure measurement" annotation (
                      Placement(transformation(extent={{-130,70},{-110,90}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conP(
                    final controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    final k=k,
                    reverseAction=true) "Building static pressure controller"
                    annotation (Placement(transformation(extent={{-40,100},{-20,
                            120}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line linExhAirDam
                    "Exhaust air damper position" annotation (Placement(
                        transformation(extent={{60,100},{80,120}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line linRetFanStaPre
                    "Return fan static pressure setpoint" annotation (Placement(
                        transformation(extent={{60,-50},{80,-30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                    "Exhaust air damper position" annotation (Placement(
                        transformation(extent={{80,10},{100,30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                    "Return fan discharge static pressure setpoint" annotation
                    (Placement(transformation(extent={{80,-100},{100,-80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division div
                    "Normalized the control error" annotation (Placement(
                        transformation(extent={{-80,70},{-60,90}})));

                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    dpBuiSetPoi(final k=dpBuiSet) "Building pressure setpoint"
                    annotation (Placement(transformation(extent={{-130,40},{-110,
                            60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    retFanDisPreMin(final k=dpDisMin)
                    "Return fan discharge static pressure minimum setpoint"
                    annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    retFanDisPreMax(final k=dpDisMax)
                    "Return fan discharge static pressure maximum setpoint"
                    annotation (Placement(transformation(extent={{0,-80},{20,-60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    zer(final k=0) "Zero fan control signal" annotation (
                      Placement(transformation(extent={{0,-120},{20,-100}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    zer1(final k=0) "Zero constant" annotation (Placement(
                        transformation(extent={{-40,42},{-20,62}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con(final k=0.5) "Constant 0.5" annotation (Placement(
                        transformation(extent={{0,60},{20,80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    one(final k=1) "Constant one" annotation (Placement(
                        transformation(extent={{0,26},{20,46}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    conOne(final k=1) "Constant one" annotation (Placement(
                        transformation(extent={{-80,100},{-60,120}})));

                equation
                  connect(movMea.u, dpBui)
                    annotation (Line(points={{-132,80},{-160,80}}, color={0,0,127}));
                  connect(swi.u2, uFan)
                    annotation (Line(points={{78,-90},{-160,-90}}, color={255,0,255}));
                  connect(swi.u3, zer.y)
                    annotation (Line(points={{78,-98},{60,-98},{60,-110},{22,-110}}, color={0,0,127}));
                  connect(zer1.y, linExhAirDam.x1)
                    annotation (Line(points={{-18,52},{30,52},{30,118},{58,118}},color={0,0,127}));
                  connect(zer1.y, linExhAirDam.f1)
                    annotation (Line(points={{-18,52},{30,52},{30,114},{58,114}},color={0,0,127}));
                  connect(con.y, linExhAirDam.x2)
                    annotation (Line(points={{22,70},{40,70},{40,106},{58,106}}, color={0,0,127}));
                  connect(one.y, linExhAirDam.f2)
                    annotation (Line(points={{22,36},{46,36},{46,102},{58,102}}, color={0,0,127}));
                  connect(con.y, linRetFanStaPre.x1)
                    annotation (Line(points={{22,70},{40,70},{40,-32},{58,-32}}, color={0,0,127}));
                  connect(one.y, linRetFanStaPre.x2)
                    annotation (Line(points={{22,36},{46,36},{46,-44},{58,-44}}, color={0,0,127}));
                  connect(retFanDisPreMin.y, linRetFanStaPre.f1)
                    annotation (Line(points={{22,-20},{30,-20},{30,-36},{58,-36}},
                      color={0,0,127}));
                  connect(retFanDisPreMax.y, linRetFanStaPre.f2)
                    annotation (Line(points={{22,-70},{30,-70},{30,-48},{58,-48}},
                      color={0,0,127}));
                  connect(linRetFanStaPre.y, swi.u1)
                    annotation (Line(points={{82,-40},{100,-40},{100,-60},{60,-60},{60,-82},{78,
                          -82}}, color={0,0,127}));
                  connect(uFan, swi1.u2)
                    annotation (Line(points={{-160,-90},{-100,-90},{-100,20},{78,20}},
                      color={255,0,255}));
                  connect(linExhAirDam.y, swi1.u1)
                    annotation (Line(points={{82,110},{100,110},{100,70},{60,70},{60,28},{78,28}},
                      color={0,0,127}));
                  connect(swi1.y, yExhDam)
                    annotation (Line(points={{102,20},{140,20}},
                      color={0,0,127}));
                  connect(zer1.y, swi1.u3)
                    annotation (Line(points={{-18,52},{30,52},{30,12},{78,12}},
                      color={0,0,127}));
                  connect(swi.y, dpDisSet)
                    annotation (Line(points={{102,-90},{140,-90}}, color={0,0,127}));
                  connect(conP.y, linExhAirDam.u)
                    annotation (Line(points={{-18,110},{58,110}}, color={0,0,127}));
                  connect(conP.y, linRetFanStaPre.u)
                    annotation (Line(points={{-18,110},{-10,110},{-10,-40},{58,-40}}, color={0,0,127}));
                  connect(dpBuiSetPoi.y, div.u2) annotation (Line(points={{-108,50},{-90,50},{-90,
                          74},{-82,74}}, color={0,0,127}));
                  connect(movMea.y, div.u1) annotation (Line(points={{-108,80},{-100,80},{-100,86},
                          {-82,86}}, color={0,0,127}));
                  connect(conOne.y, conP.u_s)
                    annotation (Line(points={{-58,110},{-42,110}}, color={0,0,127}));
                  connect(div.y, conP.u_m)
                    annotation (Line(points={{-58,80},{-30,80},{-30,98}}, color={0,0,127}));

                annotation (
                  defaultComponentName="buiPreCon",
                  Icon(graphics={
                        Text(extent={{-98,142},{102,102}},
                          lineColor={0,0,255},
                          textString="%name"),
                        Rectangle(
                        extent={{-100,-100},{100,100}},
                        lineColor={0,0,127},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                        Line(points={{-78,52},{-78,-32},{78,-32},{78,52},{78,52}}, color={28,108,
                              200}),
                        Line(
                          points={{-78,-32},{4,52}},
                          color={0,0,0},
                          thickness=0.5),
                        Line(
                          points={{4,-32},{78,52}},
                          color={0,0,0},
                          pattern=LinePattern.Dash,
                          thickness=0.5),
                        Text(
                          extent={{-50,-36},{60,-62}},
                          lineColor={28,108,200},
                          textString="Building pressure control loop signal")}),
                  Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,-140},{120,140}}),
                        graphics={
                        Rectangle(
                          extent={{-138,138},{118,4}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          pattern=LinePattern.None),
                        Rectangle(
                          extent={{-138,-4},{118,-138}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          pattern=LinePattern.None),
                        Text(
                          extent={{-138,140},{-62,122}},
                          lineColor={0,0,255},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          horizontalAlignment=TextAlignment.Left,
                          textString="Exhaust air damper control"),
                        Text(
                          extent={{-136,-98},{-12,-120}},
                          lineColor={0,0,255},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          horizontalAlignment=TextAlignment.Left,
                          textString="Return fan discharge static pressure setpoint")}),
                  Documentation(info="<html>
<p>
Setpoint for return fan discharge pressure and exhaust air damper
for a multi zone VAV AHU according to ASHRAE guideline G36,
PART 5.N.10 (return fan control with direct building pressure).
</p>
<ol>
<li>
<p>Return fan operates whenever associated supply fan is proven on and is
off otherwise.</p>
</li>
<li>
<p>Return fan is controlled to maintain return fan discharge static pressure
at setpoint <code>dpBuiSet</code>.</p>
</li>
<li>
<p>Exhaust damper is only enabled when the associated supply and return
fans are proven on (<code>uFan=true</code>) and the minimum outdoor air damper is open
(to be controlled in a separate sequence).
The exhaust dampers is closed when the fan is disabled.</p>
</li>
<li>
<p>The building static pressure is time averaged with a sliding 5-minute window
to dampen fluctuations. The averaged value shall be displayed and is used
for control.</p>
</li>
<li>
<p>When the exhaust damper is enabled, a control loop modulates the exhaust damper
in sequence with the return fan static pressure setpoint as shown in the figure
below to maintain the building pressure equal to <code>dpBuiSet</code>,
which is by default <i>12</i> Pa (<i>0.05</i> inches).
</p>
</li>
</ol>
<p>
The output signal of the building pressure control is as follows:
</p>
<ol>
<li>
From <i>0</i> to <i>0.5</i>, the building pressure control loop modulates the exhaust
dampers from <code>yExhDam = 0</code> (closed) to <code>yExhDam = 1</code> (open).
</li>
<li>
From <i>0.5</i> to <i>1</i>, the building pressure control loop resets the return fan
discharge static pressure setpoint from <code>dpDisMin</code>
to <code>dpDisMax</code>. The <code>dpDisMin</code> and
<code>dpDisMax</code> are specified in Section G36 PART 3.2A.3.b.
</li>
</ol>
<p align=\"center\">
<img alt=\"Image of return fan control for multi zone AHU\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/ReturnFanControlWithPressure.png\"/>
</p>
</html>",                 revisions="<html>
<ul>
<li>
October 16, 2017, by Michael Wetter:<br/>
Revised implementation, normalized control input
and updated documentation.
</li>
<li>
October 16, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                end ReturnFanDirectPressure;

                block SupplyFan  "Block to control multi zone VAV AHU supply fan"

                  parameter Boolean have_perZonRehBox = false
                    "Check if there is any VAV-reheat boxes on perimeter zones"
                    annotation(Dialog(group="System configuration"));
                  parameter Boolean have_duaDucBox = false
                    "Check if the AHU serves dual duct boxes"
                    annotation(Dialog(group="System configuration"));
                  parameter Boolean have_airFloMeaSta = false
                    "Check if the AHU has AFMS (Airflow measurement station)"
                    annotation(Dialog(group="System configuration"));
                  parameter Real iniSet(
                    final unit="Pa",
                    final quantity="PressureDifference") = 120
                    "Initial setpoint"
                    annotation (Dialog(group="Trim and respond for pressure setpoint"));
                  parameter Real minSet(
                    final unit="Pa",
                    final quantity="PressureDifference") = 25
                    "Minimum setpoint"
                    annotation (Dialog(group="Trim and respond for pressure setpoint"));
                  parameter Real maxSet(
                    final unit="Pa",
                    final quantity="PressureDifference")
                    "Maximum setpoint"
                    annotation (Dialog(group="Trim and respond for pressure setpoint"));
                  parameter Real delTim(
                    final unit="s",
                    final quantity="Time")= 600
                   "Delay time after which trim and respond is activated"
                    annotation (Dialog(group="Trim and respond for pressure setpoint"));
                  parameter Real samplePeriod(
                    final unit="s",
                    final quantity="Time") = 120  "Sample period"
                    annotation (Dialog(group="Trim and respond for pressure setpoint"));
                  parameter Integer numIgnReq = 2
                    "Number of ignored requests"
                    annotation (Dialog(group="Trim and respond for pressure setpoint"));
                  parameter Real triAmo(
                    final unit="Pa",
                    final quantity="PressureDifference") = -12.0
                    "Trim amount"
                    annotation (Dialog(group="Trim and respond for pressure setpoint"));
                  parameter Real resAmo(
                    final unit="Pa",
                    final quantity="PressureDifference") = 15
                    "Respond amount (must be opposite in to triAmo)"
                    annotation (Dialog(group="Trim and respond for pressure setpoint"));
                  parameter Real maxRes(
                    final unit="Pa",
                    final quantity="PressureDifference") = 32
                    "Maximum response per time interval (same sign as resAmo)"
                    annotation (Dialog(group="Trim and respond for pressure setpoint"));
                  parameter
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                    controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                    "Type of controller"
                    annotation (Dialog(group="Fan PID controller"));
                  parameter Real k(final unit="1")=0.1
                    "Gain of controller, normalized using maxSet"
                    annotation (Dialog(group="Fan PID controller"));
                  parameter Real Ti(
                    final unit="s",
                    final quantity="Time",
                    min=0)=60
                    "Time constant of integrator block"
                    annotation (Dialog(group="Fan PID controller",
                      enable=controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                           or controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                  parameter Real Td(
                    final unit="s",
                    final quantity="Time",
                    final min=0) = 0.1
                    "Time constant of derivative block"
                    annotation (Dialog(group="Fan PID controller",
                      enable=controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                           or controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                  parameter Real yFanMax(min=0.1, max=1, unit="1") = 1
                    "Maximum allowed fan speed"
                    annotation (Dialog(group="Fan PID controller"));
                  parameter Real yFanMin(min=0.1, max=1, unit="1") = 0.1
                    "Lowest allowed fan speed if fan is on"
                    annotation (Dialog(group="Fan PID controller"));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uOpeMod "System operation mode" annotation (Placement(
                        transformation(extent={{-200,100},{-160,140}}),
                        iconTransformation(extent={{-140,60},{-100,100}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput ducStaPre(final
                      unit="Pa", quantity="PressureDifference")
                    "Measured duct static pressure" annotation (Placement(
                        transformation(extent={{-200,-130},{-160,-90}}),
                        iconTransformation(extent={{-140,-100},{-100,-60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uZonPreResReq "Zone static pressure reset requests"
                    annotation (Placement(transformation(extent={{-200,-80},{-160,
                            -40}}), iconTransformation(extent={{-140,-50},{-100,
                            -10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput
                    ySupFan "Supply fan on status" annotation (Placement(
                        transformation(extent={{140,50},{180,90}}),
                        iconTransformation(extent={{100,50},{140,90}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput ySupFanSpe(
                    min=0,
                    max=1,
                    final unit="1") "Supply fan speed" annotation (Placement(
                        transformation(extent={{140,-120},{180,-80}}),
                        iconTransformation(extent={{100,-20},{140,20}})));

                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.TrimAndRespond
                    staPreSetRes(
                    final iniSet=iniSet,
                    final minSet=minSet,
                    final maxSet=maxSet,
                    final delTim=delTim,
                    final samplePeriod=samplePeriod,
                    final numIgnReq=numIgnReq,
                    final triAmo=triAmo,
                    final resAmo=resAmo,
                    final maxRes=maxRes)
                    "Static pressure setpoint reset using trim and respond logic"
                    annotation (Placement(transformation(extent={{-130,-60},{-110,
                            -40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conSpe(
                    final controllerType=controllerType,
                    final k=k,
                    final Ti=Ti,
                    final Td=Td,
                    final yMax=yFanMax,
                    final yMin=yFanMin,
                    reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter,

                    y_reset=yFanMin) "Supply fan speed control" annotation (
                      Placement(transformation(extent={{-40,-80},{-20,-60}})));

                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    zerSpe(k=0) "Zero fan speed when it becomes OFF"
                    annotation (Placement(transformation(extent={{20,-90},{40,-70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                    "If fan is OFF, fan speed outputs to zero" annotation (
                      Placement(transformation(extent={{80,-90},{100,-110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or1
                    "Check whether supply fan should be ON" annotation (
                      Placement(transformation(extent={{80,60},{100,80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or2 if
                    have_perZonRehBox "Setback or warmup mode" annotation (
                      Placement(transformation(extent={{20,30},{40,50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or3 or3
                    "Cool-down or setup or occupied mode" annotation (Placement(
                        transformation(extent={{20,90},{40,110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                    con(k=false) if not have_perZonRehBox "Constant true"
                    annotation (Placement(transformation(extent={{20,0},{40,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    conInt(k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.coolDown)
                    "Cool down mode" annotation (Placement(transformation(
                          extent={{-120,120},{-100,140}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    conInt4(k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                    "Warm-up mode" annotation (Placement(transformation(extent=
                            {{-120,0},{-100,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    conInt1(k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.setUp)
                    "Set up mode" annotation (Placement(transformation(extent={
                            {-120,90},{-100,110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    conInt2(k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                    "Occupied mode" annotation (Placement(transformation(extent
                          ={{-120,60},{-100,80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    conInt3(k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.setBack)
                    "Set back mode" annotation (Placement(transformation(extent
                          ={{-120,30},{-100,50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu
                    "Check if current operation mode is cool-down mode"
                    annotation (Placement(transformation(extent={{-60,120},{-40,
                            140}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu1
                    "Check if current operation mode is setup mode" annotation
                    (Placement(transformation(extent={{-60,90},{-40,110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu2
                    "Check if current operation mode is occupied mode"
                    annotation (Placement(transformation(extent={{-60,60},{-40,
                            80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu3
                    "Check if current operation mode is setback mode"
                    annotation (Placement(transformation(extent={{-60,30},{-40,
                            50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu4
                    "Check if current operation mode is warmup mode"
                    annotation (Placement(transformation(extent={{-60,0},{-40,
                            20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    gaiNor(final k=maxSet)
                    "Gain for normalization of controller input" annotation (
                      Placement(transformation(extent={{-130,-100},{-110,-80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division norPSet
                    "Normalization for pressure set point" annotation (
                      Placement(transformation(extent={{-70,-80},{-50,-60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division norPMea
                    "Normalization of pressure measurement" annotation (
                      Placement(transformation(extent={{-70,-120},{-50,-100}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.FirstOrderHold
                    firOrdHol(final samplePeriod=samplePeriod)
                    "Extrapolation through the values of the last two sampled input signals"
                    annotation (Placement(transformation(extent={{-100,-60},{-80,
                            -40}})));

                equation
                  connect(or2.y, or1.u2)
                    annotation (Line(points={{42,40},{60,40},{60,62},{78,62}},
                      color={255,0,255}));
                  connect(or1.y, ySupFan)
                    annotation (Line(points={{102,70},{160,70}},
                      color={255,0,255}));
                  connect(or1.y, staPreSetRes.uDevSta)
                    annotation (Line(points={{102,70},{120,70},{120,-8},{-150,-8},{-150,-42},{-132,
                          -42}},     color={255,0,255}));
                  connect(or1.y, swi.u2)
                    annotation (Line(points={{102,70},{120,70},{120,-8},{0,-8},{0,-100},{78,-100}},
                      color={255,0,255}));
                  connect(conSpe.y, swi.u1)
                    annotation (Line(points={{-18,-70},{-4,-70},{-4,-108},{78,-108}},
                      color={0,0,127}));
                  connect(zerSpe.y, swi.u3)
                    annotation (Line(points={{42,-80},{60,-80},{60,-92},{78,-92}},
                      color={0,0,127}));
                  connect(swi.y, ySupFanSpe)
                    annotation (Line(points={{102,-100},{160,-100}},
                      color={0,0,127}));
                  connect(uZonPreResReq, staPreSetRes.numOfReq)
                    annotation (Line(points={{-180,-60},{-148,-60},{-148,-58},{-132,-58}},
                      color={255,127,0}));
                  connect(con.y, or1.u2)
                    annotation (Line(points={{42,10},{60,10},{60,62},{78,62}},
                      color={255,0,255}));
                  connect(intEqu.y, or3.u1)
                    annotation (Line(points={{-38,130},{0,130},{0,108},{18,108}},
                      color={255,0,255}));
                  connect(intEqu2.y, or3.u3)
                    annotation (Line(points={{-38,70},{0,70},{0,92},{18,92}},
                      color={255,0,255}));
                  connect(intEqu1.y, or3.u2)
                    annotation (Line(points={{-38,100},{18,100}}, color={255,0,255}));
                  connect(conInt.y, intEqu.u2)
                    annotation (Line(points={{-98,130},{-90,130},{-90,122},{-62,122}},
                      color={255,127,0}));
                  connect(conInt1.y, intEqu1.u2)
                    annotation (Line(points={{-98,100},{-90,100},{-90,92},{-62,92}},
                      color={255,127,0}));
                  connect(conInt2.y, intEqu2.u2)
                    annotation (Line(points={{-98,70},{-90,70},{-90,62},{-62,62}},
                      color={255,127,0}));
                  connect(conInt3.y, intEqu3.u2)
                    annotation (Line(points={{-98,40},{-90,40},{-90,32},{-62,32}},
                      color={255,127,0}));
                  connect(conInt4.y, intEqu4.u2)
                    annotation (Line(points={{-98,10},{-90,10},{-90,2},{-62,2}},
                      color={255,127,0}));
                  connect(uOpeMod, intEqu.u1)
                    annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},{-80,130},
                      {-62,130}}, color={255,127,0}));
                  connect(uOpeMod, intEqu1.u1)
                    annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},{-80,100},
                      {-62,100}}, color={255,127,0}));
                  connect(uOpeMod, intEqu2.u1)
                    annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},
                      {-80,70},{-62,70}}, color={255,127,0}));
                  connect(uOpeMod, intEqu3.u1)
                    annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},
                      {-80,40},{-62,40}}, color={255,127,0}));
                  connect(uOpeMod, intEqu4.u1)
                    annotation (Line(points={{-180,120},{-140,120},{-140,150},{-80,150},
                      {-80,10},{-62,10}}, color={255,127,0}));
                  connect(or3.y, or1.u1)
                    annotation (Line(points={{42,100},{60,100},{60,70},{78,70}},
                      color={255,0,255}));
                  connect(intEqu3.y, or2.u1)
                    annotation (Line(points={{-38,40},{18,40}}, color={255,0,255}));
                  connect(intEqu4.y, or2.u2)
                    annotation (Line(points={{-38,10},{0,10},{0,32},{18,32}},
                      color={255,0,255}));
                  connect(norPSet.y, conSpe.u_s)
                    annotation (Line(points={{-48,-70},{-42,-70}}, color={0,0,127}));
                  connect(norPMea.y, conSpe.u_m)
                    annotation (Line(points={{-48,-110},{-30,-110},{-30,-82}}, color={0,0,127}));
                  connect(staPreSetRes.y, firOrdHol.u)
                    annotation (Line(points={{-108,-50},{-102,-50}}, color={0,0,127}));
                  connect(conSpe.trigger, or1.y)
                    annotation (Line(points={{-38,-82},{-38,-100},{0,-100},{0,-8},{120,-8},{120,
                          70},{102,70}},  color={255,0,255}));
                  connect(gaiNor.y, norPSet.u2) annotation (Line(points={{-108,-90},{-92,-90},{-92,
                          -76},{-72,-76}}, color={0,0,127}));
                  connect(ducStaPre, norPMea.u1) annotation (Line(points={{-180,-110},{-80,-110},
                          {-80,-104},{-72,-104}}, color={0,0,127}));
                  connect(gaiNor.y, norPMea.u2) annotation (Line(points={{-108,-90},{-92,-90},{-92,
                          -116},{-72,-116}}, color={0,0,127}));
                  connect(firOrdHol.y, norPSet.u1) annotation (Line(points={{-78,-50},{-76,-50},
                          {-76,-64},{-72,-64}}, color={0,0,127}));

                annotation (
                  defaultComponentName="conSupFan",
                  Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-160,-140},{140,160}}),
                        graphics={
                        Rectangle(
                          extent={{-156,-22},{134,-128}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          pattern=LinePattern.None),
                        Rectangle(
                          extent={{-156,156},{134,-6}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          pattern=LinePattern.None),
                        Text(
                          extent={{42,156},{124,134}},
                          lineColor={0,0,255},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          horizontalAlignment=TextAlignment.Left,
                          textString="Check current operation mode"),
                        Text(
                          extent={{54,-26},{124,-38}},
                          lineColor={0,0,255},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          horizontalAlignment=TextAlignment.Left,
                          textString="Reset pressure setpoint"),
                        Text(
                          extent={{-34,-106},{20,-136}},
                          lineColor={0,0,255},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          textString="Control fan speed"),
                        Text(
                          extent={{42,142},{96,126}},
                          lineColor={0,0,255},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          horizontalAlignment=TextAlignment.Left,
                          textString="Check fan on or off")}),
                  Icon(graphics={
                        Text(
                          extent={{-102,140},{96,118}},
                          lineColor={0,0,255},
                          textString="%name"),
                               Rectangle(
                          extent={{-100,100},{100,-100}},
                          lineColor={0,0,0},
                          fillColor={223,211,169},
                          fillPattern=FillPattern.Solid),
                        Text(
                          extent={{-96,90},{-54,70}},
                          lineColor={0,0,127},
                          textString="uOpeMod"),
                        Text(
                          extent={{-96,-16},{-44,-44}},
                          lineColor={0,0,127},
                          textString="uZonPreResReq"),
                        Text(
                          extent={{-96,-70},{-54,-90}},
                          lineColor={0,0,127},
                          textString="ducStaPre"),
                        Text(
                          extent={{54,-60},{96,-80}},
                          lineColor={0,0,127},
                          textString="sumVDis_flow"),
                        Text(
                          extent={{52,10},{94,-10}},
                          lineColor={0,0,127},
                          textString="yFanSpe"),
                        Text(
                          extent={{52,78},{94,58}},
                          lineColor={0,0,127},
                          textString="ySupFan")}),
                  Documentation(info="<html>
<p>
Supply fan control for a multi zone VAV AHU according to
ASHRAE guideline G36, PART 5.N.1 (Supply fan control).
</p>
<h4>Supply fan start/stop</h4>
<ul>
<li>Supply fan shall run when system is in the Cool-down, Setup, or Occupied mode</li>
<li>If there are any VAV-reheat boxes on perimeter zones, supply fan shall also
run when system is in Setback or Warmup mode;</li>
<li>If the AHU does not serve dual duct boxes
that do not have hot-duct inlet airflow sensors (<code>have_duaDucBox=true</code>)
or the AHU does not have airflow measurement station (<code>have_airFloMeaSta=false</code>),
sum the current airflow rate from the VAV boxes and output to a software point.</li>
</ul>
<h4>Static pressure setpoint reset</h4>
<p>
Static pressure setpoint shall be reset using trim-respond logic using following
parameters as a starting point:
</p>
<table summary=\"summary\" border=\"1\">
<tr><th> Variable </th> <th> Value </th> <th> Definition </th> </tr>
<tr><td>Device</td><td>AHU Supply Fan</td> <td>Associated device</td></tr>
<tr><td>SP0</td><td><code>iniSet</code></td><td>Initial setpoint</td></tr>
<tr><td>SPmin</td><td><code>minSet</code></td><td>Minimum setpoint</td></tr>
<tr><td>SPmax</td><td><code>maxSet</code></td><td>Maximum setpoint</td></tr>
<tr><td>Td</td><td><code>delTim</code></td><td>Delay timer</td></tr>
<tr><td>T</td><td><code>samplePeriod</code></td><td>Time step</td></tr>
<tr><td>I</td><td><code>numIgnReq</code></td><td>Number of ignored requests</td></tr>
<tr><td>R</td><td><code>uZonPreResReq</code></td><td>Number of requests</td></tr>
<tr><td>SPtrim</td><td><code>triAmo</code></td><td>Trim amount</td></tr>
<tr><td>SPres</td><td><code>resAmo</code></td><td>Respond amount</td></tr>
<tr><td>SPres_max</td><td><code>maxRes</code></td><td>Maximum response per time interval</td></tr>
</table>
<br/>
<h4>Static pressure control</h4>
<p>
Supply fan speed is controlled with a PI controller to maintain duct static pressure at setpoint
when the fan is proven on. The setpoint for the PI controller and the measured
duct static pressure are normalized with the maximum design static presssure
<code>maxSet</code>.
Where the zone groups served by the system are small,
provide multiple sets of gains that are used in the control loop as a function
of a load indicator (such as supply fan airflow rate, the area of the zone groups
that are occupied, etc.).
</p>
</html>",                 revisions="<html>
<ul>
<li>
March 12, 2020, by Jianjun Hu:<br/>
Removed the sum of flow rate as it is not used in any other sequences.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">issue 1829</a>.
</li>
<li>
January 7, 2020, by Michael Wetter:<br/>
Reformulated to avoid relying on the <code>final</code> keyword.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1701\">issue 1701</a>.
</li>
<li>
October 14, 2017, by Michael Wetter:<br/>
Added normalization of pressure set point and measurement as the measured
quantity is a few hundred Pascal.
</li>
<li>
August 15, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                end SupplyFan;

                block SupplySignals "Multizone VAV AHU coil valve positions"

                  parameter
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                    controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                    "Type of controller for supply air temperature signal";
                  parameter Real kTSup(final unit="1/K")=0.05
                    "Gain of controller for supply air temperature signal";
                  parameter Real TiTSup(
                    final unit="s",
                    final quantity="Time")=600
                    "Time constant of integrator block for supply temperature control signal"
                    annotation(Dialog(
                      enable=controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                           or controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                  parameter Real TdTSup(
                    final unit="s",
                    final quantity="Time")=0.1
                    "Time constant of derivative block for supply temperature control signal"
                    annotation(Dialog(enable=controllerType ==
                          hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                           or controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                  parameter Real uHeaMax(
                    final min=-0.9,
                    final unit="1")=-0.25
                    "Upper limit of controller signal when heating coil is off. Require -1 < uHeaMax < uCooMin < 1.";
                  parameter Real uCooMin(
                    final max=0.9,
                    final unit="1")=0.25
                    "Lower limit of controller signal when cooling coil is off. Require -1 < uHeaMax < uCooMin < 1.";

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSup(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Measured supply air temperature" annotation (Placement(
                        transformation(extent={{-140,-40},{-100,0}}),
                        iconTransformation(extent={{-140,-70},{-100,-30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSupSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Setpoint for supply air temperature" annotation (Placement(
                        transformation(extent={{-140,10},{-100,50}}),
                        iconTransformation(extent={{-140,-20},{-100,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                    uSupFan "Supply fan status" annotation (Placement(
                        transformation(extent={{-140,60},{-100,100}}),
                        iconTransformation(extent={{-140,30},{-100,70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yHea(
                    final min=0,
                    final max=1,
                    final unit="1") "Control signal for heating" annotation (
                      Placement(transformation(extent={{100,0},{140,40}}),
                        iconTransformation(extent={{100,-20},{140,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yCoo(
                    final min=0,
                    final max=1,
                    final unit="1") "Control signal for cooling" annotation (
                      Placement(transformation(extent={{100,-40},{140,0}}),
                        iconTransformation(extent={{100,-60},{140,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput uTSup(
                    final max=1,
                    final unit="1",
                    final min=-1) "Supply temperature control signal"
                    annotation (Placement(transformation(extent={{100,40},{140,
                            80}}), iconTransformation(extent={{100,20},{140,60}})));

                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conTSup(
                    final controllerType=controllerType,
                    final k=kTSup,
                    final Ti=TiTSup,
                    final Td=TdTSup,
                    final yMax=1,
                    final yMin=-1,
                    final y_reset=0,
                    final reverseAction=true,
                    final reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter)
                    "Controller for supply air temperature control signal (to be used by heating coil, cooling coil and economizer)"
                    annotation (Placement(transformation(extent={{-60,20},{-40,
                            40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                    "Switch to select supply temperature control signal based on status of supply fan"
                    annotation (Placement(transformation(extent={{0,50},{20,70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    uHeaMaxCon(final k=uHeaMax)
                    "Constant signal to map control action" annotation (
                      Placement(transformation(extent={{0,-20},{20,0}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    negOne(final k=-1) "Negative unity signal" annotation (
                      Placement(transformation(extent={{0,18},{20,38}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    uCooMinCon(final k=uCooMin)
                    "Constant signal to map control action" annotation (
                      Placement(transformation(extent={{0,-60},{20,-40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    zer(final k=0) "Zero control signal" annotation (Placement(
                        transformation(extent={{-60,-50},{-40,-30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    one(final k=1) "Unity signal" annotation (Placement(
                        transformation(extent={{0,-90},{20,-70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line conSigCoo(final
                      limitBelow=true, final limitAbove=false)
                    "Cooling control signal" annotation (Placement(
                        transformation(extent={{60,-30},{80,-10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line conSigHea(final
                      limitBelow=false, final limitAbove=true)
                    "Heating control signal" annotation (Placement(
                        transformation(extent={{60,10},{80,30}})));

                equation
                  connect(zer.y,swi. u3)
                    annotation (Line(points={{-38,-40},{-20,-40},{-20,52},{-2,52}},
                      color={0,0,127}));
                  connect(TSup,conTSup. u_m)
                    annotation (Line(points={{-120,-20},{-50,-20},{-50,18}}, color={0,0,127}));
                  connect(negOne.y,conSigHea. x1)
                    annotation (Line(points={{22,28},{58,28}},
                      color={0,0,127}));
                  connect(one.y,conSigHea. f1)
                    annotation (Line(points={{22,-80},{50,-80},{50,24},{58,24}},
                      color={0,0,127}));
                  connect(swi.y,conSigHea. u)
                    annotation (Line(points={{22,60},{46,60},{46,20},{58,20}},
                      color={0,0,127}));
                  connect(swi.y,conSigCoo. u)
                    annotation (Line(points={{22,60},{46,60},{46,-20},{58,-20}},
                      color={0,0,127}));
                  connect(uHeaMaxCon.y,conSigHea. x2)
                    annotation (Line(points={{22,-10},{30,-10},{30,16},{58,16}},
                      color={0,0,127}));
                  connect(zer.y,conSigHea. f2)
                    annotation (Line(points={{-38,-40},{-20,-40},{-20,-30},{36,-30},{36,12},
                      {58,12}}, color={0,0,127}));
                  connect(uCooMinCon.y,conSigCoo. x1)
                    annotation (Line(points={{22,-50},{40,-50},{40,-12},{58,-12}},
                      color={0,0,127}));
                  connect(zer.y,conSigCoo. f1)
                    annotation (Line(points={{-38,-40},{-20,-40},{-20,-30},{36,-30},{36,-16},
                      {58,-16}}, color={0,0,127}));
                  connect(one.y,conSigCoo. x2)
                    annotation (Line(points={{22,-80},{50,-80},{50,-24},{58,-24}},
                      color={0,0,127}));
                  connect(one.y,conSigCoo. f2)
                    annotation (Line(points={{22,-80},{50,-80},{50,-28},{58,-28}},
                      color={0,0,127}));
                  connect(conSigHea.y,yHea)
                    annotation (Line(points={{82,20},{120,20}},  color={0,0,127}));
                  connect(conSigCoo.y,yCoo)
                    annotation (Line(points={{82,-20},{120,-20}}, color={0,0,127}));
                  connect(swi.y,uTSup)
                    annotation (Line(points={{22,60},{120,60}},  color={0,0,127}));
                  connect(TSupSet, conTSup.u_s)
                    annotation (Line(points={{-120,30},{-62,30}},
                      color={0,0,127}));
                  connect(uSupFan, swi.u2)
                    annotation (Line(points={{-120,80},{-80,80},{-80,60},{-2,60}},
                      color={255,0,255}));
                  connect(conTSup.y, swi.u1)
                    annotation (Line(points={{-38,30},{-28,30},{-28,68},{-2,68}},
                      color={0,0,127}));
                  connect(uSupFan, conTSup.trigger)
                    annotation (Line(points={{-120,80},{-80,80},{-80,8},{-58,8},{-58,18}},
                      color={255,0,255}));

                annotation (
                  defaultComponentName = "supSig",
                  Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                        Rectangle(
                        extent={{-100,-100},{100,100}},
                        lineColor={0,0,127},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                        Text(
                          extent={{-96,8},{-64,-6}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="TSup"),
                        Text(
                          extent={{-94,-38},{-48,-62}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="uSupFan"),
                        Text(
                          extent={{76,8},{96,-2}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="yHea"),
                        Text(
                          extent={{74,46},{96,34}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="uTSup"),
                        Text(
                          extent={{76,-34},{96,-44}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="yCoo"),
                        Text(
                          extent={{-96,56},{-56,42}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="TSupSet"),
                        Text(
                          extent={{-124,146},{96,108}},
                          lineColor={0,0,255},
                          textString="%name")}),Documentation(info="<html>
<p>
Block that outputs the supply temperature control loop signal,
and the coil valve postions for VAV system with multiple zones,
implemented according to the ASHRAE Guideline G36, PART 5.N.2
(Supply air temperature control).
</p>
<p>
The supply air temperature control loop signal <code>uTSup</code>
is computed using a PI controller that tracks the supply air temperature
setpoint <code>TSupSet</code>.
If the fan is off, then <code>uTSup = 0</code>.
</p>
<p>
Heating valve control signal (or modulating electric heating
coil if applicable) <code>yHea</code> and cooling valve control signal <code>yCoo</code>
are sequenced based on the supply air temperature control loop signal <code>uTSup</code>.
From <code>uTSup = uHeaMax</code> to <code>uTSup = -1</code>,
<code>yHea</code> increases linearly from <i>0</i> to <i>1</i>.
Similarly, <code>uTSup = uCooMin</code> to <code>uTSup = +1</code>,
<code>yCoo</code> increases linearly from <i>0</i> to <i>1</i>.
</p>
<p>
The output <code>uTSup</code> can be used in a controller for the economizer.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                end SupplySignals;

                block SupplyTemperature
                  "Supply air temperature setpoint for multi zone system"

                  parameter Real TSupSetMin(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") = 285.15
                    "Lowest cooling supply air temperature setpoint"
                    annotation (Dialog(group="Temperatures"));
                  parameter Real TSupSetMax(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") = 291.15
                    "Highest cooling supply air temperature setpoint. It is typically 18 degC (65 degF) 
    in mild and dry climates, 16 degC (60 degF) or lower in humid climates"
                    annotation (Dialog(group="Temperatures"));
                  parameter Real TSupSetDes(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") = 286.15
                    "Nominal supply air temperature setpoint"
                    annotation (Dialog(group="Temperatures"));
                  parameter Real TOutMin(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") = 289.15
                    "Lower value of the outdoor air temperature reset range. Typically value is 16 degC (60 degF)"
                    annotation (Dialog(group="Temperatures"));
                  parameter Real TOutMax(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") = 294.15
                    "Higher value of the outdoor air temperature reset range. Typically value is 21 degC (70 degF)"
                    annotation (Dialog(group="Temperatures"));
                  parameter Real TSupWarUpSetBac(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=308.15
                    "Supply temperature in warm up and set back mode"
                    annotation (Dialog(group="Temperatures"));
                  parameter Real iniSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") = maxSet
                    "Initial setpoint"
                    annotation (Dialog(group="Trim and respond logic"));
                  parameter Real maxSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") = TSupSetMax
                    "Maximum setpoint"
                    annotation (Dialog(group="Trim and respond logic"));
                  parameter Real minSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") = TSupSetDes
                    "Minimum setpoint"
                    annotation (Dialog(group="Trim and respond logic"));
                  parameter Real delTim(
                    final unit="s",
                    final quantity="Time") = 600
                    "Delay timer"
                    annotation(Dialog(group="Trim and respond logic"));
                  parameter Real samplePeriod(
                    final unit="s",
                    final quantity="Time",
                    final min=1E-3) = 120
                    "Sample period of component"
                    annotation(Dialog(group="Trim and respond logic"));
                  parameter Integer numIgnReq = 2
                    "Number of ignorable requests for TrimResponse logic"
                    annotation(Dialog(group="Trim and respond logic"));
                  parameter Real triAmo(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference") = 0.1
                    "Trim amount"
                    annotation (Dialog(group="Trim and respond logic"));
                  parameter Real resAmo(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference") = -0.2
                    "Response amount"
                    annotation (Dialog(group="Trim and respond logic"));
                  parameter Real maxRes(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference") = -0.6
                    "Maximum response per time interval"
                    annotation (Dialog(group="Trim and respond logic"));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TOut(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Outdoor air temperature" annotation (Placement(
                        transformation(extent={{-180,40},{-140,80}}),
                        iconTransformation(extent={{-140,20},{-100,60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonSetAve(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Average of heating and cooling setpoint" annotation (
                      Placement(transformation(extent={{-180,70},{-140,110}}),
                        iconTransformation(extent={{-140,60},{-100,100}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                    uSupFan "Supply fan status" annotation (Placement(
                        transformation(extent={{-180,-50},{-140,-10}}),
                        iconTransformation(extent={{-140,-60},{-100,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uOpeMod "System operation mode" annotation (Placement(
                        transformation(extent={{-180,-120},{-140,-80}}),
                        iconTransformation(extent={{-140,-100},{-100,-60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uZonTemResReq
                    "Zone cooling supply air temperature reset request"
                    annotation (Placement(transformation(extent={{-180,0},{-140,
                            40}}), iconTransformation(extent={{-140,-20},{-100,
                            20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TSupSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Setpoint for supply air temperature" annotation (Placement(
                        transformation(extent={{140,-20},{180,20}}),
                        iconTransformation(extent={{100,-20},{140,20}})));

                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.TrimAndRespond
                    maxSupTemRes(
                    final delTim=delTim,
                    final iniSet=iniSet,
                    final minSet=minSet,
                    final maxSet=maxSet,
                    final samplePeriod=samplePeriod,
                    final numIgnReq=numIgnReq,
                    final triAmo=triAmo,
                    final resAmo=resAmo,
                    final maxRes=maxRes)
                    "Maximum cooling supply temperature reset" annotation (
                      Placement(transformation(extent={{-100,20},{-80,40}})));

                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line lin "Supply temperature distributes linearly between minimum and maximum supply 
    air temperature, according to outdoor temperature" annotation (Placement(
                        transformation(extent={{20,40},{40,60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    minOutTem(k=TOutMin)
                    "Lower value of the outdoor air temperature reset range"
                    annotation (Placement(transformation(extent={{-40,60},{-20,
                            80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    maxOutTem(k=TOutMax)
                    "Higher value of the outdoor air temperature reset range"
                    annotation (Placement(transformation(extent={{-40,20},{-20,
                            40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    minSupTem(k=TSupSetMin)
                    "Lowest cooling supply air temperature setpoint"
                    annotation (Placement(transformation(extent={{-100,-20},{-80,
                            0}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2
                    "Check if it is in Setup or Cool-down mode" annotation (
                      Placement(transformation(extent={{-40,-60},{-20,-40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1
                    "Check if it is in Warmup or Setback mode" annotation (
                      Placement(transformation(extent={{20,-100},{40,-80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    supTemWarUpSetBac(k=TSupWarUpSetBac)
                    "Supply temperature setpoint under warm-up and setback mode"
                    annotation (Placement(transformation(extent={{20,-130},{40,
                            -110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                    "If operation mode is setup or cool-down, setpoint shall be 35 degC"
                    annotation (Placement(transformation(extent={{80,-60},{100,
                            -40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi2
                    "If operation mode is setup or cool-down, setpoint shall be TSupSetMin"
                    annotation (Placement(transformation(extent={{20,-60},{40,-40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Limiter TDea(uMax=
                        297.15, uMin=294.15)
                    "Limiter that outputs the dead band value for the supply air temperature"
                    annotation (Placement(transformation(extent={{-100,80},{-80,
                            100}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi3
                    "Check output regarding supply fan status" annotation (
                      Placement(transformation(extent={{80,-10},{100,10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.LessThreshold
                    intLesThr(threshold=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                    "Check if operation mode index is less than warm-up mode index (4)"
                    annotation (Placement(transformation(extent={{-100,-60},{-80,
                            -40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold
                    intGreThr(threshold=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                    "Check if operation mode index is greater than occupied mode index (1)"
                    annotation (Placement(transformation(extent={{-100,-90},{-80,
                            -70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.LessThreshold
                    intLesThr1(threshold=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.unoccupied)
                    "Check if operation mode index is less than unoccupied mode index (7)"
                    annotation (Placement(transformation(extent={{-40,-100},{-20,
                            -80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold
                    intGreThr1(threshold=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.setUp)
                    "Check if operation mode index is greater than set up mode index (3)"
                    annotation (Placement(transformation(extent={{-40,-130},{-20,
                            -110}})));

                equation
                  connect(minOutTem.y, lin.x1)
                    annotation (Line(points={{-18,70},{0,70},{0,58},{18,58}},
                      color={0,0,127}));
                  connect(TOut, lin.u)
                    annotation (Line(points={{-160,60},{-100,60},{-100,50},{18,50}},
                      color={0,0,127}));
                  connect(maxOutTem.y, lin.x2)
                    annotation (Line(points={{-18,30},{0,30},{0,46},{18,46}},
                      color={0,0,127}));
                  connect(minSupTem.y, lin.f2)
                    annotation (Line(points={{-78,-10},{10,-10},{10,42},{18,42}},
                      color={0,0,127}));
                  connect(and1.y, swi1.u2)
                    annotation (Line(points={{42,-90},{60,-90},{60,-50},{78,-50}},
                      color={255,0,255}));
                  connect(supTemWarUpSetBac.y, swi1.u1)
                    annotation (Line(points={{42,-120},{68,-120},{68,-42},{78,-42}},
                      color={0,0,127}));
                  connect(and2.y, swi2.u2)
                    annotation (Line(points={{-18,-50},{18,-50}},color={255,0,255}));
                  connect(minSupTem.y, swi2.u1)
                    annotation (Line(points={{-78,-10},{0,-10},{0,-42},{18,-42}},
                      color={0,0,127}));
                  connect(swi2.y, swi1.u3)
                    annotation (Line(points={{42,-50},{50,-50},{50,-58},{78,-58}},
                      color={0,0,127}));
                  connect(TZonSetAve, TDea.u)
                    annotation (Line(points={{-160,90},{-102,90}},
                      color={0,0,127}));
                  connect(uSupFan, swi3.u2)
                    annotation (Line(points={{-160,-30},{-120,-30},{-120,10},{-60,10},{-60,0},
                      {78,0}}, color={255,0,255}));
                  connect(swi1.y, swi3.u1)
                    annotation (Line(points={{102,-50},{110,-50},{110,-20},{68,-20},{68,8},{78,8}},
                      color={0,0,127}));
                  connect(TDea.y, swi3.u3)
                    annotation (Line(points={{-78,90},{60,90},{60,-8},{78,-8}},
                      color={0,0,127}));
                  connect(intLesThr1.y, and1.u1)
                    annotation (Line(points={{-18,-90},{18,-90}},
                      color={255,0,255}));
                  connect(intGreThr1.y, and1.u2)
                    annotation (Line(points={{-18,-120},{0,-120},{0,-98},{18,-98}},
                      color={255,0,255}));
                  connect(intLesThr.y, and2.u1)
                    annotation (Line(points={{-78,-50},{-42,-50}},color={255,0,255}));
                  connect(intGreThr.y, and2.u2)
                    annotation (Line(points={{-78,-80},{-60,-80},{-60,-58},{-42,-58}},
                      color={255,0,255}));
                  connect(uOpeMod, intLesThr.u)
                    annotation (Line(points={{-160,-100},{-120,-100},{-120,-50},{-102,-50}},
                      color={255,127,0}));
                  connect(uOpeMod, intGreThr.u)
                    annotation (Line(points={{-160,-100},{-120,-100},{-120,-80},{-102,-80}},
                      color={255,127,0}));
                  connect(uOpeMod, intLesThr1.u)
                    annotation (Line(points={{-160,-100},{-60,-100},{-60,-90},{-42,-90}},
                      color={255,127,0}));
                  connect(uOpeMod, intGreThr1.u)
                    annotation (Line(points={{-160,-100},{-120,-100},{-120,-120},{-42,-120}},
                      color={255,127,0}));
                  connect(lin.y, swi2.u3)
                    annotation (Line(points={{42,50},{50,50},{50,-30},{8,-30},{8,-58},{18,-58}},
                      color={0,0,127}));
                  connect(uZonTemResReq, maxSupTemRes.numOfReq)
                    annotation (Line(points={{-160,20},{-112,20},{-112,22},{-102,22}},
                      color={255,127,0}));
                  connect(uSupFan, maxSupTemRes.uDevSta)
                    annotation (Line(points={{-160,-30},{-120,-30},{-120,38},{-102,38}},
                      color={255,0,255}));
                  connect(maxSupTemRes.y, lin.f1)
                    annotation (Line(points={{-78,30},{-60,30},{-60,54},{18,54}},
                      color={0,0,127}));
                  connect(swi3.y, TSupSet)
                    annotation (Line(points={{102,0},{160,0}},   color={0,0,127}));

                annotation (
                  defaultComponentName = "conTSupSet",
                  Icon(graphics={
                        Rectangle(
                        extent={{-100,-100},{100,100}},
                        lineColor={0,0,127},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                        Text(
                          extent={{-94,92},{-42,66}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="TZonSetAve"),
                        Text(
                          extent={{-96,46},{-68,34}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="TOut"),
                        Text(
                          extent={{-94,-22},{-14,-58}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="uZonTemResReq"),
                        Text(
                          extent={{-94,12},{-48,-12}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="uSupFan"),
                        Text(
                          extent={{-94,-70},{-50,-90}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="uOpeMod"),
                        Text(
                          extent={{68,8},{96,-8}},
                          lineColor={0,0,127},
                          pattern=LinePattern.Dash,
                          textString="TSupSet"),
                        Text(
                          extent={{-124,146},{96,108}},
                          lineColor={0,0,255},
                          textString="%name")}),
                  Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,-140},{140,120}})),
                  Documentation(info="<html>
<p>
Block that outputs the supply air temperature setpoint and the coil valve control
inputs for VAV system with multiple zones, implemented according to the ASHRAE
Guideline G36, PART 5.N.2 (Supply air temperature control).
</p>
<p>
The control loop is enabled when the supply air fan <code>uSupFan</code> is proven on,
and disabled and the output set to Deadband otherwise.
</p>
<p> The supply air temperature setpoint is computed as follows.</p>
<h4>Setpoints for <code>TSupSetMin</code>, <code>TSupSetMax</code>,
<code>TSupSetDes</code>, <code>TOutMin</code>, <code>TOutMax</code></h4>
<p>
The default range of outdoor air temperature (<code>TOutMin=16&deg;C</code>,
<code>TOutMax=21&deg;C</code>) used to reset the occupied mode <code>TSupSet</code>
was chosen to maximize economizer hours. It may be preferable to use a lower
range of outdoor air temperature (e.g. <code>TOutMin=13&deg;C</code>,
<code>TOutMax=18&deg;C</code>) to minimize fan energy.
</p>
<p>
The <code>TSupSetMin</code> variable is used during warm weather when little reheat
is expected to minimize fan energy. It should not be set too low or it may cause
excessive chilled water temperature reset requests which will reduce chiller
plant efficiency. It should be set no lower than the design coil leaving air
temperature.
</p>
<p>
The <code>TSupSetMax</code> variable is typically 18 &deg;C in mild and dry climate,
16 &deg;C or lower in humid climates. It should not typically be greater than
18 &deg;C since this may lead to excessive fan energy that can offset the mechanical
cooling savings from economizer operation.
</p>

<h4>During occupied mode (<code>uOpeMod=1</code>)</h4>
<p>
The <code>TSupSet</code> shall be reset from <code>TSupSetMin</code> when the outdoor
air temperature is <code>TOutMax</code> and above, proportionally up to
maximum supply temperature when the outdoor air temperature is <code>TOutMin</code> and
below. The maximum supply temperature shall be reset using trim and respond logic between
<code>TSupSetDes</code> and <code>TSupSetMax</code>. Parameters suggested for the
trim and respond logic are shown in the table below. They require adjustment
during the commissioning and tuning phase.
</p>

<table summary=\"summary\" border=\"1\">
<tr><th> Variable </th> <th> Value </th> <th> Definition </th> </tr>
<tr><td>Device</td><td>AHU Supply Fan</td> <td>Associated device</td></tr>
<tr><td>SP0</td><td><code>iniSet</code></td><td>Initial setpoint</td></tr>
<tr><td>SPmin</td><td><code>TSupSetDes</code></td><td>Minimum setpoint</td></tr>
<tr><td>SPmax</td><td><code>TSupSetMax</code></td><td>Maximum setpoint</td></tr>
<tr><td>Td</td><td><code>delTim</code></td><td>Delay timer</td></tr>
<tr><td>T</td><td><code>samplePeriod</code></td><td>Time step</td></tr>
<tr><td>I</td><td><code>numIgnReq</code></td><td>Number of ignored requests</td></tr>
<tr><td>R</td><td><code>uZonTemResReq</code></td><td>Number of requests</td></tr>
<tr><td>SPtrim</td><td><code>triAmo</code></td><td>Trim amount</td></tr>
<tr><td>SPres</td><td><code>resAmo</code></td><td>Respond amount</td></tr>
<tr><td>SPres_max</td><td><code>maxRes</code></td><td>Maximum response per time interval</td></tr>
</table>
<br/>

<p align=\"center\">
<img alt=\"Image of set point reset\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAVSupTempSet.png\"/>
</p>

<h4>During Setup and Cool-down modes (<code>uOpeMod=2</code>, <code>uOpeMod=3</code>)</h4>
<p>
Supply air temperature setpoint <code>TSupSet</code> shall be <code>TSupSetMin</code>.
</p>
<h4>During Setback and Warmup modes (<code>uOpeMod=4</code>, <code>uOpeMod=5</code>)</h4>
<p>
Supply air temperature setpoint <code>TSupSet</code> shall be <code>TSupWarUpSetBac</code>.
</p>

<h4>Valves control</h4>
<p>
Supply air temperature shall be controlled to setpoint using a control loop whose
output is mapped to sequence the hot water valve or modulating electric heating
coil (if applicable) or chilled water valves.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 12, 2020, by Jianjun Hu:<br/>
Propagated supply temperature setpoint of warmup and setback mode.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
July 11, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                end SupplyTemperature;

                package OutdoorAirFlow "Package of sequences for calculating minimum outdoor airflow rate"
                  block AHU "Output outdoor airflow related calculations at the AHU level"

                    parameter Real VPriSysMax_flow(unit="m3/s")
                      "Maximum expected system primary airflow at design stage"
                      annotation(Dialog(group="Nominal condition"));

                    parameter Real peaSysPop(final unit="1")
                      "Peak system population"
                      annotation(Dialog(group="Nominal condition"));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      sumDesZonPop(final min=0, final unit="1")
                      "Sum of the design population of the zones in the group"
                      annotation (Placement(transformation(extent={{-260,180},{
                              -220,220}}), iconTransformation(extent={{-140,70},
                              {-100,110}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VSumDesPopBreZon_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Sum of the population component design breathing zone flow rate"
                      annotation (Placement(transformation(extent={{-260,140},{
                              -220,180}}), iconTransformation(extent={{-140,50},
                              {-100,90}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VSumDesAreBreZon_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Sum of the area component design breathing zone flow rate"
                      annotation (Placement(transformation(extent={{-260,100},{
                              -220,140}}), iconTransformation(extent={{-140,30},
                              {-100,70}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uDesSysVenEff(final min=0, final unit="1")
                      "Design system ventilation efficiency, equals to the minimum of all zones ventilation efficiency"
                      annotation (Placement(transformation(extent={{-260,60},{-220,
                              100}}), iconTransformation(extent={{-140,10},{-100,
                              50}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VSumUncOutAir_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Sum of all zones required uncorrected outdoor airflow rate"
                      annotation (Placement(transformation(extent={{-260,-44},{
                              -220,-4}}), iconTransformation(extent={{-140,-10},
                              {-100,30}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VSumSysPriAir_flow(final unit="m3/s", final quantity=
                          "VolumeFlowRate")
                      "System primary airflow rate, equals to the sum of the measured discharged flow rate of all terminal units"
                      annotation (Placement(transformation(extent={{-260,-80},{
                              -220,-40}}), iconTransformation(extent={{-140,-30},
                              {-100,10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uOutAirFra_max(final min=0, final unit="1")
                      "Maximum zone outdoor air fraction, equals to the maximum of primary outdoor air fraction of all zones"
                      annotation (Placement(transformation(extent={{-260,-120},
                              {-220,-80}}), iconTransformation(extent={{-140,-50},
                              {-100,-10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                      uSupFan "Supply fan status, true if on, false if off"
                      annotation (Placement(transformation(extent={{-260,-160},
                              {-220,-120}}), iconTransformation(extent={{-140,-90},
                              {-100,-50}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                      uOpeMod "AHU operation mode status signal" annotation (
                        Placement(transformation(extent={{-260,-200},{-220,-160}}),
                          iconTransformation(extent={{-140,-110},{-100,-70}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VDesUncOutAir_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Design uncorrected minimum outdoor airflow rate"
                      annotation (Placement(transformation(extent={{240,160},{
                              280,200}}), iconTransformation(extent={{100,60},{
                              140,100}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yAveOutAirFraPlu(final min=0, final unit="1")
                      "Average outdoor air flow fraction plus 1" annotation (
                        Placement(transformation(extent={{240,110},{280,150}}),
                          iconTransformation(extent={{100,30},{140,70}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VDesOutAir_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Design minimum outdoor airflow rate" annotation (
                        Placement(transformation(extent={{240,60},{280,100}}),
                          iconTransformation(extent={{100,0},{140,40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VEffOutAir_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Effective minimum outdoor airflow setpoint" annotation (
                        Placement(transformation(extent={{240,10},{280,50}}),
                          iconTransformation(extent={{100,-40},{140,0}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      effOutAir_normalized(final unit="1")
                      "Effective minimum outdoor airflow setpoint, normalized by VDesOutMin_flow_nominal"
                      annotation (Placement(transformation(extent={{240,-70},{
                              280,-30}}), iconTransformation(extent={{100,-70},
                              {140,-30}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput
                      yReqOutAir
                      "True if the AHU supply fan is on and the zone is in occupied mode"
                      annotation (Placement(transformation(extent={{240,-160},{
                              280,-120}}), iconTransformation(extent={{100,-100},
                              {140,-60}})));

                  protected
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division outAirFra
                      "System outdoor air fraction" annotation (Placement(
                          transformation(extent={{-120,-20},{-100,0}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter
                      addPar(final p=1, final k=1)
                      "System outdoor air flow fraction plus 1" annotation (
                        Placement(transformation(extent={{-80,-20},{-60,0}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add sysVenEff(final k2=
                          -1) "Current system ventilation efficiency"
                      annotation (Placement(transformation(extent={{-40,-40},{-20,
                              -20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division effMinOutAirInt
                      "Effective minimum outdoor air setpoint" annotation (
                        Placement(transformation(extent={{100,10},{120,30}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division occDivFra
                      "Occupant diversity fraction" annotation (Placement(
                          transformation(extent={{-120,180},{-100,200}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add unCorOutAirInk
                      "Uncorrected outdoor air intake" annotation (Placement(
                          transformation(extent={{0,140},{20,160}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro
                      "Product of inputs" annotation (Placement(transformation(
                            extent={{-60,160},{-40,180}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain aveOutAirFra(final k=1
                          /VPriSysMax_flow) "Average outdoor air fraction"
                      annotation (Placement(transformation(extent={{60,120},{80,
                              140}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter
                      addPar1(final p=1, final k=1)
                      "Average outdoor air flow fraction plus 1" annotation (
                        Placement(transformation(extent={{120,120},{140,140}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division desOutAirInt
                      "Design system outdoor air intake" annotation (Placement(
                          transformation(extent={{60,70},{80,90}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min min
                      "Minimum outdoor airflow rate should not be more than designed outdoor airflow rate"
                      annotation (Placement(transformation(extent={{180,20},{
                              200,40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min sysUncOutAir
                      "Uncorrected outdoor air rate should not be higher than its design value"
                      annotation (Placement(transformation(extent={{-180,0},{-160,
                              20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      occMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "Occupied mode index" annotation (Placement(
                          transformation(extent={{-180,-230},{-160,-210}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      peaSysPopulation(final k=peaSysPop)
                      "Peak system population" annotation (Placement(
                          transformation(extent={{-180,210},{-160,230}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu1
                      "Check if operation mode is occupied" annotation (
                        Placement(transformation(extent={{-100,-190},{-80,-170}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1
                      "Logical and" annotation (Placement(transformation(extent
                            ={{120,-150},{140,-130}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi4
                      "Ensuring the system efficiency will not be negative"
                      annotation (Placement(transformation(extent={{60,-70},{80,
                              -50}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      conOne(final k=1)
                      "Set system ventilation efficiency to 1" annotation (
                        Placement(transformation(extent={{20,-80},{40,-60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division norVOutMin
                      "Normalization for minimum outdoor air flow rate"
                      annotation (Placement(transformation(extent={{180,-60},{
                              200,-40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis
                      hys1(final uLow=1E-4, final uHigh=1E-3)
                      "Check if system ventilation efficiency is greater than 0 (using 1E-4 tolerance)"
                      annotation (Placement(transformation(extent={{22,-40},{42,
                              -20}})));

                  equation
                    connect(peaSysPopulation.y, occDivFra.u1)
                      annotation (Line(points={{-158,220},{-140,220},{-140,196},{-122,196}},
                        color={0,0,127}));
                    connect(pro.y, unCorOutAirInk.u1)
                      annotation (Line(points={{-38,170},{-20,170},{-20,156},{-2,156}},
                        color={0,0,127}));
                    connect(aveOutAirFra.y, addPar1.u)
                      annotation (Line(points={{82,130},{118,130}},color={0,0,127}));
                    connect(unCorOutAirInk.y, desOutAirInt.u1)
                      annotation (Line(points={{22,150},{40,150},{40,86},{58,86}},    color={0,0,127}));
                    connect(sysUncOutAir.y, effMinOutAirInt.u1) annotation (Line(points={{-158,10},
                            {-140,10},{-140,26},{98,26}}, color={0,0,127}));
                    connect(sysUncOutAir.y, outAirFra.u1) annotation (Line(points={{-158,10},{-140,
                            10},{-140,-4},{-122,-4}}, color={0,0,127}));
                    connect(unCorOutAirInk.y, sysUncOutAir.u1) annotation (Line(points={{22,150},{
                            40,150},{40,50},{-200,50},{-200,16},{-182,16}}, color={0,0,127}));
                    connect(desOutAirInt.y, min.u1)
                      annotation (Line(points={{82,80},{140,80},{140,36},{178,36}},
                        color={0,0,127}));
                    connect(unCorOutAirInk.y, VDesUncOutAir_flow)
                      annotation (Line(points={{22,150},{40,150},{40,180},{260,180}},
                        color={0,0,127}));
                    connect(desOutAirInt.y, VDesOutAir_flow)
                      annotation (Line(points={{82,80},{260,80}}, color={0,0,127}));
                    connect(occDivFra.y, pro.u1)
                      annotation (Line(points={{-98,190},{-80,190},{-80,176},{-62,176}},
                        color={0,0,127}));
                    connect(uOpeMod, intEqu1.u1)
                      annotation (Line(points={{-240,-180},{-102,-180}},color={255,127,0}));
                    connect(occMod.y, intEqu1.u2)
                      annotation (Line(points={{-158,-220},{-140,-220},{-140,-188},{-102,-188}},
                        color={255,127,0}));
                    connect(intEqu1.y, and1.u2)
                      annotation (Line(points={{-78,-180},{20,-180},{20,-148},{118,-148}},
                        color={255,0,255}));
                    connect(sysVenEff.y, swi4.u1)
                      annotation (Line(points={{-18,-30},{0,-30},{0,-52},{58,-52}},
                        color={0,0,127}));
                    connect(swi4.y, effMinOutAirInt.u2)
                      annotation (Line(points={{82,-60},{90,-60},{90,14},{98,14}},
                        color={0,0,127}));
                    connect(outAirFra.y, addPar.u)
                      annotation (Line(points={{-98,-10},{-82,-10}}, color={0,0,127}));
                    connect(addPar.y, sysVenEff.u1)
                      annotation (Line(points={{-58,-10},{-50,-10},{-50,-24},{-42,-24}},
                        color={0,0,127}));
                    connect(conOne.y, swi4.u3)
                      annotation (Line(points={{42,-70},{50,-70},{50,-68},{58,-68}},
                        color={0,0,127}));
                    connect(VEffOutAir_flow, min.y)
                      annotation (Line(points={{260,30},{202,30}}, color={0,0,127}));
                    connect(effMinOutAirInt.y, min.u2)
                      annotation (Line(points={{122,20},{160,20},{160,24},{178,24}},
                        color={0,0,127}));
                    connect(norVOutMin.u1, min.y)
                      annotation (Line(points={{178,-44},{160,-44},{160,-10},{220,-10},
                        {220,30},{202,30}}, color={0,0,127}));
                    connect(desOutAirInt.y, norVOutMin.u2)
                      annotation (Line(points={{82,80},{140,80},{140,-56},{178,-56}},
                        color={0,0,127}));
                    connect(norVOutMin.y, effOutAir_normalized)
                      annotation (Line(points={{202,-50},{260,-50}}, color={0,0,127}));
                    connect(uSupFan, and1.u1)
                      annotation (Line(points={{-240,-140},{118,-140}},
                        color={255,0,255}));
                    connect(sysVenEff.y, hys1.u)
                      annotation (Line(points={{-18,-30},{20,-30}}, color={0,0,127}));
                    connect(hys1.y, swi4.u2)
                      annotation (Line(points={{44,-30},{50,-30},{50,-60},{58,-60}},
                        color={255,0,255}));
                    connect(addPar1.y, yAveOutAirFraPlu)
                      annotation (Line(points={{142,130},{260,130}},color={0,0,127}));
                    connect(occDivFra.u2, sumDesZonPop)
                      annotation (Line(points={{-122,184},{-200,184},{-200,200},{-240,200}},
                        color={0,0,127}));
                    connect(pro.u2, VSumDesPopBreZon_flow) annotation (Line(points={{-62,164},{-200,
                            164},{-200,160},{-240,160}}, color={0,0,127}));
                    connect(unCorOutAirInk.u2, VSumDesAreBreZon_flow) annotation (Line(points={{-2,144},
                            {-200,144},{-200,120},{-240,120}},      color={0,0,127}));
                    connect(desOutAirInt.u2, uDesSysVenEff) annotation (Line(points={{58,74},{-80,
                            74},{-80,80},{-240,80}}, color={0,0,127}));
                    connect(sysUncOutAir.u2, VSumUncOutAir_flow) annotation (Line(points={{-182,4},
                            {-200,4},{-200,-24},{-240,-24}}, color={0,0,127}));
                    connect(outAirFra.u2, VSumSysPriAir_flow) annotation (Line(points={{-122,-16},
                            {-140,-16},{-140,-60},{-240,-60}}, color={0,0,127}));
                    connect(sysVenEff.u2, uOutAirFra_max)
                      annotation (Line(points={{-42,-36},{-60,-36},{-60,-100},{-240,-100}},
                        color={0,0,127}));

                    connect(and1.y, yReqOutAir)
                      annotation (Line(points={{142,-140},{260,-140}}, color={255,0,255}));
                    connect(aveOutAirFra.u, unCorOutAirInk.y) annotation (Line(points={{58,130},{40,
                            130},{40,150},{22,150}}, color={0,0,127}));
                  annotation (
                    defaultComponentName="ahuOutAirSet",
                    Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                         graphics={Rectangle(
                            extent={{-100,100},{100,-100}},
                            lineColor={0,0,0},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-100,158},{100,118}},
                            lineColor={0,0,255},
                            textString="%name"),
                          Text(
                            extent={{-98,98},{-34,86}},
                            lineColor={0,0,0},
                            textString="sumDesZonPop"),
                          Text(
                            extent={{-96,-62},{-52,-76}},
                            lineColor={255,0,255},
                            textString="uSupFan"),
                          Text(
                            extent={{-96,-82},{-50,-96}},
                            lineColor={255,127,0},
                            textString="uOpeMod"),
                          Text(
                            extent={{-98,78},{-12,62}},
                            lineColor={0,0,0},
                            textString="VDesPopBreZon_flow"),
                          Text(
                            extent={{-98,58},{-12,42}},
                            lineColor={0,0,0},
                            textString="VDesAreBreZon_flow"),
                          Text(
                            extent={{-98,38},{-34,26}},
                            lineColor={0,0,0},
                            textString="desSysVenEff"),
                          Text(
                            extent={{-98,18},{-30,4}},
                            lineColor={0,0,0},
                            textString="VUncOutAir_flow"),
                          Text(
                            extent={{-98,-2},{-34,-18}},
                            lineColor={0,0,0},
                            textString="VSysPriAir_flow"),
                          Text(
                            extent={{-98,-22},{-28,-38}},
                            lineColor={0,0,0},
                            textString="uOutAirFra_max"),
                          Text(
                            extent={{42,-74},{102,-86}},
                            lineColor={255,0,255},
                            textString="yReqOutAir"),
                          Text(
                            extent={{20,88},{96,72}},
                            lineColor={0,0,0},
                            textString="VDesUncOutAir_flow"),
                          Text(
                            extent={{30,60},{98,44}},
                            lineColor={0,0,0},
                            textString="yAveOutAirFraPlu"),
                          Text(
                            extent={{34,30},{98,12}},
                            lineColor={0,0,0},
                            textString="VDesOutAir_flow"),
                          Text(
                            extent={{38,-10},{98,-26}},
                            lineColor={0,0,0},
                            textString="VEffOutAir_flow"),
                          Text(
                            extent={{18,-40},{98,-56}},
                            lineColor={0,0,0},
                            textString="effOutAir_normalized")}),
                  Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-220,-240},{240,240}})),
                  Documentation(info="<html>
<p>
This sequence outputs AHU level design minimum outdoor airflow rate
<code>VDesOutAir_flow</code> and effective minimum outdoor airflow rate
<code>VEffOutAir_flow</code>.
</p>
<p>
It requires following inputs which are sum, maximum or minimum of the outputs from
the zone level calculation:
</p>
<ol>
<li>
Sum of the design population of the zones in the group, <code>sumDesZonPop</code>.
</li>
<li>
Sum of the population component design breathing zone flow rate,
<code>VSumDesPopBreZon_flow</code>.
</li>
<li>
Sum of the area component design breathing zone flow rate,
<code>VSumDesAreBreZon_flow</code>.
</li>
<li>
Minimum of all zones ventilation efficiency, <code>uDesSysVenEff</code>.
</li>
<li>
Sum of all zones required uncorrected outdoor airflow rate, <code>VSumUncOutAir_flow</code>.
</li>
<li>
Sum of the measured discharged flow rate of all terminal units,
<code>VSumSysPriAir_flow</code>.
</li>
<li>
Maximum of primary outdoor air fraction of all zones, <code>uOutAirFra_max</code>.
</li>
</ol>
<p>
The calculation is done using the steps below.
</p>
<ol>
<li>
<p>
Compute the occupancy diversity fraction <code>occDivFra</code>.
During system operation, the system population equals the sum of the zone population,
so <code>occDivFra=1</code>. It has no impact on the calculation of the uncorrected
outdoor airflow <code>sysUncOutAir</code>.
For design purpose, compute for all zones
</p>
<pre>
    occDivFra = peaSysPop/sumDesZonPop
</pre>
<p>
where <code>peaSysPop</code> is the peak system population and
<code>sumDesZonPop</code> is the sum of the design population.
</p>
</li>
<li>
<p>
Compute the design uncorrected outdoor airflow rate <code>VDesUncOutAir_flow</code> as
</p>
<pre>
    VDesUncOutAir_flow = occDivFra*VSumDesPopBreZon_flow+VSumDesAreBreZon_flow.
</pre>
</li>
<li>
<p>
Compute the uncorrected outdoor airflow rate <code>sysUncOutAir</code> as
</p>
<pre>
    sysUncOutAir = min(VDesUncOutAir_flow, VSumUncOutAir_flow)
</pre>
<p>
where <code>VSumUncOutAir_flow</code> is sum of all zones required uncorrected
outdoor airflow rate
</p>
</li>
<li>
<p>
Compute the outdoor air fraction as
</p>
<pre>
    outAirFra = sysUncOutAir/VSumSysPriAir_flow.
</pre>
<p>
For design purpose, use
</p>
<pre>
    aveOutAirFra = sysUncOutAir/VPriSysMax_flow.
</pre>
<p>
where <code>VPriSysMax_flow</code> is the maximum expected system primary airflow
at design stage.
</p>
</li>
<li>
<p>
Compute the system ventilation efficiency <code>sysVenEff</code>. During system
operation, the efficiency is
</p>
<pre>
    sysVenEff = 1 + outAirFra - uOutAirFra_max
</pre> 
</li>
<li>
<p>
Compute the minimum required AHU outdoor air intake flow rate.
The minimum required system outdoor air intake flow should be the uncorrected
outdoor air intake <code>sysUncOutAir</code> divided by the system ventilation
efficiency <code>sysVenEff</code>, but it should not be larger than the design
outdoor air rate <code>desOutAirInt</code>. Hence,
</p>
<pre>
    effMinOutAirInt = min(sysUncOutAir/sysVenEff, desOutAirInt),
</pre>
<p>
where the design outdoor air rate <code>desOutAirInt</code> is
</p>
<pre>
    desOutAirInt = VDesUncOutAir_flow/uDesSysVenEff.
</pre>
</li>
</ol>
</html>",                   revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Separated from original sequence of finding the system minimum outdoor air setpoint.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
February 27, 2020, by Jianjun Hu:<br/>
Applied hysteresis for checking ventilation efficiency.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1787\">#1787</a>.
</li>
<li>
January 30, 2020, by Michael Wetter:<br/>
Removed the use of <code>fill</code> when assigning the <code>unit</code> attribute.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1728\">#1728</a>.
</li>
<li>
January 12, 2019, by Michael Wetter:<br/>
Added missing <code>each</code>.
</li>
<li>
July 5, 2017, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
May 12, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end AHU;

                  block SumZone
                    "Output the sum, maximum and minimum from the zone level calculation"

                    parameter Integer numZon(min=2)
                      "Total number of zones that the system serves";

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uDesZonPeaOcc[numZon](final min=fill(0, numZon), final
                        unit=fill("1", numZon)) "Design zone peak occupancy"
                      annotation (Placement(transformation(extent={{-140,100},{
                              -100,140}}), iconTransformation(extent={{-140,60},
                              {-100,100}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VDesPopBreZon_flow[numZon](
                      final min=fill(0, numZon),
                      final unit=fill("m3/s", numZon),
                      final quantity=fill("VolumeFlowRate", numZon))
                      "Population component breathing zone design outdoor airflow"
                      annotation (Placement(transformation(extent={{-140,70},{-100,
                              110}}), iconTransformation(extent={{-140,40},{-100,
                              80}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VDesAreBreZon_flow[numZon](
                      final min=fill(0, numZon),
                      final unit=fill("m3/s", numZon),
                      final quantity=fill("VolumeFlowRate", numZon))
                      "Area component breathing zone design outdoor airflow"
                      annotation (Placement(transformation(extent={{-140,40},{-100,
                              80}}), iconTransformation(extent={{-140,20},{-100,
                              60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      yAveOutAirFraPlu(final min=0, final unit="1")
                      "Average system outdoor air flow fraction plus 1"
                      annotation (Placement(transformation(extent={{-140,0},{-100,
                              40}}), iconTransformation(extent={{-140,0},{-100,
                              40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uDesPriOutAirFra[numZon](
                      final min=fill(0, numZon),
                      final max=fill(1, numZon),
                      final unit=fill("1", numZon))
                      "Design zone primary outdoor air fraction" annotation (
                        Placement(transformation(extent={{-140,-40},{-100,0}}),
                          iconTransformation(extent={{-140,-40},{-100,0}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VUncOutAir_flow[numZon](
                      final min=fill(0, numZon),
                      final unit=fill("m3/s", numZon),
                      final quantity=fill("VolumeFlowRate", numZon))
                      "Uncorrected outdoor airflow rate" annotation (Placement(
                          transformation(extent={{-140,-70},{-100,-30}}),
                          iconTransformation(extent={{-140,-60},{-100,-20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uPriOutAirFra[numZon](
                      final min=fill(0, numZon),
                      final max=fill(1, numZon),
                      final unit=fill("1", numZon))
                      "Primary outdoor air fraction" annotation (Placement(
                          transformation(extent={{-140,-100},{-100,-60}}),
                          iconTransformation(extent={{-140,-80},{-100,-40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VPriAir_flow[numZon](
                      final min=fill(0, numZon),
                      final unit=fill("m3/s", numZon),
                      final quantity=fill("VolumeFlowRate", numZon))
                      "Primary airflow rate" annotation (Placement(
                          transformation(extent={{-140,-140},{-100,-100}}),
                          iconTransformation(extent={{-140,-100},{-100,-60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      ySumDesZonPop(final min=0, final unit="1")
                      "Sum of the design population of the zones in the group"
                      annotation (Placement(transformation(extent={{100,100},{
                              140,140}}), iconTransformation(extent={{100,70},{
                              140,110}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VSumDesPopBreZon_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Sum of the population component design breathing zone flow rate"
                      annotation (Placement(transformation(extent={{100,70},{
                              140,110}}), iconTransformation(extent={{100,40},{
                              140,80}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VSumDesAreBreZon_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Sum of the area component design breathing zone flow rate"
                      annotation (Placement(transformation(extent={{100,40},{
                              140,80}}), iconTransformation(extent={{100,10},{
                              140,50}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yDesSysVenEff(final min=0, final unit="1")
                      "Design system ventilation efficiency, equals to the minimum of all zones ventilation efficiency"
                      annotation (Placement(transformation(extent={{100,-20},{
                              140,20}}), iconTransformation(extent={{100,-20},{
                              140,20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VSumUncOutAir_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Sum of the required uncorrected outdoor airflow rate"
                      annotation (Placement(transformation(extent={{100,-70},{
                              140,-30}}), iconTransformation(extent={{100,-50},
                              {140,-10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      uOutAirFra_max(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Maximum zone outdoor air fraction, equals to the maximum of primary outdoor air fraction of all zones"
                      annotation (Placement(transformation(extent={{100,-100},{
                              140,-60}}), iconTransformation(extent={{100,-80},
                              {140,-40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VSumSysPriAir_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "AHU level primary airflow rate, equals to the sum of the measured discharged flow rate of all terminal units"
                      annotation (Placement(transformation(extent={{100,-140},{
                              140,-100}}), iconTransformation(extent={{100,-110},
                              {140,-70}})));

                  protected
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum sysUncOutAir(final nin
                        =numZon) "Uncorrected outdoor airflow" annotation (
                        Placement(transformation(extent={{-10,-60},{10,-40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum sysPriAirRate(final nin
                        =numZon) "System primary airflow rate" annotation (
                        Placement(transformation(extent={{-10,-130},{10,-110}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum sumDesZonPop(final nin
                        =numZon)
                      "Sum of the design zone population for all zones"
                      annotation (Placement(transformation(extent={{-10,110},{
                              10,130}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum sumDesBreZonPop(final nin
                        =numZon)
                      "Sum of the design breathing zone flow rate for population component"
                      annotation (Placement(transformation(extent={{-10,80},{10,
                              100}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum sumDesBreZonAre(final nin
                        =numZon)
                      "Sum of the design breathing zone flow rate for area component"
                      annotation (Placement(transformation(extent={{-10,50},{10,
                              70}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add zonVenEff[numZon](
                        final k2=fill(-1, numZon))
                      "Zone ventilation efficiency" annotation (Placement(
                          transformation(extent={{-10,-10},{10,10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiMin desSysVenEff(final nin
                        =numZon) "Design system ventilation efficiency"
                      annotation (Placement(transformation(extent={{20,-10},{40,
                              10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiMax maxPriOutAirFra(final nin
                        =numZon) "Maximum zone outdoor air fraction"
                      annotation (Placement(transformation(extent={{-10,-90},{
                              10,-70}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Routing.RealReplicator
                      reaRep(final nout=numZon) "Replicate Real input signal"
                      annotation (Placement(transformation(extent={{-80,10},{-60,
                              30}})));

                  equation
                    connect(zonVenEff.y, desSysVenEff.u)
                      annotation (Line(points={{12,0},{18,0}},color={0,0,127}));
                    connect(reaRep.y, zonVenEff.u1)
                      annotation (Line(points={{-58,20},{-40,20},{-40,6},{-12,6}},
                        color={0,0,127}));
                    connect(sumDesZonPop.y, ySumDesZonPop)
                      annotation (Line(points={{12,120},{120,120}},  color={0,0,127}));
                    connect(sumDesBreZonPop.y, VSumDesPopBreZon_flow)
                      annotation (Line(points={{12,90},{120,90}},color={0,0,127}));
                    connect(sumDesBreZonAre.y, VSumDesAreBreZon_flow)
                      annotation (Line(points={{12,60},{120,60}}, color={0,0,127}));
                    connect(desSysVenEff.y, yDesSysVenEff)
                      annotation (Line(points={{42,0},{120,0}}, color={0,0,127}));
                    connect(sysUncOutAir.y, VSumUncOutAir_flow)
                      annotation (Line(points={{12,-50},{120,-50}},  color={0,0,127}));
                    connect(sysPriAirRate.y, VSumSysPriAir_flow)
                      annotation (Line(points={{12,-120},{120,-120}}, color={0,0,127}));
                    connect(maxPriOutAirFra.y, uOutAirFra_max)
                      annotation (Line(points={{12,-80},{120,-80}},color={0,0,127}));
                    connect(yAveOutAirFraPlu, reaRep.u)
                      annotation (Line(points={{-120,20},{-82,20}}, color={0,0,127}));
                    connect(uDesZonPeaOcc, sumDesZonPop.u)
                      annotation (Line(points={{-120,120},{-12,120}}, color={0,0,127}));
                    connect(VDesPopBreZon_flow, sumDesBreZonPop.u)
                      annotation (Line(points={{-120,90},{-12,90}}, color={0,0,127}));
                    connect(VDesAreBreZon_flow, sumDesBreZonAre.u)
                      annotation (Line(points={{-120,60},{-12,60}},color={0,0,127}));
                    connect(uDesPriOutAirFra, zonVenEff.u2)
                      annotation (Line(points={{-120,-20},{-40,-20},{-40,-6},{-12,-6}},
                        color={0,0,127}));
                    connect(VUncOutAir_flow, sysUncOutAir.u)
                      annotation (Line(points={{-120,-50},{-12,-50}}, color={0,0,127}));
                    connect(VPriAir_flow, sysPriAirRate.u)
                      annotation (Line(points={{-120,-120},{-12,-120}},
                                                                      color={0,0,127}));
                    connect(uPriOutAirFra, maxPriOutAirFra.u)
                      annotation (Line(points={{-120,-80},{-12,-80}}, color={0,0,127}));

                  annotation (
                    Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                         graphics={Rectangle(
                            extent={{-100,100},{100,-100}},
                            lineColor={0,0,0},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-100,158},{100,118}},
                            lineColor={0,0,255},
                            textString="%name"),
                          Text(
                            extent={{-98,88},{-34,74}},
                            lineColor={0,0,0},
                            textString="uDesZonPeaOcc"),
                          Text(
                            extent={{-98,68},{-22,54}},
                            lineColor={0,0,0},
                            textString="VDesPopBreZon_flow"),
                          Text(
                            extent={{-98,26},{-30,14}},
                            lineColor={0,0,0},
                            textString="yAveOutAirFraPlu"),
                          Text(
                            extent={{-98,48},{-24,32}},
                            lineColor={0,0,0},
                            textString="VDesAreBreZon_flow"),
                          Text(
                            extent={{-98,-52},{-44,-66}},
                            lineColor={0,0,0},
                            textString="uPriOutAirFra"),
                          Text(
                            extent={{-98,-74},{-50,-86}},
                            lineColor={0,0,0},
                            textString="VPriAir_flow"),
                          Text(
                            extent={{-98,-32},{-30,-46}},
                            lineColor={0,0,0},
                            textString="VUncOutAir_flow"),
                          Text(
                            extent={{-98,-12},{-28,-26}},
                            lineColor={0,0,0},
                            textString="uDesPriOutAirFra"),
                          Text(
                            extent={{42,8},{96,-6}},
                            lineColor={0,0,0},
                            textString="yDesSysVenEff"),
                          Text(
                            extent={{12,40},{96,24}},
                            lineColor={0,0,0},
                            textString="VSumDesAreBreZon_flow"),
                          Text(
                            extent={{12,70},{96,54}},
                            lineColor={0,0,0},
                            textString="VSumDesPopBreZon_flow"),
                          Text(
                            extent={{36,98},{96,82}},
                            lineColor={0,0,0},
                            textString="ySumDesZonPop"),
                          Text(
                            extent={{36,-50},{96,-66}},
                            lineColor={0,0,0},
                            textString="uOutAirFra_max"),
                          Text(
                            extent={{26,-20},{96,-36}},
                            lineColor={0,0,0},
                            textString="VSumUncOutAir_flow"),
                          Text(
                            extent={{24,-80},{96,-96}},
                            lineColor={0,0,0},
                            textString="VSumSysPriAir_flow")}),
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-140},{100,140}})),
                    defaultComponentName="zonToSys",
                    Documentation(info="<html>
<p>
This sequence sums up the zone level minimum outdoor airflow setpoints, finds the
maximum zone outdoor air fraction and the minimum zone ventilation efficiency. It
collects zone level outputs and prepares inputs for specifying AHU level minimum
outdoor air setpoint.
</p>
<p>
It requires following inputs from zone level calculation,
</p>
<ul>
<li>
Design zone peak occupancy, <code>uDesZonPeaOcc</code>,
</li>
<li>
Population component of the breathing zone design outdoor airflow, <code>VDesPopBreZon_flow</code>,
</li>
<li>
Area component of the breathing zone design outdoor airflow, <code>VDesAreBreZon_flow</code>,
</li>
<li>
Design zone primary outdoor air fraction, <code>uDesPriOutAirFra</code>,
</li>
<li>
Uncorrected outdoor airflow rate, <code>VUncOutAir_flow</code>, 
</li>
<li>
Primary outdoor air fraction, <code>uPriOutAirFra</code>,
</li>
<li>
Primary airflow rate, <code>VPriAir_flow</code>,
</li>
</ul>
<p>
and following input from AHU level calculation,
</p>
<ul>
<li>
Average AHU level outdoor air flow fraction plus 1, <code>yAveOutAirFraPlu</code>.
</li>
</ul>
<p>
The sequence gives following outputs for AHU level calculation:
</p>
<ul>
<li>
Sum of the design population of the zones, <code>ySumDesZonPop</code>,
</li>
<li>
Sum of the population component of the design breathing zone flow rate, <code>VSumDesPopBreZon_flow</code>,
</li>
<li>
Sum of the area component of the design breathing zone flow rate, <code>VSumDesAreBreZon_flow</code>,
</li>
<li>
Design system ventilation efficiency, <code>yDesSysVenEff</code>,
<p>
First, compute the zone ventilation efficiency <code>zonVenEff</code>, for design purpose, as
</p>
<pre>
    zonVenEff[i] = yAveOutAirFraPlu - uDesPriOutAirFra[i]
</pre>
<p>
where the <code>uDesPriOutAirFra</code> is the design zone outdoor airflow fraction.
Then the design system ventilation efficiency <code>yDesSysVenEff</code> is
</p>
<pre>
    yDesSysVenEff = min(zonVenEff[i]).
</pre>
</li>
<li>
Sum of the required uncorrected outdoor airflow rate, <code>VSumUncOutAir_flow</code>,
</li>
<li>
Maximum zone outdoor air fraction, <code>uOutAirFra_max</code>,
</li>
<li>
AHU level primary airflow rate, <code>VSumSysPriAir_flow</code>.
</li>
</ul>
</html>",                   revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Separated from original sequence of finding the system minimum outdoor air setpoint.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
</ul>
</html>"));
                  end SumZone;

                  block Zone
                    "Output outdoor airflow related calculations at the zone level"

                    parameter Real VOutPerAre_flow(
                      final unit = "m3/(s.m2)")=3e-4
                      "Outdoor air rate per unit area"
                      annotation(Dialog(group="Nominal condition"));

                    parameter Real VOutPerPer_flow(unit="m3/s")=2.5e-3
                      "Outdoor air rate per person"
                      annotation(Dialog(group="Nominal condition"));

                    parameter Real AFlo(unit="m2")
                      "Floor area of each zone"
                      annotation(Dialog(group="Nominal condition"));

                    parameter Boolean have_occSen=true
                      "Set to true if zones have occupancy sensor";

                    parameter Boolean have_winSen=true
                      "Set to true if zones have window status sensor";

                    parameter Real occDen(final unit = "1/m2") = 0.05
                      "Default number of person in unit area";

                    parameter Real zonDisEffHea(final unit = "1") = 0.8
                      "Zone air distribution effectiveness during heating";

                    parameter Real zonDisEffCoo(final unit = "1") = 1.0
                      "Zone air distribution effectiveness during cooling";

                    parameter Real desZonDisEff(final unit = "1") = 1.0
                      "Design zone air distribution effectiveness"
                      annotation(Dialog(group="Nominal condition"));

                    parameter Real desZonPop(
                      final min=occDen*AFlo,
                      final unit = "1")
                      "Design zone population during peak occupancy"
                      annotation(Dialog(group="Nominal condition"));

                    parameter Real uLow(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="ThermodynamicTemperature") = -0.5
                      "If zone space temperature minus supply air temperature is less than uLow,
     then it should use heating supply air distribution effectiveness"
                      annotation (Dialog(tab="Advanced"));

                    parameter Real uHig(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="ThermodynamicTemperature") = 0.5
                      "If zone space temperature minus supply air temperature is more than uHig,
     then it should use cooling supply air distribution effectiveness"
                      annotation (Dialog(tab="Advanced"));

                    parameter Real minZonPriFlo(unit="m3/s")
                      "Minimum expected zone primary flow rate"
                      annotation(Dialog(group="Nominal condition"));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                      nOcc if have_occSen "Number of occupants" annotation (
                        Placement(transformation(extent={{-200,20},{-160,60}}),
                          iconTransformation(extent={{-140,70},{-100,110}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                      uWin if have_winSen
                      "Window status, true if open, false if closed"
                      annotation (Placement(transformation(extent={{-200,-70},{
                              -160,-30}}), iconTransformation(extent={{-140,40},
                              {-100,80}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                      uReqOutAir
                      "True if the AHU supply fan is on and the zone is in occupied mode"
                      annotation (Placement(transformation(extent={{-200,-110},
                              {-160,-70}}), iconTransformation(extent={{-140,10},
                              {-100,50}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      TZon(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Measured zone air temperature" annotation (Placement(
                          transformation(extent={{-200,-150},{-160,-110}}),
                          iconTransformation(extent={{-140,-20},{-100,20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      TDis(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Measured discharge air temperature" annotation (
                        Placement(transformation(extent={{-200,-190},{-160,-150}}),
                          iconTransformation(extent={{-140,-50},{-100,-10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VDis_flow(final unit="m3/s", final quantity=
                          "VolumeFlowRate")
                      "Primary airflow rate to the ventilation zone from the air handler, including outdoor air and recirculated air"
                      annotation (Placement(transformation(extent={{-200,-230},
                              {-160,-190}}), iconTransformation(extent={{-140,-80},
                              {-100,-40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VUncOut_flow_nominal(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "AHU level design uncorrected minimum outdoor airflow rate"
                      annotation (Placement(transformation(extent={{-200,-270},
                              {-160,-230}}), iconTransformation(extent={{-140,-110},
                              {-100,-70}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yDesZonPeaOcc(final min=0, final unit="1")
                      "Design zone peak occupancy" annotation (Placement(
                          transformation(extent={{180,220},{220,260}}),
                          iconTransformation(extent={{100,70},{140,110}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VDesPopBreZon_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Population component breathing zone design outdoor airflow"
                      annotation (Placement(transformation(extent={{180,180},{
                              220,220}}), iconTransformation(extent={{100,40},{
                              140,80}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VDesAreBreZon_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Area component breathing zone outdoor airflow"
                      annotation (Placement(transformation(extent={{180,120},{
                              220,160}}), iconTransformation(extent={{100,10},{
                              140,50}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yDesPriOutAirFra(final min=0, final unit="1")
                      "Design zone primary outdoor air fraction" annotation (
                        Placement(transformation(extent={{180,50},{220,90}}),
                          iconTransformation(extent={{100,-20},{140,20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VUncOutAir_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Uncorrected outdoor airflow rate" annotation (Placement(
                          transformation(extent={{180,-110},{220,-70}}),
                          iconTransformation(extent={{100,-50},{140,-10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yPriOutAirFra(final min=0, final unit="1")
                      "Primary outdoor air fraction" annotation (Placement(
                          transformation(extent={{180,-180},{220,-140}}),
                          iconTransformation(extent={{100,-80},{140,-40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      VPriAir_flow(
                      final min=0,
                      final unit="m3/s",
                      final quantity="VolumeFlowRate") "Primary airflow rate"
                      annotation (Placement(transformation(extent={{180,-240},{
                              220,-200}}), iconTransformation(extent={{100,-110},
                              {140,-70}})));

                  protected
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.IntegerToReal
                      intToRea if have_occSen "Type converter" annotation (
                        Placement(transformation(extent={{-140,30},{-120,50}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add breZon
                      "Breathing zone airflow" annotation (Placement(
                          transformation(extent={{20,40},{40,60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai(final k=
                          VOutPerPer_flow) if have_occSen
                      "Outdoor air per person" annotation (Placement(
                          transformation(extent={{-100,30},{-80,50}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                      "If there is occupancy sensor, then using the real time occupancy; otherwise, using the default occupancy"
                      annotation (Placement(transformation(extent={{-40,-10},{-20,
                              10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                      "Switch between cooling or heating distribution effectiveness"
                      annotation (Placement(transformation(extent={{-20,-160},{
                              0,-140}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division zonOutAirRate
                      "Required zone outdoor airflow rate" annotation (
                        Placement(transformation(extent={{80,10},{100,30}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division priOutAirFra
                      "Primary outdoor air fraction" annotation (Placement(
                          transformation(extent={{120,-170},{140,-150}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add desBreZon
                      "Breathing zone design airflow" annotation (Placement(
                          transformation(extent={{20,190},{40,210}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division desZonOutAirRate
                      "Required design zone outdoor airflow rate" annotation (
                        Placement(transformation(extent={{80,170},{100,190}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division desZonPriOutAirRate
                      "Design zone primary outdoor air fraction" annotation (
                        Placement(transformation(extent={{140,60},{160,80}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2(final k2=
                          -1)
                      "Zone space temperature minus supply air temperature"
                      annotation (Placement(transformation(extent={{-120,-160},
                              {-100,-140}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis
                      hys(
                      final uLow=uLow,
                      final uHigh=uHig,
                      final pre_y_start=true)
                      "Check if cooling or heating air distribution effectiveness should be applied, with 1 degC deadband"
                      annotation (Placement(transformation(extent={{-80,-160},{
                              -60,-140}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      occSen(final k=have_occSen)
                      "Boolean constant to indicate if there is occupancy sensor"
                      annotation (Placement(transformation(extent={{-140,-10},{
                              -120,10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      desDisEff(final k=desZonDisEff)
                      "Design zone air distribution effectiveness" annotation (
                        Placement(transformation(extent={{20,150},{40,170}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      minZonFlo(final k=minZonPriFlo)
                      "Minimum expected zone primary flow rate" annotation (
                        Placement(transformation(extent={{80,60},{100,80}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      disEffHea(final k=zonDisEffHea)
                      "Zone distribution effectiveness for heating" annotation
                      (Placement(transformation(extent={{-80,-200},{-60,-180}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      disEffCoo(final k=zonDisEffCoo)
                      "Zone distribution effectiveness fo cooling" annotation (
                        Placement(transformation(extent={{-80,-120},{-60,-100}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      zerOutAir(final k=0)
                      "Zero required outdoor airflow rate when window is open or when zone is not in occupied mode"
                      annotation (Placement(transformation(extent={{-40,-80},{-20,
                              -60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      zerOcc(final k=0) if not have_occSen
                      "Zero occupant when there is no occupancy sensor"
                      annotation (Placement(transformation(extent={{-140,70},{-120,
                              90}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      cloWin(final k=false) if not have_winSen
                      "Closed window status when there is no window sensor"
                      annotation (Placement(transformation(extent={{-100,-80},{
                              -80,-60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi4
                      "If window is open, the required outdoor airflow rate should be zero"
                      annotation (Placement(transformation(extent={{60,-60},{80,
                              -40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi5
                      "If supply fan is off or it is not in occupied mode, then outdoor airflow rate should be zero"
                      annotation (Placement(transformation(extent={{120,-100},{
                              140,-80}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Max max
                      "If supply fan is off, giving a small primary airflow rate to avoid division by zero"
                      annotation (Placement(transformation(extent={{-20,-230},{
                              0,-210}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product breZonAre
                      "Area component of the breathing zone outdoor airflow"
                      annotation (Placement(transformation(extent={{-80,130},{-60,
                              150}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro
                      "Product of flow rate per person and floor area"
                      annotation (Placement(transformation(extent={{-80,170},{-60,
                              190}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      floPerAre(final k=VOutPerAre_flow)
                      "Flow rate per unit area" annotation (Placement(
                          transformation(extent={{-140,110},{-120,130}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      floAre(final k=AFlo) "Floor area" annotation (Placement(
                          transformation(extent={{-140,150},{-120,170}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      floPerPer(final k=VOutPerPer_flow) "Flow rate per person"
                      annotation (Placement(transformation(extent={{-140,190},{
                              -120,210}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain breZonPop(final k=
                          occDen)
                      "Default population component of the breathing zone outdoor airflow"
                      annotation (Placement(transformation(extent={{-100,-40},{
                              -80,-20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gaiDivZer(final k=
                          1E-3)
                      "Gain, used to avoid division by zero if the flow rate is smaller than 0.1%"
                      annotation (Placement(transformation(extent={{-80,-250},{
                              -60,-230}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      desPeaOcc(final k=desZonPop)
                      "Design zone population during peak occupancy"
                      annotation (Placement(transformation(extent={{-140,230},{
                              -120,250}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product desBreZonPer
                      "Population component of the breathing zone design outdoor airflow"
                      annotation (Placement(transformation(extent={{-80,210},{-60,
                              230}})));

                  equation
                    connect(gai.y, swi.u1)
                      annotation (Line(points={{-78,40},{-60,40},{-60,8},{-42,8}},
                        color={0,0,127}));
                   connect(swi.y, breZon.u2)
                      annotation (Line(points={{-18,0},{0,0},{0,44},{18,44}},
                        color={0,0,127}));
                    connect(disEffCoo.y, swi1.u1)
                      annotation (Line(points={{-58,-110},{-40,-110},{-40,-142},{-22,-142}},
                        color={0,0,127}));
                    connect(disEffHea.y, swi1.u3)
                      annotation (Line(points={{-58,-190},{-40,-190},{-40,-158},{-22,-158}},
                        color={0,0,127}));
                    connect(breZon.y, zonOutAirRate.u1)
                      annotation (Line(points={{42,50},{60,50},{60,26},{78,26}},
                        color={0,0,127}));
                    connect(swi1.y, zonOutAirRate.u2)
                      annotation (Line(points={{2,-150},{20,-150},{20,14},{78,14}},
                        color={0,0,127}));
                    connect(desDisEff.y, desZonOutAirRate.u2)
                      annotation (Line(points={{42,160},{60,160},{60,174},{78,174}},
                        color={0,0,127}));
                    connect(desBreZon.y, desZonOutAirRate.u1)
                      annotation (Line(points={{42,200},{60,200},{60,186},{78,186}},
                        color={0,0,127}));
                    connect(desZonOutAirRate.y, desZonPriOutAirRate.u1)
                      annotation (Line(points={{102,180},{120,180},{120,76},{138,76}},
                        color={0,0,127}));
                    connect(minZonFlo.y, desZonPriOutAirRate.u2)
                      annotation (Line(points={{102,70},{120,70},{120,64},{138,64}},
                        color={0,0,127}));
                    connect(swi.u2, occSen.y)
                      annotation (Line(points={{-42,0},{-118,0}},
                        color={255,0,255}));
                    connect(TDis, add2.u2)
                      annotation (Line(points={{-180,-170},{-140,-170},{-140,-156},{-122,-156}},
                        color={0,0,127}));
                    connect(TZon, add2.u1)
                      annotation (Line(points={{-180,-130},{-140,-130},{-140,-144},{-122,-144}},
                        color={0,0,127}));
                    connect(add2.y, hys.u)
                      annotation (Line(points={{-98,-150},{-82,-150}},
                        color={0,0,127}));
                    connect(hys.y, swi1.u2)
                      annotation (Line(points={{-58,-150},{-22,-150}}, color={255,0,255}));
                    connect(zerOcc.y, swi.u1)
                      annotation (Line(points={{-118,80},{-60,80},{-60,8},{-42,8}},
                        color={0,0,127}));
                    connect(intToRea.y, gai.u)
                      annotation (Line(points={{-118,40},{-102,40}}, color={0,0,127}));
                    connect(nOcc, intToRea.u)
                      annotation (Line(points={{-180,40},{-142,40}}, color={255,127,0}));
                    connect(desZonPriOutAirRate.y, yDesPriOutAirFra)
                      annotation (Line(points={{162,70},{200,70}}, color={0,0,127}));
                    connect(priOutAirFra.y, yPriOutAirFra)
                      annotation (Line(points={{142,-160},{200,-160}}, color={0,0,127}));
                    connect(zerOutAir.y, swi4.u1) annotation (Line(points={{-18,-70},{0,-70},{0,-42},
                            {58,-42}}, color={0,0,127}));
                    connect(zonOutAirRate.y, swi4.u3) annotation (Line(points={{102,20},{120,20},{
                            120,-20},{40,-20},{40,-58},{58,-58}},  color={0,0,127}));
                    connect(swi5.y, VUncOutAir_flow)
                      annotation (Line(points={{142,-90},{200,-90}}, color={0,0,127}));
                    connect(swi5.y, priOutAirFra.u1) annotation (Line(points={{142,-90},{160,-90},
                            {160,-120},{100,-120},{100,-154},{118,-154}}, color={0,0,127}));
                    connect(uWin, swi4.u2) annotation (Line(points={{-180,-50},{58,-50}},
                            color={255,0,255}));
                    connect(cloWin.y, swi4.u2) annotation (Line(points={{-78,-70},{-60,-70},{-60,-50},
                            {58,-50}},color={255,0,255}));
                    connect(uReqOutAir, swi5.u2)
                      annotation (Line(points={{-180,-90},{118,-90}}, color={255,0,255}));
                    connect(VDis_flow, max.u1) annotation (Line(points={{-180,-210},{-40,-210},{-40,
                            -214},{-22,-214}}, color={0,0,127}));
                    connect(max.y, priOutAirFra.u2) annotation (Line(points={{2,-220},{100,-220},{
                            100,-166},{118,-166}}, color={0,0,127}));
                    connect(max.y, VPriAir_flow)
                      annotation (Line(points={{2,-220},{200,-220}}, color={0,0,127}));
                    connect(floAre.y, breZonAre.u1) annotation (Line(points={{-118,160},{-100,160},
                            {-100,146},{-82,146}}, color={0,0,127}));
                    connect(floPerAre.y, breZonAre.u2) annotation (Line(points={{-118,120},{-100,120},
                            {-100,134},{-82,134}},color={0,0,127}));
                    connect(breZonAre.y, desBreZon.u2) annotation (Line(points={{-58,140},{0,140},
                            {0,194},{18,194}}, color={0,0,127}));
                    connect(breZonAre.y, breZon.u1) annotation (Line(points={{-58,140},{0,140},{0,
                            56},{18,56}},   color={0,0,127}));
                    connect(floPerPer.y, pro.u1) annotation (Line(points={{-118,200},{-100,200},{-100,
                            186},{-82,186}}, color={0,0,127}));
                    connect(floAre.y, pro.u2) annotation (Line(points={{-118,160},{-100,160},{-100,
                            174},{-82,174}}, color={0,0,127}));
                    connect(breZonPop.y, swi.u3) annotation (Line(points={{-78,-30},{-60,-30},{-60,
                            -8},{-42,-8}}, color={0,0,127}));
                    connect(pro.y, breZonPop.u) annotation (Line(points={{-58,180},{-40,180},{-40,
                            100},{-110,100},{-110,-30},{-102,-30}}, color={0,0,127}));
                    connect(VUncOut_flow_nominal, gaiDivZer.u)
                      annotation (Line(points={{-180,-250},{-100,-250},{-100,-240},{-82,-240}},
                        color={0,0,127}));
                    connect(gaiDivZer.y, max.u2)
                      annotation (Line(points={{-58,-240},{-40,-240},{-40,-226},{-22,-226}},
                        color={0,0,127}));
                    connect(floPerPer.y, desBreZonPer.u2) annotation (Line(points={{-118,200},{-100,
                            200},{-100,214},{-82,214}}, color={0,0,127}));
                    connect(desPeaOcc.y, desBreZonPer.u1) annotation (Line(points={{-118,240},{-100,
                            240},{-100,226},{-82,226}}, color={0,0,127}));
                    connect(desBreZonPer.y, desBreZon.u1) annotation (Line(points={{-58,220},{0,220},
                            {0,206},{18,206}}, color={0,0,127}));
                    connect(desPeaOcc.y, yDesZonPeaOcc)
                      annotation (Line(points={{-118,240},{200,240}}, color={0,0,127}));
                    connect(desBreZonPer.y, VDesPopBreZon_flow) annotation (Line(points={{-58,220},
                            {120,220},{120,200},{200,200}}, color={0,0,127}));
                    connect(breZonAre.y, VDesAreBreZon_flow)
                      annotation (Line(points={{-58,140},{200,140}}, color={0,0,127}));
                    connect(zerOutAir.y, swi5.u3) annotation (Line(points={{-18,-70},{0,-70},{0,-98},
                            {118,-98}}, color={0,0,127}));
                    connect(swi4.y, swi5.u1) annotation (Line(points={{82,-50},{100,-50},{100,-82},
                            {118,-82}}, color={0,0,127}));

                  annotation (
                    defaultComponentName="zonOutAirSet",
                    Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                         graphics={Rectangle(
                            extent={{-100,100},{100,-100}},
                            lineColor={0,0,0},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-98,-82},{-14,-98}},
                            lineColor={0,0,0},
                            textString="VUncOut_flow_nominal"),
                          Text(
                            extent={{-100,158},{100,118}},
                            lineColor={0,0,255},
                            textString="%name"),
                          Text(
                            extent={{-100,-54},{-58,-64}},
                            lineColor={0,0,0},
                            textString="VDis_flow"),
                          Text(
                            extent={{-100,-24},{-72,-36}},
                            lineColor={0,0,0},
                            textString="TDis"),
                          Text(
                            extent={{-100,8},{-70,-4}},
                            lineColor={0,0,0},
                            textString="TZon"),
                          Text(
                            extent={{-100,36},{-40,24}},
                            lineColor={255,0,255},
                            textString="uReqOutAir"),
                          Text(
                            visible=have_winSen,
                            extent={{-100,68},{-72,56}},
                            lineColor={255,0,255},
                            textString="uWin"),
                          Text(
                            visible=have_occSen,
                            extent={{-100,98},{-70,86}},
                            lineColor={255,127,0},
                            textString="nOcc"),
                          Text(
                            extent={{28,98},{98,82}},
                            lineColor={0,0,0},
                            textString="yDesZonPeaOcc"),
                          Text(
                            extent={{12,70},{96,54}},
                            lineColor={0,0,0},
                            textString="VDesPopBreZon_flow"),
                          Text(
                            extent={{14,38},{98,22}},
                            lineColor={0,0,0},
                            textString="VDesAreBreZon_flow"),
                          Text(
                            extent={{28,10},{98,-8}},
                            lineColor={0,0,0},
                            textString="yDesPriOutAirFra"),
                          Text(
                            extent={{28,-20},{98,-36}},
                            lineColor={0,0,0},
                            textString="VUncOutAir_flow"),
                          Text(
                            extent={{40,-50},{96,-66}},
                            lineColor={0,0,0},
                            textString="yPriOutAirFra"),
                          Text(
                            extent={{48,-82},{98,-96}},
                            lineColor={0,0,0},
                            textString="VPriAir_flow")}),
                  Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-160,-260},{180,260}})),
                  Documentation(info="<html>
<p>
This sequence conducts calculations of the minimum outdoor airflow rate at the zone
level. It gives outputs below.
</p>
<ol>
<li>
The population component of the breathing zone outdoor airflow, <code>VDesPopBreZon_flow</code>.
</li>
<li>
The area component of the breathing zone outdoor airflow, <code>VDesAreBreZon_flow</code>.
</li>
<li>
Design zone primary outdoor air fraction, <code>yDesPriOutAirFra</code>.
</li>
<li>
Uncorrected outdoor airflow rate, <code>VUncOutAir_flow</code>. This flow rate
is calculated based on: occupancy (if there is occupancy sensor) or design
occupancy (if there is no occupancy sensor), and air distribution effectiveness
(warm or cool air).
</li>
<li>
Primary outdoor air fraction, <code>yPriOutAirFra</code>.
</li>
<li>
Primary airflow rate, <code>VPriAir_flow</code>.
</li>
</ol>
<p>
The calculation is done using the steps below.
</p>
<ol>
<li>
<p>
Compute the required breathing zone outdoor airflow using the following components.
</p>
<ul>
<li>The area component of the breathing zone outdoor airflow, <code>VDesAreBreZon_flow</code>.
</li>
<li>The population component of the breathing zone outdoor airflow, <code>VDesPopBreZon_flow</code>.
</li>
</ul>
<p>
The number of occupant in the zone can be retrieved directly from occupancy sensor
(<code>nOcc</code>) if the sensor exists, or using the default occupant density
(<code>occDen</code>) and multiplying it with zone area (<code>AFlo</code>).
The occupant density can be found from Table 6.2.2.1 in ASHRAE Standard
62.1-2013. For design purpose, use the design zone population (<code>desZonPop</code>)
to determine the minimum requirement at the ventilation-design condition.
</p>
</li>
<li>
<p>
Compute the zone air-distribution effectiveness.
Table 6.2.2.2 in ASHRAE 62.1-2013 lists some typical values for setting the
effectiveness. Depending on difference between zone space temperature
<code>TZon</code> and discharge air temperature (after the reheat coil) <code>TDis</code>, Warm-air
effectiveness <code>zonDisEffHea</code> or Cool-air effectiveness
<code>zonDisEffCoo</code> should be applied.
</p>
</li>
<li>
<p>
Compute the required zone outdoor airflow <code>zonOutAirRate</code>.
If the zone is in any mode other than occupied mode (<code>uReqOutAir=false</code>)
or if the zone has window switches and the window is open (<code>uWin=true</code>),
set <code>zonOutAirRate = 0</code>.
Otherwise, the required zone outdoor airflow <code>zonOutAirRate</code>
shall be calculated as follows:
</p>
<ul>
<li>
If the zone is populated (<code>nOcc</code> &gt; 0), or if there is no occupancy sensor
(<code>have_occSen = false</code>):
<ul>
<li>
If the discharge air temperature at the terminal unit is less than or equal to
the zone space temperature, set <code>zonOutAirRate = (breZonAre+breZonPop)/disEffCoo</code>.
</li>
<li>
If the discharge air temperature at the terminal unit is greater than zone space
temperature, set <code>zonOutAirRate = (breZonAre+breZonPop)/disEffHea</code>.
</li>
</ul>
</li>
<li>
If the zone has an occupancy sensor and is unpopulated (<code>nOcc=0</code>):
<ul>
<li>
If the discharge air temperature at the terminal unit is less than or equal to
the zone space temperature, set <code>zonOutAirRate = breZonAre/disEffCoo</code>.
</li>
<li>
If the discharge air temperature at the terminal unit is greater than zone
space temperature, set <code>zonOutAirRate = breZonAre/disEffHea</code>.
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
Compute the outdoor air fraction for the zone <code>yPriOutAirFra</code> as follows.
Set the zone outdoor air fraction to
</p>
<pre>
    yPriOutAirFra = zonOutAirRate/VPriAir_flow
</pre>
<p>
where, <code>VPriAir_flow</code> is the maximum between the measured discharge air
flow rate from the zone VAV box <code>VDis_flow</code> and 0.1% of AHU level
design uncorrected minimum outdoor airflow rate <code>VUncOut_flow_nominal</code>.
For design purpose, the design zone outdoor air fraction <code>yDesPriOutAirFra</code>
is
</p>
<pre>
    yDesPriOutAirFra = desZonOutAirRate/minZonPriFlo
</pre>
<p>
where <code>minZonPriFlo</code> is the minimum expected zone primary flow rate and
<code>desZonOutAirRate</code> is the required design zone outdoor airflow rate.
</p>
</li>
</ol>
<h4>References</h4>
<p>
ANSI/ASHRAE Standard 62.1-2013,
<i>Ventilation for Acceptable Indoor Air Quality.</i>
</p>
<p>
Stanke, D., 2010. <i>Dynamic Reset for Multiple-Zone Systems.</i> ASHRAE Journal, March
2010.
</p>
</html>",                   revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Separated from original sequence of finding the system minimum outdoor air setpoint.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
February 27, 2020, by Jianjun Hu:<br/>
Applied hysteresis for checking ventilation efficiency.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1787\">#1787</a>.
</li>
<li>
January 30, 2020, by Michael Wetter:<br/>
Removed the use of <code>fill</code> when assigning the <code>unit</code> attribute.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1728\">#1728</a>.
</li>
<li>
January 12, 2019, by Michael Wetter:<br/>
Added missing <code>each</code>.
</li>
<li>
October 28, 2017, by Michael Wetter:<br/>
Corrected bug in guarding against division by zero.
</li>
<li>
September 27, 2017, by Michael Wetter:<br/>
Changed handling of guard against zero division, as the flow rate
can be zero at the instant when the fan switches on.
</li>
<li>
July 6, 2017, by Jianjun Hu:<br/>
Replaced <code>cooCtrlSig</code> input with <code>TZon</code> and <code>TDis</code>
inputs to check if cool or warm air distribution effectiveness should be applied.
Applied hysteresis to avoid rapid change.
</li>
<li>
July 5, 2017, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
May 12, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Zone;

                  package Validation "Collection of validation models"

                    model OutdoorAirFlow
                      "Validate the sequences of setting AHU level minimum outdoor airflow rate"

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone
                        zon1(
                        AFlo=40,
                        have_winSen=false,
                        desZonPop=4,
                        minZonPriFlo=0.08)
                        "Outdoor airflow related calculations for zone 1"
                        annotation (Placement(transformation(extent={{-120,100},
                                {-100,120}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone
                        zon2(
                        AFlo=35,
                        desZonPop=4,
                        minZonPriFlo=0.08)
                        "Outdoor airflow related calculations for zone 2"
                        annotation (Placement(transformation(extent={{-120,-10},
                                {-100,10}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone
                        zon3(
                        AFlo=30,
                        desZonPop=3,
                        minZonPriFlo=0.06)
                        "Outdoor airflow related calculations for zone 3"
                        annotation (Placement(transformation(extent={{-120,-120},
                                {-100,-100}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.AHU
                        ahu1(VPriSysMax_flow=0.6, peaSysPop=12)
                        "AHU level minimum outdoor airflow setpoint"
                        annotation (Placement(transformation(extent={{220,40},{
                                240,60}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.SumZone
                        zonToAhu(final numZon=3) "From zone level to AHU level"
                        annotation (Placement(transformation(extent={{140,40},{
                                160,60}})));

                    protected
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        supFan(k=true) "Status of supply fan" annotation (
                          Placement(transformation(extent={{140,-30},{160,-10}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        opeMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                        "AHU operation mode is Occupied" annotation (Placement(
                            transformation(extent={{140,-70},{160,-50}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        numOfOcc2(duration=3600, height=3)
                        "Occupant number in zone 2" annotation (Placement(
                            transformation(extent={{-260,170},{-240,190}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                        reaToInt1 "Convert real to integer" annotation (
                          Placement(transformation(extent={{-220,170},{-200,190}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        numOfOcc3(
                        duration=3600,
                        height=3,
                        startTime=900) "Occupant number in zone 3" annotation (
                          Placement(transformation(extent={{-260,30},{-240,50}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                        reaToInt2 "Convert real to integer" annotation (
                          Placement(transformation(extent={{-220,30},{-200,50}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        winSta(k=false) "Status of windows" annotation (
                          Placement(transformation(extent={{-220,-10},{-200,10}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse
                        winSta1(period=3600) "Status of windows" annotation (
                          Placement(transformation(extent={{-220,-140},{-200,-120}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        numOfOcc4(
                        duration=3600,
                        startTime=900,
                        height=2) "Occupant number" annotation (Placement(
                            transformation(extent={{-260,-90},{-240,-70}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                        reaToInt3 "Convert real to integer" annotation (
                          Placement(transformation(extent={{-220,-90},{-200,-70}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        TZon(
                        height=6,
                        offset=280.15,
                        duration=3600) "Measured zone temperature" annotation (
                          Placement(transformation(extent={{-260,130},{-240,150}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        TDis(
                        height=4,
                        duration=3600,
                        offset=281.15)
                        "Terminal unit discharge air temperature" annotation (
                          Placement(transformation(extent={{-220,110},{-200,130}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        zonPriFloRat(k=0.1)
                        "Measured primary flow rate at VAV box" annotation (
                          Placement(transformation(extent={{-260,80},{-240,100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        zonPriFloRat1(k=0.12)
                        "Measured primary flow rate at VAV box" annotation (
                          Placement(transformation(extent={{-260,-40},{-240,-20}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        zonPriFloRat2(k=0.09)
                        "Measured primary flow rate at VAV box" annotation (
                          Placement(transformation(extent={{-260,-170},{-240,-150}})));

                    equation
                      connect(zon1.yDesZonPeaOcc,zonToAhu. uDesZonPeaOcc[1]) annotation (Line(
                            points={{-98,119},{-44,119},{-44,56.6667},{138,56.6667}}, color={0,0,127}));
                      connect(zon2.yDesZonPeaOcc,zonToAhu. uDesZonPeaOcc[2]) annotation (Line(
                            points={{-98,9},{-20,9},{-20,58},{138,58}},     color={0,0,127}));
                      connect(zon3.yDesZonPeaOcc,zonToAhu. uDesZonPeaOcc[3]) annotation (Line(
                            points={{-98,-101},{42,-101},{42,59.3333},{138,59.3333}},   color={0,0,127}));
                      connect(zon1.VDesPopBreZon_flow,zonToAhu. VDesPopBreZon_flow[1]) annotation (
                          Line(points={{-98,116},{-50,116},{-50,54.6667},{138,54.6667}}, color={0,0,127}));
                      connect(zon2.VDesPopBreZon_flow,zonToAhu. VDesPopBreZon_flow[2]) annotation (
                          Line(points={{-98,6},{-12,6},{-12,56},{138,56}},     color={0,0,127}));
                      connect(zon3.VDesPopBreZon_flow,zonToAhu. VDesPopBreZon_flow[3]) annotation (
                          Line(points={{-98,-104},{48,-104},{48,57.3333},{138,57.3333}},   color={0,0,127}));
                      connect(zon1.VDesAreBreZon_flow,zonToAhu. VDesAreBreZon_flow[1]) annotation (
                          Line(points={{-98,113},{-56,113},{-56,52.6667},{138,52.6667}}, color={0,0,127}));
                      connect(zon2.VDesAreBreZon_flow,zonToAhu. VDesAreBreZon_flow[2]) annotation (
                          Line(points={{-98,3},{-6,3},{-6,54},{138,54}},       color={0,0,127}));
                      connect(zon3.VDesAreBreZon_flow,zonToAhu. VDesAreBreZon_flow[3]) annotation (
                          Line(points={{-98,-107},{54,-107},{54,55.3333},{138,55.3333}},   color={0,0,127}));
                      connect(zon1.yDesPriOutAirFra,zonToAhu. uDesPriOutAirFra[1]) annotation (Line(
                            points={{-98,110},{-62,110},{-62,46.6667},{138,46.6667}}, color={0,0,127}));
                      connect(zon2.yDesPriOutAirFra,zonToAhu. uDesPriOutAirFra[2]) annotation (Line(
                            points={{-98,0},{2,0},{2,48},{138,48}}, color={0,0,127}));
                      connect(zon3.yDesPriOutAirFra,zonToAhu. uDesPriOutAirFra[3]) annotation (Line(
                            points={{-98,-110},{60,-110},{60,49.3333},{138,49.3333}},   color={0,0,127}));
                      connect(zon1.VUncOutAir_flow,zonToAhu. VUncOutAir_flow[1]) annotation (Line(
                            points={{-98,107},{-68,107},{-68,44.6667},{138,44.6667}}, color={0,0,127}));
                      connect(zon2.VUncOutAir_flow,zonToAhu. VUncOutAir_flow[2]) annotation (Line(
                            points={{-98,-3},{8,-3},{8,46},{138,46}}, color={0,0,127}));
                      connect(zon3.VUncOutAir_flow,zonToAhu. VUncOutAir_flow[3]) annotation (Line(
                            points={{-98,-113},{66,-113},{66,47.3333},{138,47.3333}}, color={0,0,127}));
                      connect(zon1.yPriOutAirFra,zonToAhu. uPriOutAirFra[1]) annotation (Line(
                            points={{-98,104},{-74,104},{-74,42.6667},{138,42.6667}}, color={0,0,127}));
                      connect(zon2.yPriOutAirFra,zonToAhu. uPriOutAirFra[2]) annotation (Line(
                            points={{-98,-6},{14,-6},{14,44},{138,44}}, color={0,0,127}));
                      connect(zon3.yPriOutAirFra,zonToAhu. uPriOutAirFra[3]) annotation (Line(
                            points={{-98,-116},{74,-116},{74,45.3333},{138,45.3333}}, color={0,0,127}));
                      connect(zon1.VPriAir_flow,zonToAhu. VPriAir_flow[1]) annotation (Line(points={{-98,101},
                              {-80,101},{-80,40.6667},{138,40.6667}}, color={0,0,127}));
                      connect(zon2.VPriAir_flow,zonToAhu. VPriAir_flow[2]) annotation (Line(points={{-98,-9},
                              {20,-9},{20,42},{138,42}}, color={0,0,127}));
                      connect(zon3.VPriAir_flow,zonToAhu. VPriAir_flow[3]) annotation (Line(points={{-98,
                              -119},{80,-119},{80,43.3333},{138,43.3333}}, color={0,0,127}));
                      connect(zonToAhu.ySumDesZonPop,ahu1. sumDesZonPop)
                        annotation (Line(points={{162,59},{218,59}}, color={0,0,127}));
                      connect(zonToAhu.VSumDesPopBreZon_flow,ahu1. VSumDesPopBreZon_flow)
                        annotation (Line(points={{162,56},{180,56},{180,57},{218,57}}, color={0,
                              0,127}));
                      connect(zonToAhu.VSumDesAreBreZon_flow,ahu1. VSumDesAreBreZon_flow)
                        annotation (Line(points={{162,53},{182,53},{182,55},{218,55}}, color={0,
                              0,127}));
                      connect(zonToAhu.yDesSysVenEff,ahu1. uDesSysVenEff) annotation (Line(points={{162,50},
                              {184,50},{184,53},{218,53}}, color={0,0,127}));
                      connect(zonToAhu.VSumUncOutAir_flow,ahu1. VSumUncOutAir_flow) annotation (
                          Line(points={{162,47},{186,47},{186,51},{218,51}}, color={0,0,127}));
                      connect(zonToAhu.uOutAirFra_max,ahu1. uOutAirFra_max) annotation (Line(points={{162,44},
                              {190,44},{190,47},{218,47}}, color={0,0,127}));
                      connect(zonToAhu.VSumSysPriAir_flow,ahu1. VSumSysPriAir_flow) annotation (
                          Line(points={{162,41},{188,41},{188,49},{218,49}}, color={0,0,127}));
                      connect(ahu1.yAveOutAirFraPlu,zonToAhu. yAveOutAirFraPlu) annotation (Line(
                            points={{242,55},{250,55},{250,170},{120,170},{120,52},{138,52}},
                            color={0,0,127}));
                      connect(supFan.y,ahu1. uSupFan) annotation (Line(points={{162,-20},{198,-20},{
                              198,43},{218,43}}, color={255,0,255}));
                      connect(opeMod.y,ahu1. uOpeMod) annotation (Line(points={{162,-60},{202,-60},{
                              202,41},{218,41}},   color={255,127,0}));
                      connect(ahu1.yReqOutAir, zon1.uReqOutAir) annotation (Line(points={{242,42},
                              {260,42},{260,174},{-160,174},{-160,113},{-122,113}}, color={255,0,
                              255}));
                      connect(ahu1.yReqOutAir, zon2.uReqOutAir) annotation (Line(points={{242,42},
                              {260,42},{260,174},{-160,174},{-160,3},{-122,3}}, color={255,0,255}));
                      connect(ahu1.yReqOutAir, zon3.uReqOutAir) annotation (Line(points={{242,42},
                              {260,42},{260,174},{-160,174},{-160,-107},{-122,-107}}, color={255,0,
                              255}));
                      connect(numOfOcc2.y,reaToInt1. u) annotation (Line(points={{-238,180},{-222,180}},
                                     color={0,0,127}));
                      connect(numOfOcc3.y, reaToInt2.u)
                        annotation (Line(points={{-238,40},{-222,40}}, color={0,0,127}));
                      connect(reaToInt1.y, zon1.nOcc) annotation (Line(points={{-198,180},{-166,180},
                              {-166,119},{-122,119}}, color={255,127,0}));
                      connect(reaToInt2.y, zon2.nOcc) annotation (Line(points={{-198,40},{-180,40},{
                              -180,9},{-122,9}},   color={255,127,0}));
                      connect(numOfOcc4.y, reaToInt3.u)
                        annotation (Line(points={{-238,-80},{-222,-80}}, color={0,0,127}));
                      connect(reaToInt3.y, zon3.nOcc) annotation (Line(points={{-198,-80},{-180,-80},
                              {-180,-101},{-122,-101}}, color={255,127,0}));
                      connect(winSta1.y, zon3.uWin) annotation (Line(points={{-198,-130},{-180,-130},
                              {-180,-104},{-122,-104}}, color={255,0,255}));
                      connect(winSta.y, zon2.uWin) annotation (Line(points={{-198,0},{-180,0},{-180,
                              6},{-122,6}},   color={255,0,255}));
                      connect(TZon.y, zon1.TZon) annotation (Line(points={{-238,140},{-174,140},{-174,
                              110},{-122,110}}, color={0,0,127}));
                      connect(TZon.y, zon2.TZon) annotation (Line(points={{-238,140},{-174,140},{-174,
                              0},{-122,0}}, color={0,0,127}));
                      connect(TZon.y, zon3.TZon) annotation (Line(points={{-238,140},{-174,140},{-174,
                              -110},{-122,-110}}, color={0,0,127}));
                      connect(TDis.y, zon1.TDis) annotation (Line(points={{-198,120},{-170,120},{-170,
                              107},{-122,107}}, color={0,0,127}));
                      connect(TDis.y, zon2.TDis) annotation (Line(points={{-198,120},{-170,120},{-170,
                              -3},{-122,-3}}, color={0,0,127}));
                      connect(TDis.y, zon3.TDis) annotation (Line(points={{-198,120},{-170,120},{-170,
                              -113},{-122,-113}}, color={0,0,127}));
                      connect(zonPriFloRat2.y, zon3.VDis_flow) annotation (Line(points={{-238,-160},
                              {-166,-160},{-166,-116},{-122,-116}}, color={0,0,127}));
                      connect(zonPriFloRat1.y, zon2.VDis_flow) annotation (Line(points={{-238,-30},{
                              -166,-30},{-166,-6},{-122,-6}}, color={0,0,127}));
                      connect(zonPriFloRat.y, zon1.VDis_flow) annotation (Line(points={{-238,90},{-166,
                              90},{-166,104},{-122,104}}, color={0,0,127}));
                      connect(ahu1.VDesUncOutAir_flow, zon1.VUncOut_flow_nominal) annotation (Line(
                            points={{242,58},{246,58},{246,168},{-154,168},{-154,101},{-122,101}},
                            color={0,0,127}));
                      connect(ahu1.VDesUncOutAir_flow, zon2.VUncOut_flow_nominal) annotation (Line(
                            points={{242,58},{246,58},{246,168},{-154,168},{-154,-9},{-122,-9}},
                            color={0,0,127}));
                      connect(ahu1.VDesUncOutAir_flow, zon3.VUncOut_flow_nominal) annotation (Line(
                            points={{242,58},{246,58},{246,168},{-154,168},{-154,-119},{-122,-119}},
                            color={0,0,127}));

                    annotation (
                      experiment(StopTime=3600.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/SetPoints/OutdoorAirFlow/Validation/OutdoorAirFlow.mos"
                        "Simulate and plot"),
                      Documentation(info="<html>
<p>
This model shows how to compose the subsequences to find the minimum outdoor
airflow setpoint of an AHU unit that serves three zones.
</p>
<ul>
<li>
The blocks <code>zon1</code>, <code>zon2</code> and <code>zon3</code> which
instantiate
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone</a>,
calculate the zone level minimum outdoor airflow setpoints.
</li>
<li>
The block <code>zonToAhu</code> which instantiates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.SumZone\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.SumZone</a>,
finds the sum, minimum and maximum of the zone level setpoints.
</li>
<li>
The AHU level minimum outdoor airflow setpoint is then specified by block <code>ahu1</code>.
See <a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.AHU\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.AHU</a>.
</li>
</ul>
</html>",                     revisions="<html>
<ul>
<li>
March 14, 2020, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),              Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                             graphics={
                            Ellipse(lineColor = {75,138,73},
                                    fillColor={255,255,255},
                                    fillPattern = FillPattern.Solid,
                                    extent = {{-100,-100},{100,100}}),
                            Polygon(lineColor = {0,0,255},
                                    fillColor = {75,138,73},
                                    pattern = LinePattern.None,
                                    fillPattern = FillPattern.Solid,
                                    points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem(extent={{-280,-200},{280,200}})));
                    end OutdoorAirFlow;
                  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),            Icon(graphics={
                          Rectangle(
                            lineColor={200,200,200},
                            fillColor={248,248,248},
                            fillPattern=FillPattern.HorizontalCylinder,
                            extent={{-100.0,-100.0},{100.0,100.0}},
                            radius=25.0),
                          Rectangle(
                            lineColor={128,128,128},
                            extent={{-100.0,-100.0},{100.0,100.0}},
                            radius=25.0),
                          Polygon(
                            origin={8.0,14.0},
                            lineColor={78,138,73},
                            fillColor={78,138,73},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
                  end Validation;
                annotation (
                Documentation(info="<html>
<p>
This package contains sequences to set the minimum outdoor airflow setpoint for 
compliance with the ventilation rate procedure of ASHRAE 62.1-2013. The
implementation is according to ASHRAE Guidline 36 (G36), PART 5.N.3.a, PART 5.B.2.b,
PART3.1-D.2.a.
</p>
<ul>
<li> 
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.Zone</a>
conducts zone level calculations for specifying minimum outdoor airflow rate,
</li>
<li> 
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.AHU\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.AHU</a>
conducts AHU level calculations for specifying minimum outdoor airflow rate,
</li>
<li> 
and <a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.SumZone\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.OutdoorAirFlow.SumZone</a>
finds the sums, the maximum and the minimum of outputs from zone level calculations.
They become inputs of AHU level calculation.
</li>
</ul>
</html>",                 revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Reimplemented sequence of calculating the outdoor airflow setpoint to separated
vector-valued calculation. This therefore breaks the single sequence to three
subsequences.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
July 23, 2019, by Michael Wetter:<br/>
Improved documentation.
</li>
</ul>
</html>"),                 Icon(graphics={
                        Rectangle(
                          lineColor={200,200,200},
                          fillColor={248,248,248},
                          fillPattern=FillPattern.HorizontalCylinder,
                          extent={{-100,-100},{100,100}},
                          radius=25.0),
                        Rectangle(
                          lineColor={128,128,128},
                          extent={{-100,-100},{100,100}},
                          radius=25.0),
                        Ellipse(
                          origin={10,10},
                          lineColor={128,128,128},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid,
                          extent={{-80.0,0.0},{-20.0,60.0}}),
                        Ellipse(
                          origin={10,10},
                          fillColor={128,128,128},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{0.0,0.0},{60.0,60.0}}),
                        Ellipse(
                          origin={10,10},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{0.0,-80.0},{60.0,-20.0}}),
                        Ellipse(
                          origin={10,10},
                          fillColor={76,76,76},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{-80.0,-80.0},{-20.0,-20.0}})}));
                end OutdoorAirFlow;

                package Validation "Collection of validation models"

                  model ExhaustDamper
                    "Validate the controller of an actuated exhaust damper without fan"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ExhaustDamper
                      exhDamPos(k=0.1)
                      "Block of controlling actuated exhaust damper without fan"
                      annotation (Placement(transformation(extent={{0,40},{20,
                              60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      supFan(k=true) "Supply fan status" annotation (Placement(
                          transformation(extent={{-80,-40},{-60,-20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      meaBuiPre(
                      height=8,
                      duration=1200,
                      offset=8,
                      startTime=0) "Measured indoor building static pressure"
                      annotation (Placement(transformation(extent={{-80,40},{-60,
                              60}})));

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ExhaustDamper
                      exhDamPos1(k=0.5)
                      "Block of controlling actuated exhaust damper without fan"
                      annotation (Placement(transformation(extent={{0,0},{20,20}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ExhaustDamper
                      exhDamPos2(k=1)
                      "Block of controlling actuated exhaust damper without fan"
                      annotation (Placement(transformation(extent={{0,-40},{20,
                              -20}})));
                  equation
                    connect(meaBuiPre.y, exhDamPos.dpBui) annotation (Line(points={{-59,50},{-40,
                            50},{-40,56},{-1,56}}, color={0,0,127}));
                    connect(supFan.y, exhDamPos.uSupFan) annotation (Line(points={{-59,-30},{-20,
                            -30},{-20,44},{-1,44}}, color={255,0,255}));

                    connect(supFan.y, exhDamPos1.uSupFan) annotation (Line(points={{-59,-30},{-20,
                            -30},{-20,4},{-1,4}}, color={255,0,255}));
                    connect(supFan.y, exhDamPos2.uSupFan) annotation (Line(points={{-59,-30},{-20,
                            -30},{-20,-36},{-1,-36}}, color={255,0,255}));
                    connect(meaBuiPre.y, exhDamPos1.dpBui) annotation (Line(points={{-59,50},{-40,
                            50},{-40,16},{-1,16}}, color={0,0,127}));
                    connect(meaBuiPre.y, exhDamPos2.dpBui) annotation (Line(points={{-59,50},{-40,
                            50},{-40,-24},{-1,-24}}, color={0,0,127}));
                  annotation (
                    experiment(StopTime=1200.0, Tolerance=1e-06),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/SetPoints/Validation/ExhaustDamper.mos"
                      "Simulate and plot"),
                    Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ExhaustDamper\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ExhaustDamper</a>.
</p>
</html>",                   revisions="<html>
<ul>
<li>
May 15, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent = {{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
                  end ExhaustDamper;

                  model ReturnFanDirectPressure
                    "Validate model for calculating return fan control with direct building pressure
  of multi zone VAV AHU"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ReturnFanDirectPressure
                      retFanPre(k=0.1)
                      "Return fan control with direct building pressure"
                      annotation (Placement(transformation(extent={{20,60},{40,
                              80}})));
                    CDL.Logical.Sources.Pulse yFan(period=4000) "Supply fan status"
                      annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
                    CDL.Continuous.Sources.Ramp dpBui(
                      height=40,
                      offset=0,
                      duration=1800) "Building static presure"
                      annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ReturnFanDirectPressure
                      retFanPre1(k=0.5)
                      "Return fan control with direct building pressure"
                      annotation (Placement(transformation(extent={{20,10},{40,
                              30}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ReturnFanDirectPressure
                      retFanPre2
                      "Return fan control with direct building pressure"
                      annotation (Placement(transformation(extent={{20,-40},{40,
                              -20}})));

                  equation
                    connect(yFan.y, retFanPre.uFan) annotation (Line(points={{-59,70},{-20,70},{-20,
                            64},{18,64}}, color={255,0,255}));
                    connect(dpBui.y, retFanPre.dpBui) annotation (Line(points={{-59,20},{0,20},{0,
                            76},{18,76}}, color={0,0,127}));
                    connect(yFan.y, retFanPre1.uFan) annotation (Line(points={{-59,70},{-20,70},{
                            -20,14},{18,14}}, color={255,0,255}));
                    connect(yFan.y, retFanPre2.uFan) annotation (Line(points={{-59,70},{-20,70},{
                            -20,-36},{18,-36}}, color={255,0,255}));
                    connect(dpBui.y, retFanPre1.dpBui) annotation (Line(points={{-59,20},{0,20},{0,
                            26},{18,26}}, color={0,0,127}));
                    connect(dpBui.y, retFanPre2.dpBui) annotation (Line(points={{-59,20},{0,20},{0,
                            -24},{18,-24}}, color={0,0,127}));

                  annotation (
                    experiment(StopTime=3600, Tolerance=1e-6),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/SetPoints/Validation/ReturnFanDirectPressure.mos"
                          "Simulate and plot"),
                      Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ReturnFanDirectPressure\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.ReturnFanDirectPressure</a>
for exhaust air damper and return fan control with direct building pressure measurement
for systems with multiple
zones.
</p>
</html>",                   revisions="<html>
<ul>
<li>
October 16, 2017, by Michael Wetter:<br/>
Changed example to also test for fan off signal.
</li>
<li>
October 16, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent = {{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
                  end ReturnFanDirectPressure;

                  model SupplyFan "Validate SupplyFan"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan
                      conSupFan(
                      Td=1,
                      controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

                      maxSet=400,
                      k=0.001,
                      Ti=10) "Block outputs supply fan speed" annotation (
                        Placement(transformation(extent={{0,20},{20,40}})));

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan
                      conSupFan1(
                      have_perZonRehBox=true,
                      Td=1,
                      controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

                      maxSet=400,
                      k=0.001,
                      Ti=10) "Block outputs supply fan speed" annotation (
                        Placement(transformation(extent={{160,20},{180,40}})));

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan
                      conSupFan2(
                      have_duaDucBox=false,
                      have_airFloMeaSta=true,
                      Td=1,
                      controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

                      maxSet=400,
                      k=0.001,
                      Ti=10) "Block outputs supply fan speed" annotation (
                        Placement(transformation(extent={{80,20},{100,40}})));

                  protected
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      ram(duration=28800, height=6)
                      "Ramp signal for generating operation mode" annotation (
                        Placement(transformation(extent={{-200,100},{-180,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                      sine(
                      freqHz=1/14400,
                      offset=3,
                      amplitude=2) "Generate sine signal " annotation (
                        Placement(transformation(extent={{-200,-10},{-180,10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                      sine1(
                      freqHz=1/14400,
                      offset=200,
                      amplitude=150) "Generate sine signal" annotation (
                        Placement(transformation(extent={{-120,-50},{-100,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs
                      "Block generates absolute value of input" annotation (
                        Placement(transformation(extent={{-160,100},{-140,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs1
                      "Block generates absolute value of input" annotation (
                        Placement(transformation(extent={{-160,-10},{-140,10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=0)
                      "Round real number to given digits" annotation (Placement(
                          transformation(extent={{-120,-10},{-100,10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                      reaToInt1 "Convert real to integer" annotation (Placement(
                          transformation(extent={{-80,-10},{-60,10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                      reaToInt2 "Convert real to integer" annotation (Placement(
                          transformation(extent={{-80,100},{-60,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
                      "Round real number to given digits" annotation (Placement(
                          transformation(extent={{-120,100},{-100,120}})));

                  equation
                    connect(sine1.y, conSupFan.ducStaPre)
                      annotation (Line(points={{-98,-40},{-10,-40},{-10,22},{-2,22}},
                        color={0,0,127}));
                    connect(sine.y, abs1.u)
                      annotation (Line(points={{-178,0},{-162,0}},
                        color={0,0,127}));
                    connect(ram.y, abs.u)
                      annotation (Line(points={{-178,110},{-162,110}},
                        color={0,0,127}));
                    connect(abs1.y, round2.u)
                      annotation (Line(points={{-138,0},{-122,0}},   color={0,0,127}));
                    connect(round2.y, reaToInt1.u)
                      annotation (Line(points={{-98,0},{-82,0}},  color={0,0,127}));
                    connect(reaToInt1.y, conSupFan.uZonPreResReq)
                      annotation (Line(points={{-58,0},{-20,0},{-20,27},{-2,27}},
                        color={255,127,0}));
                    connect(abs.y, round1.u)
                      annotation (Line(points={{-138,110},{-122,110}},
                                                                   color={0,0,127}));
                    connect(round1.y, reaToInt2.u)
                      annotation (Line(points={{-98,110},{-82,110}},
                                                                color={0,0,127}));
                    connect(reaToInt2.y, conSupFan.uOpeMod)
                      annotation (Line(points={{-58,110},{-20,110},{-20,38},{-2,38}},
                        color={255,127,0}));

                    connect(reaToInt2.y, conSupFan2.uOpeMod) annotation (Line(points={{-58,110},{
                            60,110},{60,38},{78,38}},
                                                   color={255,127,0}));
                    connect(reaToInt1.y, conSupFan2.uZonPreResReq) annotation (Line(points={{-58,0},
                            {60,0},{60,27},{78,27}}, color={255,127,0}));
                    connect(sine1.y, conSupFan2.ducStaPre) annotation (Line(points={{-98,-40},{70,
                            -40},{70,22},{78,22}}, color={0,0,127}));
                    connect(reaToInt2.y, conSupFan1.uOpeMod) annotation (Line(points={{-58,110},{
                            150,110},{150,38},{158,38}},
                                                     color={255,127,0}));
                    connect(reaToInt1.y, conSupFan1.uZonPreResReq) annotation (Line(points={{-58,0},
                            {150,0},{150,27},{158,27}}, color={255,127,0}));
                    connect(sine1.y, conSupFan1.ducStaPre) annotation (Line(points={{-98,-40},{
                            152,-40},{152,22},{158,22}},
                                                     color={0,0,127}));
                  annotation (experiment(StopTime=28800.0, Tolerance=1e-06),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/SetPoints/Validation/SupplyFan.mos"
                      "Simulate and plot"),
                      Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyFan</a>.
</p>
</html>",                   revisions="<html>
<ul>
<li>
July 19, 2019, by Milica Grahovac:<br/>
Added test cases.
</li>
<li>
August 24, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent = {{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                      Diagram(coordinateSystem(extent={{-220,-80},{220,140}})));
                  end SupplyFan;

                  model SupplySignals_Valve
                    "Validate model for controlling coil valve postion of multi zone VAV AHU"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals
                      supSig
                      "Output valve position and supply air temperature control loop signal"
                      annotation (Placement(transformation(extent={{20,60},{40,
                              80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse
                      supFanSta(period=7200) "Supply fan status" annotation (
                        Placement(transformation(extent={{-80,-10},{-60,10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                      TSup(
                      amplitude=2,
                      offset=16 + 273.15,
                      freqHz=1/7200) "Supply air temperature" annotation (
                        Placement(transformation(extent={{-80,30},{-60,50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      TSupSet(
                      height=3,
                      duration=7200,
                      offset=15 + 273.15) "Supply air temperature setpoint"
                      annotation (Placement(transformation(extent={{-80,70},{-60,
                              90}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals
                      supSig1
                      "Output valve position and supply air temperature control loop signal"
                      annotation (Placement(transformation(extent={{20,0},{40,
                              20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      fanOn(k=true) "Fan on" annotation (Placement(
                          transformation(extent={{-80,-50},{-60,-30}})));

                  equation
                    connect(TSupSet.y,supSig.TSupSet)
                      annotation (Line(points={{-59,80},{-40,80},{-40,75},{19,75}},
                        color={0,0,127}));
                    connect(TSup.y, supSig.TSup)
                      annotation (Line(points={{-59,40},{-30,40},{-30,70},{19,70}},
                        color={0,0,127}));
                    connect(supFanSta.y, supSig.uSupFan)
                      annotation (Line(points={{-59,0},{-20,0},{-20,65},{19,65}},
                        color={255,0,255}));
                    connect(TSupSet.y,supSig1.TSupSet)
                      annotation (Line(points={{-59,80},{-40,80},{-40,15},{19,15}},
                        color={0,0,127}));
                    connect(TSup.y, supSig1.TSup)
                      annotation (Line(points={{-59,40},{-30,40},{-30,10},{19,10}},
                        color={0,0,127}));
                    connect(fanOn.y, supSig1.uSupFan)
                      annotation (Line(points={{-59,-40},{0,-40},{0,5},{19,5}},
                        color={255,0,255}));

                  annotation (
                    experiment(StopTime=7200, Tolerance=1e-6),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/SetPoints/Validation/SupplySignals_Valve.mos"
                          "Simulate and plot"),
                      Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplySignals</a>
for a change of the supply air temperature setpoint, measured supply air temperature and
the supply fan status, to specify coil valve positions, and generate control
loop signal.
</p>
</html>",                   revisions="<html>
<ul>
<li>
November 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent = {{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
                  end SupplySignals_Valve;

                  model SupplyTemperature
                    "Validate model for calculating supply air temperature of multi zone VAV AHU"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyTemperature
                      conTSupSet
                      "Supply air temperature setpoint for multi zone system"
                      annotation (Placement(transformation(extent={{70,-10},{90,
                              10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      setZonTem(k=22.5 + 273.15)
                      "Average of heating and cooling setpoint" annotation (
                        Placement(transformation(extent={{-80,60},{-60,80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                      outTem(
                      amplitude=5,
                      freqHz=1/86400,
                      offset=18 + 273.15) "Outdoor air temperature" annotation
                      (Placement(transformation(extent={{-80,30},{-60,50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse
                      supFanSta(period=43200) "Supply fan status" annotation (
                        Placement(transformation(extent={{-80,-10},{-60,10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      opeMod(
                      offset=1,
                      height=1,
                      duration=90000) "Operation mode" annotation (Placement(
                          transformation(extent={{-80,-80},{-60,-60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs
                      "Block generates absolute value of input" annotation (
                        Placement(transformation(extent={{-40,-50},{-20,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                      sine(amplitude=6, freqHz=1/86400)
                      "Block generates sine signal" annotation (Placement(
                          transformation(extent={{-80,-50},{-60,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                      reaToInt1 "Convert real to integer" annotation (Placement(
                          transformation(extent={{32,-50},{52,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
                      "Round real number to given digits" annotation (Placement(
                          transformation(extent={{0,-50},{20,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                      reaToInt2 "Convert real to integer" annotation (Placement(
                          transformation(extent={{0,-80},{20,-60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=0)
                      "Round real number to given digits" annotation (Placement(
                          transformation(extent={{-40,-80},{-20,-60}})));

                  equation
                    connect(supFanSta.y, conTSupSet.uSupFan)
                      annotation (Line(points={{-59,0},{69,0}},
                        color={255,0,255}));
                    connect(outTem.y, conTSupSet.TOut)
                      annotation (Line(points={{-59,40},{40,40},{40,4},{69,4}},
                        color={0,0,127}));
                    connect(setZonTem.y, conTSupSet.TZonSetAve) annotation (Line(points={{-59,70},
                            {60,70},{60,8},{69,8}}, color={0,0,127}));
                    connect(sine.y, abs.u)
                      annotation (Line(points={{-59,-40},{-42,-40}}, color={0,0,127}));
                    connect(opeMod.y, round2.u)
                      annotation (Line(points={{-59,-70},{-42,-70}}, color={0,0,127}));
                    connect(round2.y, reaToInt2.u)
                      annotation (Line(points={{-19,-70},{-12,-70},{-12,-70},{-2,-70}},
                        color={0,0,127}));
                    connect(abs.y, round1.u)
                      annotation (Line(points={{-19,-40},{-2,-40}}, color={0,0,127}));
                    connect(round1.y, reaToInt1.u)
                      annotation (Line(points={{21,-40},{30,-40}}, color={0,0,127}));
                    connect(reaToInt1.y, conTSupSet.uZonTemResReq)
                      annotation (Line(points={{53,-40},{60,-40},{60,-4},{69,-4}},
                        color={255,127,0}));
                    connect(reaToInt2.y, conTSupSet.uOpeMod)
                      annotation (Line(points={{21,-70},{66,-70},{66,-8},{69,-8}},
                        color={255,127,0}));

                  annotation (
                    experiment(StopTime=86400, Tolerance=1e-6),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/SetPoints/Validation/SupplyTemperature.mos"
                          "Simulate and plot"),
                      Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyTemperature\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints.SupplyTemperature</a>
for a change of outdoor temperature, operation mode, supply fan status, maximum
supply temperature, to specify the supply air temperature for systems with multiple
zones.
</p>
</html>",                   revisions="<html>
<ul>
<li>
July 11, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent = {{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
                  end SupplyTemperature;
                annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.SetPoints</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),          Icon(graphics={
                        Rectangle(
                          lineColor={200,200,200},
                          fillColor={248,248,248},
                          fillPattern=FillPattern.HorizontalCylinder,
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Rectangle(
                          lineColor={128,128,128},
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Polygon(
                          origin={8.0,14.0},
                          lineColor={78,138,73},
                          fillColor={78,138,73},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
                end Validation;
              annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains sequences generating setpoints for VAV AHU control.
</p>
</html>"),      Icon(graphics={
                      Rectangle(
                        lineColor={200,200,200},
                        fillColor={248,248,248},
                        fillPattern=FillPattern.HorizontalCylinder,
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Rectangle(
                        lineColor={128,128,128},
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                    Text(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      textString="S")}));
              end SetPoints;

              package Validation "Collection of validation models"

                model Controller "Validation controller model"

                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Controller
                    conAHU(VPriSysMax_flow=0.35, peaSysPop=6)
                    "Multizone VAV AHU controller" annotation (Placement(
                        transformation(extent={{100,-60},{180,68}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    TSetRooCooOn(final k=273.15 + 24) "Cooling on setpoint"
                    annotation (Placement(transformation(extent={{-160,189},{-140,
                            210}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    TSetRooHeaOn(final k=273.15 + 20) "Heating on setpoint"
                    annotation (Placement(transformation(extent={{-220,209},{-200,
                            230}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    TOutCut(final k=297.15)
                    "Outdoor temperature high limit cutoff" annotation (
                      Placement(transformation(extent={{-100,-90},{-80,-70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    TSup(
                    height=4,
                    duration=3600,
                    offset=273.15 + 14) "AHU supply air temperature"
                    annotation (Placement(transformation(extent={{-180,-70},{-160,
                            -50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    VOut_flow(
                    duration=1800,
                    offset=0.02,
                    height=0.0168) "Measured outdoor airflow rate" annotation (
                      Placement(transformation(extent={{-180,-110},{-160,-90}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    TMixMea(
                    height=4,
                    duration=1,
                    offset=273.15 + 2,
                    startTime=0) "Measured mixed air temperature" annotation (
                      Placement(transformation(extent={{-60,-130},{-40,-110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                    TOut(
                    amplitude=5,
                    offset=18 + 273.15,
                    freqHz=1/3600) "Outdoor air temperature" annotation (
                      Placement(transformation(extent={{-220,170},{-200,190}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                    ducStaPre(
                    offset=200,
                    amplitude=150,
                    freqHz=1/3600) "Duct static pressure" annotation (Placement(
                        transformation(extent={{-160,150},{-140,170}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                    sine2(
                    offset=3,
                    amplitude=2,
                    freqHz=1/9600)
                    "Duct static pressure setpoint reset requests" annotation (
                      Placement(transformation(extent={{-220,-210},{-200,-190}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                    sine3(amplitude=6, freqHz=1/9600)
                    "Maximum supply temperature setpoint reset" annotation (
                      Placement(transformation(extent={{-220,-170},{-200,-150}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs2
                    "Block generates absolute value of input" annotation (
                      Placement(transformation(extent={{-140,-170},{-120,-150}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs3
                    "Block generates absolute value of input" annotation (
                      Placement(transformation(extent={{-140,-210},{-120,-190}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round3(n=0)
                    "Round real number to given digits" annotation (Placement(
                        transformation(extent={{-100,-170},{-80,-150}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round4(n=0)
                    "Round real number to given digits" annotation (Placement(
                        transformation(extent={{-100,-210},{-80,-190}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                    ducPreResReq "Convert real to integer" annotation (
                      Placement(transformation(extent={{-60,-210},{-40,-190}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                    maxSupResReq "Convert real to integer" annotation (
                      Placement(transformation(extent={{-60,-170},{-40,-150}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    opeMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                    "AHU operation mode is occupied" annotation (Placement(
                        transformation(extent={{-180,-150},{-160,-130}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    sumDesZonPop(final k=5) "Sum of design zone population"
                    annotation (Placement(transformation(extent={{-220,119},{-200,
                            140}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    sumDesPopBreZon(final k=0.0125)
                    "Sum of the population component design breathing zone flow rate"
                    annotation (Placement(transformation(extent={{-160,101},{-140,
                            122}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    sumDesAreBreZon(final k=0.03)
                    "Sum of the area component design breathing zone flow rate"
                    annotation (Placement(transformation(extent={{-220,79},{-200,
                            100}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    desSysVenEff(final k=1)
                    "Design system ventilation efficiency" annotation (
                      Placement(transformation(extent={{-160,51},{-140,72}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse
                    uncOutAir(
                    amplitude=0.01,
                    width=0.25,
                    period=3600,
                    offset=0.0375)
                    "Sum of all zones required uncorrected outdoor airflow rate"
                    annotation (Placement(transformation(extent={{-220,30},{-200,
                            50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    vavBoxFlo2(
                    offset=1,
                    height=0.5,
                    duration=3600)
                    "Ramp signal for generating VAV box flow rate" annotation (
                      Placement(transformation(extent={{-160,10},{-140,30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    vavBoxFlo1(
                    height=1.5,
                    offset=1,
                    duration=3600)
                    "Ramp signal for generating VAV box flow rate" annotation (
                      Placement(transformation(extent={{-160,-30},{-140,-10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2
                    "System primary airflow rate, equals to the sum of the measured discharged flow rate of all terminal units"
                    annotation (Placement(transformation(extent={{-100,-10},{-80,
                            10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse
                    uOutAirFra_max(
                    amplitude=0.005,
                    width=0.25,
                    period=3600,
                    offset=0.015)
                    "Maximum zone outdoor air fraction, equals to the maximum of primary outdoor air fraction of all zones"
                    annotation (Placement(transformation(extent={{-220,-50},{-200,
                            -30}})));

                equation
                  connect(TSetRooHeaOn.y, conAHU.TZonHeaSet) annotation (Line(points={{-198,
                          219.5},{40,219.5},{40,64.4444},{96,64.4444}},
                                                                 color={0,0,127}));
                  connect(TSetRooCooOn.y, conAHU.TZonCooSet) annotation (Line(points={{-138,
                          199.5},{34,199.5},{34,59.1111},{96,59.1111}},
                                                                 color={0,0,127}));
                  connect(TOut.y, conAHU.TOut) annotation (Line(points={{-198,180},{28,180},{28,
                          53.7778},{96,53.7778}}, color={0,0,127}));
                  connect(ducStaPre.y, conAHU.ducStaPre) annotation (Line(points={{-138,160},{
                          22,160},{22,48.4444},{96,48.4444}},
                                                           color={0,0,127}));
                  connect(sine2.y, abs3.u)
                    annotation (Line(points={{-198,-200},{-142,-200}}, color={0,0,127}));
                  connect(abs3.y,round4. u)
                    annotation (Line(points={{-118,-200},{-102,-200}},color={0,0,127}));
                  connect(round4.y, ducPreResReq.u)
                    annotation (Line(points={{-78,-200},{-62,-200}}, color={0,0,127}));
                  connect(sine3.y, abs2.u)
                    annotation (Line(points={{-198,-160},{-142,-160}}, color={0,0,127}));
                  connect(abs2.y, round3.u)
                    annotation (Line(points={{-118,-160},{-102,-160}}, color={0,0,127}));
                  connect(round3.y, maxSupResReq.u)
                    annotation (Line(points={{-78,-160},{-62,-160}}, color={0,0,127}));
                  connect(opeMod.y, conAHU.uOpeMod) annotation (Line(points={{-158,-140},{28,
                          -140},{28,-40.4444},{96,-40.4444}},
                                                        color={255,127,0}));
                  connect(maxSupResReq.y, conAHU.uZonTemResReq) annotation (Line(points={{-38,
                          -160},{34,-160},{34,-45.7778},{96,-45.7778}},
                                                                  color={255,127,0}));
                  connect(ducPreResReq.y, conAHU.uZonPreResReq) annotation (Line(points={{-38,
                          -200},{40,-200},{40,-51.1111},{96,-51.1111}},
                                                                  color={255,127,0}));
                  connect(TMixMea.y, conAHU.TMix) annotation (Line(points={{-38,-120},{22,-120},
                          {22,-33.3333},{96,-33.3333}}, color={0,0,127}));
                  connect(VOut_flow.y, conAHU.VOut_flow) annotation (Line(points={{-158,-100},{
                          16,-100},{16,-26.2222},{96,-26.2222}},
                                                              color={0,0,127}));
                  connect(TOutCut.y, conAHU.TOutCut) annotation (Line(points={{-78,-80},{10,-80},
                          {10,-10.2222},{96,-10.2222}}, color={0,0,127}));
                  connect(TSup.y, conAHU.TSup) annotation (Line(points={{-158,-60},{4,-60},{4,-4.88889},
                          {96,-4.88889}}, color={0,0,127}));
                  connect(sumDesZonPop.y, conAHU.sumDesZonPop) annotation (Line(points={{-198,
                          129.5},{16,129.5},{16,37.7778},{96,37.7778}},
                                                                 color={0,0,127}));
                  connect(sumDesPopBreZon.y, conAHU.VSumDesPopBreZon_flow) annotation (Line(
                        points={{-138,111.5},{10,111.5},{10,32.4444},{96,32.4444}}, color={0,0,127}));
                  connect(sumDesAreBreZon.y, conAHU.VSumDesAreBreZon_flow) annotation (Line(
                        points={{-198,89.5},{4,89.5},{4,27.1111},{96,27.1111}}, color={0,0,127}));
                  connect(desSysVenEff.y, conAHU.uDesSysVenEff) annotation (Line(points={{-138,
                          61.5},{-2,61.5},{-2,21.7778},{96,21.7778}},
                                                                color={0,0,127}));
                  connect(uncOutAir.y, conAHU.VSumUncOutAir_flow) annotation (Line(points={{-198,40},
                          {-8,40},{-8,16.4444},{96,16.4444}}, color={0,0,127}));
                  connect(vavBoxFlo2.y, add2.u1) annotation (Line(points={{-138,20},{-120,20},{-120,
                          6},{-102,6}}, color={0,0,127}));
                  connect(vavBoxFlo1.y, add2.u2) annotation (Line(points={{-138,-20},{-120,-20},
                          {-120,-6},{-102,-6}}, color={0,0,127}));
                  connect(add2.y, conAHU.VSumSysPriAir_flow) annotation (Line(points={{-78,0},{
                          -8,0},{-8,11.1111},{96,11.1111}},
                                                         color={0,0,127}));
                  connect(uOutAirFra_max.y, conAHU.uOutAirFra_max) annotation (Line(points={{-198,
                          -40},{-2,-40},{-2,5.77778},{96,5.77778}}, color={0,0,127}));

                annotation (experiment(StopTime=3600.0, Tolerance=1e-06),
                  __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/MultiZone/VAV/Validation/Controller.mos"
                    "Simulate and plot"),
                    Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone.VAV.Controller</a>.
</p>
</html>",                 revisions="<html>
<ul>
<li>
March 16, 2020, by Jianjun Hu:<br/>
Reimplemented to validate new controller which does not have vector
related calculation.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1829\">#1829</a>.
</li>
<li>
January 12, 2019, by Michael Wetter:<br/>
Removed wrong use of <code>each</code>.
</li>
<li>
October 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Diagram(coordinateSystem(extent={{-240,-240},{240,240}})),
                    Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                         graphics={
                        Ellipse(lineColor = {75,138,73},
                                fillColor={255,255,255},
                                fillPattern = FillPattern.Solid,
                                extent = {{-100,-100},{100,100}}),
                        Polygon(lineColor = {0,0,255},
                                fillColor = {75,138,73},
                                pattern = LinePattern.None,
                                fillPattern = FillPattern.Solid,
                                points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
                end Controller;
              annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.MultiZone</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),      Icon(graphics={
                      Rectangle(
                        lineColor={200,200,200},
                        fillColor={248,248,248},
                        fillPattern=FillPattern.HorizontalCylinder,
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Rectangle(
                        lineColor={128,128,128},
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Polygon(
                        origin={8.0,14.0},
                        lineColor={78,138,73},
                        fillColor={78,138,73},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
              end Validation;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains control sequences from ASHRAE Guideline 36, Part 5.N for
multi zone VAV air handling unit control.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Ellipse(
                      origin={10.0,10.0},
                      fillColor={76,76,76},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{-80.0,-80.0},{-20.0,-20.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{0.0,-80.0},{60.0,-20.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      fillColor={128,128,128},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{0.0,0.0},{60.0,60.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      lineColor={128,128,128},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid,
                      extent={{-80.0,0.0},{-20.0,60.0}})}));
            end VAV;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains control sequences from ASHRAE Guideline 36 for multi zone air handling units.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),      Rectangle(
                      extent={{-78,78},{74,-76}},
                      lineColor={0,0,0},
                      lineThickness=0.5),
                                       Rectangle(
                      extent={{-44,44},{40,-42}},
                      lineColor={0,0,0},
                      lineThickness=0.5),
                Line(
                  points={{-24,44},{-24,78}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{20,44},{20,78}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{22,-76},{22,-42}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{-22,-76},{-22,-42}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{-78,24},{-44,24}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{-78,-24},{-44,-24}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{40,-24},{74,-24}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{40,24},{74,24}},
                  color={0,0,0},
                  thickness=0.5)}));
          end MultiZone;

          package SingleZone "Sequences for single zone AHU control"

            package VAV "Sequences for single zone VAV AHU control"

              block Controller
                "Single Zone AHU controller that composes subsequences for controlling fan speed, economizer, and supply air temperature"
                parameter Real TZonHeaOn(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=293.15
                  "Heating setpoint during on"
                  annotation (Dialog(group="Zone setpoints"));
                parameter Real TZonHeaOff(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=285.15
                  "Heating setpoint during off"
                  annotation (Dialog(group="Zone setpoints"));
                parameter Real TZonCooOn(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=297.15
                  "Cooling setpoint during on"
                  annotation (Dialog(group="Zone setpoints"));
                parameter Real TZonCooOff(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=303.15
                  "Cooling setpoint during off"
                  annotation (Dialog(group="Zone setpoints"));

                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeCoo=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                  "Type of controller"
                  annotation (Dialog(group="Cooling loop signal"));
                parameter Real kCoo(final unit="1/K") = 0.1
                  "Gain for cooling control loop signal"
                  annotation(Dialog(group="Cooling loop signal"));
                parameter Real TiCoo(
                  final unit="s",
                  final quantity="Time")=900
                  "Time constant of integrator block for cooling control loop signal"
                  annotation(Dialog(group="Cooling loop signal",
                    enable=controllerTypeCoo == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeCoo == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                parameter Real TdCoo(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of derivative block for cooling control loop signal"
                  annotation (Dialog(group="Cooling loop signal",
                    enable=controllerTypeCoo == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeCoo == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeHea=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                  "Type of controller"
                  annotation (Dialog(group="Heating loop signal"));
                parameter Real kHea(final unit="1/K")=0.1
                  "Gain for heating control loop signal"
                  annotation(Dialog(group="Heating loop signal"));
                parameter Real TiHea(
                  final unit="s",
                  final quantity="Time")=900
                  "Time constant of integrator block for heating control loop signal"
                  annotation(Dialog(group="Heating loop signal",
                  enable=controllerTypeHea == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeHea == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                parameter Real TdHea(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of derivative block for heating control loop signal"
                  annotation (Dialog(group="Heating loop signal",
                    enable=controllerTypeHea == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeHea == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeCooCoi=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P
                  "Type of controller"
                  annotation (Dialog(group="Cooling coil loop signal"));
                parameter Real kCooCoi(final unit="1/K")=1.0
                  "Gain for cooling coil control loop signal"
                  annotation(Dialog(group="Cooling coil loop signal"));
                parameter Real TiCooCoil(
                  final unit="s",
                  final quantity="Time")=900
                  "Time constant of integrator block for cooling coil control loop signal"
                  annotation(Dialog(group="Cooling coil loop signal",
                  enable=controllerTypeCooCoi == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeCooCoi == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                parameter Real TdCooCoil(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of derivative block for cooling coil control loop signal"
                  annotation (Dialog(group="Cooling coil loop signal",
                    enable=controllerTypeCooCoi == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeCooCoi == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                parameter Real TSupSetMax(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Maximum supply air temperature for heating"
                  annotation (Dialog(tab="VAV Setpoints",group="Temperature limits"));
                parameter Real TSupSetMin(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Minimum supply air temperature for cooling"
                  annotation (Dialog(tab="VAV Setpoints",group="Temperature limits"));
                parameter Real yHeaMax(min=0, max=1, unit="1")
                  "Maximum fan speed for heating"
                  annotation (Dialog(tab="VAV Setpoints",group="Speed"));
                parameter Real yMin(min=0, max=1, unit="1")
                  "Minimum fan speed"
                  annotation (Dialog(tab="VAV Setpoints",group="Speed"));
                parameter Real yCooMax(min=0, max=1, unit="1") = 1
                  "Maximum fan speed for cooling"
                  annotation (Dialog(tab="VAV Setpoints",group="Speed"));

                parameter Real VOutPerAre_flow(final unit="m3/(s.m2)") = 3e-4
                  "Outdoor air rate per unit area"
                  annotation(Dialog(tab="Outside Air Flow", group="Nominal condition"));
                parameter Real VOutPerPer_flow(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") = 2.5e-3
                  "Outdoor air rate per person"
                  annotation(Dialog(tab="Outside Air Flow", group="Nominal condition"));
                parameter Real AFlo(final unit="m2", final quantity="Area")
                  "Floor area"
                  annotation(Dialog(tab="Outside Air Flow", group="Nominal condition"));
                parameter Boolean have_occSen
                  "Set to true if zones have occupancy sensor"
                  annotation(Dialog(tab="Outside Air Flow", group="Occupancy"));
                parameter Real occDen(final unit="1/m2") = 0.05
                  "Default number of person in unit area"
                  annotation(Dialog(tab="Outside Air Flow", group="Occupancy"));
                parameter Real zonDisEffHea(final unit="1") = 0.8
                  "Zone air distribution effectiveness during heating"
                  annotation(Dialog(tab="Outside Air Flow", group="Occupancy"));
                parameter Real zonDisEffCoo(final unit="1") = 1.0
                  "Zone air distribution effectiveness during cooling"
                  annotation(Dialog(tab="Outside Air Flow", group="Occupancy"));
                parameter Boolean use_enthalpy = false
                  "Set to true if enthalpy measurement is used in addition to temperature measurement"
                  annotation(Dialog(tab="Economizer", group="General", enable=not use_fixed_plus_differential_drybulb));
                parameter Boolean use_fixed_plus_differential_drybulb = false
                  "Set to true to only evaluate fixed plus differential dry bulb temperature high limit cutoff;
    shall not be used with enthalpy"
                  annotation(Dialog(tab="Economizer", group="General", enable=not use_enthalpy));
                parameter Boolean use_TMix=true
                  "Set to true if mixed air temperature measurement is enabled"
                  annotation(Dialog(tab="Economizer", group="General"));
                parameter Boolean use_G36FrePro=false
                  "Set to true if G36 freeze protection is implemented"
                  annotation(Dialog(tab="Economizer", group="General"));
                parameter Real delTOutHis(
                  final unit="K",
                  final displayUnit="K",
                  final quantity="TemperatureDifference")=1
                  "Delta between the temperature hysteresis high and low limit"
                  annotation(Dialog(tab="Economizer", group="Advanced"));
                parameter Real delEntHis(
                  final unit="J/kg",
                  final quantity="SpecificEnergy")=1000
                  "Delta between the enthalpy hysteresis high and low limits"
                   annotation(Dialog(tab="Economizer", group="Advanced", enable = use_enthalpy));
                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeMod=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                  "Type of controller"
                  annotation (Dialog(tab="Economizer", group="Modulation"));
                parameter Real kMod(final unit="1/K")=1 "Gain of modulation controller"
                  annotation(Dialog(tab="Economizer", group="Modulation"));
                parameter Real TiMod(
                  final unit="s",
                  final quantity="Time")=300
                  "Time constant of modulation controller integrator block"
                  annotation (Dialog(tab="Economizer", group="Modulation",
                    enable=controllerTypeMod == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeMod == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                parameter Real TdMod(
                  final unit="s",
                  final quantity="Time")=0.1
                  "Time constant of derivative block for modulation controller"
                  annotation (Dialog(tab="Economizer", group="Modulation",
                    enable=controllerTypeMod == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeMod == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                parameter Real uMin(
                  final min=0,
                  final max=1,
                  final unit="1") = 0.1
                  "Lower limit of controller output uTSup at which the dampers are at their limits"
                  annotation(Dialog(tab="Economizer", group="General"));
                parameter Real uMax(
                  final min=0,
                  final max=1,
                  final unit="1") = 0.9
                  "Upper limit of controller output uTSup at which the dampers are at their limits"
                  annotation(Dialog(tab="Economizer", group="General"));

                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeFre=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                  "Type of controller" annotation (Dialog(
                    tab="Economizer",
                    group="Freeze protection",
                    enable=use_TMix));
                parameter Real kFre(final unit="1/K") = 0.1
                  "Gain for mixed air temperature tracking for freeze protection, used if use_TMix=true"
                   annotation(Dialog(tab="Economizer", group="Freeze protection", enable=use_TMix));
                parameter Real TiFre(
                  final unit="s",
                  final quantity="Time")=120
                  "Time constant of controller for mixed air temperature tracking for freeze protection. Require TiFre < TiMinOut"
                   annotation(Dialog(tab="Economizer", group="Freeze protection",
                     enable=use_TMix and (controllerTypeFre ==
                        hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeFre == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID)));
                parameter Real TdFre(
                  final unit="s",
                  final quantity="Time")=0.1
                   "Time constant of derivative block for freeze protection"
                   annotation (Dialog(tab="Economizer", group="Freeze protection",
                     enable=use_TMix and (controllerTypeFre ==
                        hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeFre == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID)));
                parameter Real TFreSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")=277.15
                  "Lower limit for mixed air temperature for freeze protection, used if use_TMix=true"
                   annotation(Dialog(tab="Economizer", group="Freeze protection", enable=use_TMix));

                parameter Real VOutMin_flow(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")=1.0
                  "Calculated minimum outdoor airflow rate"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));
                parameter Real VOutDes_flow(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")=2.0
                  "Calculated design outdoor airflow rate"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));
                parameter Real yDam_VOutMin_minSpe(
                  final min=outDamPhyPosMin,
                  final max=outDamPhyPosMax,
                  final unit="1") = 0.4
                  "OA damper position to supply minimum outdoor airflow at minimum fan speed"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));
                parameter Real yDam_VOutMin_maxSpe(
                  final min=outDamPhyPosMin,
                  final max=outDamPhyPosMax,
                  final unit="1") = 0.3
                  "OA damper position to supply minimum outdoor airflow at maximum fan speed"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));
                parameter Real yDam_VOutDes_minSpe(
                  final min=yDam_VOutMin_minSpe,
                  final max=outDamPhyPosMax,
                  final unit="1") = 0.9
                  "OA damper position to supply design outdoor airflow at minimum fan speed"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));
                parameter Real yDam_VOutDes_maxSpe(
                  final min=yDam_VOutMin_maxSpe,
                  final max=outDamPhyPosMax,
                  final unit="1") = 0.8
                  "OA damper position to supply design outdoor airflow at maximum fan speed"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));
                parameter Real outDamPhyPosMax(
                  final min=0,
                  final max=1,
                  final unit="1") = 1
                  "Physically fixed maximum position of the outdoor air damper"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));
                parameter Real outDamPhyPosMin(
                  final min=0,
                  final max=1,
                  final unit="1") = 0
                  "Physically fixed minimum position of the outdoor air damper"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));
                parameter Real retDamPhyPosMax(
                  final min=0,
                  final max=1,
                  final unit="1") = 1
                  "Physically fixed maximum position of the return air damper"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));
                parameter Real retDamPhyPosMin(
                  final min=0,
                  final max=1,
                  final unit="1") = 0
                  "Physically fixed minimum position of the return air damper"
                  annotation(Dialog(tab="Economizer", group="Commissioning"));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TOut(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Outside air temperature" annotation (Placement(
                      transformation(extent={{-240,220},{-200,260}}),
                      iconTransformation(extent={{-240,220},{-200,260}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput tNexOcc
                  "Time to next occupied period" annotation (Placement(
                      transformation(extent={{-240,180},{-200,220}}),
                      iconTransformation(extent={{-240,180},{-200,220}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZon(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Measured zone temperatures" annotation (Placement(
                      transformation(extent={{-240,140},{-200,180}}),
                      iconTransformation(extent={{-240,140},{-200,180}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uOcc
                  "Current occupancy period, true if it is in occupant period"
                  annotation (Placement(transformation(extent={{-240,100},{-200,
                          140}}), iconTransformation(extent={{-240,100},{-200,
                          140}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TCut(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Economizer high limit cutoff. Fixed dry bulb or differential dry bulb temeprature"
                  annotation (Placement(transformation(extent={{-240,60},{-200,
                          100}}), iconTransformation(extent={{-240,60},{-200,
                          100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSup(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Measured supply air temperature" annotation (Placement(
                      transformation(extent={{-240,20},{-200,60}}),
                      iconTransformation(extent={{-240,20},{-200,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TMix(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature") if use_TMix
                  "Measured mixed air temperature, used for freeze protection if use_TMix is true"
                  annotation (Placement(transformation(extent={{-240,-20},{-200,
                          20}}), iconTransformation(extent={{-240,-20},{-200,20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput nOcc(final
                    unit="1") if have_occSen "Number of occupants" annotation (
                    Placement(transformation(extent={{-240,-60},{-200,-20}}),
                      iconTransformation(extent={{-240,-60},{-200,-20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uWin
                  "Window status, true if open, false if closed" annotation (
                    Placement(transformation(extent={{-240,-100},{-200,-60}}),
                      iconTransformation(extent={{-240,-100},{-200,-60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput hOut(final
                    unit="J/kg", final quantity="SpecificEnergy") if
                  use_enthalpy "Outdoor air enthalpy" annotation (Placement(
                      transformation(extent={{-240,-140},{-200,-100}}),
                      iconTransformation(extent={{-240,-140},{-200,-100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput hCut(final
                    unit="J/kg", final quantity="SpecificEnergy") if
                  use_enthalpy
                  "Economizer enthalpy high limit cutoff. Fixed enthalpy or differential enthalpy"
                  annotation (Placement(transformation(extent={{-240,-180},{-200,
                          -140}}), iconTransformation(extent={{-240,-180},{-200,
                          -140}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TRet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature") if
                  use_fixed_plus_differential_drybulb
                  "Used only for fixed plus differential dry bulb temperature high limit cutoff"
                  annotation (Placement(transformation(extent={{-240,-220},{-200,
                          -180}}), iconTransformation(extent={{-240,-220},{-200,
                          -180}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uFreProSta if
                  use_G36FrePro
                  "Freeze protection status, used if use_G36FrePro=true"
                  annotation (Placement(transformation(extent={{-240,-260},{-200,
                          -220}}), iconTransformation(extent={{-240,-260},{-200,
                          -220}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TSupHeaEco(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Temperature setpoint for heating coil and for economizer"
                  annotation (Placement(transformation(extent={{200,230},{220,
                          250}}), iconTransformation(extent={{200,200},{240,240}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TSupCoo(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Cooling supply air temperature setpoint" annotation (
                    Placement(transformation(extent={{200,170},{220,190}}),
                      iconTransformation(extent={{200,150},{240,190}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yFan(
                  final min=0,
                  final max=1,
                  final unit="1") "Fan speed" annotation (Placement(
                      transformation(extent={{200,110},{220,130}}),
                      iconTransformation(extent={{200,100},{240,140}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TZonHeaSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Zone heating setpoint temperature" annotation (Placement(
                      transformation(extent={{200,50},{220,70}}),
                      iconTransformation(extent={{200,40},{240,80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TZonCooSet(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Zone cooling setpoint temperature" annotation (Placement(
                      transformation(extent={{200,-10},{220,10}}),
                      iconTransformation(extent={{200,-20},{240,20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yHeaCoi(
                  final min=0,
                  final max=1,
                  final unit="1") "Heating coil control signal" annotation (
                    Placement(transformation(extent={{200,-70},{220,-50}}),
                      iconTransformation(extent={{200,-80},{240,-40}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yCooCoi(
                  final min=0,
                  final max=1,
                  final unit="1") "Cooling coil control signal" annotation (
                    Placement(transformation(extent={{200,-130},{220,-110}}),
                      iconTransformation(extent={{200,-140},{240,-100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yOutDamPos(
                  final min=0,
                  final max=1,
                  final unit="1") "Outdoor air damper position" annotation (
                    Placement(transformation(extent={{200,-190},{220,-170}}),
                      iconTransformation(extent={{200,-190},{240,-150}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yRetDamPos(
                  final min=0,
                  final max=1,
                  final unit="1") "Return air damper position" annotation (
                    Placement(transformation(extent={{200,-250},{220,-230}}),
                      iconTransformation(extent={{200,-240},{240,-200}})));

                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply
                  setPoiVAV(
                  final TSupSetMax=TSupSetMax,
                  final TSupSetMin=TSupSetMin,
                  final yHeaMax=yHeaMax,
                  final yMin=yMin,
                  final yCooMax=yCooMax)
                  "Supply air set point and fan signal for single zone VAV system"
                  annotation (Placement(transformation(extent={{40,180},{60,200}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID cooPI(
                  final reverseAction=true,
                  final controllerType=controllerTypeCoo,
                  final k=kCoo,
                  final Ti=TiCoo,
                  final Td=TdCoo,
                  final reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter)
                  "Zone cooling control signal" annotation (Placement(
                      transformation(extent={{-50,150},{-30,170}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID heaPI(
                  final reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter,

                  final controllerType=controllerTypeHea,
                  final k=kHea,
                  final Ti=TiHea,
                  final Td=TdHea) "Zone heating control signal" annotation (
                    Placement(transformation(extent={{-50,210},{-30,230}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Average ave
                  "Average of zone heating and cooling setpoint" annotation (
                    Placement(transformation(extent={{-100,190},{-80,210}})));
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller
                  conEco(
                  final use_TMix=use_TMix,
                  final use_G36FrePro=use_G36FrePro,
                  final delTOutHis=delTOutHis,
                  final delEntHis=delEntHis,
                  final controllerTypeMod=controllerTypeMod,
                  final kMod=kMod,
                  final TiMod=TiMod,
                  final TdMod=TdMod,
                  final uMin=uMin,
                  final uMax=uMax,
                  final controllerTypeFre=controllerTypeFre,
                  final kFre=kFre,
                  final TiFre=TiFre,
                  final TdFre=TdFre,
                  final TFreSet=TFreSet,
                  final VOutMin_flow=VOutMin_flow,
                  final VOutDes_flow=VOutDes_flow,
                  final yDam_VOutMin_maxSpe=yDam_VOutMin_maxSpe,
                  final yDam_VOutDes_minSpe=yDam_VOutDes_minSpe,
                  final yDam_VOutDes_maxSpe=yDam_VOutDes_maxSpe,
                  final outDamPhyPosMax=outDamPhyPosMax,
                  final outDamPhyPosMin=outDamPhyPosMin,
                  final retDamPhyPosMax=retDamPhyPosMax,
                  final retDamPhyPosMin=retDamPhyPosMin,
                  final use_enthalpy=use_enthalpy,
                  final use_fixed_plus_differential_drybulb=
                      use_fixed_plus_differential_drybulb,
                  final yFanMin=0,
                  final yFanMax=1) "Economizer control sequence" annotation (
                    Placement(transformation(extent={{120,-50},{140,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.OutsideAirFlow
                  outAirSetPoi(
                  final AFlo=AFlo,
                  final have_occSen=have_occSen,
                  final VOutPerAre_flow=VOutPerAre_flow,
                  final VOutPerPer_flow=VOutPerPer_flow,
                  final occDen=occDen,
                  final zonDisEffHea=zonDisEffHea,
                  final zonDisEffCoo=zonDisEffCoo)
                  "Output the minimum outdoor airflow rate setpoint "
                  annotation (Placement(transformation(extent={{40,50},{60,70}})));
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.ZoneState
                  zonSta "Zone state" annotation (Placement(transformation(
                        extent={{40,130},{60,150}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  conInt(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.unoccupied)
                  "Unoccupied mode" annotation (Placement(transformation(extent
                        ={{-160,-240},{-140,-220}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu
                  "Check if current operation mode is unoccupied mode"
                  annotation (Placement(transformation(extent={{-110,-240},{-90,
                          -220}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not switch
                  "If in unoccupied mode, switch off" annotation (Placement(
                      transformation(extent={{-80,-240},{-60,-220}})));
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints
                  modSetPoi(
                  final TZonHeaOn=TZonHeaOn,
                  final TZonHeaOff=TZonHeaOff,
                  final TZonCooOn=TZonCooOn,
                  final TZonCooOff=TZonCooOff)
                  "Output zone setpoint with operation mode selection"
                  annotation (Placement(transformation(extent={{-180,180},{-160,
                          200}})));
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.CoolingCoil
                  cooCoi(final controllerTypeCooCoi=controllerTypeCooCoi,
                    kCooCoi=kCooCoi) "Controller for cooling coil valve"
                  annotation (Placement(transformation(extent={{120,-130},{140,
                          -110}})));

              equation
                connect(modSetPoi.tNexOcc, tNexOcc) annotation (Line(points={{-182,199},{-192,
                        199},{-192,200},{-220,200}},      color={0,0,127}));
                connect(ave.y, setPoiVAV.TZonSet) annotation (Line(points={{-78,200},{-10,200},
                        {-10,191.667},{38,191.667}}, color={0,0,127}));
                connect(TCut, conEco.TCut) annotation (Line(points={{-220,80},{-90,80},{-90,-32.2},
                        {119,-32.2}}, color={0,0,127}));
                connect(conEco.TSup, TSup) annotation (Line(points={{119,-38.6},{-4,-38.6},{-4,
                        40},{-220,40}}, color={0,0,127}));
                connect(setPoiVAV.TSupHeaEco, conEco.THeaSupSet) annotation (Line(points={{62,195},
                        {92,195},{92,-40.2},{119,-40.2}},   color={0,0,127}));
                connect(setPoiVAV.y, conEco.uSupFanSpe) annotation (Line(points={{62,185},{86,
                        185},{86,-43},{119,-43}}, color={0,0,127}));
                connect(TMix, conEco.TMix) annotation (Line(points={{-220,0},{0,0},{0,-44.4},{
                        119,-44.4}}, color={0,0,127}));
                connect(setPoiVAV.TSupHeaEco, TSupHeaEco) annotation (Line(points={{62,195},{
                        160,195},{160,240},{210,240}},  color={0,0,127}));
                connect(setPoiVAV.TSupCoo, TSupCoo) annotation (Line(points={{62,190},{140,190},
                        {140,180},{210,180}}, color={0,0,127}));
                connect(setPoiVAV.y, yFan) annotation (Line(points={{62,185},{120,185},{120,
                        120},{210,120}}, color={0,0,127}));
                connect(conEco.yRetDamPos, yRetDamPos) annotation (Line(points={{141,-40},{168,
                        -40},{168,-240},{210,-240}},   color={0,0,127}));
                connect(conEco.yOutDamPos, yOutDamPos) annotation (Line(points={{141,-44},{160,
                        -44},{160,-180},{210,-180}}, color={0,0,127}));
                connect(outAirSetPoi.TDis, TSup) annotation (Line(points={{38,57},{-4,57},{-4,
                        40},{-220,40}},      color={0,0,127}));
                connect(conEco.VOutMinSet_flow, outAirSetPoi.VOutMinSet_flow) annotation (
                    Line(points={{119,-41.6},{108,-41.6},{108,60},{62,60}},
                                                                     color={0,0,127}));
                connect(TOut, setPoiVAV.TOut) annotation (Line(points={{-220,240},{10,240},{
                        10,185},{38,185}}, color={0,0,127}));
                connect(conEco.TOut, setPoiVAV.TOut) annotation (Line(points={{119,-30.6},{10,
                        -30.6},{10,185},{38,185}},
                                                 color={0,0,127}));
                connect(zonSta.yZonSta, conEco.uZonSta) annotation (Line(points={{61,140},{80,
                        140},{80,-48.2},{119,-48.2}},
                                                  color={255,127,0}));
                connect(conInt.y, intEqu.u2) annotation (Line(points={{-138,-230},{-130,-230},
                        {-130,-238},{-112,-238}},color={255,127,0}));
                connect(intEqu.y, switch.u) annotation (Line(points={{-88,-230},{-82,-230}}, color={255,0,255}));
                connect(modSetPoi.TZonHeaSet, ave.u2) annotation (Line(points={{-158,190},{-130,
                        190},{-130,194},{-102,194}},     color={0,0,127}));
                connect(modSetPoi.TZonHeaSet, heaPI.u_s) annotation (Line(points={{-158,190},{
                        -130,190},{-130,220},{-52,220}},  color={0,0,127}));
                connect(modSetPoi.TZonCooSet, cooPI.u_s) annotation (Line(points={{-158,197},{
                        -114,197},{-114,160},{-52,160}},color={0,0,127}));
                connect(outAirSetPoi.uWin, uWin) annotation (Line(points={{38,64},{8,64},{8,-80},
                        {-220,-80}},      color={255,0,255}));
                connect(modSetPoi.uOcc, uOcc) annotation (Line(points={{-182,196.025},{-186,196.025},
                        {-186,120},{-220,120}},          color={255,0,255}));
                connect(TZon, modSetPoi.TZon) annotation (Line(points={{-220,160},{-192,160},{
                        -192,193},{-182,193}},  color={0,0,127}));
                connect(TZon, cooPI.u_m) annotation (Line(points={{-220,160},{-120,160},{-120,
                        140},{-40,140},{-40,148}}, color={0,0,127}));
                connect(nOcc, outAirSetPoi.nOcc) annotation (Line(points={{-220,-40},{4,-40},{
                        4,68},{38,68}},  color={0,0,127}));
                connect(uFreProSta, conEco.uFreProSta) annotation (Line(points={{-220,-240},{-180,
                        -240},{-180,-180},{40,-180},{40,-49.6},{119,-49.6}},
                                                 color={255,127,0}));
                connect(conEco.hOut, hOut) annotation (Line(points={{119,-35.4},{100,-35.4},{100,
                        -120},{-220,-120}},
                                      color={0,0,127}));
                connect(conEco.hCut, hCut) annotation (Line(points={{119,-37},{102,-37},{102,-160},
                        {-220,-160}}, color={0,0,127}));
                connect(conEco.TRet, TRet) annotation (Line(points={{119,-33.8},{102,-33.8},{102,
                        -200},{-220,-200}},
                                      color={0,0,127}));
                connect(conEco.yHeaCoi, yHeaCoi) annotation (Line(points={{141,-36},{174,-36},
                        {174,-60},{210,-60}}, color={0,0,127}));
                connect(modSetPoi.yOpeMod, conEco.uOpeMod) annotation (Line(points={{-158,183},
                        {-152,183},{-152,-47},{119,-47}}, color={255,127,0}));
                connect(modSetPoi.TZonHeaSet, TZonHeaSet) annotation (Line(points={{-158,190},
                        {-130,190},{-130,100},{160,100},{160,60},{210,60}}, color={0,0,127}));
                connect(cooCoi.yCooCoi, yCooCoi)
                  annotation (Line(points={{142,-120},{210,-120}}, color={0,0,127}));
                connect(switch.y, cooCoi.uSupFan) annotation (Line(points={{-58,-230},{110,-230},
                        {110,-128},{118,-128}}, color={255,0,255}));
                connect(zonSta.yZonSta, cooCoi.uZonSta) annotation (Line(points={{61,140},{74,
                        140},{74,-124},{118,-124}}, color={255,127,0}));
                connect(cooCoi.TSup, TSup) annotation (Line(points={{118,-116},{-4,-116},{-4,
                        40},{-220,40}},
                                    color={0,0,127}));
                connect(switch.y, outAirSetPoi.uSupFan) annotation (Line(points={{-58,-230},{-20,
                        -230},{-20,54},{38,54}}, color={255,0,255}));
                connect(switch.y, conEco.uSupFan) annotation (Line(points={{-58,-230},{60,-230},
                        {60,-45.6},{119,-45.6}},
                                             color={255,0,255}));
                connect(switch.y, setPoiVAV.uFan) annotation (Line(points={{-58,-230},{28,
                        -230},{28,181.667},{38,181.667}},
                                            color={255,0,255}));
                connect(heaPI.y, setPoiVAV.uHea) annotation (Line(points={{-28,220},{0,220},{
                        0,198.333},{38,198.333}},
                                             color={0,0,127}));
                connect(heaPI.y, zonSta.uHea) annotation (Line(points={{-28,220},{0,220},{0,144},
                        {38,144}},      color={0,0,127}));
                connect(cooPI.y, setPoiVAV.uCoo) annotation (Line(points={{-28,160},{-20,160},
                        {-20,195},{38,195}}, color={0,0,127}));
                connect(cooPI.y, zonSta.uCoo) annotation (Line(points={{-28,160},{-20,160},{-20,
                        136},{38,136}}, color={0,0,127}));
                connect(switch.y, heaPI.trigger) annotation (Line(points={{-58,-230},{-48,-230},
                        {-48,80},{-60,80},{-60,190},{-46,190},{-46,208}}, color={255,0,255}));
                connect(switch.y, cooPI.trigger) annotation (Line(points={{-58,-230},{-46,-230},
                        {-46,148}}, color={255,0,255}));
                connect(modSetPoi.TZonCooSet, TZonCooSet) annotation (Line(points={{-158,197},
                        {-114,197},{-114,108},{120,108},{120,0},{210,0}}, color={0,0,127}));
                connect(TZon, heaPI.u_m) annotation (Line(points={{-220,160},{-120,160},{-120,
                        180},{-40,180},{-40,208}}, color={0,0,127}));
                connect(intEqu.u1, modSetPoi.yOpeMod) annotation (Line(points={{-112,-230},{-120,
                        -230},{-120,-60},{-152,-60},{-152,183},{-158,183}},      color={255,
                        127,0}));
                connect(setPoiVAV.TSupCoo, cooCoi.TSupCoo) annotation (Line(points={{62,190},{
                        80,190},{80,-112},{118,-112}}, color={0,0,127}));
                connect(modSetPoi.TZonCooSet, ave.u1) annotation (Line(points={{-158,197},{-114,
                        197},{-114,206},{-102,206}}, color={0,0,127}));
                connect(TZon, setPoiVAV.TZon) annotation (Line(points={{-220,160},{-120,160},
                        {-120,180},{-40,180},{-40,188.333},{38,188.333}},color={0,0,127}));
                connect(TZon, outAirSetPoi.TZon) annotation (Line(points={{-220,160},{-120,160},
                        {-120,140},{-40,140},{-40,60},{38,60}}, color={0,0,127}));
                connect(modSetPoi.yOpeMod, outAirSetPoi.uOpeMod) annotation (Line(points={{-158,
                        183},{-152,183},{-152,51},{38,51}}, color={255,127,0}));

              annotation (defaultComponentName="conVAV",
                  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-200,-260},{200,
                          260}}),
                      graphics={Rectangle(
                      extent={{-200,-260},{200,260}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-148,312},{152,272}},
                        textString="%name",
                        lineColor={0,0,255}),
                      Text(
                        extent={{-192,262},{-138,224}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TOut"),
                      Text(
                        extent={{-194,218},{-140,180}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="tNexOcc"),
                      Text(
                        extent={{-192,180},{-138,142}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TZon"),
                      Text(
                        extent={{-192,140},{-138,102}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="uOcc"),
                      Text(
                        extent={{-192,102},{-138,64}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TCut"),
                      Text(
                        extent={{-192,62},{-138,24}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TSup"),
                      Text(
                        visible=use_TMix,
                        extent={{-192,20},{-138,-18}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TMix"),
                      Text(
                        visible=have_occSen,
                        extent={{-192,-56},{-138,-18}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="nOcc"),
                      Text(
                        extent={{-192,-58},{-138,-96}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="uWin"),
                      Text(
                        visible=use_enthalpy,
                        extent={{-192,-136},{-138,-174}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="hCut"),
                      Text(
                        visible=use_enthalpy,
                        extent={{-192,-98},{-138,-136}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="hOut"),
                      Text(
                        visible=use_fixed_plus_differential_drybulb,
                        extent={{-192,-180},{-138,-218}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TRet"),
                      Text(
                        visible=use_G36FrePro,
                        extent={{-192,-218},{-138,-256}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="uFreProSta"),
                      Text(
                        extent={{132,242},{186,204}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TSupHeaEco"),
                      Text(
                        extent={{136,190},{190,152}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TSupCoo"),
                      Text(
                        extent={{136,140},{190,102}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="yFan"),
                      Text(
                        extent={{136,82},{190,44}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TZonHeaSet"),
                      Text(
                        extent={{140,22},{194,-16}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="TZonCooSet"),
                      Text(
                        extent={{140,-40},{194,-78}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="yHeaCoi"),
                      Text(
                        extent={{140,-100},{194,-138}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="yCooCoi"),
                      Text(
                        extent={{138,-150},{192,-188}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="yOutDamPos"),
                      Text(
                        extent={{140,-200},{194,-238}},
                        lineColor={0,0,127},
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid,
                        textString="yRetDamPos")}),
                        Diagram(coordinateSystem(
                        preserveAspectRatio=false, extent={{-200,-260},{200,260}})),
              Documentation(info="<html>
<p>
Block for single zone VAV control. It outputs supply fan speed, supply air temperature
setpoints for heating, economizer and cooling, zone air heating and cooling setpoints,
outdoor and return air damper positions, and valve positions of heating and cooling coils.
</p>
<p>
It is implemented according to the ASHRAE Guideline 36, Part 5.18.
</p>
<p>
The sequences consist of the following subsequences.
</p>
<h4>Supply fan speed control</h4>
<p>
The fan speed control is implemented according to PART 5.18.4. It outputs
the control signal <code>yFan</code> to adjust the speed of the supply fan.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply</a>
for more detailed description.
</p>
<h4>Supply air temperature setpoints</h4>
<p>
The supply air temperature setpoints control sequences are implemented based on PART 5.18.4.
They are implemented in the same control block as the supply fan speed control. The supply air temperature setpoint
for heating and economizer is the same; while the supply air temperature setpoint for cooling has
a separate control loop. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply</a>
for more detailed description.
</p>
<h4>Economizer control</h4>
<p>
The Economizer control block outputs outdoor and return air damper position, i.e. <code>yOutDamPos</code> and
<code>yRetDamPos</code>, as well as control signal for heating coil <code>yHeaCoi</code>.
Optionally, there is also an override for freeze protection, which is not part of Guideline 36.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller</a>
for more detailed description.
</p>
<h4>Minimum outdoor airflow</h4>
<p>
Control sequences are implemented to compute the minimum outdoor airflow
setpoint, which is used as an input for the economizer control. More detailed
information can be found at
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.OutsideAirFlow\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.OutsideAirFlow</a>.
</p>
<h4>Zone air heating and cooling setpoints</h4>
<p>
Zone air heating and cooling setpoints as well as system operation modes are detailed at
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
March 10, 2020, by Jianjun Hu:<br/>
Replaced the block for calculating the operation mode and setpoint temperature with the one
from the terminal unit package. The new block does not have vector-valued calculations.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1709\">#1709</a>.
</li>
<li>
August 3, 2019, by David Blum &amp; Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"));
              end Controller;

              model CoolingCoil "Controller for cooling coil valve"

                parameter
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                  controllerTypeCooCoi=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                  "Type of controller"
                  annotation (Dialog(group="Cooling coil loop signal"));
                parameter Real kCooCoi(final unit="1/K")=0.1
                  "Gain for cooling coil control loop signal"
                  annotation(Dialog(group="Cooling coil loop signal"));
                parameter Real TiCooCoi(final unit="s")=900
                  "Time constant of integrator block for cooling coil control loop signal"
                  annotation(Dialog(group="Cooling coil loop signal",
                  enable=controllerTypeCooCoi == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                         or controllerTypeCooCoi == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                parameter Real TdCooCoi(final unit="s")=0.1
                  "Time constant of derivative block for cooling coil control loop signal"
                  annotation (Dialog(group="Cooling coil loop signal",
                    enable=controllerTypeCooCoi == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                         or controllerTypeCooCoi == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSupCoo(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Cooling supply air temperature setpoint" annotation (
                    Placement(transformation(extent={{-140,60},{-100,100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSup(
                  final unit="K",
                  final displayUnit="degC",
                  final quantity="ThermodynamicTemperature")
                  "Supply air temperature measurement" annotation (Placement(
                      transformation(extent={{-140,20},{-100,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uZonSta
                  "Zone state" annotation (Placement(transformation(extent={{-140,
                          -60},{-100,-20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uSupFan
                  "Supply fan status" annotation (Placement(transformation(
                        extent={{-140,-100},{-100,-60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yCooCoi
                  "Cooling coil control signal" annotation (Placement(
                      transformation(extent={{100,-10},{120,10}}),
                      iconTransformation(extent={{100,-20},{140,20}})));

              protected
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu
                  "Logical block to check if zone is in cooling state"
                  annotation (Placement(transformation(extent={{-40,-30},{-20,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  conInt(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.cooling)
                  "Cooling state value" annotation (Placement(transformation(
                        extent={{-80,-30},{-60,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID cooCoiPI(
                  reverseAction=true,
                  reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter,

                  controllerType=controllerTypeCooCoi,
                  k=kCooCoi,
                  Ti=TiCooCoi,
                  Td=TdCooCoi) "Cooling coil control signal" annotation (
                    Placement(transformation(extent={{-10,70},{10,90}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch switch
                  "Switch to assign cooling coil control signal" annotation (
                    Placement(transformation(extent={{72,-10},{92,10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  const(k=0) "Cooling off mode" annotation (Placement(
                      transformation(extent={{40,-30},{60,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2
                  "Conditions for cooling state" annotation (Placement(
                      transformation(extent={{0,-30},{20,-10}})));

              equation
                connect(const.y, switch.u3) annotation (Line(points={{62,-20},{66,-20},{66,-8},
                        {70,-8}}, color={0,0,127}));
                connect(cooCoiPI.trigger, uSupFan) annotation (Line(points={{-8,68},{-8,-80},
                        {-120,-80}},                     color={255,0,255}));
                connect(cooCoiPI.u_s, TSupCoo) annotation (Line(points={{-12,80},{-120,80}},
                                    color={0,0,127}));
                connect(cooCoiPI.u_m, TSup)
                  annotation (Line(points={{0,68},{0,40},{-120,40}},    color={0,0,127}));
                connect(switch.y, yCooCoi)
                  annotation (Line(points={{94,0},{110,0}}, color={0,0,127}));
                connect(intEqu.y, and2.u1) annotation (Line(points={{-18,-20},{-2,-20}},
                                  color={255,0,255}));
                connect(and2.u2, uSupFan) annotation (Line(points={{-2,-28},{-8,-28},{-8,-80},
                        {-120,-80}}, color={255,0,255}));
                connect(and2.y, switch.u2) annotation (Line(points={{22,-20},{30,-20},{30,0},
                        {70,0}},color={255,0,255}));
                connect(conInt.y, intEqu.u1)
                  annotation (Line(points={{-58,-20},{-42,-20}}, color={255,127,0}));
                connect(uZonSta, intEqu.u2) annotation (Line(points={{-120,-40},{-50,-40},{
                        -50,-28},{-42,-28}}, color={255,127,0}));
                connect(cooCoiPI.y, switch.u1)
                  annotation (Line(points={{12,80},{60,80},{60,8},{70,8}}, color={0,0,127}));
                annotation (defaultComponentName="cooCoi",
                      Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                      Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                      Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255})}),
                      Diagram(coordinateSystem(
                        preserveAspectRatio=false)),
              Documentation(info="<html>
<p>
This block outputs the cooling coil control signal if the fan is on and the zone status
is <code>uZonSta = Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.ZoneStates.cooling</code>.
Otherwise, the control signal for the coil is set to <code>0</code>.
</p>
</html>",              revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Moved interfaces instances to be right after parameter section.
</li>
<li>
August 1, 2019, by David Blum:<br/>
First implementation.
</li>
</ul>
</html>"));
              end CoolingCoil;

              block ZoneState "Select the zone state"
                parameter Real uLow(final unit = "1") = 0.01
                  "Hysteresis parameter uLow for heating and cooling control signals to avoid chattering";
                parameter Real uHigh(final unit = "1") = 0.05
                  "Hysteresis parameter uHigh for heating and cooling control signals to avoid chattering";

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uHea
                  "Heating control signal" annotation (Placement(transformation(
                        extent={{-180,20},{-140,60}}), iconTransformation(
                        extent={{-140,20},{-100,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uCoo
                  "Cooling control signal" annotation (Placement(transformation(
                        extent={{-180,-60},{-140,-20}}), iconTransformation(
                        extent={{-140,-60},{-100,-20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput
                  yZonSta "Zone state" annotation (Placement(transformation(
                        extent={{140,-20},{180,20}}), iconTransformation(extent
                        ={{100,-10},{120,10}})));

              protected
                hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                  booToIntHea(final integerFalse=0, final integerTrue=
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.heating)
                  "Convert Boolean to Integer number" annotation (Placement(
                      transformation(extent={{0,30},{20,50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                  booToIntCoo(final integerFalse=0, final integerTrue=
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.cooling)
                  "Convert Boolean to Integer number" annotation (Placement(
                      transformation(extent={{28,-30},{48,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Nor isDea
                  "In deadband state" annotation (Placement(transformation(
                        extent={{30,-80},{50,-60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                  booToIntDea(final integerFalse=0, final integerTrue=
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.deadband)
                  "Convert Boolean to Integer number" annotation (Placement(
                      transformation(extent={{70,-80},{90,-60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And isHea
                  "In heating state if both conditions are true" annotation (
                    Placement(transformation(extent={{-72,30},{-52,50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hysUHea(final
                    uLow=uLow, final uHigh=uHigh)
                  "Check if it is in heating state" annotation (Placement(
                      transformation(extent={{-120,60},{-100,80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hysUCoo(final
                    uLow=uLow, final uHigh=uHigh)
                  "Check if it is in cooling state" annotation (Placement(
                      transformation(extent={{-100,-50},{-80,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add uHeaMinUCoo(final k2=
                      -1) "Difference between uHea and uCoo" annotation (
                    Placement(transformation(extent={{-130,0},{-110,20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And isCoo
                  "In cooling state if both inputs are true" annotation (
                    Placement(transformation(extent={{-10,-30},{10,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hysU(final
                    uLow=-uLow, final uHigh=uLow)
                  "Check if heating control signal is bigger than cooling control signal"
                  annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not notHea
                  "Not in heating state" annotation (Placement(transformation(
                        extent={{-44,0},{-24,20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Add addInt
                  "Add two integer inputs" annotation (Placement(transformation(
                        extent={{70,20},{90,40}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Add addInt1
                  "Add two integer inputs" annotation (Placement(transformation(
                        extent={{110,-10},{130,10}})));

              equation
                connect(isDea.y, booToIntDea.u)
                  annotation (Line(points={{52,-70},{68,-70}}, color={255,0,255}));
                connect(hysUHea.y, isHea.u1) annotation (Line(points={{-98,70},{-76,70},{-76,
                        40},{-74,40}}, color={255,0,255}));
                connect(uHea, hysUHea.u) annotation (Line(points={{-160,40},{-136,40},{-136,
                        70},{-122,70}}, color={0,0,127}));
                connect(uCoo,hysUCoo. u)
                  annotation (Line(points={{-160,-40},{-102,-40}},color={0,0,127}));
                connect(uCoo, uHeaMinUCoo.u2) annotation (Line(points={{-160,-40},{-136,-40},
                        {-136,4},{-132,4}}, color={0,0,127}));
                connect(uHea, uHeaMinUCoo.u1) annotation (Line(points={{-160,40},{-136,40},{-136,
                        16},{-132,16}}, color={0,0,127}));
                connect(isCoo.y, booToIntCoo.u)
                  annotation (Line(points={{12,-20},{26,-20}}, color={255,0,255}));
                connect(hysUCoo.y, isCoo.u2) annotation (Line(points={{-78,-40},{-20,-40},{-20,
                        -28},{-12,-28}}, color={255,0,255}));
                connect(uHeaMinUCoo.y, hysU.u)
                  annotation (Line(points={{-108,10},{-102,10}}, color={0,0,127}));
                connect(isHea.y, booToIntHea.u)
                  annotation (Line(points={{-50,40},{-2,40}}, color={255,0,255}));
                connect(isHea.y, notHea.u) annotation (Line(points={{-50,40},{-48,40},{-48,10},
                        {-46,10}}, color={255,0,255}));
                connect(hysU.y, isHea.u2) annotation (Line(points={{-78,10},{-76,10},{-76,32},
                        {-74,32}}, color={255,0,255}));
                connect(notHea.y, isCoo.u1) annotation (Line(points={{-22,10},{-20,10},{-20,-20},
                        {-12,-20}}, color={255,0,255}));
                connect(isCoo.y, isDea.u2) annotation (Line(points={{12,-20},{20,-20},{20,-78},
                        {28,-78}}, color={255,0,255}));
                connect(isHea.y, isDea.u1) annotation (Line(points={{-50,40},{-48,40},{-48,-70},
                        {28,-70}},                 color={255,0,255}));
                connect(booToIntHea.y, addInt.u1) annotation (Line(points={{22,40},{60,40},{60,
                        36},{68,36}}, color={255,127,0}));
                connect(booToIntCoo.y, addInt.u2) annotation (Line(points={{50,-20},{60,-20},{
                        60,24},{68,24}}, color={255,127,0}));
                connect(addInt.y, addInt1.u1) annotation (Line(points={{92,30},{100,30},{100,6},
                        {108,6}}, color={255,127,0}));
                connect(booToIntDea.y, addInt1.u2) annotation (Line(points={{92,-70},{100,-70},
                        {100,-6},{108,-6}}, color={255,127,0}));
                connect(addInt1.y, yZonSta)
                  annotation (Line(points={{132,0},{160,0}}, color={255,127,0}));
                annotation (
                      defaultComponentName="zonSta",
                      Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                      Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-150,150},{150,110}},
                      textString="%name",
                      lineColor={0,0,255})}), Diagram(coordinateSystem(
                        preserveAspectRatio=false, extent={{-140,-100},{140,100}})),
                 Documentation(info="<html>
<p>
Block that outputs the zone state. It first checks if the zone is in heating state;
if not, it checks if the zone is in cooling state; otherwise it is in deadband state.
</p>
<p>
These states are defined in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.ZoneStates\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.ZoneStates</a>.
</p>
<p>
The logic of the block is as follows.
</p>
<ol>
<li>
The zone state is heating when both of the following two conditions are satisfied:
(i) The heating control signal satisfies <code>uHea &gt; uHigh</code>, where
<code>uHigh</code> is a parameter,
and (ii) the following condition is satisfied <code>uHea - uCoo > uLow</code>,
where <code>uCoo</code> is the cooling control signal and <code>uLow</code> is a parameter.
The second condition is
used to avoid errors when <code>uHea > 0</code> and <code>uCoo > 0</code> at the same time.
</li>
<li>
The zone state is cooling when the zone state is not heating and the cooling control signal satisfies
<code>uCoo > uHigh</code>, where <code>uHigh</code> is a parameter.
If <code>uCoo &lt; uLow</code>, then the zone state is not cooling.
</li>
<li>
The zone state is deadband when it is neither in heating state nor in cooling state.
</li>
</ol>
</html>",              revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Replaced <code>multiSum</code> block with two addition blocks to avoid vector related implementation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1709\">#1709</a>.
</li>
<li>
September 11, 2019, by Kun Zhang:<br/>
Improved the implementation to avoid issues when heating and cooling controls occur at the same time.
</li>
<li>
October 24, 2018, by David Blum:<br/>
First implementation.
</li>
</ul>
</html>"));
              end ZoneState;

              package Economizers "Economizer control of single zone VAV AHU"

                block Controller "Single zone VAV AHU economizer control sequence"

                  parameter Boolean use_enthalpy = false
                    "Set to true if enthalpy measurement is used in addition to temperature measurement"
                    annotation(Dialog(enable=not use_fixed_plus_differential_drybulb));
                  parameter Boolean use_fixed_plus_differential_drybulb = false
                    "Set to true to only evaluate fixed plus differential dry bulb temperature high limit cutoff;
    shall not be used with enthalpy"
                    annotation(Dialog(enable=not use_enthalpy));
                  parameter Boolean use_TMix=true
                    "Set to true if mixed air temperature measurement is enabled";
                  parameter Boolean use_G36FrePro=false
                    "Set to true if G36 freeze protection is implemented";

                  parameter Real delTOutHis(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference")=1
                    "Delta between the temperature hysteresis high and low limit"
                    annotation(Dialog(tab="Advanced", group="Hysteresis"));

                  parameter Real delEntHis(
                    final unit="J/kg",
                    final quantity="SpecificEnergy")=1000
                    "Delta between the enthalpy hysteresis high and low limits"
                    annotation(Dialog(tab="Advanced", group="Hysteresis", enable = use_enthalpy));

                  parameter
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                    controllerTypeMod=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                    "Type of controller" annotation (Dialog(group="Modulation"));

                  parameter Real kMod(final unit="1/K")=1 "Gain of modulation controller"
                    annotation(Dialog(group="Modulation"));

                  parameter Real TiMod(
                    final unit="s",
                    final quantity="Time")=300
                    "Time constant of modulation controller integrator block"
                    annotation (Dialog(group="Modulation",
                      enable=controllerTypeMod == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                           or controllerTypeMod == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                  parameter Real TdMod(
                    final unit="s",
                    final quantity="Time")=0.1
                    "Time constant of derivative block for modulation controller"
                    annotation (Dialog(group="Modulation",
                      enable=controllerTypeMod == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                           or controllerTypeMod == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                  parameter Real uMin(
                    final min=0.1,
                    final max=0.9,
                    final unit="1") = 0.1
                    "Lower limit of controller output at which the dampers are at their limits";
                  parameter Real uMax(
                    final min=0.1,
                    final max=1,
                    final unit="1") = 0.9
                    "Upper limit of controller output at which the dampers are at their limits";

                  parameter
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                    controllerTypeFre=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                    "Type of controller" annotation (Dialog(group=
                          "Freeze protection", enable=use_TMix));

                  parameter Real kFre(final unit="1/K") = 0.1
                    "Gain for mixed air temperature tracking for freeze protection, used if use_TMix=true"
                     annotation(Dialog(group="Freeze protection", enable=use_TMix));

                  parameter Real TiFre(
                    final unit="s",
                    final quantity="Time")=120
                    "Time constant of controller for mixed air temperature tracking for freeze protection. Require TiFre < TiMinOut"
                     annotation(Dialog(group="Freeze protection",
                       enable=use_TMix and (controllerTypeFre ==
                          hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                           or controllerTypeFre == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID)));

                  parameter Real TdFre(
                    final unit="s",
                    final quantity="Time")=0.1
                     "Time constant of derivative block for freeze protection"
                     annotation (Dialog(group="Freeze protection",
                       enable=use_TMix and (controllerTypeFre ==
                          hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                           or controllerTypeFre == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID)));

                  parameter Real TFreSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") = 277.15
                    "Lower limit for mixed air temperature for freeze protection, used if use_TMix=true"
                     annotation(Dialog(group="Freeze protection", enable=use_TMix));

                  parameter Real yFanMin(
                    final min=0,
                    final max=1,
                    final unit="1") = 0.1 "Minimum supply fan operation speed"
                    annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                  parameter Real yFanMax(
                    final min=0,
                    final max=1,
                    final unit="1") = 0.9 "Maximum supply fan operation speed"
                    annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                  parameter Real VOutMin_flow(
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")=1.0
                    "Calculated minimum outdoor airflow rate"
                    annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                  parameter Real VOutDes_flow(
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")=2.0
                    "Calculated design outdoor airflow rate"
                    annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                  parameter Real yDam_VOutMin_minSpe(
                    final min=outDamPhyPosMin,
                    final max=outDamPhyPosMax,
                    final unit="1") = 0.4
                    "Outdoor air damper position to supply minimum outdoor airflow at minimum fan speed"
                    annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                  parameter Real yDam_VOutMin_maxSpe(
                    final min=outDamPhyPosMin,
                    final max=outDamPhyPosMax,
                    final unit="1") = 0.3
                    "Outdoor air damper position to supply minimum outdoor airflow at maximum fan speed"
                    annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                  parameter Real yDam_VOutDes_minSpe(
                    final min=yDam_VOutMin_minSpe,
                    final max=outDamPhyPosMax,
                    final unit="1") = 0.9
                    "Outdoor air damper position to supply design outdoor airflow at minimum fan speed"
                    annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                  parameter Real yDam_VOutDes_maxSpe(
                    final min=yDam_VOutMin_maxSpe,
                    final max=outDamPhyPosMax,
                    final unit="1") = 0.8
                    "Outdoor air damper position to supply design outdoor airflow at maximum fan speed"
                    annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                  parameter Real outDamPhyPosMax(
                    final min=0,
                    final max=1,
                    final unit="1") = 1
                    "Physically fixed maximum position of the outdoor air damper"
                    annotation(Dialog(tab="Commissioning", group="Physical damper position limits"));
                  parameter Real outDamPhyPosMin(
                    final min=0,
                    final max=1,
                    final unit="1") = 0
                    "Physically fixed minimum position of the outdoor air damper"
                    annotation(Dialog(tab="Commissioning", group="Physical damper position limits"));
                  parameter Real retDamPhyPosMax(
                    final min=0,
                    final max=1,
                    final unit="1") = 1
                    "Physically fixed maximum position of the return air damper"
                    annotation(Dialog(tab="Commissioning", group="Physical damper position limits"));
                  parameter Real retDamPhyPosMin(
                    final min=0,
                    final max=1,
                    final unit="1") = 0
                    "Physically fixed minimum position of the return air damper"
                    annotation(Dialog(tab="Commissioning", group="Physical damper position limits"));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput THeaSupSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Supply air temperature heating setpoint" annotation (
                      Placement(transformation(extent={{-160,10},{-140,30}}),
                        iconTransformation(extent={{-120,-12},{-100,8}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSup(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Measured supply air temperature" annotation (Placement(
                        transformation(extent={{-160,30},{-140,50}}),
                        iconTransformation(extent={{-120,4},{-100,24}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TOut(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Outdoor air temperature" annotation (Placement(
                        transformation(extent={{-160,130},{-140,150}}),
                        iconTransformation(extent={{-120,84},{-100,104}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TCut(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Outdoor air temperature high limit cutoff. For differential dry bulb temeprature condition use return air temperature measurement"
                    annotation (Placement(transformation(extent={{-160,110},{-140,
                            130}}), iconTransformation(extent={{-120,68},{-100,
                            88}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TRet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") if
                    use_fixed_plus_differential_drybulb
                    "Used only for fixed plus differential dry bulb temperature high limit cutoff"
                    annotation (Placement(transformation(extent={{-160,90},{-140,
                            110}}), iconTransformation(extent={{-120,52},{-100,
                            72}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput hOut(final
                      unit="J/kg", final quantity="SpecificEnergy") if
                    use_enthalpy "Outdoor air enthalpy" annotation (Placement(
                        transformation(extent={{-160,70},{-140,90}}),
                        iconTransformation(extent={{-120,36},{-100,56}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput hCut(final
                      unit="J/kg", final quantity="SpecificEnergy") if
                    use_enthalpy
                    "Outdoor air enthalpy high limit cutoff. For differential enthalpy use return air enthalpy measurement"
                    annotation (Placement(transformation(extent={{-160,50},{-140,
                            70}}), iconTransformation(extent={{-120,20},{-100,
                            40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TMix(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature") if use_TMix
                    "Measured mixed air temperature, used for freeze protection"
                    annotation (Placement(transformation(extent={{-160,-50},{-140,
                            -30}}), iconTransformation(extent={{-120,-54},{-100,
                            -34}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VOutMinSet_flow(
                    final min=VOutMin_flow,
                    final max=VOutDes_flow,
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")
                    "Minimum outdoor airflow setpoint" annotation (Placement(
                        transformation(extent={{-160,-10},{-140,10}}),
                        iconTransformation(extent={{-120,-26},{-100,-6}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uSupFanSpe(
                    final min=yFanMin,
                    final max=yFanMax,
                    final unit="1") "Supply fan speed" annotation (Placement(
                        transformation(extent={{-160,-30},{-140,-10}}),
                        iconTransformation(extent={{-120,-40},{-100,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uZonSta "Zone state signal" annotation (Placement(
                        transformation(extent={{-162,-110},{-140,-88}}),
                        iconTransformation(extent={{-120,-92},{-100,-72}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uFreProSta if use_G36FrePro "Freeze protection status"
                    annotation (Placement(transformation(extent={{-162,-130},{-140,
                            -108}}), iconTransformation(extent={{-120,-106},{-100,
                            -86}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uOpeMod "AHU operation mode status signal" annotation (
                      Placement(transformation(extent={{-162,-90},{-140,-68}}),
                        iconTransformation(extent={{-120,-80},{-100,-60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                    uSupFan "Supply fan status" annotation (Placement(
                        transformation(extent={{-160,-70},{-140,-50}}),
                        iconTransformation(extent={{-120,-66},{-100,-46}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yRetDamPos(
                    final min=0,
                    final max=1,
                    final unit="1") "Return air damper position" annotation (
                      Placement(transformation(extent={{140,30},{160,50}}),
                        iconTransformation(extent={{100,-10},{120,10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yOutDamPos(
                    final min=0,
                    final max=1,
                    final unit="1") "Outdoor air damper position" annotation (
                      Placement(transformation(extent={{140,-50},{160,-30}}),
                        iconTransformation(extent={{100,-50},{120,-30}})));

                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable
                    enaDis(
                    final retDamPhyPosMax=retDamPhyPosMax,
                    final use_enthalpy=use_enthalpy,
                    final use_fixed_plus_differential_drybulb=
                        use_fixed_plus_differential_drybulb,
                    final delTOutHis=delTOutHis,
                    final delEntHis=delEntHis,
                    final retDamPhyPosMin=retDamPhyPosMin)
                    "Single zone VAV AHU economizer enable/disable sequence"
                    annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits
                    damLim(
                    final yFanMin=yFanMin,
                    final yFanMax=yFanMax,
                    final outDamPhyPosMax=outDamPhyPosMax,
                    final outDamPhyPosMin=outDamPhyPosMin,
                    final VOutMin_flow=VOutMin_flow,
                    final VOutDes_flow=VOutDes_flow,
                    final yDam_VOutMin_minSpe=yDam_VOutMin_minSpe,
                    final yDam_VOutMin_maxSpe=yDam_VOutMin_maxSpe,
                    final yDam_VOutDes_minSpe=yDam_VOutDes_minSpe,
                    final yDam_VOutDes_maxSpe=yDam_VOutDes_maxSpe)
                    "Single zone VAV AHU economizer minimum outdoor air requirement damper limit sequence"
                    annotation (Placement(transformation(extent={{-100,0},{-80,
                            20}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Modulation
                    mod(
                    final controllerType=controllerTypeMod,
                    final k=kMod,
                    final Ti=TiMod,
                    final Td=TdMod,
                    final uMin=uMin,
                    final uMax=uMax)
                    "Single zone VAV AHU economizer damper modulation sequence"
                    annotation (Placement(transformation(extent={{20,0},{40,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.FreezeProtectionMixedAir
                    freProTMix(
                    final controllerType=controllerTypeFre,
                    final k=kFre,
                    final Ti=TiFre,
                    final Td=TdFre,
                    final TFreSet=TFreSet) if use_TMix
                    "Block that tracks TMix against a freeze protection setpoint"
                    annotation (Placement(transformation(extent={{60,-20},{80,0}})));

                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Max retDamMinFre
                    "Minimum position for return air damper due to freeze protection"
                    annotation (Placement(transformation(extent={{100,40},{120,
                            60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min outDamMaxFre
                    "Maximum control signal for outdoor air damper due to freeze protection"
                    annotation (Placement(transformation(extent={{100,-60},{120,
                            -40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    noTMix1(k=1) if not use_TMix
                    "Ignore min evaluation if there is no TMix sensor"
                    annotation (Placement(transformation(extent={{60,-66},{80,-46}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    noTMix(k=0) if not use_TMix
                    "Ignore max evaluation if there is no TMix sensor"
                    annotation (Placement(transformation(extent={{60,46},{80,66}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                    if not use_G36FrePro
                    "Freeze protection status is 0. Used if G36 freeze protection is not implemented"
                    annotation (Placement(transformation(extent={{-140,-150},{-120,
                            -130}})));

                public
                  CDL.Interfaces.RealOutput yHeaCoi "Heating coil control signal"
                    annotation (Placement(transformation(extent={{140,92},{160,112}}),
                        iconTransformation(extent={{100,30},{120,50}})));
                equation
                  connect(uSupFan, enaDis.uSupFan)
                    annotation (Line(points={{-150,-60},{-100,-60},{-100,-34},{-21,-34}},
                                                                                       color={255,0,255}));
                  connect(uFreProSta, enaDis.uFreProSta)
                    annotation (Line(points={{-151,-119},{-60,-119},{-60,-30},{-21,-30}},color={255,127,0}));
                  connect(TRet, enaDis.TRet)
                                            annotation (Line(points={{-150,100},{-28,100},{-28,
                          -24},{-21,-24}},
                                     color={0,0,127}));
                  connect(hCut, enaDis.hCut) annotation (Line(points={{-150,60},{-40,60},{-40,
                          -28},{-21,-28}},
                                     color={0,0,127}));
                  connect(hOut, enaDis.hOut)
                    annotation (Line(points={{-150,80},{-36,80},{-36,-26},{-21,-26}},  color={0,0,127}));
                  connect(TCut, enaDis.TCut) annotation (Line(points={{-150,120},{-26,120},{-26,
                          -22.2},{-21,-22.2}},
                                          color={0,0,127}));
                  connect(TOut, enaDis.TOut)
                    annotation (Line(points={{-150,140},{-24,140},{-24,-20.6},{-21,-20.6}},
                                                                                       color={0,0,127}));
                  connect(uSupFan, damLim.uSupFan)
                    annotation (Line(points={{-150,-60},{-124,-60},{-124,10},{-102,10}},
                                                                                      color={255,0,255}));
                  connect(uOpeMod, damLim.uOpeMod)
                    annotation (Line(points={{-151,-79},{-122,-79},{-122,1.8},{-102,1.8}},
                      color={255,127,0}));
                  connect(uFreProSta, damLim.uFreProSta)
                    annotation (Line(points={{-151,-119},{-110,-119},{-110,6},{-102,6}},
                      color={255,127,0}));
                  connect(damLim.yOutDamPosMax, enaDis.uOutDamPosMax)
                    annotation (Line(points={{-78,16},{-30,16},{-30,-36},{-21,-36}},
                                                                                  color={0,0,127}));
                  connect(enaDis.yOutDamPosMax, mod.uOutDamPosMax)
                    annotation (Line(points={{2,-24},{10,-24},{10,6},{18,6}}, color={0,0,127}));
                  connect(enaDis.yRetDamPosMax, mod.uRetDamPosMax)
                    annotation (Line(points={{2,-30},{12,-30},{12,12},{18,12}},  color={0,0,127}));
                  connect(damLim.yOutDamPosMin, mod.uOutDamPosMin)
                    annotation (Line(points={{-78,4},{18,4}}, color={0,0,127}));
                  connect(enaDis.yRetDamPosMin, mod.uRetDamPosMin)
                    annotation (Line(points={{2,-36},{14,-36},{14,10},{18,10}},  color={0,0,127}));
                  connect(uZonSta, enaDis.uZonSta)
                    annotation (Line(points={{-151,-99},{-58,-99},{-58,-32},{-21,-32}},  color={255,127,0}));
                  connect(uSupFanSpe, damLim.uSupFanSpe)
                    annotation (Line(points={{-150,-20},{-126,-20},{-126,14},{-102,14}},color={0,0,127}));
                  connect(VOutMinSet_flow, damLim.VOutMinSet_flow)
                    annotation (Line(points={{-150,0},{-130,0},{-130,18},{-102,18}},  color={0,0,127}));
                  connect(outDamMaxFre.u2, noTMix1.y)
                    annotation (Line(points={{98,-56},{82,-56}}, color={0,0,127}));
                  connect(retDamMinFre.u1, noTMix.y)
                    annotation (Line(points={{98,56},{82,56}}, color={0,0,127}));
                  connect(retDamMinFre.y, yRetDamPos)
                    annotation (Line(points={{122,50},{126,50},{126,40},{150,40}}, color={0,0,127}));
                  connect(outDamMaxFre.y, yOutDamPos)
                    annotation (Line(points={{122,-50},{126,-50},{126,-40},{150,-40}}, color={0,0,127}));
                  connect(mod.yRetDamPos, retDamMinFre.u2)
                    annotation (Line(points={{41,10},{92,10},{92,44},{98,44}},    color={0,0,127}));
                  connect(mod.yOutDamPos, outDamMaxFre.u1)
                    annotation (Line(points={{41,6},{94,6},{94,-44},{98,-44}},   color={0,0,127}));
                  connect(freProTMix.yFrePro, retDamMinFre.u1)
                    annotation (Line(points={{82,-13},{86,-13},{86,56},{98,56}}, color={0,0,127}));
                  connect(freProTMix.yFreProInv, outDamMaxFre.u2)
                    annotation (Line(points={{82,-7},{88,-7},{88,-56},{98,-56}}, color={0,0,127}));
                  connect(freProSta.y, enaDis.uFreProSta)
                    annotation (Line(points={{-118,-140},{-40,-140},{-40,-30},{-21,-30}},
                                                                                        color={255,127,0}));
                  connect(freProSta.y, damLim.uFreProSta)
                    annotation (Line(points={{-118,-140},{-114,-140},{-114,6},{-102,6}},
                      color={255,127,0}));
                  connect(uSupFan, mod.uSupFan)
                    annotation (Line(points={{-150,-60},{-100,-60},{-100,-10},{18,-10},{18,1}},
                      color={255,0,255}));

                  connect(mod.yHeaCoi, yHeaCoi) annotation (Line(points={{41,14},{46,14},{46,
                          102},{150,102}},
                                      color={0,0,127}));
                  connect(damLim.yOutDamPosMin, enaDis.uOutDamPosMin) annotation (Line(points={
                          {-78,4},{-34,4},{-34,-38},{-21,-38}}, color={0,0,127}));
                  connect(TMix, freProTMix.TMix) annotation (Line(points={{-150,-40},{-80,-40},
                          {-80,-60},{40,-60},{40,-10},{58,-10}}, color={0,0,127}));
                  connect(TSup, mod.TSup) annotation (Line(points={{-150,40},{0,40},{0,18},{18,
                          18}}, color={0,0,127}));
                  connect(THeaSupSet, mod.THeaSupSet) annotation (Line(points={{-150,20},{-130,
                          20},{-130,34},{-4,34},{-4,16},{18,16}}, color={0,0,127}));
                annotation (defaultComponentName = "conEco",
                        Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                             graphics={Rectangle(
                        extent={{-100,-100},{100,100}},
                        lineColor={0,0,127},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                        Line(points={{-66,-36},{-42,-36},{-4,40},{34,40}}, color={0,0,127},
                          thickness=0.5),
                        Line(
                          points={{-64,40},{-38,40},{2,-40},{66,-40}},
                          color={0,0,127},
                          pattern=LinePattern.Dash,
                          thickness=0.5),
                        Line(
                          points={{34,40},{34,-36},{34,-36},{66,-36}},
                          color={0,0,127},
                          thickness=0.5),
                        Text(
                          extent={{-170,142},{158,104}},
                          lineColor={0,0,127},
                          textString="%name")}),
                        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,-160},
                            {140,160}}),
                        graphics={Rectangle(
                          extent={{50,100},{130,-100}},
                          lineColor={0,0,127},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid),
                                                  Text(
                          extent={{56,-86},{134,-96}},
                          lineColor={95,95,95},
                          textString="Freeze protection based on TMix,
not a part of G36",       horizontalAlignment=TextAlignment.Left)}),
                Documentation(info="<html>
<p>
Single zone VAV AHU economizer control sequence that calculates
outdoor and return air damper positions based on ASHRAE
Guidline 36, PART 5 sections: P.4.d, P.5, P.9, P.3.b, A.17.
</p>
<p>
The sequence consists of three subsequences.
<ul>
<li>
First, the block <code>damLim</code> computes the damper position limits to satisfy
outdoor air requirements. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits</a>
for a description.
</li>
<li>
Second, the block <code>enaDis</code> enables or disables the economizer based on
outdoor temperature and optionally enthalpy, and based on the supply fan status,
freeze protection stage and zone state.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable</a>
for a description.
</li>
<li>
Third, the block <code>mod</code> modulates the outdoor and return damper position
to track the supply air temperature setpoint for heating, subject to the limits of the damper positions
that were computed in the above two blocks.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Modulation\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Modulation</a>
for a description.
</li>
</ul>
</html>",                 revisions="<html>
<ul>
<li>
July 30, 2019, by Kun Zhang:<br/>
Added fixed plus differential dry bulb temperature high limit cut off.
</li>
<li>
October 31, 2018, by David Blum:<br/>
Added heating coil output.
</li>
<li>
June 28, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                end Controller;

                package Subsequences "Subsequences for economizer control"

                  block Enable
                    "Single zone VAV AHU economizer enable/disable switch"

                    parameter Boolean use_enthalpy = true
                      "Set to true to evaluate outdoor air (OA) enthalpy in addition to temperature"
                      annotation(Dialog(group="Conditional", enable=not use_fixed_plus_differential_drybulb));
                    parameter Boolean use_fixed_plus_differential_drybulb = false
                      "Set to true to evaluate fixed plus differential dry bulb temperature high limit cutoff;
    shall not be used with enthalpy"
                      annotation(Dialog(group="Conditional", enable=not use_enthalpy));
                    parameter Real delTOutHis(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="TemperatureDifference")=1
                      "Delta between the temperature hysteresis high and low limit"
                      annotation(Dialog(tab="Advanced", group="Hysteresis"));
                    parameter Real delEntHis(
                      final unit="J/kg",
                      final quantity="SpecificEnergy")=1000
                      "Delta between the enthalpy hysteresis high and low limits"
                      annotation(Dialog(tab="Advanced", group="Hysteresis", enable = use_enthalpy));
                    parameter Real retDamPhyPosMax(
                      final min=0,
                      final max=1,
                      final unit="1") = 1
                      "Physically fixed maximum position of the return air damper"
                      annotation(Dialog(tab="Commissioning", group="Physical damper position limits"));
                    parameter Real retDamPhyPosMin(
                      final min=0,
                      final max=1,
                      final unit="1") = 0
                      "Physically fixed minimum position of the return air damper"
                      annotation(Dialog(tab="Commissioning", group="Physical damper position limits"));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      TOut(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Outdoor air temperature" annotation (Placement(
                          transformation(extent={{-220,250},{-180,290}}),
                          iconTransformation(extent={{-120,84},{-100,104}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      hOut(final unit="J/kg", final quantity="SpecificEnergy")
                      if use_enthalpy "Outdoor air enthalpy" annotation (
                        Placement(transformation(extent={{-220,160},{-180,200}}),
                          iconTransformation(extent={{-120,30},{-100,50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      TCut(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "OA temperature high limit cutoff. For differential dry bulb temeprature condition use return air temperature measurement"
                      annotation (Placement(transformation(extent={{-220,220},{
                              -180,260}}), iconTransformation(extent={{-120,68},
                              {-100,88}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      TRet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature") if
                      use_fixed_plus_differential_drybulb
                      "Used only for fixed plus differential dry bulb temperature high limit cutoff"
                      annotation (Placement(transformation(extent={{-220,190},{
                              -180,230}}), iconTransformation(extent={{-120,50},
                              {-100,70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      hCut(final unit="J/kg", final quantity="SpecificEnergy")
                      if use_enthalpy
                      "OA enthalpy high limit cutoff. For differential enthalpy use return air enthalpy measurement"
                      annotation (Placement(transformation(extent={{-220,130},{
                              -180,170}}), iconTransformation(extent={{-120,10},
                              {-100,30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uOutDamPosMin(
                      final unit="1",
                      final min=0,
                      final max=1)
                      "Minimum outdoor air damper position, get from damper position limits sequence"
                      annotation (Placement(transformation(extent={{-220,-180},
                              {-180,-140}}), iconTransformation(extent={{-120,-90},
                              {-100,-70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uOutDamPosMax(
                      final unit="1",
                      final min=0,
                      final max=1)
                      "Maximum outdoor air damper position, get from damper position limits sequence"
                      annotation (Placement(transformation(extent={{-220,-150},
                              {-180,-110}}), iconTransformation(extent={{-120,-70},
                              {-100,-50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                      uSupFan "Supply fan on/off status signal" annotation (
                        Placement(transformation(extent={{-220,90},{-180,130}}),
                          iconTransformation(extent={{-120,-50},{-100,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                      uZonSta "Zone state status signal" annotation (Placement(
                          transformation(extent={{-220,-30},{-180,10}}),
                          iconTransformation(extent={{-120,-30},{-100,-10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                      uFreProSta "Freeze protection stage status signal"
                      annotation (Placement(transformation(extent={{-220,30},{-180,
                              70}}), iconTransformation(extent={{-120,-10},{-100,
                              10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yOutDamPosMax(
                      final min=0,
                      final max=1,
                      final unit="1") "Maximum outdoor air damper position"
                      annotation (Placement(transformation(extent={{180,-160},{
                              220,-120}}), iconTransformation(extent={{100,40},
                              {140,80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yRetDamPosMin(
                      final min=retDamPhyPosMin,
                      final max=retDamPhyPosMax,
                      final unit="1") "Minimum return air damper position"
                      annotation (Placement(transformation(extent={{180,-260},{
                              220,-220}}), iconTransformation(extent={{100,-80},
                              {140,-40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yRetDamPosMax(
                      final min=retDamPhyPosMin,
                      final max=retDamPhyPosMax,
                      final unit="1") "Maximum return air damper position"
                      annotation (Placement(transformation(extent={{180,-230},{
                              220,-190}}), iconTransformation(extent={{100,-20},
                              {140,20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And3 andEnaDis
                      "Logical and that checks freeze protection stage and zone state"
                      annotation (Placement(transformation(extent={{40,30},{60,
                              50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold
                      truFalHol(trueHoldDuration=600) "10 min on/off delay"
                      annotation (Placement(transformation(extent={{124,214},{
                              144,234}})));
                    CDL.Logical.Xor xor "Either fixed+differential temperature cutoff or others"
                      annotation (Placement(transformation(extent={{74,242},{94,262}})));
                  protected
                    final parameter Real TOutHigLimCutHig(
                      final unit="K",
                      final displayUnit="K",
                      final quantity="TemperatureDifference") = 0
                      "Hysteresis high limit cutoff";
                    final parameter Real TOutHigLimCutLow = TOutHigLimCutHig - delTOutHis
                      "Hysteresis low limit cutoff";
                    final parameter Real hOutHigLimCutHig(
                      final unit="J/kg",
                      final quantity="SpecificEnergy") = 0
                      "Hysteresis block high limit cutoff";
                    final parameter Real hOutHigLimCutLow = hOutHigLimCutHig - delEntHis
                      "Hysteresis block low limit cutoff";

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      entSubst(final k=false) if not use_enthalpy
                      "Deactivates outdoor air enthalpy condition if there is no enthalpy sensor"
                      annotation (Placement(transformation(extent={{-60,170},{-40,
                              190}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      retDamPhyPosMinSig(final k=retDamPhyPosMin)
                      "Physically fixed minimum position of the return air damper"
                      annotation (Placement(transformation(extent={{-140,-258},
                              {-120,-238}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      retDamPhyPosMaxSig(final k=retDamPhyPosMax)
                      "Physically fixed maximum position of the return air damper. This is the initial condition of the return air damper"
                      annotation (Placement(transformation(extent={{-140,-220},
                              {-120,-200}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis
                      hysOutTem(final uHigh=TOutHigLimCutHig, final uLow=
                          TOutHigLimCutLow)
                      "Outdoor air temperature hysteresis for fixed or differential dry bulb temperature cutoff conditions"
                      annotation (Placement(transformation(extent={{-100,244},{
                              -80,264}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis
                      hysOutEnt(final uLow=hOutHigLimCutLow, final uHigh=
                          hOutHigLimCutHig) if use_enthalpy
                      "Outdoor air enthalpy hysteresis for fixed or differential enthalpy cutoff conditions"
                      annotation (Placement(transformation(extent={{-98,150},{-78,
                              170}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2(final k2=
                          -1) if use_enthalpy
                      "Add block that determines the difference between hOut and hOutCut"
                      annotation (Placement(transformation(extent={{-140,150},{
                              -120,170}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(final k2=
                          -1)
                      "Add block that determines difference the between TOut and TOutCut"
                      annotation (Placement(transformation(extent={{-140,244},{
                              -120,264}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch outDamSwitch
                      "Set maximum OA damper position to minimum at disable (after time delay)"
                      annotation (Placement(transformation(extent={{40,-150},{
                              60,-130}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch minRetDamSwitch
                      "Keep minimum RA damper position at physical maximum for a short time period after disable"
                      annotation (Placement(transformation(extent={{40,-250},{
                              60,-230}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Nor nor1
                      "Logical nor" annotation (Placement(transformation(extent
                            ={{18,178},{38,198}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not2
                      "Logical not that starts the timer at disable signal "
                      annotation (Placement(transformation(extent={{-10,-70},{
                              10,-50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1
                      "Logical and checks supply fan status" annotation (
                        Placement(transformation(extent={{4,100},{24,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      conInt(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                      "Freeze protection stage 0" annotation (Placement(
                          transformation(extent={{-120,30},{-100,50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu
                      "Logical block to check if the freeze protection is deactivated"
                      annotation (Placement(transformation(extent={{-80,50},{-60,
                              70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      conInt1(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.heating)
                      "Heating zone state" annotation (Placement(transformation(
                            extent={{-120,-30},{-100,-10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu1
                      "Logical block to check if the freeze protection is deactivated"
                      annotation (Placement(transformation(extent={{-80,-10},{-60,
                              10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not3
                      "Negation for check of freeze protection status"
                      annotation (Placement(transformation(extent={{-44,-10},{-24,
                              10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add3(final k2=
                          -1) if use_fixed_plus_differential_drybulb
                      "Add block that determines difference the between TOut and TOutCut"
                      annotation (Placement(transformation(extent={{-140,200},{
                              -120,220}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis
                      hysCutTem(final uHigh=TOutHigLimCutHig, final uLow=
                          TOutHigLimCutLow) if
                      use_fixed_plus_differential_drybulb
                      "Outdoor air temperature hysteresis for both fixed and differential dry bulb temperature cutoff conditions"
                      annotation (Placement(transformation(extent={{-100,200},{
                              -80,220}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      entSubst1(final k=false) if not
                      use_fixed_plus_differential_drybulb
                      "Deactivates the option if not using both fixed and differential dry bulb"
                      annotation (Placement(transformation(extent={{18,212},{38,
                              232}})));
                    CDL.Logical.Nor nor2 if use_fixed_plus_differential_drybulb "Logical nor"
                      annotation (Placement(transformation(extent={{18,244},{38,264}})));
                  equation
                    connect(outDamSwitch.y, yOutDamPosMax)
                      annotation (Line(points={{62,-140},{200,-140}},           color={0,0,127}));
                    connect(TOut, add1.u1)
                      annotation (Line(points={{-200,270},{-160,270},{-160,260},{-142,260}},color={0,0,127}));
                    connect(TCut, add1.u2) annotation (Line(points={{-200,240},{-160,240},{-160,248},
                            {-142,248}}, color={0,0,127}));
                    connect(add1.y, hysOutTem.u)
                      annotation (Line(points={{-118,254},{-102,254}}, color={0,0,127}));
                    connect(hOut, add2.u1)
                      annotation (Line(points={{-200,180},{-160,180},{-160,166},{-142,166}},color={0,0,127}));
                    connect(hCut, add2.u2) annotation (Line(points={{-200,150},{-160,150},{-160,154},
                            {-142,154}}, color={0,0,127}));
                    connect(add2.y, hysOutEnt.u)
                      annotation (Line(points={{-118,160},{-100,160}}, color={0,0,127}));
                    connect(hysOutTem.y, nor1.u1)
                      annotation (Line(points={{-78,254},{-14,254},{-14,188},{16,188}},
                      color={255,0,255}));
                    connect(hysOutEnt.y, nor1.u2)
                      annotation (Line(points={{-76,160},{-14,160},{-14,180},{16,180}},   color={255,0,255}));
                    connect(entSubst.y, nor1.u2)
                      annotation (Line(points={{-38,180},{16,180}},
                      color={255,0,255}));
                    connect(uOutDamPosMin, outDamSwitch.u1)
                      annotation (Line(points={{-200,-160},{-60,-160},{-60,-132},{38,-132}},
                      color={0,0,127}));
                    connect(uOutDamPosMax, outDamSwitch.u3)
                      annotation (Line(points={{-200,-130},{-80,-130},{-80,-148},{38,-148}}, color={0,0,127}));
                    connect(andEnaDis.y, not2.u)
                      annotation (Line(points={{62,40},{72,40},{72,-20},{-20,-20},{-20,-60},{-12,-60}},
                      color={255,0,255}));
                    connect(minRetDamSwitch.y, yRetDamPosMin)
                      annotation (Line(points={{62,-240},{200,-240}},  color={0,0,127}));
                    connect(truFalHol.y, and1.u1)
                      annotation (Line(points={{146,224},{164,224},{164,130},{-26,130},{-26,110},
                            {2,110}},
                      color={255,0,255}));
                    connect(and1.y, andEnaDis.u1)
                      annotation (Line(points={{26,110},{30,110},{30,48},{38,48}},          color={255,0,255}));
                    connect(uSupFan, and1.u2)
                      annotation (Line(points={{-200,110},{-102,110},{-102,102},{2,102}},  color={255,0,255}));
                    connect(retDamPhyPosMaxSig.y, minRetDamSwitch.u1)
                      annotation (Line(points={{-118,-210},{-4,-210},{-4,-232},{38,-232}}, color={0,0,127}));
                    connect(retDamPhyPosMinSig.y, minRetDamSwitch.u3)
                      annotation (Line(points={{-118,-248},{38,-248}},  color={0,0,127}));
                    connect(retDamPhyPosMaxSig.y, yRetDamPosMax)
                      annotation (Line(points={{-118,-210},{200,-210}}, color={0,0,127}));
                    connect(not2.y, minRetDamSwitch.u2)
                      annotation (Line(points={{12,-60},{16,-60},{16,-240},{38,-240}}, color={255,0,255}));
                    connect(not2.y, outDamSwitch.u2)
                      annotation (Line(points={{12,-60},{28,-60},{28,-140},{38,-140}}, color={255,0,255}));
                    connect(conInt.y,intEqu. u2)
                      annotation (Line(points={{-98,40},{-92,40},{-92,52},{-82,52}}, color={255,127,0}));
                    connect(conInt1.y,intEqu1. u2)
                      annotation (Line(points={{-98,-20},{-90,-20},{-90,-8},{-82,-8}}, color={255,127,0}));
                    connect(intEqu1.y,not3. u)
                      annotation (Line(points={{-58,0},{-46,0}}, color={255,0,255}));
                    connect(uZonSta, intEqu1.u1)
                      annotation (Line(points={{-200,-10},{-140,-10},{-140,0},{-82,0}}, color={255,127,0}));
                    connect(uFreProSta, intEqu.u1)
                      annotation (Line(points={{-200,50},{-140,50},{-140,60},{-82,60}}, color={255,127,0}));
                    connect(intEqu.y, andEnaDis.u2)
                      annotation (Line(points={{-58,60},{-10,60},{-10,40},{38,40}}, color={255,0,255}));
                    connect(not3.y, andEnaDis.u3)
                      annotation (Line(points={{-22,0},{8,0},{8,32},{38,32}}, color={255,0,255}));
                    connect(TRet, add3.u2) annotation (Line(points={{-200,210},{-160,210},{-160,204},
                            {-142,204}}, color={0,0,127}));
                    connect(TOut, add3.u1) annotation (Line(points={{-200,270},{-160,270},{-160,260},
                            {-152,260},{-152,216},{-142,216}}, color={0,0,127}));
                    connect(add3.y, hysCutTem.u)
                      annotation (Line(points={{-118,210},{-102,210}}, color={0,0,127}));
                    connect(hysCutTem.y, nor2.u2) annotation (Line(points={{-78,210},{-38,210},{
                            -38,246},{16,246}},
                                            color={255,0,255}));
                    connect(nor2.u1, hysOutTem.y) annotation (Line(points={{16,254},{-78,254}},
                                        color={255,0,255}));
                    connect(nor2.y, xor.u1) annotation (Line(points={{40,254},{56,254},{56,252},{
                            72,252}},
                                   color={255,0,255}));
                    connect(entSubst1.y, xor.u1) annotation (Line(points={{40,222},{54,222},{54,
                            252},{72,252}},
                                       color={255,0,255}));
                    connect(nor1.y, xor.u2) annotation (Line(points={{40,188},{62,188},{62,244},{
                            72,244}},
                                   color={255,0,255}));
                    connect(xor.y, truFalHol.u) annotation (Line(points={{96,252},{106,252},{106,
                            224},{122,224}},
                                        color={255,0,255}));

                  annotation (
                    defaultComponentName = "enaDis",
                    Icon(graphics={
                          Rectangle(
                            extent={{-100,-100},{100,100}},
                            lineColor={0,0,127},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid),
                          Line(
                            points={{0,60},{80,60}},
                            color={0,0,127},
                            thickness=0.5),
                          Line(
                            points={{-76,-60},{0,-60},{0,60}},
                            color={0,0,127},
                            thickness=0.5),
                          Text(
                            extent={{-170,142},{158,104}},
                            lineColor={0,0,127},
                            textString="%name")}),
                      Diagram(coordinateSystem(
                          preserveAspectRatio=false,
                          extent={{-180,-280},{180,280}}), graphics={
                          Rectangle(
                            extent={{-170,-44},{170,-274}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-170,16},{170,-36}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-170,76},{170,24}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-170,136},{170,84}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-170,276},{170,146}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                                                       Text(
                            extent={{102,168},{178,156}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Outdoor air
conditions"),                                          Text(
                            extent={{100,70},{264,48}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Freeze protection -
disable if stage1
and above"),                                           Text(
                            extent={{100,-34},{214,-86}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Damper position
limit assignments"),                                   Text(
                            extent={{102,16},{206,-22}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Zone state -
disable if
heating"),                                             Text(
                            extent={{100,102},{182,92}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Supply fan status")}),
                      Documentation(info="<html>
<p>
This is a single zone VAV AHU economizer enable/disable sequence
based on ASHRAE G36 PART 5.5 and PART 5.A.17. Additional
conditions included in the sequence are:
</p>
<ul>
<li>
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages</a> (PART 5.9),
</li>
<li>
Supply fan status <code>TSupFan</code> (PART 5.4.d),
</li>
<li>
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.ZoneStates\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types.ZoneStates</a> (PART 5.3.b).
</li>
</ul>
<p>
The economizer is disabled whenever the outdoor air conditions
exceed the economizer high limit cutoff setpoint plus the hysteresis low limit parameter
(<code>TOutHigLimCutLow</code> or <code>hOutHigLimCutLow</code>) as shown in the figure.
And the economizer is enabled whenever the outdoor air conditions are below the economizer
high limit cutoff setpoint plus the hysteresis high limit parameter (<code>TOutHigLimCutHig</code> or 
<code>hOutHigLimCutHig</code>). This sequence allows for all device types listed in
ASHRAE 90.1-2013 and Title 24-2013.
</p>
<p>
In addition, the economizer is disabled without a delay whenever any of the
following is <code>true</code>:
</p>
<ul>
<li>supply fan is off,
</li>
<li>
zone state is <code>heating</code>,
</li>
<li>
freeze protection stage is not <code>0</code>.
</li>
</ul>
<p>
The following state machine chart illustrates the transitions between enabling and disabling:
</p>
<p align=\"center\">
<img alt=\"Image of economizer enable-disable state machine chart\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/Enable.png\"/>
</p>
</html>",                   revisions="<html>
<ul>
<li>
July 30, 2019, by Kun Zhang:<br/>
Added the option to allow fixed plus differential dry bulb temperature cutoff.
</li>
<li>
July 06, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Enable;

                  block Limits "Single zone VAV AHU minimum outdoor air control - damper position limits"

                    parameter Real yFanMin(
                      final min=0,
                      final max=1,
                      final unit="1") = 0.1 "Minimum supply fan operation speed"
                      annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                    parameter Real yFanMax(
                      final min=0,
                      final max=1,
                      final unit="1") = 1 "Maximum supply fan operation speed"
                      annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                    parameter Real yDam_VOutMin_minSpe(
                      final min=outDamPhyPosMin,
                      final max=outDamPhyPosMax,
                      final unit="1") = 0.4
                      "OA damper position to supply minimum outdoor airflow at minimum fan speed"
                      annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                    parameter Real yDam_VOutMin_maxSpe(
                      final min=outDamPhyPosMin,
                      final max=outDamPhyPosMax,
                      final unit="1") = 0.3
                      "OA damper position to supply minimum outdoor airflow at maximum fan speed"
                      annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                    parameter Real yDam_VOutDes_minSpe(
                      final min=yDam_VOutMin_minSpe,
                      final max=outDamPhyPosMax,
                      final unit="1") = 0.9
                      "OA damper position to supply design outdoor airflow at minimum fan speed"
                      annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                    parameter Real yDam_VOutDes_maxSpe(
                      final min=yDam_VOutMin_maxSpe,
                      final max=outDamPhyPosMax,
                      final unit="1") = 0.8
                      "OA damper position to supply design outdoor airflow at maximum fan speed"
                      annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                    parameter Real VOutMin_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate") "Calculated minimum outdoor airflow rate"
                      annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                    parameter Real VOutDes_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")
                      "Calculated design outdoor airflow rate"
                      annotation(Dialog(tab="Commissioning", group="Damper position limits"));
                    parameter Real outDamPhyPosMax(
                      final min=0,
                      final max=1,
                      final unit="1") = 1
                      "Physically fixed maximum position of the outdoor air damper"
                      annotation(Dialog(tab="Commissioning", group="Physical damper position limits"));
                    parameter Real outDamPhyPosMin(
                      final min=0,
                      final max=1,
                      final unit="1") = 0
                      "Physically fixed minimum position of the outdoor air damper"
                      annotation(Dialog(tab="Commissioning", group="Physical damper position limits"));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uSupFanSpe(
                      final min=0,
                      final max=1,
                      final unit="1") "Supply fan speed" annotation (Placement(
                          transformation(extent={{-200,90},{-160,130}}),
                          iconTransformation(extent={{-140,20},{-100,60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      VOutMinSet_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate",
                      final min=VOutMin_flow,
                      final max=VOutDes_flow)
                      "Minimum outdoor airflow setpoint" annotation (Placement(
                          transformation(extent={{-200,160},{-160,200}}),
                          iconTransformation(extent={{-140,60},{-100,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                      uOpeMod "AHU operation mode status signal" annotation (
                        Placement(transformation(extent={{-200,-180},{-160,-140}}),
                          iconTransformation(extent={{-140,-102},{-100,-62}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                      uFreProSta "Freeze protection status signal" annotation (
                        Placement(transformation(extent={{-200,-140},{-160,-100}}),
                          iconTransformation(extent={{-140,-60},{-100,-20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                      uSupFan "Supply fan status signal" annotation (Placement(
                          transformation(extent={{-200,-100},{-160,-60}}),
                          iconTransformation(extent={{-140,-20},{-100,20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yOutDamPosMin(
                      final min=outDamPhyPosMin,
                      final max=outDamPhyPosMax,
                      final unit="1")
                      "Minimum outdoor air damper position limit" annotation (
                        Placement(transformation(extent={{160,-60},{200,-20}}),
                          iconTransformation(extent={{100,-80},{140,-40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yOutDamPosMax(
                      final min=outDamPhyPosMin,
                      final max=outDamPhyPosMax,
                      final unit="1")
                      "Maximum outdoor air damper position limit" annotation (
                        Placement(transformation(extent={{160,22},{200,62}}),
                          iconTransformation(extent={{100,40},{140,80}})));

                  protected
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      yFanMinSig(final k=yFanMin) "Minimum supply fan speed"
                      annotation (Placement(transformation(extent={{-140,50},{-120,
                              70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      outDamPhyPosMinSig(final k=outDamPhyPosMin)
                      "Physically fixed minimum position of the outdoor air damper"
                      annotation (Placement(transformation(extent={{-40,-20},{-20,
                              0}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      outDamPhyPosMaxSig(final k=outDamPhyPosMax)
                      "Physically fixed maximum position of the outdoor air damper"
                      annotation (Placement(transformation(extent={{-80,-20},{-60,
                              0}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      yFanMaxSig(final k=yFanMax) "Maximum supply fan speed"
                      annotation (Placement(transformation(extent={{-140,80},{-120,
                              100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      yDam_VOutMin_minSpeSig(final k=yDam_VOutMin_minSpe)
                      "OA damper position to supply minimum outdoor airflow at minimum fan speed"
                      annotation (Placement(transformation(extent={{-140,120},{
                              -120,140}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      yDam_VOutDes_minSpeSig(final k=yDam_VOutDes_minSpe)
                      "OA damper position to supply design outdoor airflow at minimum fan speed"
                      annotation (Placement(transformation(extent={{-140,-30},{
                              -120,-10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      yDam_VOutMin_maxSpeSig(final k=yDam_VOutMin_maxSpe)
                      "OA damper position to supply minimum outdoor airflow at maximum fan speed"
                      annotation (Placement(transformation(extent={{-140,150},{
                              -120,170}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      yDam_VOutDes_maxSpeSig(final k=yDam_VOutDes_maxSpe)
                      "OA damper position to supply design outdoor airflow at maximum fan speed"
                      annotation (Placement(transformation(extent={{-140,0},{-120,
                              20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      minVOutSig(final k=VOutMin_flow)
                      "Minimum outdoor airflow rate" annotation (Placement(
                          transformation(extent={{16,170},{36,190}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      desVOutSig(final k=VOutDes_flow)
                      "Design outdoor airflow rate" annotation (Placement(
                          transformation(extent={{16,90},{36,110}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line yDam_VOutMin_curSpe(final
                        limitBelow=true, final limitAbove=true)
                      "Calculates OA damper position required to supply minimum outdoor airflow at current fan speed"
                      annotation (Placement(transformation(extent={{16,130},{36,
                              150}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line yDam_VOutDes_curSpe(final
                        limitBelow=true, final limitAbove=true)
                      "Calculates OA damper position required to supply design outdoor airflow at current fan speed"
                      annotation (Placement(transformation(extent={{16,40},{36,
                              60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line minVOutSetCurFanSpePos(final
                        limitBelow=true, final limitAbove=true)
                      "Calculates OA damper position required to supply minimum outdoor airflow setpoint at current fan speed"
                      annotation (Placement(transformation(extent={{100,110},{
                              120,130}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch enaDis
                      "Logical switch to enable damper position limit calculation or disable it (set min limit to physical minimum)"
                      annotation (Placement(transformation(extent={{82,-120},{
                              102,-100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                      "Logical not block" annotation (Placement(transformation(
                            extent={{-20,-80},{0,-60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch enaDis1
                      "Logical switch to enable damper position limit calculation or disable it (set max limit to physical minimum)"
                      annotation (Placement(transformation(extent={{80,-80},{
                              100,-60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      conInt(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                      "Freeze protection stage 1" annotation (Placement(
                          transformation(extent={{-140,-150},{-120,-130}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.LessEqual intLesEqu
                      "Check if freeze protection stage is stage 0" annotation
                      (Placement(transformation(extent={{-100,-130},{-80,-110}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      conInt1(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "Occupied mode index" annotation (Placement(
                          transformation(extent={{-140,-190},{-120,-170}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu1
                      "Check if operation mode is occupied" annotation (
                        Placement(transformation(extent={{-100,-170},{-80,-150}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And3 and3
                      "Logical and" annotation (Placement(transformation(extent
                            ={{-60,-80},{-40,-60}})));

                  equation
                    connect(minVOutSig.y, minVOutSetCurFanSpePos.x1)
                      annotation (Line(points={{38,180},{76,180},{76,128},{98,128}},color={0,0,127}));
                    connect(desVOutSig.y, minVOutSetCurFanSpePos.x2)
                      annotation (Line(points={{38,100},{66,100},{66,116},{98,116}},color={0,0,127}));
                    connect(yDam_VOutMin_curSpe.y, minVOutSetCurFanSpePos.f1)
                      annotation (Line(points={{38,140},{38,142},{66,142},{66,124},{98,124}}, color={0,0,127}));
                    connect(yDam_VOutDes_curSpe.y, minVOutSetCurFanSpePos.f2)
                      annotation (Line(points={{38,50},{76,50},{76,112},{98,112}}, color={0,0,127}));
                    connect(enaDis.y, yOutDamPosMin)
                      annotation (Line(points={{104,-110},{150,-110},{150,-40},{180,-40}},
                      color={0,0,127}));
                    connect(yDam_VOutDes_minSpeSig.y, yDam_VOutDes_curSpe.f1)
                      annotation (Line(points={{-118,-20},{-100,-20},{-100,54},{14,54}}, color={0,0,127}));
                    connect(yDam_VOutDes_maxSpeSig.y, yDam_VOutDes_curSpe.f2)
                      annotation (Line(points={{-118,10},{-8,10},{-8,42},{14,42}}, color={0,0,127}));
                    connect(yDam_VOutMin_minSpeSig.y, yDam_VOutMin_curSpe.f1)
                      annotation (Line(points={{-118,130},{-118,130},{-118,130},{-28,130},{-28,144},
                            {14,144}},       color={0,0,127}));
                    connect(yDam_VOutMin_maxSpeSig.y, yDam_VOutMin_curSpe.f2)
                      annotation (Line(points={{-118,160},{-58,160},{-58,132},{14,132}}, color={0,0,127}));
                    connect(uSupFanSpe, yDam_VOutMin_curSpe.u)
                      annotation (Line(points={{-180,110},{-24,110},{-24,140},{14,140}}, color={0,0,127}));
                    connect(yFanMaxSig.y, yDam_VOutMin_curSpe.x2)
                      annotation (Line(points={{-118,90},{2,90},{2,136},{14,136}}, color={0,0,127}));
                    connect(yFanMinSig.y, yDam_VOutMin_curSpe.x1)
                      annotation (Line(points={{-118,60},{-8,60},{-8,148},{14,148}}, color={0,0,127}));
                    connect(yFanMinSig.y, yDam_VOutDes_curSpe.x1)
                      annotation (Line(points={{-118,60},{-8,60},{-8,58},{14,58}}, color={0,0,127}));
                    connect(yFanMaxSig.y, yDam_VOutDes_curSpe.x2)
                      annotation (Line(points={{-118,90},{-14,90},{-14,46},{14,46}}, color={0,0,127}));
                    connect(VOutMinSet_flow, minVOutSetCurFanSpePos.u)
                      annotation (Line(points={{-180,180},{-20,180},{-20,160},{60,160},{60,120},{98,120}}, color={0,0,127}));
                    connect(uSupFanSpe, yDam_VOutDes_curSpe.u)
                      annotation (Line(points={{-180,110},{-24,110},{-24,50},{14,50}}, color={0,0,127}));
                    connect(not1.y, enaDis.u2)
                      annotation (Line(points={{2,-70},{2,-70},{2,-70},{0,-70},{40,-70},{40,-110},
                            {80,-110}},                                                                      color={255,0,255}));
                    connect(outDamPhyPosMinSig.y, enaDis.u1)
                      annotation (Line(points={{-18,-10},{68,-10},{68,-102},{80,-102}},color={0,0,127}));
                    connect(minVOutSetCurFanSpePos.y, enaDis.u3)
                      annotation (Line(points={{122,120},{130,120},{130,20},{60,20},{60,-118},{80,
                            -118}},                                                                      color={0,0,127}));
                    connect(outDamPhyPosMinSig.y, enaDis1.u1)
                      annotation (Line(points={{-18,-10},{40,-10},{40,-62},{78,-62}},color={0,0,127}));
                    connect(outDamPhyPosMaxSig.y, enaDis1.u3)
                      annotation (Line(points={{-58,-10},{-50,-10},{-50,-30},{20,-30},{20,-78},{78,
                            -78}},                                                                       color={0,0,127}));
                    connect(enaDis1.y, yOutDamPosMax)
                      annotation (Line(points={{102,-70},{140,-70},{140,42},{180,42}}, color={0,0,127}));
                    connect(not1.y, enaDis1.u2)
                      annotation (Line(points={{2,-70},{78,-70}}, color={255,0,255}));
                    connect(uOpeMod, intEqu1.u1)
                      annotation (Line(points={{-180,-160},{-102,-160}}, color={255,127,0}));
                    connect(conInt1.y, intEqu1.u2)
                      annotation (Line(points={{-118,-180},{-112,-180},{-112,-168},{-102,-168}},
                        color={255,127,0}));
                    connect(intLesEqu.u2, conInt.y)
                      annotation (Line(points={{-102,-128},{-110,-128},{-110,-140},{-118,-140}}, color={255,127,0}));
                    connect(uFreProSta, intLesEqu.u1)
                      annotation (Line(points={{-180,-120},{-102,-120}}, color={255,127,0}));
                    connect(uSupFan, and3.u1) annotation (Line(points={{-180,-80},{-80,-80},{-80,
                            -62},{-62,-62}}, color={255,0,255}));
                    connect(intLesEqu.y, and3.u2) annotation (Line(points={{-78,-120},{-74,-120},
                            {-74,-70},{-62,-70}}, color={255,0,255}));
                    connect(intEqu1.y, and3.u3) annotation (Line(points={{-78,-160},{-68,-160},{
                            -68,-78},{-62,-78}}, color={255,0,255}));
                    connect(and3.y, not1.u)
                      annotation (Line(points={{-38,-70},{-22,-70}}, color={255,0,255}));
                  annotation (Placement(transformation(extent={{-20,110},{0,130}})),
                                  Placement(transformation(extent={{-20,20},{0,40}})),
                                  Placement(transformation(extent={{60,90},{80,110}})),
                                  Placement(transformation(extent={{-140,130},{-120,150}})),
                                  Placement(transformation(extent={{-140,-30},{-120,-10}})),
                                  Placement(transformation(extent={{-140,160},{-120,180}})),
                                  Placement(transformation(extent={{-140,0},{-120,20}})),
                      defaultComponentName = "damLim",
                      Icon(graphics={
                          Rectangle(
                          extent={{-100,-100},{100,100}},
                          lineColor={0,0,0},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid),
                          Ellipse(
                            extent={{-76,80},{-72,76}},
                            lineColor={28,108,200},
                            fillColor={0,0,0},
                            fillPattern=FillPattern.Solid),
                          Ellipse(
                            extent={{-78,-56},{-74,-60}},
                            lineColor={28,108,200},
                            fillColor={0,0,0},
                            fillPattern=FillPattern.Solid),
                          Ellipse(
                            extent={{72,60},{76,56}},
                            lineColor={28,108,200},
                            fillColor={0,0,0},
                            fillPattern=FillPattern.Solid),
                          Ellipse(
                            extent={{72,-74},{76,-78}},
                            lineColor={28,108,200},
                            fillColor={0,0,0},
                            fillPattern=FillPattern.Solid),
                          Line(
                            points={{-74,78},{72,58}},
                            color={0,0,127},
                            thickness=0.5),
                          Line(
                            points={{-74,-58},{74,-76}},
                            color={0,0,127},
                            thickness=0.5),
                          Line(
                            points={{-2,-66},{-2,70}},
                            color={0,0,127},
                            thickness=0.5),
                          Rectangle(
                            extent={{-4,-64},{0,-68}},
                            lineColor={0,0,127},
                            fillColor={0,0,127},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-4,70},{0,66}},
                            lineColor={0,0,127},
                            fillColor={0,0,127},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-124,146},{128,110}},
                            lineColor={0,0,127},
                            textString="%name"),
                          Ellipse(
                            extent={{-4,-10},{0,-14}},
                            lineColor={28,108,200},
                            fillColor={0,0,0},
                            fillPattern=FillPattern.Solid)}),
                      Diagram(coordinateSystem(extent={{-160,-220},{160,220}}), graphics={
                          Rectangle(
                            extent={{-152,-52},{152,-214}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                                                     Text(
                            extent={{-52,-156},{158,-194}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Enable/disable conditions
for damper position limits
control loop"),           Rectangle(
                            extent={{-152,214},{-4,-46}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                                                     Text(
                            extent={{-140,212},{-32,194}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Values set at commissioning"),
                          Rectangle(
                            extent={{4,214},{152,-46}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                                                     Text(
                            extent={{48,212},{126,196}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Damper position limit"),
                          Text(
                            extent={{50,198},{152,186}},
                            lineColor={0,0,0},
                            textString="calculation and assignments")}),
                      Documentation(info="<html>
<p>
This block implements the single zone VAV AHU minimum outdoor air control with a single
common damper for minimum outdoor air and economizer functions based on outdoor airflow
setpoint (<code>VOutMinSet_flow</code>) and supply fan speed (<code>uSupFanSpe</code>),
designed in line with ASHRAE Guidline 36, PART 5.P.4.d.
</p>
<p>
The controller is enabled when the supply fan is proven on (<code>uSupFan=true</code>),
the AHU operation mode <code>uOpeMod</code> is Occupied, and Freeze protection stage
<code>uFreProSta</code> is 1 or smaller. Otherwise the damper position limits are set to
their corresponding maximum and minimum physical or at commissioning fixed limits, as illustrated below:
<br/>
</p>
<p align=\"center\">
<img alt=\"Image of damper position limits state machine chart\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/LimitsStateMachine.png\"/>
</p>
<p>
If limit modulation is enabled, the outdoor air damper position <code>yOutDamPosMin</code> is computed as
follows:</p>
<ol>
<li>
Calculate outdoor air damper position <code>yDam_VOutMin_curSpe</code>
which ensures minimum outdoor airflow rate <code>VOutMin_flow</code>
at current supply fan speed <code>uSupFanSpe</code> as a linear
interpolation between the following values set at commissioning:<br/>
<ul>
<li>minimum damper position at minimum fan speed for minimum outdoor airflow
<code>yDam_VOutMin_minSpe</code> and
</li>
<li>
minimum damper position at maximum fan speed for minimum outdoor airflow
<code>yDam_VOutMin_maxSpe</code>.
</li>
</ul>
</li>
<li>
Calculate outdoor air damper position <code>yDam_VOutDes_curSpe</code>
which ensures design outdoor airflow rate <code>VOutDes_flow</code> at
current supply fan speed <code>uSupFanSpe</code>, as a linear
interpolation between the following values set at commissioning:<br/>
<ul>
<li>
minimum damper position at minimum fan speed for design outdoor airflow
<code>yDam_VOutDes_minSpe</code> and
</li>
<li>
minimum damper position at maximum fan speed for design outdoor airflow
<code>yDam_VOutDes_maxSpe</code>.
</li>
</ul>
</li>
<li>
Calculate outdoor air damper position <code>yOutDamPosMin</code>
which ensures outdoor airflow setpoint <code>VOutMinSet_flow</code>
at current supply fan speed <code>uSupFanSpe</code> as a linear interpolation
between <code>yDam_VOutMin_curSpe</code> and <code>yDam_VOutDes_curSpe</code>, proportional to ratios of
<code>VOutMinSet_flow</code> to <code>VOutDes_flow</code> and <code>VOutMin_flow</code>.
</li>
</ol>
<p>
The chart below illustrates the OA damper position limit calculation:
<br/>
</p>
<p align=\"center\">
<img alt=\"Image of damper position limits control chart\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/LimitsControlChart.png\"/>
</p>
</html>",                   revisions="<html>
<ul>
<li>
March 13, 2020, by Jianjun Hu:<br/>
Replaced multiAnd block with and3 block to avoid vector related implementation.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1709\">#1709</a>.
</li>
<li>
July 06, 2017, by Milica Grahovac:<br/>
Refactored implementation.
</li>
<li>
April 15, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Limits;

                  block Modulation "Outdoor and return air damper position modulation sequence for single zone VAV AHU"

                    parameter
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController
                      controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                      "Type of controller";
                    parameter Real k(final unit="1/K") = 1 "Gain of controller";
                    parameter Real Ti(
                      final unit="s",
                      final quantity="Time")=300
                      "Time constant of modulation controller integrator block"
                      annotation (Dialog(
                        enable=controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                             or controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));
                    parameter Real Td(
                      final unit="s",
                      final quantity="Time")=0.1
                      "Time constant of derivative block for cooling control loop signal"
                      annotation (Dialog(
                        enable=controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                             or controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

                    parameter Real uMin(
                      final min=0.1,
                      final max=0.9,
                      final unit="1") = 0.1
                      "Lower limit of controller output uTSup at which the dampers are at their limits";
                    parameter Real uMax(
                      final min=0.1,
                      final max=1,
                      final unit="1") = 0.9
                      "Upper limit of controller output uTSup at which the dampers are at their limits";

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      TSup(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Measured supply air temperature" annotation (Placement(
                          transformation(extent={{-160,90},{-120,130}}),
                          iconTransformation(extent={{-140,60},{-100,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      THeaSupSet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")
                      "Supply air temperature heating setpoint" annotation (
                        Placement(transformation(extent={{-160,60},{-120,100}}),
                          iconTransformation(extent={{-140,40},{-100,80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                      uSupFan "Supply fan status" annotation (Placement(
                          transformation(extent={{-160,-130},{-120,-90}}),
                          iconTransformation(extent={{-140,-110},{-100,-70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uOutDamPosMin(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Minimum economizer damper position limit as returned by the damper position limits sequence"
                      annotation (Placement(transformation(extent={{-160,-90},{
                              -120,-50}}), iconTransformation(extent={{-140,-80},
                              {-100,-40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uOutDamPosMax(
                      final min=0,
                      final max=1,
                      final unit="1") "Maximum economizer damper position limit as returned by the economizer enable-disable sequence.
    If the economizer is disabled, this value equals uOutDamPosMin" annotation
                      (Placement(transformation(extent={{-160,-60},{-120,-20}}),
                          iconTransformation(extent={{-140,-60},{-100,-20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uRetDamPosMin(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Minimum return air damper position limit as returned by the economizer enable-disable sequence"
                      annotation (Placement(transformation(extent={{-160,-20},{
                              -120,20}}), iconTransformation(extent={{-140,-20},
                              {-100,20}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput
                      uRetDamPosMax(
                      final min=0,
                      final max=1,
                      final unit="1")
                      "Maximum return air damper position limit as returned by the economizer enable-disable sequence"
                      annotation (Placement(transformation(extent={{-160,20},{-120,
                              60}}), iconTransformation(extent={{-140,0},{-100,
                              40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yHeaCoi(
                      final min=0,
                      final max=1,
                      final unit="1") "Heating coil control signal" annotation
                      (Placement(transformation(extent={{120,30},{140,50}}),
                          iconTransformation(extent={{100,30},{120,50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yOutDamPos(
                      final min=0,
                      final max=1,
                      final unit="1") "Economizer damper position" annotation (
                        Placement(transformation(extent={{120,-50},{140,-30}}),
                          iconTransformation(extent={{100,-50},{120,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput
                      yRetDamPos(
                      final min=0,
                      final max=1,
                      final unit="1") "Return air damper position" annotation (
                        Placement(transformation(extent={{120,-10},{140,10}}),
                          iconTransformation(extent={{100,-10},{120,10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID uTSup(
                      final controllerType=controllerType,
                      final k=k,
                      final Ti=Ti,
                      final Td=Td,
                      final reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter,

                      final yMax=1,
                      final yMin=0)
                      "Contoller that outputs a signal based on the error between the measured SAT and SAT heating setpoint"
                      annotation (Placement(transformation(extent={{-100,70},{-80,
                              90}})));

                  protected
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      outDamMinLimSig(final k=uMin)
                      "Minimal control loop signal for the outdoor air damper"
                      annotation (Placement(transformation(extent={{-60,-88},{-40,
                              -68}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      retDamMaxLimSig(final k=uMax)
                      "Maximal control loop signal for the return air damper"
                      annotation (Placement(transformation(extent={{-60,-34},{-40,
                              -14}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line outDamPos(final
                        limitBelow=true, final limitAbove=true)
                      "Damper position is linearly proportional to the control signal between signal limits"
                      annotation (Placement(transformation(extent={{24,-50},{44,
                              -30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line retDamPos(final
                        limitBelow=true, final limitAbove=true)
                      "Damper position is linearly proportional to the control signal between signal limits"
                      annotation (Placement(transformation(extent={{22,-10},{42,
                              10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line HeaCoi(final
                        limitBelow=true, final limitAbove=true)
                      "Heating coil signal is linearly proportional to the control signal between signal limits"
                      annotation (Placement(transformation(extent={{22,30},{42,
                              50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      heaCoiMaxLimSig(final k=1)
                      "Maximal control loop signal for the heating coil"
                      annotation (Placement(transformation(extent={{-60,50},{-40,
                              70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      heaCoiMinLimSig(final k=0)
                      "Minimum control loop signal for the heating coil"
                      annotation (Placement(transformation(extent={{-60,10},{-40,
                              30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      uMaxHeaCoi(final k=1)
                      "Maximal control loop signal for the heating coil"
                      annotation (Placement(transformation(extent={{-60,90},{-40,
                              110}})));
                    CDL.Logical.Switch enaDis "Enable or disable the heating coil"
                      annotation (Placement(transformation(extent={{76,30},{96,50}})));
                    CDL.Continuous.Sources.Constant Off(final k=0) "Off signal for heating coil"
                      annotation (Placement(transformation(extent={{6,-90},{26,-70}})));
                  equation
                    connect(retDamMaxLimSig.y,retDamPos. x2)
                      annotation (Line(points={{-38,-24},{-12,-24},{-12,-4},{20,-4}},                 color={0,0,127}));
                    connect(uTSup.y, retDamPos.u) annotation (Line(points={{-78,80},{4,80},{4,0},
                            {20,0}},      color={0,0,127}));
                    connect(uTSup.y, outDamPos.u) annotation (Line(points={{-78,80},{4,80},{4,-40},
                            {22,-40}}, color={0,0,127}));
                    connect(outDamMinLimSig.y, outDamPos.x1)
                      annotation (Line(points={{-38,-78},{-8,-78},{-8,-32},{22,-32}},        color={0,0,127}));
                    connect(retDamMaxLimSig.y, outDamPos.x2)
                      annotation (Line(points={{-38,-24},{-12,-24},{-12,-44},{22,-44}},
                                                                                  color={0,0,127}));
                    connect(outDamMinLimSig.y, retDamPos.x1)
                      annotation (Line(points={{-38,-78},{-8,-78},{-8,8},{20,8}}, color={0,0,127}));
                    connect(HeaCoi.u, retDamPos.u)
                      annotation (Line(points={{20,40},{4,40},{4,0},{20,0}},   color={0,0,127}));
                    connect(THeaSupSet, uTSup.u_s)
                      annotation (Line(points={{-140,80},{-102,80}},color={0,0,127}));
                    connect(TSup, uTSup.u_m) annotation (Line(points={{-140,110},{-108,110},{-108,
                            60},{-90,60},{-90,68}}, color={0,0,127}));
                    connect(heaCoiMinLimSig.y, HeaCoi.f1) annotation (Line(points={{-38,20},{-8,
                            20},{-8,44},{20,44}},
                                              color={0,0,127}));
                    connect(heaCoiMaxLimSig.y, HeaCoi.f2) annotation (Line(points={{-38,60},{-4,
                            60},{-4,32},{20,32}},
                                              color={0,0,127}));
                    connect(retDamMaxLimSig.y, HeaCoi.x1) annotation (Line(points={{-38,-24},{-12,
                            -24},{-12,48},{20,48}},
                                              color={0,0,127}));
                    connect(uMaxHeaCoi.y, HeaCoi.x2) annotation (Line(points={{-38,100},{10,100},
                            {10,36},{20,36}},
                                      color={0,0,127}));
                    connect(uOutDamPosMin, outDamPos.f2) annotation (Line(points={{-140,-70},{-92,
                            -70},{-92,-48},{22,-48}}, color={0,0,127}));
                    connect(uRetDamPosMin, retDamPos.f1)
                      annotation (Line(points={{-140,0},{-2,0},{-2,4},{20,4}}, color={0,0,127}));
                    connect(uRetDamPosMax, retDamPos.f2) annotation (Line(points={{-140,40},{-92,
                            40},{-92,-8},{20,-8}},
                                               color={0,0,127}));
                    connect(Off.y, enaDis.u3) annotation (Line(points={{28,-80},{62,-80},{62,32},
                            {74,32}}, color={0,0,127}));
                    connect(uSupFan, enaDis.u2) annotation (Line(points={{-140,-110},{56,-110},{
                            56,40},{74,40}}, color={255,0,255}));
                    connect(HeaCoi.y, enaDis.u1) annotation (Line(points={{44,40},{50,40},{50,48},
                            {74,48}}, color={0,0,127}));
                    connect(enaDis.y, yHeaCoi)
                      annotation (Line(points={{98,40},{130,40}}, color={0,0,127}));
                    connect(uOutDamPosMax, outDamPos.f1) annotation (Line(points={{-140,-40},{-2,
                            -40},{-2,-36},{22,-36}}, color={0,0,127}));
                    connect(retDamPos.y, yRetDamPos)
                      annotation (Line(points={{44,0},{130,0}}, color={0,0,127}));
                    connect(outDamPos.y, yOutDamPos)
                      annotation (Line(points={{46,-40},{130,-40}}, color={0,0,127}));
                    connect(uSupFan, uTSup.trigger) annotation (Line(points={{-140,-110},{-98,
                            -110},{-98,68}}, color={255,0,255}));
                    annotation (
                      defaultComponentName = "mod",
                      Icon(graphics={
                          Rectangle(
                            extent={{-100,-100},{100,100}},
                            lineColor={0,0,127},
                            fillColor={255,255,255},
                            fillPattern=FillPattern.Solid),
                          Line(points={{20,58}}, color={28,108,200}),
                          Line(
                            points={{-92,-84},{-50,-84},{12,70},{82,70}},
                            color={0,0,127},
                            thickness=0.5),
                          Line(
                            points={{-66,58},{12,58},{50,-76},{100,-76}},
                            color={0,0,127},
                            pattern=LinePattern.Dash,
                            thickness=0.5),
                          Text(
                            extent={{-108,138},{102,110}},
                            lineColor={0,0,127},
                            textString="%name"),
                          Line(
                            points={{-50,-84},{-94,80}},
                            color={0,0,127},
                            thickness=0.5)}),
                      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-120,-120},{120,
                              120}}), graphics={
                          Rectangle(
                            extent={{-18,118},{118,-118}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Rectangle(
                            extent={{-116,118},{-20,-118}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                                                     Text(
                            extent={{-104,128},{-60,88}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Damper position
supply air temperature
control loop"),                                      Text(
                            extent={{32,128},{76,88}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Damper position
assignments and heating coil signal")}),
                      Documentation(info="<html>
<p>
This is a single zone VAV AHU economizer modulation block. It calculates
the outdoor and return air damper positions based on the single zone VAV AHU
supply air temperature control loop signal. Economizer dampers are modulated
based on the calculated heating supply air temperature setpoint.
The implementation is in line with ASHRAE
Guidline 36 (G36), PART 5.P.3.b. Damper positions are linearly mapped to
the supply air control loop signal. This is a final sequence in the
composite single zone VAV AHU economizer control sequence. Damper position
limits, which are the inputs to the sequence, are the outputs of
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits</a> and
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable</a>
sequences.
</p>
<p>
When the economizer is enabled, the PI controller modulates the damper
positions. Return and outdoor damper are not interlocked. When the economizer is disabled,
the damper positions are set to the minimum outdoor air damper position limits.
</p>
<p>
The figures below show the input-output structure and an economizer damper
modulation sequence assuming a well configured controller. 
</p>
<p>
Control diagram:
</p>
<p align=\"center\">
<img alt=\"Image of the single zone AHU modulation sequence control diagram\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/ModulationControlDiagram.png\"/>
</p>
<p>
Single zone AHU economizer modulation control chart:
<br/>
</p>
<p align=\"center\">
<img alt=\"Image of the single zone AHU modulation sequence expected performance\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/ModulationControlChart.png\"/>
</p>
</html>",                   revisions="<html>
<ul>
<li>
July 29, 2019, by Kun Zhang:<br/>
Reimplemented economizer modulation control sequence.
</li>
<li>
October 31, 2018, by David Blum:<br/>
Added heating coil output.
</li>
<li>
October 19, 2017, by Jianjun Hu:<br/>
Changed name of controller output limit from <code>yMin</code> and <code>yMax</code> to <code>uMin</code> and <code>uMax</code>.
</li>
<li>
July 07, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Modulation;

                  package Validation "Collection of validation models"

                    model Enable_FreProSta_ZonSta
                      "Model validates economizer disable for heating zone state and activated freeze protection"

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable
                        enaDis "Single zone VAV AHU enable disable sequence"
                        annotation (Placement(transformation(extent={{82,40},{
                                102,60}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable
                        enaDis1 "Single zone VAV AHU enable disable sequence"
                        annotation (Placement(transformation(extent={{82,-40},{
                                102,-20}})));

                    protected
                      final parameter Real TOutCutoff(
                        final unit="K",
                        final displayUnit="degC",
                        final quantity = "ThermodynamicTemperature")=297.15
                        "Outdoor temperature high limit cutoff";
                      final parameter Real hOutCutoff(
                        final unit="J/kg",
                        final quantity = "SpecificEnergy")=65100
                        "Outdoor air enthalpy high limit cutoff";

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutBelowCutoff(final k=TOutCutoff - 2)
                        "Outdoor air temperature cutoff" annotation (Placement(
                            transformation(extent={{-40,140},{-20,160}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutCut(final k=TOutCutoff)
                        "Outdoor temperature high limit cutoff" annotation (
                          Placement(transformation(extent={{-40,100},{-20,120}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutBelowCutoff(final k=hOutCutoff - 1000)
                        "Outdoor air enthalpy is slightly below the cutoff"
                        annotation (Placement(transformation(extent={{-100,100},
                                {-80,120}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutCut(final k=hOutCutoff)
                        "Outdoor air enthalpy cutoff" annotation (Placement(
                            transformation(extent={{-100,60},{-80,80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                        "Freeze protection status is stage0" annotation (
                          Placement(transformation(extent={{-160,40},{-140,60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        zonSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.heating)
                        "Zone state is heating" annotation (Placement(
                            transformation(extent={{-160,0},{-140,20}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta1(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                        "Freeze protection status is stage1" annotation (
                          Placement(transformation(extent={{40,-120},{60,-100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        zonSta1(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.deadband)
                        "Zone state is deadband" annotation (Placement(
                            transformation(extent={{40,-80},{60,-60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMax(final k=0.9)
                        "Maximal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-60,-120},
                                {-40,-100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMin(final k=0.1)
                        "Minimal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-60,-160},
                                {-40,-140}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        supFanSta(final k=true) "Supply fan status" annotation
                        (Placement(transformation(extent={{-160,-40},{-140,-20}})));

                    equation
                      connect(TOutBelowCutoff.y, enaDis.TOut)
                        annotation (Line(points={{-18,150},{32,150},{32,59.4},{81,59.4}},
                                                                                      color={0,0,127}));
                      connect(TOutCut.y, enaDis.TCut)
                        annotation (Line(points={{-18,110},{31.5,110},{31.5,57.8},{81,57.8}},
                                                                                          color={0,0,127}));
                      connect(TOutCut.y, enaDis1.TCut)
                        annotation (Line(points={{-18,110},{32,110},{32,-22.2},{81,-22.2}},
                                                                                        color={0,0,127}));
                      connect(TOutBelowCutoff.y, enaDis1.TOut)
                        annotation (Line(points={{-18,150},{34,150},{34,-20.6},{81,-20.6}},
                                                                                        color={0,0,127}));
                      connect(hOutBelowCutoff.y, enaDis.hOut)
                        annotation (Line(points={{-78,110},{-60,110},{-60,60},{10,60},{10,54},{81,
                              54}},                                                     color={0,0,127}));
                      connect(hOutCut.y, enaDis.hCut)
                        annotation (Line(points={{-78,70},{-70,70},{-70,52},{81,52}}, color={0,0,127}));
                      connect(hOutBelowCutoff.y, enaDis1.hOut)
                        annotation (Line(points={{-78,110},{-60,110},{-60,60},{10,60},{10,-26},{81,
                              -26}},
                        color={0,0,127}));
                      connect(hOutCut.y, enaDis1.hCut)
                        annotation (Line(points={{-78,70},{-70,70},{-70,56},{6,56},{6,-28},{81,-28}},
                        color={0,0,127}));
                      connect(zonSta.y, enaDis.uZonSta)
                        annotation (Line(points={{-138,10},{-120,10},{-120,48},{81,48}}, color={255,127,0}));
                      connect(freProSta.y, enaDis.uFreProSta)
                        annotation (Line(points={{-138,50},{-130,50},{-130,50},{81,50}}, color={255,127,0}));
                      connect(freProSta1.y, enaDis1.uFreProSta)
                        annotation (Line(points={{62,-110},{70,-110},{70,-30},{81,-30}}, color={255,127,0}));
                      connect(zonSta1.y, enaDis1.uZonSta)
                        annotation (Line(points={{62,-70},{72,-70},{72,-32},{81,-32}}, color={255,127,0}));
                      connect(outDamPosMax.y, enaDis.uOutDamPosMax)
                        annotation (Line(points={{-38,-110},{-30,-110},{-30,44},{81,44}}, color={0,0,127}));
                      connect(outDamPosMin.y, enaDis.uOutDamPosMin)
                        annotation (Line(points={{-38,-150},{-28,-150},{-28,42},{81,42}}, color={0,0,127}));
                      connect(outDamPosMin.y, enaDis1.uOutDamPosMin)
                        annotation (Line(points={{-38,-150},{22,-150},{22,-38},{81,-38}}, color={0,0,127}));
                      connect(outDamPosMax.y, enaDis1.uOutDamPosMax)
                        annotation (Line(points={{-38,-110},{20,-110},{20,-36},{81,-36}}, color={0,0,127}));
                      connect(supFanSta.y, enaDis.uSupFan)
                        annotation (Line(points={{-138,-30},{-34,-30},{-34,46},{81,46}}, color={255,0,255}));
                      connect(supFanSta.y, enaDis1.uSupFan)
                        annotation (Line(points={{-138,-30},{-34,-30},{-34,-34},{81,-34}}, color={255,0,255}));
                        annotation (
                        experiment(StopTime=1800.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/Validation/Enable_FreProSta_ZonSta.mos"
                        "Simulate and plot"),
                      Icon(graphics={
                            Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}),
                            Polygon(lineColor = {0,0,255},
                                    fillColor = {75,138,73},
                                    pattern = LinePattern.None,
                                    fillPattern = FillPattern.Solid,
                                    points={{-36,58},{64,-2},{-36,-62},{-36,58}})}), Diagram(
                            coordinateSystem(preserveAspectRatio=false, extent={{-180,-180},{180,180}}), graphics={
                            Text(
                              extent={{80,42},{164,14}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Tests zone state disable condition"),
                            Text(
                              extent={{80,-40},{178,-58}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Tests freeze protection disable condition")}),
                        Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable</a>
for the zone state and freeze protection stage control signals.
</p>
</html>",                     revisions="<html>
<ul>
<li>
June 13, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Enable_FreProSta_ZonSta;

                    model Enable_TOut_hOut
                      "Model validates economizer disable in case outdoor air conditions are above cutoff"

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutCut(final k=TOutCutoff)
                        "Outdoor air temperature cutoff" annotation (Placement(
                            transformation(extent={{-160,40},{-140,60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutCut1(final k=hOutCutoff)
                        "Outdoor air enthalpy cutoff" annotation (Placement(
                            transformation(extent={{-80,0},{-60,20}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TriggeredTrapezoid
                        TOut(
                        final rising=1000,
                        final falling=800,
                        final amplitude=4,
                        final offset=TOutCutoff - 2) "Outoor air temperature"
                        annotation (Placement(transformation(extent={{-160,80},
                                {-140,100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TriggeredTrapezoid
                        hOut(
                        final amplitude=4000,
                        final offset=hOutCutoff - 2200,
                        final rising=1000,
                        final falling=800) "Outdoor air enthalpy" annotation (
                          Placement(transformation(extent={{-40,40},{-20,60}})));

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable
                        enaDis
                        "Single zone VAV AHU economizer enable disable sequence"
                        annotation (Placement(transformation(extent={{-80,-80},
                                {-60,-60}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable
                        enaDis1
                        "Single zone VAV AHU economizer enable disable sequence"
                        annotation (Placement(transformation(extent={{88,-80},{
                                108,-60}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable
                        enaDis2(use_enthalpy=false)
                        "Single zone VAV AHU economizer enable disable sequence"
                        annotation (Placement(transformation(extent={{220,-80},
                                {240,-60}})));

                      Enable enaDis4(use_enthalpy=false, use_fixed_plus_differential_drybulb=true)
                        "Test fixed and differential dry bulb"
                        annotation (Placement(transformation(extent={{120,100},{140,120}})));
                      CDL.Logical.TriggeredTrapezoid TRet(
                        final rising=1000,
                        final falling=800,
                        final amplitude=4,
                        final offset=TOutCutoff - 4) "Outoor air temperature"
                        annotation (Placement(transformation(extent={{-50,106},{-30,126}})));
                    protected
                      final parameter Real TOutCutoff(
                        final unit="K",
                        final displayUnit="degC",
                        final quantity = "ThermodynamicTemperature")=297.15
                        "Outdoor temperature high limit cutoff";
                      final parameter Real hOutCutoff(
                        final unit="J/kg",
                        final quantity = "SpecificEnergy")=65100
                        "Outdoor air enthalpy high limit cutoff";
                      final parameter Real outDamPosMin=0.1
                        "Minimum outdoor air damper position";
                      final parameter Real outDamPosMax=0.9
                        "Minimum return air damper position";
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutCut(final k=hOutCutoff)
                        "Outdoor air enthalpy cutoff" annotation (Placement(
                            transformation(extent={{-240,0},{-220,20}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutCut1(final k=TOutCutoff)
                        "Outdoor air temperature cutoff" annotation (Placement(
                            transformation(extent={{0,40},{20,60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        hOutBelowCutoff(final k=hOutCutoff - 1000)
                        "Outdoor air enthalpy is slightly below the cutoff"
                        annotation (Placement(transformation(extent={{-240,40},
                                {-220,60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TOutBelowCutoff(final k=TOutCutoff - 2)
                        "Outdoor air temperature is slightly below the cutoff"
                        annotation (Placement(transformation(extent={{54,40},{
                                74,60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        zoneState(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.deadband)
                        "Zone State is deadband" annotation (Placement(
                            transformation(extent={{-200,-50},{-180,-30}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMaxSig(final k=outDamPosMax)
                        "Maximal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-240,-120},
                                {-220,-100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMinSig(final k=outDamPosMin)
                        "Minimal allowed economizer damper position"
                        annotation (Placement(transformation(extent={{-240,-160},
                                {-220,-140}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                        "Freeze Protection Status - Disabled" annotation (
                          Placement(transformation(extent={{-200,-20},{-180,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        supFanSta(final k=true) "Supply fan status signal"
                        annotation (Placement(transformation(extent={{-200,-80},
                                {-180,-60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse
                        booPul(final startTime=10, final period=2000)
                        "Boolean pulse signal" annotation (Placement(
                            transformation(extent={{-200,80},{-180,100}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse
                        booPul1(final startTime=10, final period=2000)
                        "Boolean pulse signal" annotation (Placement(
                            transformation(extent={{-80,40},{-60,60}})));
                      CDL.Logical.Sources.Pulse booPul2(
                        final startTime=10,
                        final period=2000) "Boolean pulse signal"
                        annotation (Placement(transformation(extent={{-90,106},{-70,126}})));
                    equation
                      connect(TOutCut.y, enaDis.TCut) annotation (Line(points={{-138,50},{-112,50},
                              {-112,-62.2},{-81,-62.2}},
                                                    color={0,0,127}));
                      connect(hOutCut.y, enaDis.hCut) annotation (Line(points={{-218,10},{-150,10},
                              {-150,-68},{-81,-68}},color={0,0,127}));
                      connect(freProSta.y, enaDis.uFreProSta)
                        annotation (Line(points={{-178,-10},{-120,-10},{-120,-70},{-81,-70}}, color={255,127,0}));
                      connect(outDamPosMaxSig.y, enaDis.uOutDamPosMax)
                        annotation (Line(points={{-218,-110},{-150,-110},{-150,-76},{-81,-76}}, color={0,0,127}));
                      connect(outDamPosMinSig.y, enaDis.uOutDamPosMin)
                        annotation (Line(points={{-218,-150},{-180,-150},{-180,-120},{-140,-120},{
                              -140,-78},{-81,-78}},                                                                     color={0,0,127}));
                      connect(enaDis.uZonSta, zoneState.y)
                        annotation (Line(points={{-81,-72},{-140,-72},{-140,-40},{-178,-40}}, color={255,127,0}));
                      connect(TOutCut1.y, enaDis1.TCut) annotation (Line(points={{22,50},{30,50},{
                              30,-62.2},{87,-62.2}},
                                              color={0,0,127}));
                      connect(hOutCut1.y, enaDis1.hCut) annotation (Line(points={{-58,10},{10,10},{
                              10,-68},{87,-68}},
                                              color={0,0,127}));
                      connect(hOutBelowCutoff.y, enaDis.hOut)
                        annotation (Line(points={{-218,50},{-180,50},{-180,26},{-130,26},{-130,-66},
                              {-81,-66}},                                                                       color={0,0,127}));
                      connect(TOutBelowCutoff.y, enaDis1.TOut)
                        annotation (Line(points={{76,50},{80,50},{80,-60.6},{87,-60.6}},      color={0,0,127}));
                      connect(booPul.y, TOut.u)
                        annotation (Line(points={{-178,90},{-162,90}}, color={255,0,255}));
                      connect(TOut.y, enaDis.TOut)
                        annotation (Line(points={{-138,90},{-110,90},{-110,-60.6},{-81,-60.6}},
                                                                                            color={0,0,127}));
                      connect(booPul1.y, hOut.u)
                        annotation (Line(points={{-58,50},{-58,50},{-42,50}}, color={255,0,255}));
                      connect(hOut.y, enaDis1.hOut)
                        annotation (Line(points={{-18,50},{-10,50},{-10,20},{20,20},{20,-66},{87,
                              -66}},                                                                    color={0,0,127}));
                      connect(freProSta.y, enaDis1.uFreProSta)
                        annotation (Line(points={{-178,-10},{-30,-10},{-30,-70},{87,-70}}, color={255,127,0}));
                      connect(zoneState.y, enaDis1.uZonSta)
                        annotation (Line(points={{-178,-40},{-160,-40},{-160,-26},{4,-26},{4,-72},{
                              87,-72}},                                                                      color={255,127,0}));
                      connect(outDamPosMaxSig.y, enaDis1.uOutDamPosMax)
                        annotation (Line(points={{-218,-110},{60,-110},{60,-76},{87,-76}},
                                                                                         color={0,0,127}));
                      connect(outDamPosMinSig.y, enaDis1.uOutDamPosMin)
                        annotation (Line(points={{-218,-150},{-180,-150},{-180,-120},{70,-120},{70,
                              -78},{87,-78}},                                                                      color={0,0,127}));
                      connect(TOut.y, enaDis2.TOut)
                        annotation (Line(points={{-138,90},{-138,90},{200,90},{200,-60.6},{219,
                              -60.6}},                                                             color={0,0,127}));
                      connect(TOutCut.y, enaDis2.TCut) annotation (Line(points={{-138,50},{-112,50},
                              {-112,80},{188,80},{188,-62.2},{219,-62.2}},
                                                                       color={0,0,127}));
                      connect(freProSta.y, enaDis2.uFreProSta)
                        annotation (Line(points={{-178,-10},{170,-10},{170,-70},{219,-70}}, color={255,127,0}));
                      connect(zoneState.y, enaDis2.uZonSta)
                        annotation (Line(points={{-178,-40},{-170,-40},{-170,-20},{150,-20},{150,
                              -72},{219,-72}},                                                                    color={255,127,0}));
                      connect(outDamPosMaxSig.y, enaDis2.uOutDamPosMax)
                        annotation (Line(points={{-218,-110},{180,-110},{180,-76},{219,-76}}, color={0,0,127}));
                      connect(outDamPosMinSig.y, enaDis2.uOutDamPosMin)
                        annotation (Line(points={{-218,-150},{-180,-150},{-180,-120},{190,-120},{
                              190,-78},{219,-78}},                                                                    color={0,0,127}));
                      connect(supFanSta.y, enaDis.uSupFan)
                        annotation (Line(points={{-178,-70},{-150,-70},{-150,-74},{-81,-74}}, color={255,0,255}));
                      connect(supFanSta.y, enaDis1.uSupFan)
                        annotation (Line(points={{-178,-70},{-160,-70},{-160,-54},{-40,-54},{-40,
                              -74},{87,-74}},                                                                    color={255,0,255}));
                      connect(supFanSta.y, enaDis2.uSupFan)
                        annotation (Line(points={{-178,-70},{-170,-70},{-170,-50},{140,-50},{140,
                              -74},{219,-74}},                                                                    color={255,0,255}));
                      connect(enaDis4.uFreProSta, enaDis2.uFreProSta) annotation (Line(points={{119,
                              110},{-8,110},{-8,-10},{128,-10},{128,-70},{219,-70}}, color={255,127,
                              0}));
                      connect(enaDis4.uZonSta, enaDis2.uZonSta) annotation (Line(points={{119,108},{
                              -6,108},{-6,-20},{150,-20},{150,-72},{219,-72}}, color={255,127,0}));
                      connect(enaDis4.uSupFan, enaDis2.uSupFan) annotation (Line(points={{119,106},{
                              -4,106},{-4,-50},{140,-50},{140,-74},{219,-74}}, color={255,0,255}));
                      connect(enaDis4.uOutDamPosMax, enaDis2.uOutDamPosMax) annotation (Line(points=
                             {{119,104},{32,104},{32,-110},{180,-110},{180,-76},{219,-76}}, color={0,
                              0,127}));
                      connect(enaDis4.uOutDamPosMin, enaDis2.uOutDamPosMin) annotation (Line(points=
                             {{119,102},{36,102},{36,-120},{190,-120},{190,-78},{219,-78}}, color={0,
                              0,127}));
                      connect(TOutCut1.y, enaDis4.TCut) annotation (Line(points={{22,50},{26,50},{
                              26,117.8},{119,117.8}},
                                               color={0,0,127}));
                      connect(TOutBelowCutoff.y, enaDis4.TOut) annotation (Line(points={{76,50},{96,
                              50},{96,119.4},{119,119.4}},
                                                       color={0,0,127}));
                      connect(booPul2.y, TRet.u)
                        annotation (Line(points={{-68,116},{-52,116}}, color={255,0,255}));
                      connect(TRet.y, enaDis4.TRet)
                        annotation (Line(points={{-28,116},{119,116}}, color={0,0,127}));
                      annotation (
                      experiment(StopTime=1800.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/Validation/Enable_TOut_hOut.mos"
                        "Simulate and plot"),
                      Icon(graphics={
                            Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}),
                            Polygon(lineColor = {0,0,255},
                                    fillColor = {75,138,73},
                                    pattern = LinePattern.None,
                                    fillPattern = FillPattern.Solid,
                                    points={{-36,58},{64,-2},{-36,-62},{-36,58}})}), Diagram(
                            coordinateSystem(preserveAspectRatio=false, extent={{-260,-180},{260,180}}),
                            graphics={Text(
                              extent={{-234,168},{346,116}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Example high limit cutoff conditions:
                      ASHRAE 90.1-2013:
                      Device Type: Fixed Drybulb, Fixed Drybulb + Fixed Differential Drybulb, Fixed Enthalpy + Fixed Drybulb,
                      TOut > 75 degF [24 degC]
                      hOut > 28 Btu/lb [65.1 kJ/kg]"),
                            Text(
                              extent={{-82,-82},{0,-96}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Tests temperature hysteresis"),
                            Text(
                              extent={{80,-80},{156,-96}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Tests enthalpy hysteresis"),
                            Text(
                              extent={{208,-82},{260,-100}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="No enthalpy
sensor"),                   Text(
                              extent={{116,146},{226,114}},
                              lineColor={0,0,0},
                              horizontalAlignment=TextAlignment.Left,
                              textString="Tests fixed + differential drybulb")}),
                    Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Enable</a>
for the following control signals: <code>TOut</code>, <code>TOutCut</code>,
<code>hOut</code>, <code>hOutCut</code>.
</p>
</html>",                     revisions="<html>
<ul>
<li>
July 30, 2019, by Kun Zhang:<br/>
Added validation for fixed plus differential dry bulb temperature cutoff.
</li>
<li>
June 13, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Enable_TOut_hOut;

                    model Limits_Disable
                      "Validation model for the Single zone VAV AHU minimum outdoor air control - damper position limits"

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits
                        damLim1(
                        final yFanMin=yFanMin,
                        final yFanMax=yFanMax,
                        final VOutMin_flow=VOutMin_flow,
                        final VOutDes_flow=VOutDes_flow)
                        "Single zone VAV AHU minimum outdoor air control - damper position limits"
                        annotation (Placement(transformation(extent={{-100,-20},
                                {-80,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits
                        damLim2(
                        final yFanMin=yFanMin,
                        final yFanMax=yFanMax,
                        final VOutMin_flow=VOutMin_flow,
                        final VOutDes_flow=VOutDes_flow)
                        "Single zone VAV AHU minimum outdoor air control - damper position limits"
                        annotation (Placement(transformation(extent={{20,-20},{
                                40,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits
                        damLim3(
                        final yFanMin=yFanMin,
                        final yFanMax=yFanMax,
                        final VOutMin_flow=VOutMin_flow,
                        final VOutDes_flow=VOutDes_flow)
                        "Single zone VAV AHU minimum outdoor air control - damper position limits"
                        annotation (Placement(transformation(extent={{140,-20},
                                {160,0}})));

                    protected
                      final parameter Real yFanMin=0.1 "Minimum supply fan operation speed";
                      final parameter Real yFanMax=0.9 "Maximum supply fan operation speed";
                      final parameter Real VOutDes_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=2.0
                        "Calculated design outdoor airflow rate";
                      final parameter Real VOutMin_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=1.0
                        "Calculated minimum outdoor airflow rate";
                      final parameter Real VOutSet_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=0.71
                        "Example volumetric airflow setpoint, 15cfm/occupant, 100 occupants";
                      final parameter Real minVOutSet_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=0.61
                        "Volumetric airflow sensor output, minimum value in the example";
                      final parameter Real incVOutSet_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=0.2
                        "Maximum increase in airflow volume during the example simulation";

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        SupFanSpeSig(
                        final duration=1800,
                        final offset=yFanMin,
                        final height=yFanMax - yFanMin)
                        "Supply fan speed signal" annotation (Placement(
                            transformation(extent={{-160,20},{-140,40}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        VOutMinSetSig(
                        final duration=1800,
                        final offset=VOutMin_flow,
                        final height=VOutDes_flow - VOutMin_flow)
                        "Constant minimum outdoor airflow setpoint" annotation
                        (Placement(transformation(extent={{-160,60},{-140,80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        fanStatus1(final k=false) "Fan is off" annotation (
                          Placement(transformation(extent={{-160,-40},{-140,-20}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta1(k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                        "Freeze protection stage is 1" annotation (Placement(
                            transformation(extent={{-160,-100},{-140,-80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        operationMode1(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                        "AHU operation mode is Occupied" annotation (Placement(
                            transformation(extent={{-160,-70},{-140,-50}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        fanStatus2(final k=true) "Fan is on" annotation (
                          Placement(transformation(extent={{-40,-40},{-20,-20}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta2(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage1)
                        "Freeze protection stage is 1" annotation (Placement(
                            transformation(extent={{-40,-100},{-20,-80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        operationMode2(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                        "AHU operation mode is NOT occupied" annotation (
                          Placement(transformation(extent={{-40,-70},{-20,-50}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        fanStatus3(final k=true) "Fan is on" annotation (
                          Placement(transformation(extent={{80,-40},{100,-20}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta3(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage2)
                        "Freeze protection stage is 2" annotation (Placement(
                            transformation(extent={{80,-100},{100,-80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        operationMode3(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                        "AHU operation mode is occupied" annotation (Placement(
                            transformation(extent={{80,-70},{100,-50}})));

                    equation
                      connect(SupFanSpeSig.y, damLim1.uSupFanSpe)
                        annotation (Line(points={{-138,30},{-120,30},{-120,-6},{-120,-6.2},{-102,-6.2},
                              {-102,-6}},
                        color={0,0,127}));
                      connect(VOutMinSetSig.y, damLim2.VOutMinSet_flow)
                        annotation (Line(points={{-138,70},{-10,70},{-10,-2},{18,-2}},  color={0,0,127}));
                      connect(fanStatus1.y, damLim1.uSupFan)
                        annotation (Line(points={{-138,-30},{-130,-30},{-130,-12},{-130,-12},{-102,-12},
                              {-102,-10}},
                        color={255,0,255}));
                      connect(freProSta1.y, damLim1.uFreProSta)
                        annotation (Line(points={{-138,-90},{-110,-90},{-110,-14},{-102,-14}}, color={255,127,0}));
                      connect(operationMode1.y, damLim1.uOpeMod)
                        annotation (Line(points={{-138,-60},{-120,-60},{-120,-18.2},{-102,-18.2}},
                                                                                               color={255,127,0}));
                      connect(fanStatus2.y,damLim2. uSupFan)
                        annotation (Line(points={{-18,-30},{-10,-30},{-10,-10},{18,-10}}, color={255,0,255}));
                      connect(freProSta2.y,damLim2. uFreProSta)
                        annotation (Line(points={{-18,-90},{10,-90},{10,-14},{18,-14}}, color={255,127,0}));
                      connect(operationMode2.y,damLim2. uOpeMod)
                        annotation (Line(points={{-18,-60},{0,-60},{0,-18.2},{18,-18.2}},
                          color={255,127,0}));
                      connect(fanStatus3.y,damLim3. uSupFan)
                        annotation (Line(points={{102,-30},{102,-30},{110,-30},{110,-10},{138,-10}},
                        color={255,0,255}));
                      connect(freProSta3.y,damLim3. uFreProSta)
                        annotation (Line(points={{102,-90},{130,-90},{130,-14},{138,-14}},color={255,127,0}));
                      connect(operationMode3.y,damLim3. uOpeMod)
                        annotation (Line(points={{102,-60},{120,-60},{120,-18.2},{138,-18.2}},
                        color={255,127,0}));
                      connect(VOutMinSetSig.y, damLim3.VOutMinSet_flow)
                        annotation (Line(points={{-138,70},{130,70},{130,-2},{138,-2}},
                        color={0,0,127}));
                      connect(VOutMinSetSig.y, damLim1.VOutMinSet_flow)
                        annotation (Line(points={{-138,70},{-110,70},{-110,-2},{-102,-2}},
                        color={0,0,127}));
                      connect(SupFanSpeSig.y, damLim2.uSupFanSpe)
                        annotation (Line(points={{-138,30},{-20,30},{-20,-6},{0,-6},{0,-6},{18,-6}},
                        color={0,0,127}));
                      connect(SupFanSpeSig.y, damLim3.uSupFanSpe)
                        annotation (Line(points={{-138,30},{120,30},{120,-6},{130,-6},{130,-6},{138,
                              -6}},
                        color={0,0,127}));
                      annotation (
                      experiment(StopTime=1800.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/Validation/Limits_Disable.mos"
                        "Simulate and plot"),
                        Icon(graphics={Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}), Polygon(
                              lineColor={0,0,255},
                              fillColor={75,138,73},
                              pattern=LinePattern.None,
                              fillPattern=FillPattern.Solid,
                              points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-180,-120},{180,120}}), graphics={
                            Text(
                              extent={{-160,110},{-130,100}},
                              lineColor={0,0,0},
                              lineThickness=0.5,
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              horizontalAlignment=TextAlignment.Left,
                              textString="Fan status"),
                            Text(
                              extent={{-40,110},{4,98}},
                              lineColor={0,0,0},
                              lineThickness=0.5,
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              horizontalAlignment=TextAlignment.Left,
                              textString="Operation mode"),
                            Text(
                              extent={{80,112},{146,96}},
                              lineColor={0,0,0},
                              lineThickness=0.5,
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              horizontalAlignment=TextAlignment.Left,
                              textString="Freeze protection stage")}),
                    Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits</a>
for the following control signals: <code>VOut_flow</code>, <code>VOutMinSet_flow</code>.
The control loop is always enabled in this example.
</p>
</html>",                     revisions="<html>
<ul>
<li>
July 12, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Limits_Disable;

                    model Limits_FanSpe_VOut_flow
                      "Validation model for the Single zone VAV AHU minimum outdoor air control - damper position limits"

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits
                        damLim(
                        final yFanMin=yFanMin,
                        final yFanMax=yFanMax,
                        final VOutMin_flow=VOutMin_flow,
                        final VOutDes_flow=VOutDes_flow)
                        "Single zone VAV AHU minimum outdoor air control - damper position limits"
                        annotation (Placement(transformation(extent={{-40,-20},
                                {-20,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits
                        damLim1(
                        final yFanMin=yFanMin,
                        final yFanMax=yFanMax,
                        final VOutMin_flow=VOutMin_flow,
                        final VOutDes_flow=VOutDes_flow)
                        "Single zone VAV AHU minimum outdoor air control - damper position limits"
                        annotation (Placement(transformation(extent={{100,-20},
                                {120,0}})));

                    protected
                      final parameter Real yFanMin=0.1 "Minimum supply fan operation speed";
                      final parameter Real yFanMax=0.9 "Maximum supply fan operation speed";
                      final parameter Real fanSpe = (yFanMax + yFanMin)/2 "Constant supply fan speed";
                      final parameter Real VOutDes_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=2.0
                        "Calculated design outdoor airflow rate";
                      final parameter Real VOutMin_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=1.0
                        "Calculated minimum outdoor airflow rate";
                      final parameter Real VOutSet_flow(
                        final unit="m3/s",
                        final quantity="VolumeFlowRate")=(VOutDes_flow + VOutMin_flow)/2
                        "Constant minimum outdoor airflow setpoint";

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        fanStatus(final k=true) "Fan is on" annotation (
                          Placement(transformation(extent={{-120,-20},{-100,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                        "Freeze protection status - disabled" annotation (
                          Placement(transformation(extent={{-120,-100},{-100,-80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                        operationMode(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                        "Operation mode - occupied" annotation (Placement(
                            transformation(extent={{-120,-60},{-100,-40}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        VOutMinSetSig(final k=VOutSet_flow)
                        "Constant minimum outdoor airflow setpoint" annotation
                        (Placement(transformation(extent={{-120,60},{-100,80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        SupFanSpeSig(
                        final duration=1800,
                        final offset=yFanMin,
                        final height=yFanMax - yFanMin)
                        "Supply fan speed signal" annotation (Placement(
                            transformation(extent={{-120,20},{-100,40}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        VOutMinSetSig1(
                        final duration=1800,
                        final offset=VOutMin_flow,
                        final height=VOutDes_flow - VOutMin_flow)
                        "Constant minimum outdoor airflow setpoint" annotation
                        (Placement(transformation(extent={{20,60},{40,80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        SupFanSpeSig1(final k=fanSpe) "Supply fan speed signal"
                        annotation (Placement(transformation(extent={{20,20},{
                                40,40}})));

                    equation
                      connect(freProSta.y, damLim.uFreProSta)
                        annotation (Line(points={{-98,-90},{-60,-90},{-60,-14},{-42,-14}}, color={255,127,0}));
                      connect(damLim.uSupFan, fanStatus.y)
                        annotation (Line(points={{-42,-10},{-70,-10},{-70,-10},{-98,-10}}, color={255,0,255}));
                      connect(operationMode.y, damLim.uOpeMod)
                        annotation (Line(points={{-98,-50},{-70,-50},{-70,-18.2},{-42,-18.2}},
                        color={255,127,0}));
                      connect(fanStatus.y, damLim1.uSupFan)
                        annotation (Line(points={{-98,-10},{-80,-10},{-80,-30},{60,-30},{60,-10},{98,
                              -10}},                                                                        color={255,0,255}));
                      connect(operationMode.y, damLim1.uOpeMod)
                        annotation (Line(points={{-98,-50},{70,-50},{70,-18.2},{98,-18.2}},
                                                                                         color={255,127,0}));
                      connect(freProSta.y, damLim1.uFreProSta)
                        annotation (Line(points={{-98,-90},{80,-90},{80,-14},{98,-14}}, color={255,127,0}));
                      connect(VOutMinSetSig.y, damLim.VOutMinSet_flow)
                        annotation (Line(points={{-98,70},{-60,70},{-60,-2},{-42,-2}}, color={0,0,127}));
                      connect(SupFanSpeSig.y, damLim.uSupFanSpe)
                        annotation (Line(points={{-98,30},{-70,30},{-70,-6},{-42,-6}},     color={0,0,127}));
                      connect(SupFanSpeSig1.y, damLim1.uSupFanSpe)
                        annotation (Line(points={{42,30},{70,30},{70,-6},{98,-6}},     color={0,0,127}));
                      connect(VOutMinSetSig1.y, damLim1.VOutMinSet_flow)
                        annotation (Line(points={{42,70},{80,70},{80,-2},{98,-2}}, color={0,0,127}));
                      annotation (
                      experiment(StopTime=1800.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/Validation/Limits_FanSpe_VOut_flow.mos"
                        "Simulate and plot"),
                        Icon(graphics={Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}), Polygon(
                              lineColor={0,0,255},
                              fillColor={75,138,73},
                              pattern=LinePattern.None,
                              fillPattern=FillPattern.Solid,
                              points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,-120},{140,120}}), graphics={
                            Text(
                              extent={{-126,114},{-2,98}},
                              lineColor={0,0,0},
                              lineThickness=0.5,
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              horizontalAlignment=TextAlignment.Left,
                              textString="Variable supply fan speed,
constant minimum outdoor airflow setpoint"),
                            Text(
                              extent={{8,110},{140,96}},
                              lineColor={0,0,0},
                              lineThickness=0.5,
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              horizontalAlignment=TextAlignment.Left,
                              textString="Variable minimum outdoor airflow setpoint,
constant supply fan speed
")}),               Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Limits</a>
for the following control signals: <code>VOut_flow</code>, <code>VOutMinSet_flow</code>.
The control loop is always enabled in this example.
</p>
</html>",                     revisions="<html>
<ul>
<li>
July 12, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Limits_FanSpe_VOut_flow;

                    model Modulation_TSup
                      "Validation model for single zone VAV AHU outdoor and return air damper position modulation sequence"

                      final parameter Real TSupSet(
                        final unit="K",
                        final displayUnit="degC",
                        final quantity="ThermodynamicTemperature")=291.15
                        "Supply air temperature setpoint";

                      hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Modulation
                        mod "Economizer modulation sequence" annotation (
                          Placement(transformation(extent={{40,20},{60,40}})));

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        TSupSetSig(final k=TSupSet)
                        "Supply air temperature setpoint" annotation (Placement(
                            transformation(extent={{-20,60},{0,80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                        TSup(
                        final duration=900,
                        final height=4,
                        final offset=TSupSet - 2)
                        "Measured supply air temperature" annotation (Placement(
                            transformation(extent={{-60,60},{-40,80}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMin(final k=0.1)
                        "Minimum outdoor air damper position" annotation (
                          Placement(transformation(extent={{-80,-20},{-60,0}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        outDamPosMax(final k=0.9)
                        "Maximum outdoor air damper position" annotation (
                          Placement(transformation(extent={{-80,10},{-60,30}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        RetDamPosMin(final k=0.1)
                        "Minimum return air damper position" annotation (
                          Placement(transformation(extent={{-80,-80},{-60,-60}})));
                      hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                        RetDamPosMax(final k=0.9)
                        "Maximum return air damper position" annotation (
                          Placement(transformation(extent={{-80,-50},{-60,-30}})));

                      hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                        fanStatus(k=true) "Fan is on" annotation (Placement(
                            transformation(extent={{0,-10},{20,10}})));
                    equation
                      connect(TSupSetSig.y, mod.THeaSupSet)
                        annotation (Line(points={{2,70},{10,70},{10,48},{10,36},{38,36}},color={0,0,127}));
                      connect(TSup.y,mod.TSup)
                        annotation (Line(points={{-38,70},{-30,70},{-30,38},{38,38}},color={0,0,127}));
                      connect(RetDamPosMax.y, mod.uRetDamPosMax)
                        annotation (Line(points={{-58,-40},{-20,-40},{-20,32},{38,32}}, color={0,0,127}));
                      connect(RetDamPosMin.y, mod.uRetDamPosMin)
                        annotation (Line(points={{-58,-70},{-10,-70},{-10,30},{38,30}}, color={0,0,127}));
                      connect(outDamPosMax.y, mod.uOutDamPosMax)
                        annotation (Line(points={{-58,20},{-30,20},{-30,26},{38,26}},  color={0,0,127}));
                      connect(outDamPosMin.y, mod.uOutDamPosMin)
                        annotation (Line(points={{-58,-10},{-26,-10},{-26,24},{38,24}},  color={0,0,127}));
                      connect(mod.uSupFan, fanStatus.y)
                        annotation (Line(points={{38,21},{32,21},{32,0},{22,0}}, color={255,0,255}));
                      annotation (
                      experiment(StopTime=900.0, Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Subsequences/Validation/Modulation_TSup.mos"
                        "Simulate and plot"),
                        Icon(graphics={Ellipse(
                              lineColor={75,138,73},
                              fillColor={255,255,255},
                              fillPattern=FillPattern.Solid,
                              extent={{-100,-100},{100,100}}), Polygon(
                              lineColor={0,0,255},
                              fillColor={75,138,73},
                              pattern=LinePattern.None,
                              fillPattern=FillPattern.Solid,
                              points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                        Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Modulation\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences.Modulation</a>
for supply air temeperature <code>TSup</code> and supply air temperature heating setpoint <code>TSupSet</code>
control signals.
</p>
</html>",                     revisions="<html>
<ul>
<li>
July 29, 2019, by Kun Zhang:<br/>
Modified inputs for better representation of results plotting.
</li>
<li>
October 31, 2018, by David Blum:<br/>
Added heating coil output.
</li>
<li>
July 07, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                    end Modulation_TSup;
                  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Subsequences</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),          Icon(graphics={
                          Rectangle(
                            lineColor={200,200,200},
                            fillColor={248,248,248},
                            fillPattern=FillPattern.HorizontalCylinder,
                            extent={{-100.0,-100.0},{100.0,100.0}},
                            radius=25.0),
                          Rectangle(
                            lineColor={128,128,128},
                            extent={{-100.0,-100.0},{100.0,100.0}},
                            radius=25.0),
                          Polygon(
                            origin={8.0,14.0},
                            lineColor={78,138,73},
                            fillColor={78,138,73},
                            pattern=LinePattern.None,
                            fillPattern=FillPattern.Solid,
                            points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
                  end Validation;
                annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains subsequences for single zone VAV AHU economizer control.
</p>
</html>"),        Icon(graphics={
                        Rectangle(
                          lineColor={200,200,200},
                          fillColor={248,248,248},
                          fillPattern=FillPattern.HorizontalCylinder,
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Rectangle(
                          lineColor={128,128,128},
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Ellipse(
                          origin={10.0,10.0},
                          lineColor={128,128,128},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid,
                          extent={{-80.0,0.0},{-20.0,60.0}}),
                        Ellipse(
                          origin={10.0,10.0},
                          fillColor={128,128,128},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{0.0,0.0},{60.0,60.0}}),
                        Ellipse(
                          origin={10.0,10.0},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{0.0,-80.0},{60.0,-20.0}}),
                        Ellipse(
                          origin={10.0,10.0},
                          fillColor={76,76,76},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          extent={{-80.0,-80.0},{-20.0,-20.0}})}));
                end Subsequences;

                package Validation "Collection of validation models"

                  model Controller_Disable
                    "Validation model for disabling the single zone VAV AHU economizer modulation and damper position limit control loops"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller
                      economizer(
                      final use_enthalpy=true,
                      final yFanMin=yFanMin,
                      final yFanMax=yFanMax,
                      final VOutMin_flow=VOutMin_flow,
                      final VOutDes_flow=VOutDes_flow,
                      use_TMix=false,
                      use_G36FrePro=true) "Single zone VAV AHU economizer"
                      annotation (Placement(transformation(extent={{20,0},{40,
                              20}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller
                      economizer1(
                      final use_enthalpy=true,
                      final yFanMin=yFanMin,
                      final yFanMax=yFanMax,
                      final VOutMin_flow=VOutMin_flow,
                      final VOutDes_flow=VOutDes_flow,
                      use_TMix=false,
                      use_G36FrePro=true) "Single zone VAV AHU economizer"
                      annotation (Placement(transformation(extent={{100,-20},{
                              120,0}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller
                      economizer2(
                      final yFanMin=yFanMin,
                      final yFanMax=yFanMax,
                      final VOutMin_flow=VOutMin_flow,
                      final VOutDes_flow=VOutDes_flow,
                      use_TMix=true,
                      use_G36FrePro=false,
                      final use_enthalpy=false)
                      "Single zone VAV AHU economizer" annotation (Placement(
                          transformation(extent={{180,-40},{200,-20}})));

                  protected
                    final parameter Real TOutCutoff(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")=297.15
                      "Outdoor temperature high limit cutoff";
                    final parameter Real hOutCutoff(
                      final unit="J/kg",
                      final quantity="SpecificEnergy")=65100
                      "Outdoor air enthalpy high limit cutoff";
                    final parameter Real TSupSet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")=291.15 "Supply air temperature setpoint";
                    final parameter Real yFanMin(
                      final min=0,
                      final max=1,
                      final unit="1")=0.1 "Minimum supply fan operation speed";
                    final parameter Real yFanMax(
                      final min=0,
                      final max=1,
                      final unit="1")=0.9 "Maximum supply fan operation speed";
                    final parameter Real VOutMin_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")=1.0
                      "Calculated minimum outdoor airflow rate";
                    final parameter Real VOutDes_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate")=2.0
                      "Calculated design outdoor airflow rate";

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      fanSta(final k=true) "Fan is on" annotation (Placement(
                          transformation(extent={{-40,-20},{-20,0}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                      "Freeze protection stage is 0" annotation (Placement(
                          transformation(extent={{-80,-130},{-60,-110}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      zonSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.heating)
                      "Zone State is heating" annotation (Placement(
                          transformation(extent={{-80,-70},{-60,-50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      opeMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "AHU operation mode is Occupied" annotation (Placement(
                          transformation(extent={{-80,-100},{-60,-80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      hOutBelowCutoff(final k=hOutCutoff - 40000)
                      "Outdoor air enthalpy is below the cutoff" annotation (
                        Placement(transformation(extent={{-120,10},{-100,30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TSupSetSig(final k=TSupSet)
                      "Heating supply air temperature setpoint" annotation (
                        Placement(transformation(extent={{-80,40},{-60,60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      freProSta2(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage2)
                      "Freeze protection stage is 2" annotation (Placement(
                          transformation(extent={{60,-130},{80,-110}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      hOutCut(final k=hOutCutoff) "Outdoor air enthalpy cutoff"
                      annotation (Placement(transformation(extent={{-120,-30},{
                              -100,-10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TOutBelowCutoff(final k=TOutCutoff - 30)
                      "Outdoor air temperature is below the cutoff" annotation
                      (Placement(transformation(extent={{-120,100},{-100,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TOutCut1(final k=TOutCutoff)
                      "Outdoor temperature high limit cutoff" annotation (
                        Placement(transformation(extent={{-120,60},{-100,80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      TSup(
                      final height=4,
                      final offset=TSupSet - 2,
                      final duration=1800) "Supply air temperature" annotation
                      (Placement(transformation(extent={{-80,80},{-60,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      VOutMinSetSig(
                      final duration=1800,
                      final offset=VOutMin_flow,
                      final height=VOutDes_flow - VOutMin_flow)
                      "Minimum outdoor airflow setpoint" annotation (Placement(
                          transformation(extent={{-40,80},{-20,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      SupFanSpeSig(
                      final duration=1800,
                      final offset=yFanMin,
                      final height=yFanMax - yFanMin) "Supply fan speed signal"
                      annotation (Placement(transformation(extent={{-40,40},{-20,
                              60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                      sin1(
                      amplitude=20,
                      freqHz=1/1800,
                      offset=272.15,
                      startTime=0) "Mixed air temperature" annotation (
                        Placement(transformation(extent={{140,-78},{160,-60}})));

                  equation
                    connect(fanSta.y, economizer.uSupFan)
                      annotation (Line(points={{-18,-10},{-10,-10},{-10,4.4},{19,4.4}},
                                                                                   color={255,0,255}));
                    connect(freProSta.y, economizer.uFreProSta)
                      annotation (Line(points={{-58,-120},{0,-120},{0,0.4},{19,0.4}},
                                                                                   color={255,127,0}));
                    connect(TOutBelowCutoff.y, economizer.TOut)
                      annotation (Line(points={{-98,110},{-6,110},{-6,19.4},{19,19.4}},
                                                                                   color={0,0,127}));
                    connect(TOutCut1.y,economizer.TCut)
                      annotation (Line(points={{-98,70},{-98,70},{-8,70},{-8,17.8},{19,17.8}},
                                                                                          color={0,0,127}));
                    connect(hOutBelowCutoff.y, economizer.hOut)
                      annotation (Line(points={{-98,20},{-60,20},{-60,18},{19,18},{19,14.6}},
                                                                                           color={0,0,127}));
                    connect(hOutCut.y,economizer.hCut)
                      annotation (Line(points={{-98,-20},{-60,-20},{-60,2},{-60,13},{19,13}},color={0,0,127}));
                    connect(TSup.y, economizer.TSup)
                      annotation (Line(points={{-58,90},{-50,90},{-50,11.4},{19,11.4}},
                                                                                   color={0,0,127}));
                    connect(TSupSetSig.y, economizer.THeaSupSet)
                      annotation (Line(points={{-58,50},{-52,50},{-52,9.8},{19,9.8}},
                                                                                   color={0,0,127}));
                    connect(TOutCut1.y,economizer1.TCut)
                      annotation (Line(points={{-98,70},{74,70},{74,-2.2},{99,-2.2}},
                                                                                color={0,0,127}));
                    connect(TOutBelowCutoff.y, economizer1.TOut)
                      annotation (Line(points={{-98,110},{80,110},{80,-0.6},{99,-0.6}},
                                                                                  color={0,0,127}));
                    connect(hOutCut.y,economizer1.hCut)
                      annotation (Line(points={{-98,-20},{-90,-20},{-90,-28},{76,-28},{76,-7},{99,
                            -7}},
                      color={0,0,127}));
                    connect(hOutBelowCutoff.y, economizer1.hOut)
                      annotation (Line(points={{-98,20},{-88,20},{-88,-26},{74,-26},{74,-5.4},{99,
                            -5.4}},
                      color={0,0,127}));
                    connect(TSup.y, economizer1.TSup)
                      annotation (Line(points={{-58,90},{-50,90},{-50,118},{82,118},{82,-8.6},{99,
                            -8.6}},
                      color={0,0,127}));
                    connect(TSupSetSig.y, economizer1.THeaSupSet)
                      annotation (Line(points={{-58,50},{-52,50},{-52,68},{72,68},{72,-10.2},{99,-10.2}},
                      color={0,0,127}));
                    connect(fanSta.y, economizer1.uSupFan)
                      annotation (Line(points={{-18,-10},{20,-10},{20,-15.6},{99,-15.6}},
                                                                                      color={255,0,255}));
                    connect(freProSta2.y, economizer1.uFreProSta)
                      annotation (Line(points={{82,-120},{90,-120},{90,-19.6},{99,-19.6}},
                                                                                       color={255,127,0}));
                    connect(zonSta.y, economizer.uZonSta)
                      annotation (Line(points={{-58,-60},{-2,-60},{-2,1.8},{19,1.8}},
                                                                                  color={255,127,0}));
                    connect(opeMod.y, economizer.uOpeMod)
                      annotation (Line(points={{-58,-90},{-4,-90},{-4,3},{19,3}}, color={255,127,0}));
                    connect(opeMod.y, economizer1.uOpeMod)
                      annotation (Line(points={{-58,-90},{20,-90},{20,-17},{99,-17}}, color={255,127,0}));
                    connect(zonSta.y, economizer1.uZonSta)
                      annotation (Line(points={{-58,-60},{22,-60},{22,-18.2},{99,-18.2}},
                                                                                      color={255,127,0}));
                    connect(VOutMinSetSig.y, economizer.VOutMinSet_flow)
                      annotation (Line(points={{-18,90},{0,90},{0,8.4},{19,8.4}},
                                                                                color={0,0,127}));
                    connect(SupFanSpeSig.y, economizer.uSupFanSpe)
                      annotation (Line(points={{-18,50},{0,50},{0,7},{19,7}}, color={0,0,127}));
                    connect(VOutMinSetSig.y, economizer1.VOutMinSet_flow)
                      annotation (Line(points={{-18,90},{78,90},{78,-11.6},{99,-11.6}},
                                                                                    color={0,0,127}));
                    connect(SupFanSpeSig.y, economizer1.uSupFanSpe)
                      annotation (Line(points={{-18,50},{68,50},{68,-13},{99,-13}}, color={0,0,127}));
                    connect(fanSta.y, economizer2.uSupFan)
                      annotation (Line(points={{-18,-10},{-10,-10},{-10,-35.6},{179,-35.6}},
                                                                                         color={255,0,255}));
                    connect(TOutBelowCutoff.y, economizer2.TOut)
                      annotation (Line(points={{-98,110},{164,110},{164,-20.6},{179,-20.6}},
                                                                                         color={0,0,127}));
                    connect(TOutCut1.y,economizer2.TCut)
                      annotation (Line(points={{-98,70},{162,70},{162,-22.2},{179,-22.2}},
                                                                                       color={0,0,127}));
                    connect(TSup.y, economizer2.TSup)
                      annotation (Line(points={{-58,90},{-52,90},{-52,-28.6},{179,-28.6}},
                      color={0,0,127}));
                    connect(TSupSetSig.y, economizer2.THeaSupSet)
                      annotation (Line(points={{-58,50},{-54,50},{-54,-30.2},{179,-30.2}},
                                                                                       color={0,0,127}));
                    connect(VOutMinSetSig.y, economizer2.VOutMinSet_flow)
                      annotation (Line(points={{-18,90},{150,90},{150,-31.6},{179,-31.6}},
                                                                                       color={0,0,127}));
                    connect(SupFanSpeSig.y, economizer2.uSupFanSpe)
                      annotation (Line(points={{-18,50},{148,50},{148,-33},{179,-33}}, color={0,0,127}));
                    connect(sin1.y, economizer2.TMix)
                      annotation (Line(points={{162,-69},{170,-69},{170,-34.4},{179,-34.4}},
                                                                                         color={0,0,127}));
                    connect(opeMod.y, economizer2.uOpeMod)
                      annotation (Line(points={{-58,-90},{60,-90},{60,-37},{179,-37}}, color={255,127,0}));
                    connect(zonSta.y, economizer2.uZonSta)
                      annotation (Line(points={{-58,-60},{62,-60},{62,-38.2},{179,-38.2}},
                                                                                       color={255,127,0}));
                    annotation (
                      experiment(StopTime=1800.0, Tolerance=1e-06),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Validation/Controller_Disable.mos"
                      "Simulate and plot"),
                    Icon(graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent={{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points={{-36,58},{64,-2},{-36,-62},{-36,58}})}), Diagram(
                          coordinateSystem(preserveAspectRatio=false, extent={{-140,-160},{220,160}}),
                          graphics={
                          Text(
                            extent={{20,148},{166,124}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Disable modulation
(zone state is heating),
enable minimal
outdoor air control"),    Text(
                            extent={{100,148},{212,120}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Disable modulation
(zone state is heating)
disable minimal
outdoor air control
(freeze protection is at stage2)"),
                          Text(
                            extent={{180,10},{238,-18}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Overide damper positions
based on the TMix tracking
freeze protection ")}),
                  Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller</a>
for control signals which disable modulation control loop only (<code>economizer</code> block)
and both minimum outdoor airflow and modulation control loops (<code>economizer1</code> block).
</p>
</html>",                   revisions="<html>
<ul>
<li>
June 12, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Controller_Disable;

                  model Controller_Mod_DamLim
                    "Validation model for single zone VAV AHU economizer operation: damper modulation and minimum ooutdoor air requirement damper position limits"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller
                      economizer(
                      final use_enthalpy=true,
                      final yFanMin=yFanMin,
                      final yFanMax=yFanMax,
                      final VOutMin_flow=VOutMin_flow,
                      final VOutDes_flow=VOutDes_flow,
                      use_G36FrePro=true,
                      use_TMix=false) "Single zone VAV AHU economizer"
                      annotation (Placement(transformation(extent={{20,0},{40,
                              20}})));
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller
                      economizer1(
                      final use_enthalpy=false,
                      final yFanMin=yFanMin,
                      final yFanMax=yFanMax,
                      final VOutMin_flow=VOutMin_flow,
                      final VOutDes_flow=VOutDes_flow,
                      use_G36FrePro=true,
                      use_TMix=false) "Single zone VAV AHU economizer"
                      annotation (Placement(transformation(extent={{100,-40},{
                              120,-20}})));

                  protected
                    parameter Real TOutCutoff(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")=297.15
                      "Outdoor temperature high limit cutoff";
                    parameter Real hOutCutoff(
                      final unit="J/kg",
                      final quantity="SpecificEnergy")=65100
                      "Outdoor air enthalpy high limit cutoff";
                    parameter Real TSupSet(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")=291.15
                      "Supply air temperature Heating setpoint";
                    parameter Real TSup(
                      final unit="K",
                      final displayUnit="degC",
                      final quantity="ThermodynamicTemperature")=290.15
                      "Measured supply air temperature";
                    parameter Real yFanMin(
                      final min=0,
                      final max=1,
                      final unit="1") = 0.1 "Minimum supply fan operation speed";
                    parameter Real yFanMax(
                      final min=0,
                      final max=1,
                      final unit="1") = 0.9 "Maximum supply fan operation speed";
                    parameter Real VOutMin_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate") = 1.0 "Calculated minimum outdoor airflow rate";
                    parameter Real VOutDes_flow(
                      final unit="m3/s",
                      final quantity="VolumeFlowRate") = 2.0 "Calculated design outdoor airflow rate";

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      fanSta(k=true) "Fan is on" annotation (Placement(
                          transformation(extent={{-80,-90},{-60,-70}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      freProSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.FreezeProtectionStages.stage0)
                      "Freeze protection status is 0" annotation (Placement(
                          transformation(extent={{-80,-130},{-60,-110}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      zonSta(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.ZoneStates.deadband)
                      "Zone State is deadband" annotation (Placement(
                          transformation(extent={{-120,-70},{-100,-50}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      opeMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "AHU operation mode is Occupied" annotation (Placement(
                          transformation(extent={{-120,-110},{-100,-90}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      hOutBelowCutoff(final k=hOutCutoff - 10000)
                      "Outdoor air enthalpy is slightly below the cutoff"
                      annotation (Placement(transformation(extent={{-120,10},{-100,
                              30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      hOutCut(final k=hOutCutoff) "Outdoor air enthalpy cutoff"
                      annotation (Placement(transformation(extent={{-120,-30},{
                              -100,-10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TOutBelowCutoff(final k=TOutCutoff - 5)
                      "Outdoor air temperature is slightly below the cutoff"
                      annotation (Placement(transformation(extent={{-120,100},{
                              -100,120}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TOutCut1(final k=TOutCutoff)
                      "Outdoor temperature high limit cutoff" annotation (
                        Placement(transformation(extent={{-120,60},{-100,80}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TSupSetSig(final k=TSupSet)
                      "Heating supply air temperature setpoint" annotation (
                        Placement(transformation(extent={{-80,40},{-60,60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TSupSig(final k=TSup) "Measured supply air temperature"
                      annotation (Placement(transformation(extent={{-80,80},{-60,
                              100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      TSupSig1(
                      final duration=900,
                      final height=2,
                      final offset=TSupSet - 1)
                      "Measured supply air temperature" annotation (Placement(
                          transformation(extent={{40,80},{60,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      VOutMinSetSig(
                      final duration=1800,
                      final offset=VOutMin_flow,
                      final height=VOutDes_flow - VOutMin_flow)
                      "Minimum outdoor airflow setpoint" annotation (Placement(
                          transformation(extent={{-40,80},{-20,100}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      SupFanSpeSig(
                      final duration=1800,
                      final offset=yFanMin,
                      final height=yFanMax - yFanMin) "Supply fan speed signal"
                      annotation (Placement(transformation(extent={{-40,40},{-20,
                              60}})));

                  equation
                    connect(fanSta.y, economizer.uSupFan)
                      annotation (Line(points={{-58,-80},{-14,-80},{-14,4.4},{19,4.4}},
                                                                                    color={255,0,255}));
                    connect(freProSta.y, economizer.uFreProSta)
                      annotation (Line(points={{-58,-120},{0,-120},{0,0.4},{19,0.4}},
                                                                                    color={255,127,0}));
                    connect(opeMod.y, economizer.uOpeMod)
                      annotation (Line(points={{-98,-100},{-50,-100},{-50,-30},{-4,-30},{-4,3},{19,
                            3}},
                      color={255,127,0}));
                    connect(zonSta.y, economizer.uZonSta)
                      annotation (Line(points={{-98,-60},{-48,-60},{-48,-32},{-2,-32},{-2,1.8},{19,
                            1.8}},
                      color={255,127,0}));
                    connect(TOutBelowCutoff.y, economizer.TOut)
                      annotation (Line(points={{-98,110},{-6,110},{-6,19.4},{19,19.4}},
                                                                                   color={0,0,127}));
                    connect(TOutCut1.y,economizer.TCut)
                      annotation (Line(points={{-98,70},{-10,70},{-10,17.8},{19,17.8}},
                                                                                    color={0,0,127}));
                    connect(hOutBelowCutoff.y, economizer.hOut)
                      annotation (Line(points={{-98,20},{-60,20},{-60,18},{19,18},{19,14.6}},
                                                                                           color={0,0,127}));
                    connect(hOutCut.y,economizer.hCut)
                      annotation (Line(points={{-98,-20},{-60,-20},{-60,2},{-60,13},{19,13}},color={0,0,127}));
                    connect(TSupSetSig.y, economizer.THeaSupSet)
                      annotation (Line(points={{-58,50},{-52,50},{-52,9.8},{19,9.8}},
                                                                                   color={0,0,127}));
                    connect(TSupSig.y, economizer.TSup)
                      annotation (Line(points={{-58,90},{-50,90},{-50,11.4},{19,11.4}},
                                                                                    color={0,0,127}));
                    connect(TOutBelowCutoff.y, economizer1.TOut)
                      annotation (Line(points={{-98,110},{90,110},{90,-20.6},{99,-20.6}},
                                                                                      color={0,0,127}));
                    connect(TOutCut1.y,economizer1.TCut)
                      annotation (Line(points={{-98,70},{88,70},{88,-22.2},{99,-22.2}},
                                                                                    color={0,0,127}));
                    connect(TSupSig1.y, economizer1.TSup)
                      annotation (Line(points={{62,90},{80,90},{80,-28.6},{99,-28.6}},
                                                                                   color={0,0,127}));
                    connect(TSupSetSig.y, economizer1.THeaSupSet)
                      annotation (Line(points={{-58,50},{-54,50},{-54,-16},{20,-16},{20,-30.2},{99,
                            -30.2}},
                      color={0,0,127}));
                    connect(fanSta.y, economizer1.uSupFan)
                      annotation (Line(points={{-58,-80},{20,-80},{20,-35.6},{99,-35.6}},
                                                                                      color={255,0,255}));
                    connect(freProSta.y, economizer1.uFreProSta)
                      annotation (Line(points={{-58,-120},{26,-120},{26,-39.6},{99,-39.6}},
                                                                                        color={255,127,0}));
                    connect(hOutBelowCutoff.y, economizer1.hOut)
                      annotation (Line(points={{-98,20},{-64,20},{-64,-12},{24,-12},{24,-25.4},{99,
                            -25.4}},
                      color={0,0,127}));
                    connect(hOutCut.y,economizer1.hCut)
                      annotation (Line(points={{-98,-20},{-20,-20},{-20,-27},{99,-27}}, color={0,0,127}));
                    connect(opeMod.y, economizer1.uOpeMod)
                      annotation (Line(points={{-98,-100},{22,-100},{22,-37},{99,-37}}, color={255,127,0}));
                    connect(zonSta.y, economizer1.uZonSta)
                      annotation (Line(points={{-98,-60},{24,-60},{24,-38.2},{99,-38.2}},
                                                                                      color={255,127,0}));
                    connect(VOutMinSetSig.y, economizer.VOutMinSet_flow)
                      annotation (Line(points={{-18,90},{0,90},{0,8.4},{19,8.4}},
                                                                                color={0,0,127}));
                    connect(VOutMinSetSig.y, economizer1.VOutMinSet_flow)
                      annotation (Line(points={{-18,90},{14,90},{14,-30},{99,-30},{99,-31.6}},
                                                                                             color={0,0,127}));
                    connect(SupFanSpeSig.y, economizer.uSupFanSpe)
                      annotation (Line(points={{-18,50},{-2,50},{-2,7},{19,7}}, color={0,0,127}));
                    connect(SupFanSpeSig.y, economizer1.uSupFanSpe)
                      annotation (Line(points={{-18,50},{78,50},{78,-33},{99,-33}}, color={0,0,127}));
                    annotation (
                      experiment(StopTime=900.0, Tolerance=1e-06),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Economizers/Validation/Controller_Mod_DamLim.mos"
                      "Simulate and plot"),
                    Icon(graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent={{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points={{-36,58},{64,-2},{-36,-62},{-36,58}})}), Diagram(
                          coordinateSystem(preserveAspectRatio=false, extent={{-140,-160},{140,160}}),
                          graphics={
                          Rectangle(
                            extent={{-136,-44},{-44,-156}},
                            lineColor={0,0,0},
                            fillColor={215,215,215},
                            fillPattern=FillPattern.Solid),
                          Text(
                            extent={{-128,-132},{-22,-154}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Enable both damper limit
and modulation control loops"),
                          Text(
                            extent={{100,6},{154,-16}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Validate damper modulation
(example without
enthalpy measurement)"),  Text(
                            extent={{20,42},{84,22}},
                            lineColor={0,0,0},
                            horizontalAlignment=TextAlignment.Left,
                            textString="Economizer fully enabled -
validate damper position limits")}),
                  Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers.Controller</a> control loops:
minimum outdoor air damper position limits control loop (<code>economizer</code> block) and modulation
control loop (<code>economizer1</code> block) for <code>VOut_flow</code> and <code>TSup</code> control signals.
Both control loops are enabled during the validation test.
</p>
</html>",                   revisions="<html>
<ul>
<li>
June 12, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
                  end Controller_Mod_DamLim;
                annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Economizers</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),        Icon(graphics={
                        Rectangle(
                          lineColor={200,200,200},
                          fillColor={248,248,248},
                          fillPattern=FillPattern.HorizontalCylinder,
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Rectangle(
                          lineColor={128,128,128},
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Polygon(
                          origin={8.0,14.0},
                          lineColor={78,138,73},
                          fillColor={78,138,73},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
                end Validation;
              annotation (preferredView="info", Documentation(info="<html>
<p>
The package contains a single zone VAV AHU economizer
control sequence and the related economizer subsequences.
</p>
</html>"),      Icon(graphics={
                      Rectangle(
                        lineColor={200,200,200},
                        fillColor={248,248,248},
                        fillPattern=FillPattern.HorizontalCylinder,
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Rectangle(
                        lineColor={128,128,128},
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Ellipse(
                        origin={10.0,10.0},
                        lineColor={128,128,128},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid,
                        extent={{-80.0,0.0},{-20.0,60.0}}),
                      Ellipse(
                        origin={10.0,10.0},
                        fillColor={128,128,128},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        extent={{0.0,0.0},{60.0,60.0}}),
                      Ellipse(
                        origin={10.0,10.0},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        extent={{0.0,-80.0},{60.0,-20.0}}),
                      Ellipse(
                        origin={10.0,10.0},
                        fillColor={76,76,76},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        extent={{-80.0,-80.0},{-20.0,-20.0}})}));
              end Economizers;

              package SetPoints "Output setpoints for AHU control"

                block ExhaustDamper
                  "Control of actuated exhaust  dampers without fans"
                  parameter Real minExhDamPos(
                    min=0,
                    max=1,
                    final unit="1") = 0.2
                    "Exhaust damper position maintaining building static pressure at setpoint when the system is at minPosMin"
                    annotation(Dialog(group="Nominal parameters"));
                  parameter Real maxExhDamPos(
                    min=0,
                    max=1,
                    final unit="1") = 0.9
                    "Exhaust damper position maintaining building static pressure at setpoint when outdoor air damper is fully open and fan speed is at cooling maximum"
                    annotation(Dialog(group="Nominal parameters"));
                  parameter Real minOutPosMin(
                    min=0,
                    max=1,
                    final unit="1") = 0.4
                    "Outdoor air damper position when fan operating at minimum speed to supply minimum outdoor air flow"
                    annotation(Dialog(group="Nominal parameters"));
                  parameter Real outDamPhyPosMax(
                    min=0,
                    max=1,
                    final unit="1")=1
                    "Physical or at the comissioning fixed maximum position of the outdoor air damper"
                    annotation(Dialog(group="Nominal parameters"));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                    uSupFan "Supply fan status" annotation (Placement(
                        transformation(extent={{-140,-70},{-100,-30}}),
                        iconTransformation(extent={{-140,-80},{-100,-40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uOutDamPos(
                    min=0,
                    max=1,
                    final unit="1") "Outdoor air damper position" annotation (
                      Placement(transformation(extent={{-140,-20},{-100,20}}),
                        iconTransformation(extent={{-140,40},{-100,80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yExhDamPos(
                    min=0,
                    max=1,
                    final unit="1") "Exhaust damper position" annotation (
                      Placement(transformation(extent={{100,-20},{140,20}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line exhDamPos
                    "Linearly map exhaust damper position to the outdoor air damper position"
                    annotation (Placement(transformation(extent={{20,-10},{40,
                            10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                    "Check if exhaust damper should be open" annotation (
                      Placement(transformation(extent={{60,-60},{80,-40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis greThr(final
                      uLow=0.02, final uHigh=0.05)
                    "Check if outdoor air damper is open" annotation (Placement(
                        transformation(extent={{-60,-40},{-40,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2
                    "Check if exhaust damper should be activated" annotation (
                      Placement(transformation(extent={{-20,-60},{0,-40}})));

                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    zerDam(final k=0) "Close damper when disabled" annotation (
                      Placement(transformation(extent={{20,-90},{40,-70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    minExhDam(final k=minExhDamPos)
                    "Exhaust damper position maintaining building static pressure at setpoint while the system is at minPosMin"
                    annotation (Placement(transformation(extent={{-80,50},{-60,
                            70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    maxExhDam(final k=maxExhDamPos)
                    "Exhaust damper position maintaining building static pressure at setpoint when outdoor air damper is fully open and fan speed is at cooling maximum"
                    annotation (Placement(transformation(extent={{-80,10},{-60,
                            30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    minPosAtMinSpd(final k=minOutPosMin)
                    "Outdoor air damper position when fan operating at minimum speed to supply minimum outdoor air flow"
                    annotation (Placement(transformation(extent={{-40,70},{-20,
                            90}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    outDamPhyPosMaxSig(final k=outDamPhyPosMax)
                    "Physical or at the comissioning fixed maximum position of the outdoor air damper"
                    annotation (Placement(transformation(extent={{-40,30},{-20,
                            50}})));

                equation
                  connect(outDamPhyPosMaxSig.y, exhDamPos.x2)
                    annotation (Line(points={{-18,40},{-4,40},{-4,-4},{18,-4}},
                      color={0,0,127}));
                  connect(maxExhDam.y, exhDamPos.f2)
                    annotation (Line(points={{-58,20},{-12,20},{-12,-8},{18,-8}},
                      color={0,0,127}));
                  connect(uOutDamPos, exhDamPos.u)
                    annotation (Line(points={{-120,0},{18,0}},
                      color={0,0,127}));
                  connect(zerDam.y, swi1.u3)
                    annotation (Line(points={{42,-80},{50,-80},{50,-58},{58,-58}},
                      color={0,0,127}));
                  connect(and2.y, swi1.u2)
                    annotation (Line(points={{2,-50},{58,-50}},
                      color={255,0,255}));
                  connect(minPosAtMinSpd.y, exhDamPos.x1)
                    annotation (Line(points={{-18,80},{12,80},{12,8},{18,8}},
                      color={0,0,127}));
                  connect(minExhDam.y, exhDamPos.f1)
                    annotation (Line(points={{-58,60},{4,60},{4,4},{18,4}},
                      color={0,0,127}));
                  connect(uOutDamPos, greThr.u)
                    annotation (Line(points={{-120,0},{-80,0},{-80,-30},{-62,-30}},
                      color={0,0,127}));
                  connect(uSupFan, and2.u2)
                    annotation (Line(points={{-120,-50},{-60,-50},{-60,-58},{-22,-58}},
                      color={255,0,255}));
                  connect(greThr.y, and2.u1)
                    annotation (Line(points={{-38,-30},{-32,-30},{-32,-50},{-22,-50}},
                      color={255,0,255}));
                  connect(exhDamPos.y, swi1.u1)
                    annotation (Line(points={{42,0},{50,0},{50,-42},{58,-42}},
                      color={0,0,127}));
                  connect(swi1.y, yExhDamPos)
                    annotation (Line(points={{82,-50},{90,-50},{90,0},{120,0}},    color={0,0,127}));

                annotation (
                  defaultComponentName = "exhDam",
                  Icon(graphics={Rectangle(
                        extent={{-100,-100},{100,100}},
                        lineColor={0,0,127},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                        Text(
                          extent={{-96,78},{-42,40}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="uOutDamPos"),
                        Text(
                          extent={{-94,-48},{-62,-72}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="uSupFan"),
                        Text(
                          extent={{46,18},{96,-18}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="yExhDamPos"),
                        Polygon(
                          points={{-46,92},{-54,70},{-38,70},{-46,92}},
                          lineColor={192,192,192},
                          fillColor={192,192,192},
                          fillPattern=FillPattern.Solid),
                        Line(points={{-46,82},{-46,-86}}, color={192,192,192}),
                        Line(points={{-56,-78},{68,-78}}, color={192,192,192}),
                        Polygon(
                          points={{72,-78},{50,-70},{50,-86},{72,-78}},
                          lineColor={192,192,192},
                          fillColor={192,192,192},
                          fillPattern=FillPattern.Solid),
                        Line(points={{-46,-78},{14,62},{80,62}}, color={0,0,127}),
                        Text(
                          extent={{-100,140},{100,100}},
                          lineColor={0,0,255},
                          textString="%name")}),
                   Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                            100}})),
                 Documentation(info="<html>
<p>
Control sequence for exhaust dampers without fans. It is implemented according
to ASHRAE Guidline 35 (G36), PART 5.N.8.(for multi zone VAV AHU), PART 5.P.6
and PART3.2B.3 (for single zone VAV AHU).
</p>

<h4>Single zone VAV AHU: Control of actuated exhaust dampers without fans (PART 5.P.6)</h4>
<ol>
<li>Exhaust damper position setpoints (PART3.2B.3)
<ul>
<li><code>minExhDamPos</code> is the exhaust damper position that maintains a building
pressure of <i>12</i> Pa (<i>0.05</i> inchWC) while the system is at <code>minOutPosMin</code>
(i.e., the economizer damper is positioned to provide minimum outdoor air while
the supply fan is at minimum speed).
</li>
<li>
<code>maxExhDamPos</code> is the exhaust damper position that maintains a building
pressure of <i>12</i> Pa (<i>0.05</i> inchWC) while the economizer damper is fully
open and the fan speed is at cooling maximum.
</li>
</ul>
</li>
<li>
The exhaust damper is enabled when the associated supply fan is proven on and
any outdoor air damper is open <code>uOutDamPos &gt; 0</code> and disabled and closed
otherwise.
</li>
<li>
The exhaust damper position is reset linearly from <code>minExhDamPos</code> to
<code>maxExhDamPos</code> as the commanded economizer damper position goes from
<code>minOutPosMin</code> to <code>outDamPhyPosMax</code>.
</li>
</ol>
<p>
The control sequence is as follows:
</p>
<p align=\"center\">
<img alt=\"Image of the exhaust damper control chart for single zone AHU\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/SetPoints/ExhaustDamper.png\"/>
</p>
</html>",                 revisions="<html>
<ul>
<li>
October 18, 2017, by Michael Wetter:<br/>
Revised documentation.
</li>
<li>
May 12, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                end ExhaustDamper;

                block OutsideAirFlow
                  "Output the minimum outdoor airflow rate setpoint for systems with a single zone"

                  parameter Real VOutPerAre_flow(
                    final unit="m3/(s.m2)") = 3e-4
                    "Outdoor air rate per unit area"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Real VOutPerPer_flow(
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")= 2.5e-3
                    "Outdoor air rate per person"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Real AFlo(
                    final unit="m2",
                    final quantity="Area") "Floor area"
                    annotation(Dialog(group="Nominal condition"));
                  parameter Boolean have_occSen
                    "Set to true if zones have occupancy sensor";
                  parameter Real occDen(final unit="1/m2") = 0.05
                    "Default number of person in unit area";
                  parameter Real zonDisEffHea(final unit="1") = 0.8
                    "Zone air distribution effectiveness during heating";
                  parameter Real zonDisEffCoo(final unit="1") = 1.0
                    "Zone air distribution effectiveness during cooling";
                  parameter Real uLow(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference") = -0.5
                    "If zone space temperature minus supply air temperature is less than uLow,
     then it should use heating supply air distribution effectiveness"
                    annotation (Dialog(tab="Advanced"));
                  parameter Real uHig(
                    final unit="K",
                    final displayUnit="K",
                    final quantity="TemperatureDifference") = 0.5
                    "If zone space temperature minus supply air temperature is more than uHig,
     then it should use cooling supply air distribution effectiveness"
                    annotation (Dialog(tab="Advanced"));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput nOcc(final
                      unit="1") if have_occSen "Number of occupants"
                    annotation (Placement(transformation(extent={{-240,140},{-200,
                            180}}), iconTransformation(extent={{-140,60},{-100,
                            100}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZon(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Measured zone air temperature" annotation (Placement(
                        transformation(extent={{-240,-60},{-200,-20}}),
                        iconTransformation(extent={{-140,-20},{-100,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TDis(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Measured discharge air temperature" annotation (Placement(
                        transformation(extent={{-240,-100},{-200,-60}}),
                        iconTransformation(extent={{-140,-50},{-100,-10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput
                    uOpeMod "AHU operation mode status signal" annotation (
                      Placement(transformation(extent={{-240,-170},{-200,-130}}),
                        iconTransformation(extent={{-140,-110},{-100,-70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                    uSupFan "Supply fan status, true if on, false if off"
                    annotation (Placement(transformation(extent={{-240,-140},{-200,
                            -100}}), iconTransformation(extent={{-140,-80},{-100,
                            -40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput
                    uWin "Window status, true if open, false if closed"
                    annotation (Placement(transformation(extent={{-240,-10},{-200,
                            30}}), iconTransformation(extent={{-140,20},{-100,
                            60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VOutMinSet_flow(
                    min=0,
                    final unit="m3/s",
                    final quantity="VolumeFlowRate")
                    "Effective minimum outdoor airflow setpoint" annotation (
                      Placement(transformation(extent={{200,-20},{240,20}}),
                        iconTransformation(extent={{100,-20},{140,20}})));

                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add breZon
                    "Breathing zone airflow" annotation (Placement(
                        transformation(extent={{-20,70},{0,90}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2(final k1=
                        +1, final k2=-1)
                    "Zone space temperature minus supply air temperature"
                    annotation (Placement(transformation(extent={{-160,-70},{-140,
                            -50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai(final k=
                        VOutPerPer_flow) if have_occSen
                    "Outdoor airflow rate per person" annotation (Placement(
                        transformation(extent={{-160,150},{-140,170}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                    "Switch for enabling occupancy sensor input" annotation (
                      Placement(transformation(extent={{-60,38},{-40,58}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                    "Switch between cooling or heating distribution effectiveness"
                    annotation (Placement(transformation(extent={{-40,-70},{-20,
                            -50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division zonOutAirRate
                    "Required zone outdoor airflow rate" annotation (Placement(
                        transformation(extent={{20,20},{40,40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi2 "If window is open or it is not in occupied mode, the required outdoor
    airflow rate should be zero" annotation (Placement(transformation(extent={{
                            80,20},{100,0}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi3
                    "If supply fan is off, then outdoor airflow rate should be zero."
                    annotation (Placement(transformation(extent={{140,0},{160,
                            20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys(
                    uLow=uLow,
                    uHigh=uHig,
                    pre_y_start=true)
                    "Check if cooling or heating air distribution effectiveness should be applied, with 1 degC deadband"
                    annotation (Placement(transformation(extent={{-100,-70},{-80,
                            -50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                    occSen(final k=have_occSen)
                    "Boolean constant to indicate if there is occupancy sensor"
                    annotation (Placement(transformation(extent={{-160,40},{-140,
                            60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    zerOutAir(final k=0)
                    "Zero required outdoor airflow rate when window open or zone is not in occupied mode"
                    annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    disEffHea(final k=zonDisEffHea)
                    "Zone distribution effectiveness during heating"
                    annotation (Placement(transformation(extent={{-100,-100},{-80,
                            -80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    disEffCoo(final k=zonDisEffCoo)
                    "Zone distribution effectiveness for cooling" annotation (
                      Placement(transformation(extent={{-100,-30},{-80,-10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    breZonAre(final k=VOutPerAre_flow*AFlo)
                    "Area component of the breathing zone outdoor airflow"
                    annotation (Placement(transformation(extent={{-60,90},{-40,
                            110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    breZonPop(final k=VOutPerPer_flow*AFlo*occDen)
                    "Population component of the breathing zone outdoor airflow"
                    annotation (Placement(transformation(extent={{-100,20},{-80,
                            40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu1
                    "Check if operation mode is occupied" annotation (Placement(
                        transformation(extent={{-140,-160},{-120,-140}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    occMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                    "Occupied mode index" annotation (Placement(transformation(
                          extent={{-180,-180},{-160,-160}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1
                    "Logical and" annotation (Placement(transformation(extent={
                            {-60,-130},{-40,-110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                    "Logical not" annotation (Placement(transformation(extent={
                            {-20,-130},{0,-110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    zerOcc(final k=0) if not have_occSen
                    "Zero occupant when there is no occupancy sensor"
                    annotation (Placement(transformation(extent={{-160,80},{-140,
                            100}})));

                equation
                  connect(breZonAre.y, breZon.u1)
                    annotation (Line(points={{-38,100},{-30,100},{-30,86},{-22,86}},
                      color={0,0,127}));
                  connect(gai.y, swi.u1)
                    annotation (Line(points={{-138,160},{-70,160},{-70,56},{-62,56}},
                      color={0,0,127}));
                  connect(breZonPop.y, swi.u3)
                    annotation (Line(points={{-78,30},{-70,30},{-70,40},{-62,40}},
                      color={0,0,127}));
                  connect(swi.y, breZon.u2)
                    annotation (Line(points={{-38,48},{-30,48},{-30,74},{-22,74}},
                      color={0,0,127}));
                  connect(disEffCoo.y, swi1.u1)
                    annotation (Line(points={{-78,-20},{-60,-20},{-60,-52},{-42,-52}},
                      color={0,0,127}));
                  connect(disEffHea.y, swi1.u3)
                    annotation (Line(points={{-78,-90},{-60,-90},{-60,-68},{-42,-68}},
                      color={0,0,127}));
                  connect(breZon.y, zonOutAirRate.u1)
                    annotation (Line(points={{2,80},{10,80},{10,36},{18,36}},
                      color={0,0,127}));
                  connect(swi1.y, zonOutAirRate.u2)
                    annotation (Line(points={{-18,-60},{10,-60},{10,24},{18,24}},
                      color={0,0,127}));
                  connect(uWin, swi2.u2)
                    annotation (Line(points={{-220,10},{-190,10},{78,10}}, color={255,0,255}));
                  connect(zerOutAir.y, swi2.u1)
                    annotation (Line(points={{42,-30},{60,-30},{60,2},{78,2}},
                      color={0,0,127}));
                  connect(zonOutAirRate.y, swi2.u3)
                    annotation (Line(points={{42,30},{60,30},{60,18},{78,18}},
                      color={0,0,127}));
                  connect(swi.u2, occSen.y)
                    annotation (Line(points={{-62,48},{-76,48},{-76,50},{-138,50}},
                      color={255,0,255}));
                  connect(nOcc, gai.u)
                    annotation (Line(points={{-220,160},{-162,160}}, color={0,0,127}));
                  connect(swi3.y, VOutMinSet_flow)
                    annotation (Line(points={{162,10},{180,10},{180,0},{220,0}}, color={0,0,127}));
                  connect(TZon, add2.u1)
                    annotation (Line(points={{-220,-40},{-200,-40},{-180,-40},{-180,-54},
                      {-162,-54}}, color={0,0,127}));
                  connect(TDis, add2.u2)
                    annotation (Line(points={{-220,-80},{-180,-80},{-180,-66}, {-162,-66}},
                      color={0,0,127}));
                  connect(add2.y, hys.u)
                    annotation (Line(points={{-138,-60},{-102,-60},{-102,-60}},
                        color={0,0,127}));
                  connect(hys.y, swi1.u2)
                    annotation (Line(points={{-78,-60},{-42,-60},{-42,-60}},
                        color={255,0,255}));
                  connect(swi2.y, swi3.u3)
                    annotation (Line(points={{102,10},{120,10},{120,2},{138,2}}, color={0,0,127}));
                  connect(zerOutAir.y, swi3.u1)
                    annotation (Line(points={{42,-30},{110,-30},{110,18},{138,18}}, color={0,0,127}));
                  connect(and1.y, not1.u)
                    annotation (Line(points={{-38,-120},{-38,-120},{-22,-120}},   color={255,0,255}));
                  connect(not1.y, swi3.u2)
                    annotation (Line(points={{2,-120},{130,-120},{130,10},{138,10}}, color={255,0,255}));
                  connect(uSupFan, and1.u1)
                    annotation (Line(points={{-220,-120},{-62,-120}}, color={255,0,255}));
                  connect(intEqu1.y, and1.u2)
                    annotation (Line(points={{-118,-150},{-90,-150},{-90,-128},{-62,-128}}, color={255,0,255}));
                  connect(uOpeMod, intEqu1.u1)
                    annotation (Line(points={{-220,-150},{-142,-150},{-142,-150}}, color={255,127,0}));
                  connect(occMod.y, intEqu1.u2)
                    annotation (Line(points={{-158,-170},{-150,-170},{-150,-158},{-142,-158}}, color={255,127,0}));
                  connect(swi.u1, zerOcc.y)
                    annotation (Line(points={{-62,56},{-70,56},{-70,90},{-138,90}}, color={0,0,127}));

                annotation (
                defaultComponentName="outAirSetPoi",
                Icon(graphics={Rectangle(
                          extent={{-100,100},{100,-100}},
                          lineColor={0,0,0},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid), Text(
                          extent={{-84,78},{92,-72}},
                          lineColor={0,0,0},
                          textString="VOutMinSet_flow"),
                        Text(
                          extent={{-100,140},{100,100}},
                          lineColor={0,0,255},
                          textString="%name")}),
                        Diagram(
                        coordinateSystem(preserveAspectRatio=false,
                        extent={{-200,-200},{200,200}},
                        initialScale=0.05)),
                 Documentation(info="<html>
<p>
This atomic sequence sets the minimum outdoor airflow setpoint for compliance
with the ventilation rate procedure of ASHRAE 62.1-2013. The implementation
is according to ASHRAE Guidline 36 (G36), PART 5.P.4.b, PART 5.B.2.b, PART3.1-D.2.a.
</p>

<h4>Step 1: Minimum breathing zone outdoor airflow required <code>breZon</code></h4>
<ul>
<li>The area component of the breathing zone outdoor airflow:
<code>breZonAre = AFlo*VOutPerAre_flow</code>.
</li>
<li>The population component of the breathing zone outdoor airflow:
<code>breZonPop = occCou*VOutPerPer_flow</code>.
</li>
</ul>
<p>
The number of occupant <code>occCou</code> could be retrieved
directly from occupancy sensor <code>nOcc</code> if the sensor exists
(<code>have_occSen=true</code>), or using the default occupant density
<code>occDen</code> to find it <code>AFlo*occDen</code>. The occupant
density can be found from Table 6.2.2.1 in ASHRAE Standard 62.1-2013.
</p>

<h4>Step 2: Zone air-distribution effectiveness <code>zonDisEff</code></h4>
<p>
Table 6.2.2.2 in ASHRAE 62.1-2013 lists some typical values for setting the
effectiveness. Depending on difference between zone space temperature
<code>TZon</code> and supply air temperature <code>TDis</code>, Warm-air
effectiveness <code>zonDisEffHea</code> or Cool-air effectiveness
<code>zonDisEffCoo</code> should be applied.
</p>

<h4>Step 3: Minimum required zone outdoor airflow <code>zonOutAirRate</code></h4>
<p>
For each zone in any mode other than occupied mode and for zones that have
window switches and the window is open, <code>zonOutAirRate</code> shall be
zero.
Otherwise, the required zone outdoor airflow <code>zonOutAirRate</code>
shall be calculated as follows:
</p>
<i>If the zone is populated, or if there is no occupancy sensor:</i>
<ul>
<li>If discharge air temperature at the terminal unit is less than or equal to
zone space temperature: <code>zonOutAirRate = (breZonAre+breZonPop)/disEffCoo</code>.
</li>
<li>
If discharge air temperature at the terminal unit is greater than zone space
temperature: <code>zonOutAirRate = (breZonAre+breZonPop)/disEffHea</code>
</li>
</ul>
<i>If the zone has an occupancy sensor and is unpopulated:</i>
<ul>
<li>If discharge air temperature at the terminal unit is less than or equal to
zone space temperature: <code>zonOutAirRate = breZonAre/disEffCoo</code></li>
<li>If discharge air temperature at the terminal unit is greater than zone
space temperature: <code>zonOutAirRate = breZonAre/disEffHea</code></li>
</ul>

<p>
For the single zone system, the required minimum outdoor airflow setpoint
<code>VOutMinSet_flow</code> equals to the <code>zonOutAirRate</code>.
</p>
</html>",                 revisions="<html>
<ul>
<li>
November 2, 2018, by Michael Wetter:<br/>
Made the input connector <code>nOcc</code> conditionally removable, as it is
for the multizone implementation.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1270\">issue 1270</a>.
</li>
<li>
July 6, 2017, by Jianjun Hu:<br/>
Replaced <code>cooCtrlSig</code> input with <code>TZon</code> and <code>TDis</code>
inputs to check if cool or warm air distribution effectiveness should be applied.
Applied hysteresis to avoid rapid change.
</li>
<li>
May 12, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
                end OutsideAirFlow;

                block Supply "Supply air set point for single zone VAV system"

                  parameter Real TSupSetMax(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Maximum supply air temperature for heating"
                    annotation (Dialog(group="Temperatures"));

                  parameter Real TSupSetMin(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")
                    "Minimum supply air temperature for cooling"
                    annotation (Dialog(group="Temperatures"));

                  parameter Real yHeaMax(min=0, max=1, unit="1")
                    "Maximum fan speed for heating"
                    annotation (Dialog(group="Speed"));

                  parameter Real yMin(min=0, max=1, unit="1")
                    "Minimum fan speed"
                    annotation (Dialog(group="Speed"));

                  parameter Real yCooMax(min=0, max=1, unit="1") = 1
                    "Maximum fan speed for cooling"
                    annotation (Dialog(group="Speed"));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uHea(
                    min=0,
                    max=1,
                    unit="1") "Heating control signal" annotation (Placement(
                        transformation(extent={{-140,90},{-100,130}}),
                        iconTransformation(extent={{-140,80},{-100,120}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uCoo(
                    min=0,
                    max=1,
                    unit="1") "Cooling control signal" annotation (Placement(
                        transformation(extent={{-140,50},{-100,90}}),
                        iconTransformation(extent={{-140,40},{-100,80}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonSet(unit="K",
                      displayUnit="degC")
                    "Average of heating and cooling setpoints for zone temperature"
                    annotation (Placement(transformation(extent={{-140,10},{-100,
                            50}}), iconTransformation(extent={{-140,0},{-100,40}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZon(unit="K",
                      displayUnit="degC") "Zone temperature" annotation (
                      Placement(transformation(extent={{-140,-30},{-100,10}}),
                        iconTransformation(extent={{-140,-40},{-100,0}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TOut(unit="K",
                      displayUnit="degC") "Outdoor air temperature" annotation
                    (Placement(transformation(extent={{-140,-100},{-100,-60}}),
                        iconTransformation(extent={{-140,-80},{-100,-40}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TSupHeaEco(unit="K",
                      displayUnit="degC")
                    "Temperature setpoint for heating coil and for economizer"
                    annotation (Placement(transformation(extent={{100,80},{140,
                            120}}), iconTransformation(extent={{100,40},{140,80}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TSupCoo(unit="K",
                      displayUnit="degC")
                    "Cooling supply air temperature setpoint" annotation (
                      Placement(transformation(extent={{100,20},{140,60}}),
                        iconTransformation(extent={{100,-20},{140,20}})));

                  hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(
                    min=0,
                    max=1,
                    unit="1") "Fan speed" annotation (Placement(transformation(
                          extent={{100,-80},{140,-40}})));

                  CDL.Interfaces.BooleanInput uFan "Supply fan status"
                    annotation (Placement(transformation(extent={{-140,-160},{-100,-120}}),
                      iconTransformation(extent={{-140,-120},{-100,-80}})));
                  CDL.Logical.Switch switch "Switch to assign control signal"
                    annotation (Placement(transformation(extent={{72,-30},{92,-10}})));
                  CDL.Continuous.Sources.Constant fanOff(k=0) "Fan off status"
                    annotation (Placement(transformation(extent={{40,-20},{60,0}})));
                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line TSetCooHig
                    "Table to compute the setpoint for cooling for uCoo = 0...1"
                    annotation (Placement(transformation(extent={{0,130},{20,
                            150}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line offSetTSetHea
                    "Table to compute the setpoint offset for heating for uCoo = 0...1"
                    annotation (Placement(transformation(extent={{0,170},{20,
                            190}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add addTHe
                    "Adder for heating setpoint calculation" annotation (
                      Placement(transformation(extent={{60,190},{80,210}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line offSetTSetCoo
                    "Table to compute the setpoint offset for cooling for uHea = 0...1"
                    annotation (Placement(transformation(extent={{0,90},{20,110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add addTSupCoo
                    "Adder for cooling setpoint calculation" annotation (
                      Placement(transformation(extent={{60,110},{80,130}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dT(final k2=
                        -1) "Difference zone minus outdoor temperature"
                    annotation (Placement(transformation(extent={{-70,-128},{-50,
                            -108}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter
                    yMed(final p=yCooMax - (yMin - yCooMax)/(0.56 - 5.6)*5.6,
                      final k=(yMin - yCooMax)/(0.56 - 5.6))
                    "Fan speed at medium cooling load" annotation (Placement(
                        transformation(extent={{-30,-128},{-10,-108}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Limiter yMedLim(final
                      uMax=yCooMax, final uMin=yMin) "Limiter for yMed"
                    annotation (Placement(transformation(extent={{0,-128},{20,-108}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Limiter TDea(final
                      uMax=24 + 273.15, final uMin=21 + 273.15)
                    "Limiter that outputs the dead band value for the supply air temperature"
                    annotation (Placement(transformation(extent={{-80,20},{-60,
                            40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line TSetHeaHig
                    "Block to compute the setpoint for heating for uHea = 0...1"
                    annotation (Placement(transformation(extent={{2,210},{22,
                            230}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con0(final k=0) "Contant that outputs zero" annotation (
                      Placement(transformation(extent={{-80,210},{-60,230}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con25(final k=0.25) "Contant that outputs 0.25" annotation
                    (Placement(transformation(extent={{-80,170},{-60,190}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con05(final k=0.5) "Contant that outputs 0.5" annotation (
                      Placement(transformation(extent={{-80,140},{-60,160}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con75(final k=0.75) "Contant that outputs 0.75" annotation
                    (Placement(transformation(extent={{-80,110},{-60,130}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    conTSupSetMax(final k=TSupSetMax)
                    "Constant that outputs TSupSetMax" annotation (Placement(
                        transformation(extent={{-80,50},{-60,70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    conTSupSetMin(final k=TSupSetMin)
                    "Constant that outputs TSupSetMin" annotation (Placement(
                        transformation(extent={{-80,-10},{-60,10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add TDeaTSupSetMin(final k2=
                        -1) "Outputs TDea-TSupSetMin" annotation (Placement(
                        transformation(extent={{-20,0},{0,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter
                    addTDea(final p=-1.1, final k=-1) "Adds constant offset"
                    annotation (Placement(transformation(extent={{10,0},{30,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add TSupSetMaxTDea(final k2=
                        -1) "Outputs TSupSetMax-TDea" annotation (Placement(
                        transformation(extent={{-20,40},{0,60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line yHea
                    "Fan speed for heating" annotation (Placement(
                        transformation(extent={{4,-60},{24,-40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line lin050(final
                      limitBelow=true, final limitAbove=true)
                    "Linear increase in control signal for 0 < yCoo < 0.75"
                    annotation (Placement(transformation(extent={{-20,-202},{0,
                            -182}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con025(final k=0.25) "Constant signal" annotation (
                      Placement(transformation(extent={{-80,-176},{-60,-156}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con1(final k=0.5) "Constant signal" annotation (Placement(
                        transformation(extent={{-80,-232},{-60,-212}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con2(final k=1) "Constant signal" annotation (Placement(
                        transformation(extent={{0,-320},{20,-300}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con3(final k=0) "Constant signal" annotation (Placement(
                        transformation(extent={{-80,-206},{-60,-186}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con4(final k=yCooMax - yMin) "Constant signal" annotation (
                      Placement(transformation(extent={{-76,-288},{-56,-268}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dY075(final k2=
                        -1, final k1=1)
                    "Change in control signal above yMedLim for y > 0.75"
                    annotation (Placement(transformation(extent={{-36,-294},{-16,
                            -274}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line lin075(final
                      limitBelow=true, final limitAbove=true)
                    "Linear increase in control signal for 0.75 < yCoo"
                    annotation (Placement(transformation(extent={{34,-294},{54,
                            -274}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con5(final k=0.75) "Constant signal" annotation (Placement(
                        transformation(extent={{0,-286},{20,-266}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con6(final k=0) "Constant signal" annotation (Placement(
                        transformation(extent={{0,-350},{20,-330}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter
                    yOffSet(final p=-yMin, k=1)
                    "Subtract yMin so that all control signals can be added"
                    annotation (Placement(transformation(extent={{36,-128},{56,
                            -108}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add addHeaCoo(final k1=
                        1, final k2=1)
                    "Add heating control signal and offset due to cooling"
                    annotation (Placement(transformation(extent={{40,-66},{60,-46}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add offCoo(final k1=
                        1, final k2=1)
                    "Offset of control signal (relative to heating signal) for cooling"
                    annotation (Placement(transformation(extent={{40,-202},{60,
                            -182}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    con7(final k=0.5) "Contant that outputs 0.5" annotation (
                      Placement(transformation(extent={{-40,-40},{-20,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    minSpe(final k=yMin)
                    "Contant that outputs minimum fan speed" annotation (
                      Placement(transformation(extent={{-80,-40},{-60,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    conOne(final k=1) "Contant that outputs 1" annotation (
                      Placement(transformation(extent={{-80,-80},{-60,-60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    maxHeaSpe(final k=yHeaMax)
                    "Contant that outputs maximum fan speed for heating"
                    annotation (Placement(transformation(extent={{-40,-80},{-20,
                            -60}})));

                equation
                  connect(offSetTSetHea.u, uCoo)
                    annotation (Line(points={{-2,180},{-32,180},{-32,82},{-94,82},{-94,70},{-120,
                          70}},            color={0,0,127}));
                  connect(offSetTSetHea.y, addTHe.u2)
                    annotation (Line(points={{22,180},{40,180},{40,194},{58,194}},
                      color={0,0,127}));
                  connect(addTHe.y, TSupHeaEco)
                    annotation (Line(points={{82,200},{92,200},{92,100},{120,100}},
                      color={0,0,127}));
                  connect(TSetCooHig.y, addTSupCoo.u1)
                    annotation (Line(points={{22,140},{40,140},{40,126},{58,126}},
                      color={0,0,127}));
                  connect(offSetTSetCoo.y, addTSupCoo.u2)
                    annotation (Line(points={{22,100},{40,100},{40,114},{58,114}},
                      color={0,0,127}));
                  connect(TSetCooHig.u, uCoo)
                    annotation (Line(points={{-2,140},{-32,140},{-32,82},{-94,82},{-94,70},{-120,
                          70}},                     color={0,0,127}));
                  connect(offSetTSetCoo.u, uHea)
                    annotation (Line(points={{-2,100},{-88,100},{-88,110},{-120,110}},
                                           color={0,0,127}));
                  connect(addTSupCoo.y, TSupCoo)
                    annotation (Line(points={{82,120},{84,120},{84,40},{120,40}},
                      color={0,0,127}));
                  connect(dT.u1, TZon)
                    annotation (Line(points={{-72,-112},{-86,-112},{-86,-10},{-120,-10}},
                      color={0,0,127}));
                  connect(dT.u2, TOut)
                    annotation (Line(points={{-72,-124},{-88,-124},{-88,-80},{-120,-80}},
                      color={0,0,127}));
                  connect(dT.y, yMed.u)
                    annotation (Line(points={{-48,-118},{-32,-118}},
                      color={0,0,127}));
                  connect(yMedLim.u, yMed.y)
                    annotation (Line(points={{-2,-118},{-8,-118}},   color={0,0,127}));
                  connect(TDea.u, TZonSet)
                    annotation (Line(points={{-82,30},{-120,30}},        color={0,0,127}));
                  connect(TDea.y, TSetHeaHig.f1)
                    annotation (Line(points={{-58,30},{-52,30},{-52,224},{0,224}},
                      color={0,0,127}));
                  connect(con05.y, TSetHeaHig.x2)
                    annotation (Line(points={{-58,150},{-46,150},{-46,216},{0,216}},
                      color={0,0,127}));
                  connect(conTSupSetMax.y, TSetHeaHig.f2)
                    annotation (Line(points={{-58,60},{-40,60},{-40,212},{0,212}},
                      color={0,0,127}));
                  connect(uHea, TSetHeaHig.u)
                    annotation (Line(points={{-120,110},{-88,110},{-88,102},{-36,102},{-36,220},
                          {0,220}},
                                color={0,0,127}));
                  connect(TSetHeaHig.y, addTHe.u1)
                    annotation (Line(points={{24,220},{40,220},{40,206},{58,206}},
                      color={0,0,127}));
                  connect(con0.y, offSetTSetHea.x1)
                    annotation (Line(points={{-58,220},{-56,220},{-56,188},{-2,188}},
                      color={0,0,127}));
                  connect(con25.y, offSetTSetHea.x2)
                    annotation (Line(points={{-58,180},{-34,180},{-34,176},{-2,176}},
                      color={0,0,127}));
                  connect(con0.y, offSetTSetHea.f1)
                    annotation (Line(points={{-58,220},{-56,220},{-56,184},{-2,184}},
                      color={0,0,127}));
                  connect(TDea.y, TDeaTSupSetMin.u1)
                    annotation (Line(points={{-58,30},{-40,30},{-40,16},{-22,16}},
                      color={0,0,127}));
                  connect(conTSupSetMin.y, TDeaTSupSetMin.u2)
                    annotation (Line(points={{-58,0},{-40,0},{-40,4},{-22,4}},
                      color={0,0,127}));
                  connect(TDeaTSupSetMin.y, addTDea.u)
                    annotation (Line(points={{2,10},{8,10}},            color={0,0,127}));
                  connect(addTDea.y, offSetTSetHea.f2)
                    annotation (Line(points={{32,10},{34,10},{34,70},{-14,70},{-14,172},{-2,172}},
                      color={0,0,127}));
                  connect(TSetCooHig.x1, con05.y)
                    annotation (Line(points={{-2,148},{-30,148},{-30,150},{-58,150}},
                      color={0,0,127}));
                  connect(TSetCooHig.f1, TDea.y)
                    annotation (Line(points={{-2,144},{-52,144},{-52,30},{-58,30}},
                      color={0,0,127}));
                  connect(TSetCooHig.x2, con75.y)
                    annotation (Line(points={{-2,136},{-44,136},{-44,120},{-58,120}},
                      color={0,0,127}));
                  connect(TSetCooHig.f2, conTSupSetMin.y)
                    annotation (Line(points={{-2,132},{-50,132},{-50,0},{-58,0}},
                      color={0,0,127}));
                  connect(offSetTSetCoo.f1, con0.y)
                    annotation (Line(points={{-2,104},{-56,104},{-56,220},{-58,220}},
                      color={0,0,127}));
                  connect(offSetTSetCoo.x1, con0.y)
                    annotation (Line(points={{-2,108},{-56,108},{-56,220},{-58,220}},
                      color={0,0,127}));
                  connect(offSetTSetCoo.x2, con05.y)
                    annotation (Line(points={{-2,96},{-46,96},{-46,150},{-58,150}},
                      color={0,0,127}));
                  connect(TSupSetMaxTDea.u1, conTSupSetMax.y)
                    annotation (Line(points={{-22,56},{-40,56},{-40,60},{-58,60}},
                      color={0,0,127}));
                  connect(TDea.y, TSupSetMaxTDea.u2)
                    annotation (Line(points={{-58,30},{-40,30},{-40,44},{-22,44}},
                      color={0,0,127}));
                  connect(TSupSetMaxTDea.y, offSetTSetCoo.f2)
                    annotation (Line(points={{2,50},{10,50},{10,80},{-10,80},{-10,92},{-2,92}},
                      color={0,0,127}));
                  connect(uCoo, lin050.u) annotation (Line(points={{-120,70},{-94,70},{-94,-146},
                          {-38,-146},{-38,-192},{-22,-192}}, color={0,0,127}));
                  connect(dY075.u1, con4.y)
                    annotation (Line(points={{-38,-278},{-54,-278}}, color={0,0,127}));
                  connect(lin075.x2, con2.y) annotation (Line(points={{32,-288},{24,-288},{24,-310},
                          {22,-310}}, color={0,0,127}));
                  connect(lin075.x1, con5.y)
                    annotation (Line(points={{32,-276},{22,-276}}, color={0,0,127}));
                  connect(uCoo, lin075.u) annotation (Line(points={{-120,70},{-90,70},{-90,-252},
                          {24,-252},{24,-284},{32,-284}}, color={0,0,127}));
                  connect(yMedLim.y, yOffSet.u)
                    annotation (Line(points={{22,-118},{34,-118}}, color={0,0,127}));
                  connect(dY075.u2, yOffSet.y) annotation (Line(points={{-38,-290},{-42,-290},{-42,
                          -160},{70,-160},{70,-118},{58,-118}}, color={0,0,127}));
                  connect(offCoo.u1, lin050.y) annotation (Line(points={{38,-186},{20,-186},{20,
                          -192},{2,-192}}, color={0,0,127}));
                  connect(offCoo.u2, lin075.y) annotation (Line(points={{38,-198},{34,-198},{34,
                          -256},{60,-256},{60,-284},{56,-284}}, color={0,0,127}));
                  connect(offCoo.y, addHeaCoo.u2) annotation (Line(points={{62,-192},{90,-192},{
                          90,-80},{30,-80},{30,-62},{38,-62}}, color={0,0,127}));
                  connect(lin050.x2, con1.y) annotation (Line(points={{-22,-196},{-46,-196},{-46,
                          -222},{-58,-222}}, color={0,0,127}));
                  connect(con025.y, lin050.x1) annotation (Line(points={{-58,-166},{-52,-166},{-52,
                          -184},{-22,-184}}, color={0,0,127}));
                  connect(lin050.f2, yOffSet.y) annotation (Line(points={{-22,-200},{-42,-200},{
                          -42,-160},{70,-160},{70,-118},{58,-118}}, color={0,0,127}));
                  connect(con3.y, lin050.f1) annotation (Line(points={{-58,-196},{-50,-196},{-50,
                          -188},{-22,-188}}, color={0,0,127}));
                  connect(dY075.y, lin075.f2) annotation (Line(points={{-14,-284},{-8,-284},{-8,
                          -292},{32,-292}}, color={0,0,127}));
                  connect(con6.y, lin075.f1) annotation (Line(points={{22,-340},{24,-340},{24,-280},
                          {32,-280}}, color={0,0,127}));
                  connect(TSetHeaHig.x1, con0.y) annotation (Line(points={{0,228},{-56,228},{-56,
                          220},{-58,220}}, color={0,0,127}));
                  connect(con7.y, yHea.x1) annotation (Line(points={{-18,-30},{-6,-30},{-6,-42},
                          {2,-42}},
                                 color={0,0,127}));
                  connect(minSpe.y, yHea.f1) annotation (Line(points={{-58,-30},{-56,-30},{-56,-46},
                          {2,-46}},  color={0,0,127}));
                  connect(uHea, yHea.u) annotation (Line(points={{-120,110},{-94,110},{-94,-50},
                          {2,-50}},  color={0,0,127}));
                  connect(conOne.y, yHea.x2) annotation (Line(points={{-58,-70},{-56,-70},{-56,-54},
                          {2,-54}},  color={0,0,127}));
                  connect(maxHeaSpe.y, yHea.f2) annotation (Line(points={{-18,-70},{-6,-70},{-6,
                          -58},{2,-58}},
                                     color={0,0,127}));
                  connect(yHea.y, addHeaCoo.u1) annotation (Line(points={{26,-50},{38,-50}},
                                     color={0,0,127}));

                  connect(uFan, switch.u2) annotation (Line(points={{-120,-140},{84,-140},{84,-42},
                          {68,-42},{68,-20},{70,-20}},
                                     color={255,0,255}));
                  connect(addHeaCoo.y, switch.u1) annotation (Line(points={{62,-56},{64,-56},{64,
                          -12},{70,-12}}, color={0,0,127}));
                  connect(fanOff.y, switch.u3)
                    annotation (Line(points={{62,-10},{66,-10},{66,-28},{70,-28}},
                                                                          color={0,0,127}));
                  connect(switch.y, y) annotation (Line(points={{94,-20},{96,-20},{96,-60},{120,
                          -60}}, color={0,0,127}));
                annotation (
                  defaultComponentName = "setPoiVAV",
                 Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-120},{100,120}}),
                    graphics={
                        Rectangle(
                        extent={{-100,-120},{100,120}},
                        lineColor={0,0,127},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-150,174},{150,134}},
                        textString="%name",
                        lineColor={0,0,255}),
                    Polygon(
                      points={{80,-76},{58,-70},{58,-82},{80,-76}},
                      lineColor={95,95,95},
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid),
                    Line(points={{8,-76},{78,-76}},   color={95,95,95}),
                    Line(points={{-54,-22},{-54,-62}},color={95,95,95}),
                    Polygon(
                      points={{-54,0},{-60,-22},{-48,-22},{-54,0}},
                      lineColor={95,95,95},
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-88,-6},{-47,-26}},
                      lineColor={0,0,0},
                          textString="T"),
                    Text(
                      extent={{64,-82},{88,-93}},
                      lineColor={0,0,0},
                          textString="u"),
                        Line(
                          points={{-44,-6},{-30,-6},{-14,-42},{26,-42},{38,-62},{60,-62}},
                          color={0,0,255},
                          thickness=0.5),
                        Line(
                          points={{-44,-6},{-30,-6},{-14,-42},{2,-42},{18,-66},{60,-66}},
                          color={255,0,0},
                          pattern=LinePattern.Dot,
                          thickness=0.5),
                    Line(points={{-4,-76},{-60,-76}}, color={95,95,95}),
                    Polygon(
                      points={{-64,-76},{-42,-70},{-42,-82},{-64,-76}},
                      lineColor={95,95,95},
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid),
                        Text(
                          extent={{-98,104},{-72,82}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="uHea"),
                        Text(
                          extent={{-98,68},{-72,46}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="uCoo"),
                        Text(
                          extent={{68,72},{94,50}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="TSupHeaEco"),
                        Text(
                          extent={{68,12},{94,-10}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="TSupCoo"),
                        Text(
                          extent={{74,-50},{100,-72}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="y"),
                        Text(
                          extent={{-96,-12},{-70,-34}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="TZon"),
                        Text(
                          extent={{-98,-50},{-72,-72}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="TOut"),
                    Line(points={{-54,50},{-54,10}},  color={95,95,95}),
                    Polygon(
                      points={{-54,72},{-60,50},{-48,50},{-54,72}},
                      lineColor={95,95,95},
                      fillColor={95,95,95},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-88,68},{-47,48}},
                      lineColor={0,0,0},
                          textString="y"),
                        Line(points={{-46,44},{-28,20},{18,20},{28,36},{38,36},{50,54}}, color={
                              0,0,0}),
                        Line(points={{18,20},{38,20},{50,54},{28,54},{18,20}}, color={0,0,0}),
                        Text(
                          extent={{-96,30},{-70,8}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="TZonSet"),
                        Text(
                          extent={{-98,-82},{-72,-104}},
                          lineColor={0,0,127},
                          fillColor={0,0,0},
                          fillPattern=FillPattern.Solid,
                          textString="uFan")}),
                        Diagram(
                        coordinateSystem(preserveAspectRatio=false,
                        extent={{-100,-380},{100,240}}), graphics={
                        Rectangle(
                          extent={{-82,-152},{84,-248}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid),
                        Text(
                          extent={{46,-252},{82,-234}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          textString="0.25 < yCoo < 0.5"),
                        Text(
                          extent={{46,-316},{82,-298}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          textString="0.75 < yCoo < 1"),
                        Rectangle(
                          extent={{-84,-100},{80,-138}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid),
                        Text(
                          extent={{28,-142},{64,-124}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          textString="0.5 < yCoo < 0.75"),
                        Rectangle(
                          extent={{-84,-16},{26,-86}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid),
                        Text(
                          extent={{-16,-78},{14,-72}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          textString="heating"),
                        Text(
                          extent={{-82,-98},{88,-90}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid,
                          horizontalAlignment=TextAlignment.Left,
                          textString="For cooling, compute the change relative to yMin, and then add the heating and
cooling control signals to output yFan"),
                        Rectangle(
                          extent={{-82,-256},{84,-356}},
                          lineColor={0,0,0},
                          fillColor={215,215,215},
                          fillPattern=FillPattern.Solid)}),
                      Documentation(info="<html>
<p>
Block that outputs the set points for the supply air temperature for
cooling, heating and economizer control,
and the fan speed for a single zone VAV system.
</p>
<p>
For the temperature set points, the
parameters are the maximum supply air temperature <code>TSupSetMax</code>,
and the minimum supply air temperature for cooling <code>TSupSetMin</code>.
The deadband temperature is equal to the
average set point for the zone temperature
for heating and cooling, as obtained from the input <code>TZonSet</code>,
constraint to be within <i>21</i>&deg;C (&asymp;<i>70</i> F) and
<i>24</i>&deg;C (&asymp;<i>75</i> F).
The setpoints are computed as shown in the figure below.
Note that the setpoint for the supply air temperature for heating
and for economizer control is the same, and this setpoint is
lower than <code>TSupSetMin</code> when the heating loop signal
is zero and the economizer is in cooling mode, as shown in the figure.
</p>
<p>
For the fan speed set point, the
parameters are the maximu fan speed at heating <code>yHeaMax</code>,
the minimum fan speed <code>yMin</code> and
the maximum fan speed for cooling <code>yCooMax</code>.
For a cooling control signal of <code>uCoo &gt; 0.25</code>,
the speed is faster increased the larger the difference is between
the zone temperature minus outdoor temperature <code>TZon-TOut</code>.
The figure below shows the sequence.
</p>
<p align=\"center\">
<img alt=\"Image of set point reset\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/SetPoints/Supply.png\"/>
</p>
<p>
The output <code>TSupCoo</code> is to be used to control the cooling coil,
and the output
<code>TSupHeaEco</code> is to be used to control the heating coil and the
economizer dampers.
</p>
<p>
Note that the inputs <code>uHea</code> and <code>uCoo</code> must be computed
based on the same temperature sensors and control loops.
</p>
</html>",                 revisions="<html>
<ul>
<li>
August 1, 2019, by Kun Zhang:<br/>
Added a switch for fan control.
</li>
<li>
March 21, 2019, by Jianjun Hu:<br/>
Used line block to avoid use block that is not in CDL.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1389\">issue 1389</a>.
</li>
<li>
March 25, 2018, by Michael Wetter:<br/>
Revised implementation of fan speed control signal calculation
to remove the hysteresis blocks.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1153\">issue 1153</a>.
</li>
<li>
April 26, 2017, by Michael Wetter:<br/>
Updated documentation and renamed output signal to <code>TSupHeaEco</code>.
</li>
<li>
January 10, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
                end Supply;

                package Validation "Collection of validation models"

                  model ExhaustDamper
                    "Validate of the controller for actuated exhaust damper without fan"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.ExhaustDamper
                      exhDamPos
                      "Block of controlling actuated exhaust damper without fan"
                      annotation (Placement(transformation(extent={{40,-10},{60,
                              10}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      supFan(k=true) "Supply fan status" annotation (Placement(
                          transformation(extent={{-40,-52},{-20,-32}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      outDamPos(
                      duration=1200,
                      startTime=0,
                      height=0.6,
                      offset=0.4) "Outdoor air damper position" annotation (
                        Placement(transformation(extent={{-40,30},{-20,50}})));

                  equation
                    connect(supFan.y, exhDamPos.uSupFan) annotation (Line(points={{-19,-42},{0,-42},
                            {0,-6},{39,-6}}, color={255,0,255}));
                    connect(outDamPos.y, exhDamPos.uOutDamPos)
                      annotation (Line(points={{-19,40},{0,40},{0,6},{39,6}},
                        color={0,0,127}));

                  annotation (
                    experiment(StopTime=1200.0, Tolerance=1e-06),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/SetPoints/Validation/ExhaustDamper.mos"
                      "Simulate and plot"),
                    Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.ExhaustDamper\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.ExhaustDamper</a>.
</p>
</html>",                   revisions="<html>
<ul>
<li>
May 15, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent = {{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
                  end ExhaustDamper;

                  model OutsideAirFlow
                    "Validate the model of calculating minimum outdoor airflow setpoint"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.OutsideAirFlow
                      outAirSet_SinZon(AFlo=40, have_occSen=true)
                      "Block to output minimum outdoor airflow rate for system with single zone "
                      annotation (Placement(transformation(extent={{20,0},{60,
                              40}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      numOfOcc(height=4, duration=3600)
                      "Number of occupant detected in zone" annotation (
                        Placement(transformation(extent={{-60,40},{-40,60}})));

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.OutsideAirFlow
                      outAirSet_SinZon_noOccSen(AFlo=40, have_occSen=false)
                      "Block to output minimum outdoor airflow rate for system with single zone without an occupancy sensor"
                      annotation (Placement(transformation(extent={{20,-60},{60,
                              -20}})));
                  protected
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      winSta(k=false) "Window status" annotation (Placement(
                          transformation(extent={{-60,-50},{-40,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                      supFan(k=true) "Supply fan status" annotation (Placement(
                          transformation(extent={{-60,-80},{-40,-60}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      TZon(
                      height=6,
                      offset=273.15 + 17,
                      duration=3600) "Measured zone temperature" annotation (
                        Placement(transformation(extent={{-60,10},{-40,30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      TDis(
                      height=4,
                      duration=3600,
                      offset=273.15 + 18)
                      "Terminal unit discharge air temperature" annotation (
                        Placement(transformation(extent={{-60,-20},{-40,0}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                      opeMod(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                      "AHU operation mode is Occupied" annotation (Placement(
                          transformation(extent={{-20,-80},{0,-60}})));

                  equation
                    connect(numOfOcc.y, outAirSet_SinZon.nOcc)
                      annotation (Line(points={{-39,50},{0,50},{0,36},{18,36}}, color={0,0,127}));
                    connect(winSta.y, outAirSet_SinZon.uWin)
                      annotation (Line(points={{-39,-40},{-9.75,-40},{-9.75,12},{18,12}}, color={255,0,255}));
                    connect(TZon.y, outAirSet_SinZon.TZon)
                      annotation (Line(points={{-39,20},{-20,20},{-20,28},{18,28}},  color={0,0,127}));
                    connect(outAirSet_SinZon.uOpeMod, opeMod.y)
                      annotation (Line(points={{18,4},{10,4},{10,-70},{1,-70}}, color={255,127,0}));
                    connect(supFan.y, outAirSet_SinZon.uSupFan)
                      annotation (Line(points={{-39,-70},{-30,-70},{-30,8},{18,8}}, color={255,0,255}));
                    connect(TDis.y, outAirSet_SinZon.TDis)
                      annotation (Line(points={{-39,-10},{0,-10},{0,20},{18,20}},  color={0,0,127}));
                    connect(winSta.y, outAirSet_SinZon_noOccSen.uWin)
                      annotation (Line(points={{-39,-40},{-9.75,-40},{-9.75,-48},{18,-48}}, color={255,0,255}));
                    connect(TZon.y, outAirSet_SinZon_noOccSen.TZon)
                      annotation (Line(points={{-39,20},{-20,20},{-20,-32},{18,-32}},  color={0,0,127}));
                    connect(outAirSet_SinZon_noOccSen.uOpeMod, opeMod.y)
                      annotation (Line(points={{18,-56},{10,-56},{10,-70},{1,-70}}, color={255,127,0}));
                    connect(supFan.y, outAirSet_SinZon_noOccSen.uSupFan)
                      annotation (Line(points={{-39,-70},{-30,-70},{-30,-52},{18,-52}}, color={255,0,255}));
                    connect(TDis.y, outAirSet_SinZon_noOccSen.TDis)
                      annotation (Line(points={{-39,-10},{0,-10},{0,-40},{18,-40}}, color={0,0,127}));
                  annotation (
                    experiment(StopTime=3600.0, Tolerance=1e-06),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/SetPoints/Validation/OutsideAirFlow.mos"
                      "Simulate and plot"),
                      Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.OutsideAirFlow\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.OutsideAirFlow</a>.
</p>
</html>",                   revisions="<html>
<ul>
<li>
July 6, 2017, by Jianjun Hu:<br/>
Revised implementation.
</li>
<li>
May 12, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent = {{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
                  end OutsideAirFlow;

                  model Supply_T
                    "Validation model for outdoor minus room air temperature"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply
                      setPoiVAV(
                      yHeaMax=0.7,
                      yMin=0.3,
                      TSupSetMax=303.15,
                      TSupSetMin=289.15,
                      yCooMax=0.9)
                      "Block that computes the setpoints for temperature and fan speed"
                      annotation (Placement(transformation(extent={{0,-10},{20,
                              10}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      uHea(k=0) "Heating control signal" annotation (Placement(
                          transformation(extent={{-80,70},{-60,90}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      uCoo(k=0.6) "Cooling control signal" annotation (
                        Placement(transformation(extent={{-80,40},{-60,60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      TOut(
                      duration=1,
                      height=18,
                      offset=273.15 + 10) "Outdoor air temperature" annotation
                      (Placement(transformation(extent={{-80,-60},{-60,-40}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TZon(k=273.15 + 22) "Zone temperature" annotation (
                        Placement(transformation(extent={{-80,-20},{-60,0}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dT(k2=-1)
                      "Difference zone minus outdoor temperature" annotation (
                        Placement(transformation(extent={{0,-50},{20,-30}})));
                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TZonSet(k=273.15 + 22) "Average zone set point"
                      annotation (Placement(transformation(extent={{-80,10},{-60,
                              30}})));
                    CDL.Logical.Sources.Constant fanSta(k=true) "Fan is on"
                      annotation (Placement(transformation(extent={{-80,-100},{-60,-80}})));
                  equation
                    connect(uCoo.y, setPoiVAV.uCoo) annotation (Line(points={{-58,50},{-31.5,50},
                            {-31.5,5},{-2,5}},color={0,0,127}));
                    connect(TZon.y, setPoiVAV.TZon) annotation (Line(points={{-58,-10},{-32,-10},
                            {-32,-1.66667},{-2,-1.66667}},
                                              color={0,0,127}));
                    connect(TOut.y, setPoiVAV.TOut) annotation (Line(points={{-58,-50},{-28,-50},
                            {-28,-5},{-2,-5}},color={0,0,127}));
                    connect(uHea.y, setPoiVAV.uHea) annotation (Line(points={{-58,80},{-58,80},{
                            -20,80},{-20,8.33333},{-2,8.33333}},
                                                 color={0,0,127}));
                    connect(dT.u1, TZon.y) annotation (Line(points={{-2,-34},{-32,-34},{-32,-10},
                            {-58,-10}},color={0,0,127}));
                    connect(dT.u2, TOut.y) annotation (Line(points={{-2,-46},{-28,-46},{-28,-50},
                            {-58,-50}},color={0,0,127}));
                    connect(TZonSet.y,setPoiVAV.TZonSet)  annotation (Line(points={{-58,20},{-40,
                            20},{-40,1.66667},{-2,1.66667}},
                                                 color={0,0,127}));
                    connect(fanSta.y, setPoiVAV.uFan) annotation (Line(points={{-58,-90},{-10,-90},
                            {-10,-8.33333},{-2,-8.33333}},
                                                 color={255,0,255}));
                    annotation (
                    experiment(StopTime=1.0, Tolerance=1e-6),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/SetPoints/Validation/Supply_T.mos"
                          "Simulate and plot"),
                      Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply</a>
for a change in temperature difference between zone air and outdoor air.
Hence, this model validates whether the adjustment of the fan speed for medium
cooling load is correctly implemented.
</p>
</html>",                   revisions="<html>
<ul>
<li>
January 10, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(coordinateSystem(extent={{-100,-120},{100,100}}),
                           graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent = {{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                      Diagram(coordinateSystem(extent={{-100,-120},{100,100}})));
                  end Supply_T;

                  model Supply_u "Validation model for temperature and fan speed"

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply
                      setPoiVAV(
                      yHeaMax=0.7,
                      yMin=0.3,
                      TSupSetMax=303.15,
                      TSupSetMin=289.15)
                      "Block that computes the setpoints for temperature and fan speed"
                      annotation (Placement(transformation(extent={{0,40},{20,
                              60}})));

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply
                      setPoiVAV1(
                      yHeaMax=0.7,
                      yMin=0.3,
                      TSupSetMax=303.15,
                      TSupSetMin=289.15)
                      "Block that computes the setpoints for temperature and fan speed"
                      annotation (Placement(transformation(extent={{0,0},{20,20}})));

                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply
                      setPoiVAV2(
                      yHeaMax=0.7,
                      yMin=0.3,
                      TSupSetMax=303.15,
                      TSupSetMin=289.15)
                      "Block that computes the setpoints for temperature and fan speed"
                      annotation (Placement(transformation(extent={{0,-40},{20,
                              -20}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TZon(k=273.15 + 28) "Zone air temperature" annotation (
                        Placement(transformation(extent={{-80,-20},{-60,0}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TOut(k=273.15 + 22) "Outdoor temperature" annotation (
                        Placement(transformation(extent={{-80,-50},{-60,-30}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      uHea(
                      duration=0.25,
                      height=-1,
                      offset=1) "Heating control signal" annotation (Placement(
                          transformation(extent={{-80,70},{-60,90}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                      uCoo(duration=0.25, startTime=0.75)
                      "Cooling control signal" annotation (Placement(
                          transformation(extent={{-80,40},{-60,60}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TZonSet(k=273.15 + 23) "Average zone set point"
                      annotation (Placement(transformation(extent={{-80,10},{-60,
                              30}})));

                    hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                      TZon1(k=273.15 + 23) "Zone air temperature" annotation (
                        Placement(transformation(extent={{-80,-80},{-60,-60}})));
                    CDL.Logical.Sources.Constant fanSta(k=true) "Fan is on"
                      annotation (Placement(transformation(extent={{-80,-110},{-60,-90}})));
                  equation
                    connect(TZon.y, setPoiVAV.TZon) annotation (Line(
                        points={{-58,-10},{-31.5,-10},{-31.5,48.3333},{-2,48.3333}},
                        color={0,0,127},
                        pattern=LinePattern.Dash));
                    connect(TOut.y, setPoiVAV.TOut) annotation (Line(points={{-58,-40},{-24,-40},{
                            -24,45},{-2,45}}, color={0,0,127}));
                    connect(uHea.y, setPoiVAV.uHea) annotation (Line(points={{-58,80},{-12,80},{
                            -12,58.3333},{-2,58.3333}},
                                          color={0,0,127}));
                    connect(uCoo.y, setPoiVAV.uCoo) annotation (Line(points={{-58,50},{-16,50},{-16,
                            55},{-2,55}}, color={0,0,127}));
                    connect(TZonSet.y,setPoiVAV.TZonSet)  annotation (Line(points={{-58,20},{-10,
                            20},{-10,51.6667},{-2,51.6667}},
                                               color={0,0,127}));
                    connect(TOut.y, setPoiVAV1.TOut) annotation (Line(points={{-58,-40},{-24,-40},
                            {-24,5},{-2,5}}, color={0,0,127}));
                    connect(uHea.y, setPoiVAV1.uHea) annotation (Line(points={{-58,80},{-12,80},{
                            -12,18.3333},{-2,18.3333}},
                                          color={0,0,127}));
                    connect(uCoo.y, setPoiVAV1.uCoo) annotation (Line(points={{-58,50},{-16,50},{-16,
                            15},{-2,15}}, color={0,0,127}));
                    connect(TZonSet.y,setPoiVAV1.TZonSet)  annotation (Line(points={{-58,20},{-10,
                            20},{-10,11.6667},{-2,11.6667}},
                                                   color={0,0,127}));
                    connect(TOut.y, setPoiVAV2.TOut)
                      annotation (Line(points={{-58,-40},{-24,-40},{-24,-35},{-2,-35}},
                                                                    color={0,0,127}));
                    connect(uHea.y, setPoiVAV2.uHea) annotation (Line(points={{-58,80},{-12,80},{
                            -12,-21.6667},{-2,-21.6667}},
                                            color={0,0,127}));
                    connect(uCoo.y, setPoiVAV2.uCoo) annotation (Line(points={{-58,50},{-16,50},{-16,
                            -25},{-2,-25}}, color={0,0,127}));
                    connect(TZonSet.y,setPoiVAV2.TZonSet)  annotation (Line(points={{-58,20},{-10,
                            20},{-10,-28.3333},{-2,-28.3333}},
                                                     color={0,0,127}));
                    connect(TOut.y, setPoiVAV1.TZon) annotation (Line(
                        points={{-58,-40},{-24,-40},{-24,8.33333},{-2,8.33333}},
                        color={0,0,127},
                        pattern=LinePattern.Dash));
                    connect(TZon1.y, setPoiVAV2.TZon) annotation (Line(
                        points={{-58,-70},{-20,-70},{-20,-31.6667},{-2,-31.6667}},
                        color={0,0,127},
                        pattern=LinePattern.Dash));
                    connect(fanSta.y, setPoiVAV.uFan) annotation (Line(points={{-58,-100},{-6,
                            -100},{-6,41.6667},{-2,41.6667}},
                                              color={255,0,255}));
                    connect(setPoiVAV1.uFan, setPoiVAV.uFan) annotation (Line(points={{-2,1.66667},
                            {-6,1.66667},{-6,41.6667},{-2,41.6667}},
                                                 color={255,0,255}));
                    connect(setPoiVAV2.uFan, setPoiVAV.uFan) annotation (Line(points={{-2,
                            -38.3333},{-6,-38.3333},{-6,41.6667},{-2,41.6667}},
                                                      color={255,0,255}));
                    annotation (
                    experiment(StopTime=1.0, Tolerance=1e-6),
                    __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/SetPoints/Validation/Supply_u.mos"
                          "Simulate and plot"),
                      Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints.Supply</a>
for different control signals.
Each controller is configured identical, but the input signal for <code>TZon</code> differs
in order to validate that the fan speed is increased correctly.
</p>
</html>",                   revisions="<html>
<ul>
<li>
March 25, 2018, by Michael Wetter:<br/>
Updated test to verify fan speed calculation.
</li>
<li>
January 10, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),            Icon(coordinateSystem(extent={{-100,-120},{100,100}}),
                           graphics={
                          Ellipse(lineColor = {75,138,73},
                                  fillColor={255,255,255},
                                  fillPattern = FillPattern.Solid,
                                  extent = {{-100,-100},{100,100}}),
                          Polygon(lineColor = {0,0,255},
                                  fillColor = {75,138,73},
                                  pattern = LinePattern.None,
                                  fillPattern = FillPattern.Solid,
                                  points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                      Diagram(coordinateSystem(extent={{-100,-120},{100,100}})));
                  end Supply_u;
                annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.SetPoints</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),        Icon(graphics={
                        Rectangle(
                          lineColor={200,200,200},
                          fillColor={248,248,248},
                          fillPattern=FillPattern.HorizontalCylinder,
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Rectangle(
                          lineColor={128,128,128},
                          extent={{-100.0,-100.0},{100.0,100.0}},
                          radius=25.0),
                        Polygon(
                          origin={8.0,14.0},
                          lineColor={78,138,73},
                          fillColor={78,138,73},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
                end Validation;
              annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains sequences generating setpoints for single zone VAV AHU control.
</p>
</html>"),      Icon(graphics={
                      Rectangle(
                        lineColor={200,200,200},
                        fillColor={248,248,248},
                        fillPattern=FillPattern.HorizontalCylinder,
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Rectangle(
                        lineColor={128,128,128},
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                    Text(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      textString="S")}));
              end SetPoints;

              package Validation "Collection of validation models"

                model Controller "Validation of the top-level controller"
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Controller
                    conVAV(
                    kHea=1,
                    yHeaMax=1,
                    yMin=0.1,
                    AFlo=50,
                    controllerTypeCoo=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    controllerTypeHea=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    have_occSen=true,
                    TSupSetMax=297.15,
                    TSupSetMin=285.15,
                    use_TMix=false,
                    controllerTypeMod=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    kMod=1,
                    VOutMin_flow=6e-3,
                    VOutDes_flow=0.25) "Validate the heating case" annotation (
                      Placement(transformation(extent={{20,74},{60,122}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    TZon(
                    duration=86400,
                    height=6,
                    offset=273.15 + 16) "Measured zone temperature" annotation
                    (Placement(transformation(extent={{-180,68},{-160,88}})));
                  hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSch(occupancy
                      =3600*{4,20}) "Occupancy schedule" annotation (Placement(
                        transformation(extent={{-120,44},{-100,64}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    TCut(final k=273.15 + 16)
                    "Fixed dry bulb temperature high limit cutoff for economizer"
                    annotation (Placement(transformation(extent={{-120,14},{-100,
                            34}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    nOcc(final k=2) "Number of occupants" annotation (Placement(
                        transformation(extent={{-120,-34},{-100,-14}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                    win(k=false) "Window status" annotation (Placement(
                        transformation(extent={{-120,-130},{-100,-110}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    TOut(final k=273.15 + 17)
                    "Outdoor air dry bulb temperature" annotation (Placement(
                        transformation(extent={{-180,112},{-160,132}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Controller
                    conVAV1(
                    kCoo=1,
                    kHea=1,
                    yHeaMax=1,
                    yMin=0.1,
                    AFlo=50,
                    controllerTypeCoo=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    controllerTypeHea=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    have_occSen=true,
                    TSupSetMax=297.15,
                    TSupSetMin=285.15,
                    use_TMix=false,
                    controllerTypeMod=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    kMod=1,
                    VOutMin_flow=6e-3,
                    VOutDes_flow=0.25) "Validate the cooling case" annotation (
                      Placement(transformation(extent={{20,12},{60,60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    TOut1(final k=273.15 + 28)
                    "Outdoor air dry bulb temperature" annotation (Placement(
                        transformation(extent={{-180,-6},{-160,14}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    TZon1(
                    duration=86400,
                    height=-3,
                    offset=273.15 + 26) "Measured zone temperature" annotation
                    (Placement(transformation(extent={{-180,-50},{-160,-30}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Controller
                    conVAV2(
                    kCoo=1,
                    kHea=1,
                    yHeaMax=1,
                    yMin=0.1,
                    AFlo=50,
                    controllerTypeCoo=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    controllerTypeHea=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    have_occSen=true,
                    TSupSetMax=297.15,
                    TSupSetMin=285.15,
                    use_TMix=false,
                    controllerTypeMod=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    kMod=1,
                    VOutMin_flow=6e-3,
                    VOutDes_flow=0.25) "Validate the cooling case" annotation (
                      Placement(transformation(extent={{20,-48},{60,0}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    TOut2(final k=273.15 + 22)
                    "Outdoor air dry bulb temperature" annotation (Placement(
                        transformation(extent={{-180,-110},{-160,-90}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Controller
                    conVAV3(
                    kCoo=1,
                    kHea=1,
                    yHeaMax=1,
                    yMin=0.1,
                    AFlo=50,
                    controllerTypeCoo=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    controllerTypeHea=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    have_occSen=true,
                    TSupSetMax=297.15,
                    TSupSetMin=285.15,
                    use_TMix=false,
                    controllerTypeMod=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,

                    kMod=1,
                    VOutMin_flow=6e-3,
                    VOutDes_flow=0.25) "Validate the cooling case" annotation (
                      Placement(transformation(extent={{20,-108},{60,-60}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                    TOut3(final k=273.15 + 16)
                    "Outdoor air dry bulb temperature" annotation (Placement(
                        transformation(extent={{-180,-148},{-160,-128}})));
                protected
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    TSup(
                    height=2,
                    duration=86400,
                    offset=273.15 + 22.5)
                    "Terminal unit discharge air temperature" annotation (
                      Placement(transformation(extent={{-180,30},{-160,50}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    TSup1(
                    height=-3,
                    duration=86400,
                    offset=273.15 + 24)
                    "Terminal unit discharge air temperature" annotation (
                      Placement(transformation(extent={{-180,-80},{-160,-60}})));
                equation
                  connect(TZon.y, conVAV.TZon) annotation (Line(points={{-158,78},{-30,78},{-30,
                          112.769},{18,112.769}},
                                          color={0,0,127}));
                  connect(occSch.occupied, conVAV.uOcc) annotation (Line(points={{-99,48},{-74,
                          48},{-74,109.077},{18,109.077}},
                                               color={255,0,255}));
                  connect(occSch.tNexOcc, conVAV.tNexOcc) annotation (Line(points={{-99,60},{
                          -78,60},{-78,116.462},{18,116.462}},
                                                   color={0,0,127}));
                  connect(TCut.y, conVAV.TCut) annotation (Line(points={{-98,24},{-52,24},{-52,
                          105.385},{18,105.385}},
                                     color={0,0,127}));
                  connect(win.y, conVAV.uWin) annotation (Line(points={{-98,-120},{0,-120},{0,
                          90.6154},{18,90.6154}},
                                    color={255,0,255}));
                  connect(nOcc.y, conVAV.nOcc) annotation (Line(points={{-98,-24},{-8,-24},{-8,94.3077},
                          {18,94.3077}},
                                    color={0,0,127}));
                  connect(TOut.y, conVAV.TOut)
                    annotation (Line(points={{-158,122},{-70,122},{-70,120.154},{18,120.154}},
                                                                   color={0,0,127}));
                  connect(TSup.y, conVAV.TSup) annotation (Line(points={{-158,40},{-140,40},{
                          -140,101.692},{18,101.692}},
                                          color={0,0,127}));
                  connect(win.y, conVAV1.uWin) annotation (Line(points={{-98,-120},{0,-120},{0,
                          28.6154},{18,28.6154}},
                                    color={255,0,255}));
                  connect(nOcc.y, conVAV1.nOcc) annotation (Line(points={{-98,-24},{-8,-24},{-8,
                          32},{6,32},{6,32.3077},{18,32.3077}},
                                        color={0,0,127}));
                  connect(occSch.tNexOcc, conVAV1.tNexOcc) annotation (Line(points={{-99,60},{
                          -20,60},{-20,54.4615},{18,54.4615}},
                                                 color={0,0,127}));
                  connect(occSch.occupied, conVAV1.uOcc)
                    annotation (Line(points={{-99,48},{-40,48},{-40,47.0769},{18,47.0769}},
                                                                color={255,0,255}));
                  connect(TOut1.y, conVAV1.TOut)
                    annotation (Line(points={{-158,4},{6,4},{6,58.1538},{18,58.1538}},
                                                                             color={0,0,127}));
                  connect(TZon1.y, conVAV1.TZon) annotation (Line(points={{-158,-40},{-70,-40},
                          {-70,50.7692},{18,50.7692}},
                                            color={0,0,127}));
                  connect(TSup1.y, conVAV1.TSup) annotation (Line(points={{-158,-70},{-84,-70},{
                          -84,39.6923},{18,39.6923}},
                                            color={0,0,127}));
                  connect(TCut.y, conVAV1.TCut) annotation (Line(points={{-98,24},{-52,24},{-52,
                          43.3846},{18,43.3846}},
                                        color={0,0,127}));
                  connect(win.y,conVAV2. uWin) annotation (Line(points={{-98,-120},{0,-120},{0,
                          -31.3846},{18,-31.3846}},
                                               color={255,0,255}));
                  connect(TSup1.y,conVAV2. TSup) annotation (Line(points={{-158,-70},{-84,-70},{
                          -84,-20.3077},{18,-20.3077}},
                                              color={0,0,127}));
                  connect(occSch.occupied,conVAV2. uOcc) annotation (Line(points={{-99,48},{-74,
                          48},{-74,-12.9231},{18,-12.9231}},           color={255,0,255}));
                  connect(occSch.tNexOcc,conVAV2. tNexOcc) annotation (Line(points={{-99,60},{-78,
                          60},{-78,-5.53846},{18,-5.53846}},
                                                       color={0,0,127}));
                  connect(TCut.y,conVAV2. TCut) annotation (Line(points={{-98,24},{-52,24},{-52,
                          -16.6154},{18,-16.6154}},           color={0,0,127}));
                  connect(nOcc.y,conVAV2. nOcc) annotation (Line(points={{-98,-24},{-8,-24},{-8,
                          -28},{6,-28},{6,-27.6923},{18,-27.6923}}, color={0,0,127}));
                  connect(TZon1.y, conVAV2.TZon) annotation (Line(points={{-158,-40},{-70,-40},{
                          -70,-9.23077},{18,-9.23077}},
                                            color={0,0,127}));
                  connect(TOut2.y, conVAV2.TOut) annotation (Line(points={{-158,-100},{-40,-100},
                          {-40,-1.84615},{18,-1.84615}},
                                           color={0,0,127}));
                  connect(win.y, conVAV3.uWin) annotation (Line(points={{-98,-120},{0,-120},{0,
                          -91.3846},{18,-91.3846}},
                                     color={255,0,255}));
                  connect(occSch.occupied, conVAV3.uOcc) annotation (Line(points={{-99,48},{-74,
                          48},{-74,-72.9231},{18,-72.9231}},
                                                   color={255,0,255}));
                  connect(TCut.y, conVAV3.TCut) annotation (Line(points={{-98,24},{-52,24},{-52,
                          -76.6154},{18,-76.6154}},
                                          color={0,0,127}));
                  connect(TSup1.y, conVAV3.TSup) annotation (Line(points={{-158,-70},{-84,-70},{
                          -84,-80.3077},{18,-80.3077}},
                                              color={0,0,127}));
                  connect(nOcc.y, conVAV3.nOcc) annotation (Line(points={{-98,-24},{-8,-24},{-8,
                          -87.6923},{18,-87.6923}},
                                          color={0,0,127}));
                  connect(TZon1.y, conVAV3.TZon) annotation (Line(points={{-158,-40},{-70,-40},
                          {-70,-69.2308},{18,-69.2308}},
                                              color={0,0,127}));
                  connect(occSch.tNexOcc, conVAV3.tNexOcc) annotation (Line(points={{-99,60},{
                          -78,60},{-78,-65.5385},{18,-65.5385}},
                                                   color={0,0,127}));
                  connect(TOut3.y, conVAV3.TOut) annotation (Line(points={{-158,-138},{8,-138},
                          {8,-61.8462},{18,-61.8462}},
                                            color={0,0,127}));
                  annotation (experiment(StopTime=86400, Interval=300, Tolerance=1e-06),
                  __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Validation/Controller.mos"
                    "Simulate and plot"),
                  Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                                                           Polygon(
                          lineColor={0,0,255},
                          fillColor={75,138,73},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          points={{-36,58},{64,-2},{-36,-62},{-36,58}}),
                                   Ellipse(
                          lineColor={75,138,73},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid,
                          extent={{-100,-100},{100,100}}), Polygon(
                          lineColor={0,0,255},
                          fillColor={75,138,73},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),        Diagram(
                        coordinateSystem(preserveAspectRatio=false, extent={{-200,-160},{80,140}})),
                Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.Controller</a>.
</p>
</html>",                 revisions="<html>
<ul>
<li>
August 7, 2019, by Kun Zhang:<br/>
Included more validation cases.
</li>
<li>
October 24, 2018, by David Blum:<br/>
First implementation.
</li>
</ul>
</html>"));
                end Controller;

                model CoolingCoil "Validation of cooling coil model"
                  final parameter Real TSupSet(
                    final unit="K",
                    final displayUnit="degC",
                    final quantity="ThermodynamicTemperature")=291.15
                    "Supply air temperature setpoint";
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.CoolingCoil
                    cooCoi(controllerTypeCooCoi=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P,
                      kCooCoi=1) "Cooling coil controller" annotation (
                      Placement(transformation(extent={{-10,-10},{10,10}})));
                  CDL.Continuous.Sources.Ramp TSup(
                    final height=4,
                    final offset=TSupSet - 2,
                    final duration=3600*8)
                    "Measured supply air temperature"
                    annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
                  CDL.Continuous.Sources.Constant TSupSetSig(
                    final k=TSupSet)
                    "Supply air temperature setpoint"
                    annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
                  CDL.Logical.Sources.Constant fanStatus(k=true)
                    "Fan is on"
                    annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
                  CDL.Continuous.Sources.Pulse zonSta(
                    offset=2,
                    period=3600*2)
                    "Zone state"
                    annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
                  CDL.Conversions.RealToInteger reaToInt
                    "Real to integer conversion"
                    annotation (Placement(transformation(extent={{-48,-30},{-28,-10}})));
                equation
                  connect(TSup.y, cooCoi.TSup) annotation (Line(points={{-58,30},{-40,30},{-40,4},
                          {-12,4}},      color={0,0,127}));
                  connect(TSupSetSig.y, cooCoi.TSupCoo) annotation (Line(points={{-58,70},{-36,70},
                          {-36,8},{-12,8}},     color={0,0,127}));
                  connect(fanStatus.y, cooCoi.uSupFan) annotation (Line(points={{-58,-50},{-20,-50},
                          {-20,-8},{-12,-8}},      color={255,0,255}));
                  connect(zonSta.y, reaToInt.u)
                    annotation (Line(points={{-58,-20},{-50,-20}},
                                                                 color={0,0,127}));
                  connect(reaToInt.y, cooCoi.uZonSta) annotation (Line(points={{-26,-20},{-24,-20},
                          {-24,-4},{-12,-4}},
                                            color={255,127,0}));
                  annotation (
                    Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                                   Ellipse(
                          lineColor={75,138,73},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid,
                          extent={{-100,-100},{100,100}}), Polygon(
                          lineColor={0,0,255},
                          fillColor={75,138,73},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                    Diagram(coordinateSystem(preserveAspectRatio=false)),
                    experiment(
                      StopTime=28000,
                      Interval=600,
                      Tolerance=1e-06),
                      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Validation/CoolingCoil.mos"
                    "Simulate and plot"),
                Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.CoolingCoil\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.CoolingCoil</a>.
</p>
</html>",                 revisions="<html>
<ul>
<li>
October 30, 2018, by David Blum:<br/>
First implementation.
</li>
</ul>
</html>"));
                end CoolingCoil;

                model ZoneState "Validation models of determining zone state"
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.ZoneState
                    zonSta "Zone state" annotation (Placement(transformation(
                          extent={{0,-10},{20,10}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse
                    uCoo(
                    period=2,
                    offset=0,
                    startTime=1,
                    amplitude=1) "Cooling control signal" annotation (Placement(
                        transformation(extent={{-80,-40},{-60,-20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse
                    uHea(
                    period=2,
                    offset=0,
                    amplitude=1,
                    startTime=2) "Heating control signal" annotation (Placement(
                        transformation(extent={{-80,20},{-60,40}})));
                equation
                  connect(uHea.y, zonSta.uHea) annotation (Line(points={{-58,30},{-50,30},{-50,
                          4},{-2,4}},     color={0,0,127}));
                  connect(uCoo.y, zonSta.uCoo) annotation (Line(points={{-58,-30},{-50,-30},{
                          -50,-4},{-2,-4}}, color={0,0,127}));
                  annotation (experiment(StopTime=3, Interval=300, Tolerance=1e-06),
                  __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/AHUs/SingleZone/VAV/Validation/ZoneState.mos"
                    "Simulate and plot"),
                    Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                                   Ellipse(
                          lineColor={75,138,73},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid,
                          extent={{-100,-100},{100,100}}), Polygon(
                          lineColor={0,0,255},
                          fillColor={75,138,73},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                    Diagram(coordinateSystem(preserveAspectRatio=false)),
                Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.ZoneState\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone.VAV.ZoneState</a>.
</p>
</html>",                 revisions="<html>
<ul>
<li>
October 24, 2018, by David Blum:<br/>
First implementation.
</li>
</ul>
</html>"));
                end ZoneState;
                annotation (Icon(graphics={
                      Rectangle(
                        lineColor={200,200,200},
                        fillColor={248,248,248},
                        fillPattern=FillPattern.HorizontalCylinder,
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Polygon(
                        origin={8.0,14.0},
                        lineColor={78,138,73},
                        fillColor={78,138,73},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}}),
                      Rectangle(
                        lineColor={128,128,128},
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0)}),
              Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs.SingleZone</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"));
              end Validation;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains control sequences from ASHRAE Guideline 36, Part 5.P for
single zone VAV air handling unit control.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Ellipse(
                      origin={10.0,10.0},
                      fillColor={76,76,76},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{-80.0,-80.0},{-20.0,-20.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{0.0,-80.0},{60.0,-20.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      fillColor={128,128,128},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      extent={{0.0,0.0},{60.0,60.0}}),
                    Ellipse(
                      origin={10.0,10.0},
                      lineColor={128,128,128},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid,
                      extent={{-80.0,0.0},{-20.0,60.0}})}));
            end VAV;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains control sequences from ASHRAE Guideline 36 for single zone air handling units.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),      Rectangle(
                      extent={{-66,70},{70,-72}},
                      lineColor={0,0,127},
                      lineThickness=0.5)}));
          end SingleZone;
          annotation (
          Documentation(info="<html>
<p>
This package contains AHU control sequences from ASHRAE Guideline 36.
</p>
</html>"),         Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),      Rectangle(
                    extent={{-60,60},{60,-60}},
                    lineColor={0,0,127},
                    lineThickness=0.5)}));
        end AHUs;

        package Generic "Generic control sequences"

          block FreezeProtectionMixedAir "Freeze protection based on mixed air temperature"

            parameter
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController controllerType=
                hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
              "Type of controller";
            parameter Real k(final unit="1/K")=0.1 "Gain";

            parameter Real Ti(
              final unit="s",
              final quantity="Time")= 120 "Time constant of integrator block";

            parameter Real Td(
              final unit="s",
              final quantity="Time")= 0.1
              "Time constant of derivative block"
              annotation (Dialog(
                enable=controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                     or controllerType == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

            parameter Real TFreSet(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")= 279.15
              "Lower limit for mixed air temperature for freeze protection";

            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TMix(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")
              "Mixed air temperature measurement" annotation (Placement(
                  transformation(extent={{-140,-20},{-100,20}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yFrePro(
              final unit="1",
              final min=0,
              final max=1)
              "Freeze protection control signal, 0 if no frost, 1 if TMix below TFreSet"
              annotation (Placement(transformation(extent={{100,-50},{140,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yFreProInv(
              final unit="1",
              final min=0,
              final max=1)
              "Inverse freeze protection control signal, 1 if no frost, 0 if TMix below TFreSet"
              annotation (Placement(transformation(extent={{100,10},{140,50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID con(
              final controllerType=controllerType,
              final k=k,
              final Ti=Ti,
              final Td=Td,
              final yMax=1,
              final yMin=0)
              "Controller for mixed air to track freeze protection set point"
              annotation (Placement(transformation(extent={{-20,20},{0,40}})));

          protected
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant setPoi(final k=
                  TFreSet) "Set point for freeze protection" annotation (
                Placement(transformation(extent={{-60,20},{-40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter yOut(final p=1,
                final k=-1) "Freeze protection control signal inverter"
              annotation (Placement(transformation(extent={{60,20},{80,40}})));

          equation
            connect(con.u_s, setPoi.y)
              annotation (Line(points={{-22,30},{-38,30}}, color={0,0,127}));
            connect(yOut.y, yFreProInv)
              annotation (Line(points={{82,30},{120,30}}, color={0,0,127}));
            connect(TMix, con.u_m)
              annotation (Line(points={{-120,0},{-10,0},{-10,18}}, color={0,0,127}));
            connect(con.y, yFrePro) annotation (Line(points={{2,30},{30,30},{30,-30},{120,
                    -30}}, color={0,0,127}));
            connect(con.y, yOut.u) annotation (Line(points={{2,30},{30,30},{30,30},{58,30}},
                  color={0,0,127}));
            annotation (Dialog(
              enable=controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI
                  or controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID),
              defaultComponentName = "freProTMix",
              Icon(graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={135,135,135},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-164,144},{164,106}},
                    lineColor={0,0,127},
                    textString="%name"),
                  Line(
                    points={{-20,-46},{-20,40},{36,40},{-20,40},{-20,2},{26,2}},
                    color={0,0,127},
                    thickness=0.5)}),
          Documentation(info="<html>
<p>
Block that tracks the mixed air temperature <code>TMix</code>
using a PI controller and outputs
a freeze protection control signal <code>yFrePro</code> and
its inverse <code>yFreProInv</code>.
</p>
</html>",           revisions="<html>
<ul>
<li>
November 2, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
          end FreezeProtectionMixedAir;

          package SetPoints "Package with sequences that output control setpoints"

            block OperationMode "Block that outputs the operation mode"

              parameter Boolean have_winSen
                "Check if the zone has window status sensor"
                annotation(Dialog(group="Sensors"));
              parameter Integer numZon(min=1) "Number of zones";
              parameter Real preWarCooTim(unit="s") = 10800
                "Maximum cool-down or warm-up time";
              parameter Real TZonFreProOn(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature") = 277.55
                "Threshold zone temperature value to activate freeze protection mode";
              parameter Real TZonFreProOff(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature") = 280.35
                "Threshold zone temperature value to finish the freeze protection mode";

              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uOcc
                "Zone occupancy status: true=occupied, false=unoccupied"
                annotation (Placement(transformation(extent={{-300,310},{-260,
                        350}}), iconTransformation(extent={{-140,100},{-100,140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput tNexOcc(final
                  unit="s", final quantity="Time")
                "Time to next occupied period" annotation (Placement(
                    transformation(extent={{-300,270},{-260,310}}),
                    iconTransformation(extent={{-140,80},{-100,120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput maxCooDowTim(final
                  unit="s", final quantity="Time")
                "Maximum cool-down time among all the zones" annotation (
                  Placement(transformation(extent={{-300,210},{-260,250}}),
                    iconTransformation(extent={{-140,60},{-100,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput maxWarUpTim(final
                  unit="s", final quantity="Time")
                "Maximum warm-up time among all the zones" annotation (
                  Placement(transformation(extent={{-300,130},{-260,170}}),
                    iconTransformation(extent={{-140,40},{-100,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput occHeaHigMin
                "True when the occupied heating setpoint temperature is higher than the minimum zone temperature"
                annotation (Placement(transformation(extent={{-300,90},{-260,
                        130}}), iconTransformation(extent={{-140,20},{-100,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput maxHigOccCoo
                "True when the maximum zone temperature is higher than the occupied cooling setpoint"
                annotation (Placement(transformation(extent={{-300,60},{-260,
                        100}}), iconTransformation(extent={{-140,0},{-100,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uWinSta if
                have_winSen "Window status: true=open, false=close" annotation
                (Placement(transformation(extent={{-300,30},{-260,70}}),
                    iconTransformation(extent={{-140,-20},{-100,20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput totColZon
                "Total number of cold zone" annotation (Placement(
                    transformation(extent={{-300,-30},{-260,10}}),
                    iconTransformation(extent={{-140,-40},{-100,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput unoHeaHigMin
                "True when the unoccupied heating setpoint is higher than minimum zone temperature"
                annotation (Placement(transformation(extent={{-300,-90},{-260,-50}}),
                    iconTransformation(extent={{-140,-60},{-100,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonMax(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Maximum zone temperature" annotation (Placement(transformation(
                      extent={{-300,-130},{-260,-90}}), iconTransformation(
                      extent={{-140,-80},{-100,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonMin(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Minimum zone temperature" annotation (Placement(transformation(
                      extent={{-300,-170},{-260,-130}}), iconTransformation(
                      extent={{-140,-100},{-100,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput totHotZon
                "Total number of hot zone" annotation (Placement(transformation(
                      extent={{-300,-230},{-260,-190}}), iconTransformation(
                      extent={{-140,-120},{-100,-80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput maxHigUnoCoo
                "True when the maximum zone temperature is higher than unoccupied cooling setpoint"
                annotation (Placement(transformation(extent={{-300,-290},{-260,
                        -250}}), iconTransformation(extent={{-140,-140},{-100,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput yOpeMod
                "Operation mode" annotation (Placement(transformation(extent={{
                        460,-40},{500,0}}), iconTransformation(extent={{100,-20},
                        {140,20}})));

            protected
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                occModInd(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                "Occupied mode " annotation (Placement(transformation(extent={{
                        200,300},{220,320}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                unoPerInd(final k=0) "Index to indicate unoccupied period"
                annotation (Placement(transformation(extent={{100,250},{120,270}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch corCooDowTim
                "Corrected cool down period" annotation (Placement(
                    transformation(extent={{-20,200},{0,220}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch corWarUpTim
                "Corrected warm-up period" annotation (Placement(transformation(
                      extent={{-20,160},{0,180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold intGreThr(final
                  threshold=4)
                "Check if the number of cold zones is not less than than 5"
                annotation (Placement(transformation(extent={{-180,-20},{-160,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold intGreThr1(final
                  threshold=numZon - 1) "Check if all zones are cold zone"
                annotation (Placement(transformation(extent={{-180,-50},{-160,-30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.FallingEdge falEdg
                "Check if the unoccupied heating setpoint becomes lower than minimum zone temperature: true to false"
                annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch lat
                "If all zone temperature are higher than unoccupied heating setpoint by a given limit, then the setback mode should be off"
                annotation (Placement(transformation(extent={{-40,-20},{-20,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch lat1
                "If all zone temperature are higher than threshold temperature of ending freeze protection, then freeze protection setback mode should be off"
                annotation (Placement(transformation(extent={{-40,-120},{-20,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch lat2
                "If all zone temperature are lower than unoccupied cooling setpoint by a given limit, then the setup mode should be off"
                annotation (Placement(transformation(extent={{-40,-220},{-20,-200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.FallingEdge falEdg1
                "Check if the unoccupied cooling setpoint becomes higher than maximum zone temperature: true to false"
                annotation (Placement(transformation(extent={{-100,-260},{-80,-240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys2(
                final pre_y_start=true,
                final uHigh=0,
                final uLow=-60)
                "Hysteresis that outputs if the maximum cool-down time is more than the allowed cool-down time"
                annotation (Placement(transformation(extent={{-100,200},{-80,
                        220}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys3(
                final pre_y_start=true,
                final uHigh=0,
                final uLow=-60)
                "Hysteresis that outputs if the maximum warm-up time is more than allowed warm-up time"
                annotation (Placement(transformation(extent={{-100,160},{-80,
                        180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add5(final k1=
                    -1)
                "Calculate differential between time-to-next-occupancy and the cool-down time"
                annotation (Placement(transformation(extent={{40,210},{60,230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys4(
                final pre_y_start=false,
                final uHigh=0,
                final uLow=-60) "Hysteresis to activate the cool-down model"
                annotation (Placement(transformation(extent={{80,210},{100,230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys5(
                final pre_y_start=false,
                final uHigh=0,
                final uLow=-60) "Hysteresis to activate the warm-up model"
                annotation (Placement(transformation(extent={{80,170},{100,190}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add6(final k1=
                    -1)
                "Calculate differential between time-to-next-occupancy and the warm-up time"
                annotation (Placement(transformation(extent={{40,170},{60,190}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys9(
                final pre_y_start=false,
                final uLow=-0.1,
                final uHigh=0.1)
                "Hysteresis that outputs if any zone temperature is lower than freeze protection threshold temperature"
                annotation (Placement(transformation(extent={{-140,-120},{-120,
                        -100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar(final p=
                    TZonFreProOn, final k=-1)
                "Calculate differential between minimum zone temperature and freeze protection threshold temperature"
                annotation (Placement(transformation(extent={{-180,-120},{-160,
                        -100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys10(
                final pre_y_start=false,
                final uLow=-0.1,
                final uHigh=0.1)
                "Hysteresis that outputs if all zone temperature are higher than threshold temperature of ending freeze protection"
                annotation (Placement(transformation(extent={{-140,-160},{-120,
                        -140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar1(final k=1,
                  final p=(-1)*TZonFreProOff)
                "Calculate differential between maximum zone temperature and threshold temperature of ending freeze protection"
                annotation (Placement(transformation(extent={{-180,-160},{-160,
                        -140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar2(final p=
                    preWarCooTim, final k=-1)
                "Calculate the differential between maximum cool down time and the allowed maximum cool down time"
                annotation (Placement(transformation(extent={{-140,200},{-120,
                        220}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar3(final p=
                    preWarCooTim, final k=-1)
                "Calculate the differential between maximum warm-up time and the allowed maximum warm-up time"
                annotation (Placement(transformation(extent={{-140,160},{-120,
                        180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                maxWarCooTime(final k=preWarCooTim)
                "Allowed maximum warm-up or cool-down time" annotation (
                  Placement(transformation(extent={{-200,180},{-180,200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch lat3
                "Hold true when it should be in warm-up mode" annotation (
                  Placement(transformation(extent={{-100,100},{-80,120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch lat4
                "Hold true when it should be in cool-down mode" annotation (
                  Placement(transformation(extent={{-100,70},{-80,90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold intGreThr2(final
                  threshold=4)
                "Check if the number of hot zones is not less than than 5"
                annotation (Placement(transformation(extent={{-180,-220},{-160,
                        -200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold intGreThr3(final
                  threshold=numZon - 1) "Check if all zones are hot zone"
                annotation (Placement(transformation(extent={{-180,-250},{-160,
                        -230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Add addInt
                "Sum of two integer inputs" annotation (Placement(
                    transformation(extent={{300,190},{320,210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Add addInt1
                "Sum of two integer inputs" annotation (Placement(
                    transformation(extent={{360,240},{380,260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Add addInt2
                "Sum of two integer inputs" annotation (Placement(
                    transformation(extent={{240,-90},{260,-70}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Add addInt3
                "Sum of two integer inputs" annotation (Placement(
                    transformation(extent={{280,-200},{300,-180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Add addInt4
                "Sum of two integer inputs" annotation (Placement(
                    transformation(extent={{320,-290},{340,-270}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Add addInt5
                "Sum of two integer inputs" annotation (Placement(
                    transformation(extent={{420,-30},{440,-10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger occMod
                "Convert Real number to Integer number" annotation (Placement(
                    transformation(extent={{300,270},{320,290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger setBacMod
                "Convert Real number to Integer number" annotation (Placement(
                    transformation(extent={{200,-20},{220,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger freProSetBacMod
                "Convert Real number to Integer number" annotation (Placement(
                    transformation(extent={{200,-120},{220,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger setUpMod
                "Convert Real number to Integer number" annotation (Placement(
                    transformation(extent={{200,-220},{220,-200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                booToInt1(final integerTrue=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                "Convert Boolean to Integer number" annotation (Placement(
                    transformation(extent={{260,170},{280,190}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                booToInt(final integerTrue=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.coolDown)
                "Convert Boolean to Integer number" annotation (Placement(
                    transformation(extent={{260,210},{280,230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                booToInt3(final integerTrue=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.unoccupied)
                "Convert Boolean to Integer " annotation (Placement(
                    transformation(extent={{220,-340},{240,-320}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea6(final
                  realTrue=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.setUp)
                "Convert Boolean to Real " annotation (Placement(transformation(
                      extent={{60,-220},{80,-200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea4(final
                  realTrue=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.freezeProtection)
                "Convert Boolean to Real " annotation (Placement(transformation(
                      extent={{60,-120},{80,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea3(final
                  realTrue=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.setBack)
                "Convert Boolean to Real " annotation (Placement(transformation(
                      extent={{60,-20},{80,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.Assert assMes(final
                  message="Level 3 alarm: freeze protection setback")
                "Generate alarm message" annotation (Placement(transformation(
                      extent={{100,-160},{120,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not2
                "Logical not" annotation (Placement(transformation(extent={{180,
                        -340},{200,-320}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1
                "Check if the warm-up time should be activated" annotation (
                  Placement(transformation(extent={{200,170},{220,190}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2
                "Check if the cool-down time should be activated" annotation (
                  Placement(transformation(extent={{200,210},{220,230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or1
                "Check if the number of cold zone is more than 5 or all zones are cold"
                annotation (Placement(transformation(extent={{-100,-20},{-80,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or3 or3
                "Check if it is in Occupied, Cool-down, or Warm-up mode"
                annotation (Placement(transformation(extent={{0,20},{20,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or4
                "Check if the number of hot zone is more than 5 or all zones are cold"
                annotation (Placement(transformation(extent={{-100,-220},{-80,-200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or3 or5
                "Check if it is in Setback, Setback_freezeProtection, or Setup mode"
                annotation (Placement(transformation(extent={{60,-320},{80,-300}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or6
                "Check if it is in any of the 6 modes except unoccupied mode"
                annotation (Placement(transformation(extent={{120,-340},{140,-320}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                "Switch between occupied mode index and unoccupied period index"
                annotation (Placement(transformation(extent={{260,270},{280,290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi3
                "If the Cool-down, warm-up, or Occupied mode is on, then setback mode should not be activated."
                annotation (Placement(transformation(extent={{160,-20},{180,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi4
                "If the Cool-down, warm-up, or Occupied mode is on, then freeze protection setback mode should not be activated."
                annotation (Placement(transformation(extent={{160,-120},{180,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi5
                "If the Cool-down, warm-up, or Occupied mode is on, then setup mode should not be activated."
                annotation (Placement(transformation(extent={{160,-220},{180,-200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not3
                "Logical not" annotation (Placement(transformation(extent={{120,
                        190},{140,210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not4
                "Logical not" annotation (Placement(transformation(extent={{120,
                        150},{140,170}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not5
                "Logical not" annotation (Placement(transformation(extent={{60,
                        -160},{80,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold notOcc(final
                  threshold=1) if have_winSen
                "Check if the operation mode is other than occupied mode"
                annotation (Placement(transformation(extent={{200,20},{220,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and3 if
                have_winSen
                "True if window open during modes other than occupied mode"
                annotation (Placement(transformation(extent={{260,40},{280,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1 if
                have_winSen "Logical not" annotation (Placement(transformation(
                      extent={{300,40},{320,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.Assert winOpe(final
                  message=
                    "Level 4 alarm: window open during modes other than occupied mode")
                if have_winSen
                "Generate alarm message when window open during modes other than occupied mode"
                annotation (Placement(transformation(extent={{340,40},{360,60}})));

            equation
              connect(swi.y, occMod.u)
                annotation (Line(points={{282,280},{298,280}},
                  color={0,0,127}));
              connect(occModInd.y, swi.u1)
                annotation (Line(points={{222,310},{240,310},{240,288},{258,288}},
                  color={0,0,127}, pattern=LinePattern.Dash));
              connect(unoPerInd.y, swi.u3)
                annotation (Line(points={{122,260},{150,260},{150,272},{258,272}},
                  color={0,0,127}, pattern=LinePattern.Dash));
              connect(intGreThr.y, or1.u1)
                annotation (Line(points={{-158,-10},{-102,-10}},
                  color={255,0,255}));
              connect(intGreThr1.y, or1.u2)
                annotation (Line(points={{-158,-40},{-120,-40},{-120,-18},{-102,-18}},
                  color={255,0,255}));
              connect(or1.y, lat.u)
                annotation (Line(points={{-78,-10},{-42,-10}},
                  color={255,0,255}));
              connect(falEdg.y, lat.clr)
                annotation (Line(points={{-78,-50},{-60,-50},{-60,-16},{-42,-16}},
                              color={255,0,255}));
              connect(lat.y, booToRea3.u)
                annotation (Line(points={{-18,-10},{58,-10}},
                  color={255,0,255}));
              connect(unoPerInd.y, swi3.u1)
                annotation (Line(points={{122,260},{150,260},{150,-2},{158,-2}},
                  color={0,0,127}, pattern=LinePattern.Dash));
              connect(or3.y, swi3.u2)
                annotation (Line(points={{22,30},{140,30},{140,-10},{158,-10}},
                  color={255,0,255}));
              connect(lat1.y, booToRea4.u)
                annotation (Line(points={{-18,-110},{58,-110}},  color={255,0,255}));
              connect(or3.y, swi4.u2)
                annotation (Line(points={{22,30},{140,30},{140,-110},{158,-110}},
                                 color={255,0,255}));
              connect(unoPerInd.y, swi4.u1)
                annotation (Line(points={{122,260},{150,260},{150,-102},{158,-102}},
                  color={0,0,127}, pattern=LinePattern.Dash));
              connect(or4.y, lat2.u)
                annotation (Line(points={{-78,-210},{-42,-210}}, color={255,0,255}));
              connect(falEdg1.y, lat2.clr)
                annotation (Line(points={{-78,-250},{-60,-250},{-60,-216},{-42,-216}},
                                          color={255,0,255}));
              connect(lat2.y, booToRea6.u)
                annotation (Line(points={{-18,-210},{58,-210}},
                  color={255,0,255}));
              connect(or3.y, swi5.u2)
                annotation (Line(points={{22,30},{140,30},{140,-210},{158,-210}},
                                          color={255,0,255}));
              connect(unoPerInd.y, swi5.u1)
                annotation (Line(points={{122,260},{150,260},{150,-202},{158,-202}},
                  color={0,0,127},  pattern=LinePattern.Dash));
              connect(swi3.y, setBacMod.u)
                annotation (Line(points={{182,-10},{198,-10}},
                  color={0,0,127}));
              connect(swi4.y, freProSetBacMod.u)
                annotation (Line(points={{182,-110},{198,-110}}, color={0,0,127}));
              connect(swi5.y, setUpMod.u)
                annotation (Line(points={{182,-210},{198,-210}},
                  color={0,0,127}));
              connect(lat.y, or5.u1)
                annotation (Line(points={{-18,-10},{10,-10},{10,-302},{58,-302}},
                               color={255,0,255}));
              connect(lat1.y, or5.u2)
                annotation (Line(points={{-18,-110},{0,-110},{0,-310},{58,-310}},
                                          color={255,0,255}));
              connect(lat2.y, or5.u3)
                annotation (Line(points={{-18,-210},{20,-210},{20,-318},{58,-318}},
                                          color={255,0,255}));
              connect(or5.y, or6.u1)
                annotation (Line(points={{82,-310},{100,-310},{100,-330},{118,-330}},
                  color={255,0,255}));
              connect(or3.y, or6.u2)
                annotation (Line(points={{22,30},{40,30},{40,-338},{118,-338}},
                  color={255,0,255}));
              connect(or6.y, not2.u)
                annotation (Line(points={{142,-330},{178,-330}},
                  color={255,0,255}));
              connect(not2.y,booToInt3. u)
                annotation (Line(points={{202,-330},{218,-330}},
                  color={255,0,255}));
              connect(and2.y, booToInt.u)
                annotation (Line(points={{222,220},{258,220}}, color={255,0,255}));
              connect(and1.y, booToInt1.u)
                annotation (Line(points={{222,180},{258,180}}, color={255,0,255}));
              connect(and2.y, or3.u2)
                annotation (Line(points={{222,220},{230,220},{230,100},{-20,100},{-20,30},{-2,
                      30}},
                  color={255,0,255}));
              connect(and1.y, or3.u1)
                annotation (Line(points={{222,180},{240,180},{240,90},{-10,90},{-10,38},{-2,
                      38}},
                  color={255,0,255}));
              connect(uOcc, swi.u2)
                annotation (Line(points={{-280,330},{-220,330},{-220,280},{258,280}},
                  color={255,0,255}));
              connect(uOcc, or3.u3)
                annotation (Line(points={{-280,330},{-220,330},{-220,22},{-2,22}},
                  color={255,0,255}));
              connect(hys2.y, corCooDowTim.u2)
                annotation (Line(points={{-78,210},{-22,210}},          color={255,0,255}));
              connect(hys3.y, corWarUpTim.u2)
                annotation (Line(points={{-78,170},{-22,170}},          color={255,0,255}));
              connect(add5.y, hys4.u)
                annotation (Line(points={{62,220},{78,220}},            color={0,0,127}));
              connect(hys4.y, and2.u1)
                annotation (Line(points={{102,220},{198,220}},
                  color={255,0,255}));
              connect(tNexOcc, add5.u1)
                annotation (Line(points={{-280,290},{20,290},{20,226},{38,226}},
                  color={0,0,127}));
              connect(corCooDowTim.y, add5.u2)
                annotation (Line(points={{2,210},{30,210},{30,214},{38,214}},
                  color={0,0,127}));
              connect(tNexOcc, add6.u1)
                annotation (Line(points={{-280,290},{20,290},{20,186},{38,186}},
                  color={0,0,127}));
              connect(corWarUpTim.y, add6.u2)
                annotation (Line(points={{2,170},{20,170},{20,174},{38,174}},
                  color={0,0,127}));
              connect(add6.y, hys5.u)
                annotation (Line(points={{62,180},{78,180}},            color={0,0,127}));
              connect(hys5.y, and1.u1)
                annotation (Line(points={{102,180},{198,180}}, color={255,0,255}));
              connect(addPar.y, hys9.u)
                annotation (Line(points={{-158,-110},{-142,-110}},       color={0,0,127}));
              connect(hys9.y, lat1.u)
                annotation (Line(points={{-118,-110},{-42,-110}},
                                                                color={255,0,255}));
              connect(addPar1.y, hys10.u)
                annotation (Line(points={{-158,-150},{-142,-150}},
                                                               color={0,0,127}));
              connect(hys10.y, lat1.clr)
                annotation (Line(points={{-118,-150},{-80,-150},{-80,-116},{-42,-116}},
                  color={255,0,255}));
              connect(addPar2.y, hys2.u)
                annotation (Line(points={{-118,210},{-102,210}},
                                                               color={0,0,127}));
              connect(addPar3.y, hys3.u)
                annotation (Line(points={{-118,170},{-102,170}},
                                                               color={0,0,127}));
              connect(maxWarCooTime.y, corCooDowTim.u3)
                annotation (Line(points={{-178,190},{-60,190},{-60,202},{-22,202}},
                  color={0,0,127}));
              connect(maxWarCooTime.y, corWarUpTim.u3)
                annotation (Line(points={{-178,190},{-60,190},{-60,162},{-22,162}},
                  color={0,0,127}));
              connect(booToRea3.y, swi3.u3)
                annotation (Line(points={{82,-10},{100,-10},{100,-18},{158,-18}},
                  color={0,0,127}));
              connect(booToRea4.y, swi4.u3)
                annotation (Line(points={{82,-110},{100,-110},{100,-118},{158,-118}},
                  color={0,0,127}));
              connect(booToRea6.y, swi5.u3)
                annotation (Line(points={{82,-210},{100,-210},{100,-218},{158,-218}},
                  color={0,0,127}));
              connect(lat3.y, and1.u2)
                annotation (Line(points={{-78,110},{188,110},{188,172},{198,172}},
                  color={255,0,255}));
              connect(lat4.y, and2.u2)
                annotation (Line(points={{-78,80},{-30,80},{-30,120},{180,120},{180,212},{198,
                      212}},
                  color={255,0,255}));
              connect(hys4.y, not3.u)
                annotation (Line(points={{102,220},{110,220},{110,200},{118,200}},
                  color={255,0,255}));
              connect(hys5.y, not4.u)
                annotation (Line(points={{102,180},{110,180},{110,160},{118,160}},
                  color={255,0,255}));
              connect(not4.y, lat3.clr)
                annotation (Line(points={{142,160},{160,160},{160,140},{-140,140},{-140,104},
                      {-102,104}},
                            color={255,0,255}));
              connect(not3.y, lat4.clr)
                annotation (Line(points={{142,200},{170,200},{170,130},{-160,130},{-160,74},
                      {-102,74}},
                            color={255,0,255}));
              connect(lat1.y, not5.u)
                annotation (Line(points={{-18,-110},{0,-110},{0,-150},{58,-150}},
                  color={255,0,255}));
              connect(not5.y, assMes.u)
                annotation (Line(points={{82,-150},{98,-150}},   color={255,0,255}));
              connect(maxCooDowTim, addPar2.u) annotation (Line(points={{-280,230},{-160,230},
                      {-160,210},{-142,210}}, color={0,0,127}));
              connect(maxCooDowTim, corCooDowTim.u1) annotation (Line(points={{-280,230},{-60,
                      230},{-60,218},{-22,218}}, color={0,0,127}));
              connect(maxWarUpTim, addPar3.u) annotation (Line(points={{-280,150},{-160,150},
                      {-160,170},{-142,170}}, color={0,0,127}));
              connect(maxWarUpTim, corWarUpTim.u1) annotation (Line(points={{-280,150},{-40,
                      150},{-40,178},{-22,178}}, color={0,0,127}));
              connect(occHeaHigMin, lat3.u)
                annotation (Line(points={{-280,110},{-102,110}}, color={255,0,255}));
              connect(maxHigOccCoo, lat4.u)
                annotation (Line(points={{-280,80},{-102,80}}, color={255,0,255}));
              connect(unoHeaHigMin, falEdg.u) annotation (Line(points={{-280,-70},{-120,-70},
                      {-120,-50},{-102,-50}}, color={255,0,255}));
              connect(TZonMax, addPar.u)
                annotation (Line(points={{-280,-110},{-182,-110}}, color={0,0,127}));
              connect(TZonMin, addPar1.u)
                annotation (Line(points={{-280,-150},{-182,-150}}, color={0,0,127}));
              connect(maxHigUnoCoo, falEdg1.u) annotation (Line(points={{-280,-270},{-120,-270},
                      {-120,-250},{-102,-250}}, color={255,0,255}));
              connect(totColZon, intGreThr.u)
                annotation (Line(points={{-280,-10},{-182,-10}}, color={255,127,0}));
              connect(totColZon, intGreThr1.u) annotation (Line(points={{-280,-10},{-220,-10},
                      {-220,-40},{-182,-40}}, color={255,127,0}));
              connect(totHotZon, intGreThr2.u)
                annotation (Line(points={{-280,-210},{-182,-210}}, color={255,127,0}));
              connect(totHotZon, intGreThr3.u) annotation (Line(points={{-280,-210},{-220,
                      -210},{-220,-240},{-182,-240}},
                                                color={255,127,0}));
              connect(intGreThr2.y, or4.u1)
                annotation (Line(points={{-158,-210},{-102,-210}}, color={255,0,255}));
              connect(intGreThr3.y, or4.u2) annotation (Line(points={{-158,-240},{-120,-240},
                      {-120,-218},{-102,-218}}, color={255,0,255}));
              connect(booToInt.y, addInt.u1) annotation (Line(points={{282,220},{290,220},{290,
                      206},{298,206}}, color={255,127,0}));
              connect(booToInt1.y, addInt.u2) annotation (Line(points={{282,180},{290,180},{
                      290,194},{298,194}}, color={255,127,0}));
              connect(occMod.y, addInt1.u1) annotation (Line(points={{322,280},{340,280},{340,
                      256},{358,256}}, color={255,127,0}));
              connect(addInt.y, addInt1.u2) annotation (Line(points={{322,200},{340,200},{340,
                      244},{358,244}}, color={255,127,0}));
              connect(setBacMod.y, addInt2.u1) annotation (Line(points={{222,-10},{230,-10},
                      {230,-74},{238,-74}}, color={255,127,0}));
              connect(freProSetBacMod.y, addInt2.u2) annotation (Line(points={{222,-110},{230,
                      -110},{230,-86},{238,-86}}, color={255,127,0}));
              connect(setUpMod.y, addInt3.u2) annotation (Line(points={{222,-210},{260,-210},
                      {260,-196},{278,-196}}, color={255,127,0}));
              connect(addInt2.y, addInt3.u1) annotation (Line(points={{262,-80},{270,-80},{270,
                      -184},{278,-184}}, color={255,127,0}));
              connect(addInt3.y, addInt4.u1) annotation (Line(points={{302,-190},{310,-190},
                      {310,-274},{318,-274}}, color={255,127,0}));
              connect(booToInt3.y, addInt4.u2) annotation (Line(points={{242,-330},{300,-330},
                      {300,-286},{318,-286}}, color={255,127,0}));
              connect(addInt1.y, addInt5.u1) annotation (Line(points={{382,250},{400,250},{400,
                      -14},{418,-14}}, color={255,127,0}));
              connect(addInt4.y, addInt5.u2) annotation (Line(points={{342,-280},{400,-280},
                      {400,-26},{418,-26}}, color={255,127,0}));
              connect(addInt5.y, yOpeMod)
                annotation (Line(points={{442,-20},{480,-20}}, color={255,127,0}));
              connect(uWinSta, and3.u1)
                annotation (Line(points={{-280,50},{258,50}}, color={255,0,255}));
              connect(notOcc.y, and3.u2) annotation (Line(points={{222,30},{240,30},{240,42},
                      {258,42}}, color={255,0,255}));
              connect(and3.y, not1.u)
                annotation (Line(points={{282,50},{298,50}}, color={255,0,255}));
              connect(addInt5.y, notOcc.u) annotation (Line(points={{442,-20},{450,-20},{450,
                      10},{180,10},{180,30},{198,30}}, color={255,127,0}));
              connect(not1.y, winOpe.u)
                annotation (Line(points={{322,50},{338,50}}, color={255,0,255}));

            annotation (
              defaultComponentName = "opeModSel",
              Diagram(
                    coordinateSystem(preserveAspectRatio=false, extent={{-260,-360},{460,360}}),
                    graphics={
                    Rectangle(
                      extent={{-258,-282},{458,-358}},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-258,-202},{458,-278}},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-258,-82},{458,-158}},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-258,-2},{458,-78}},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-258,188},{458,112}},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-258,268},{458,192}},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-258,348},{458,272}},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Text(
                      extent={{336,332},{426,314}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Occupied mode"),
                    Text(
                      extent={{296,-32},{380,-54}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Setback mode"),
                    Text(
                      extent={{324,-224},{396,-246}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Setup mode"),
                    Text(
                      extent={{314,-308},{418,-338}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Unoccupied mode"),
                    Text(
                      extent={{280,-114},{452,-142}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Freeze protection setback mode"),
                    Text(
                      extent={{250,170},{338,146}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Warm-up mode"),
                    Text(
                      extent={{188,262},{276,234}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Cool-down mode")}),
               Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                    graphics={
                    Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-98,80},{-52,68}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="maxCooDowTim"),
                    Text(
                      extent={{-98,64},{-56,54}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="maxWarUpTim"),
                    Text(
                      extent={{58,12},{96,-10}},
                      lineColor={255,127,0},
                      pattern=LinePattern.Dash,
                      textString="yOpeMod"),
                    Text(
                      extent={{-120,144},{100,106}},
                      lineColor={0,0,255},
                      textString="%name"),
                    Text(
                      extent={{-98,94},{-74,82}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="tNexOcc"),
                    Text(
                      extent={{-100,104},{-82,96}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uOcc"),
                    Text(
                      extent={{-98,42},{-50,30}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="occHeaHigMin"),
                    Text(
                      extent={{-98,24},{-48,12}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="maxHigOccCoo"),
                    Text(
                      extent={{-98,-14},{-60,-24}},
                      lineColor={255,127,0},
                      pattern=LinePattern.Dash,
                      textString="totColZon"),
                    Text(
                      extent={{-98,-32},{-48,-44}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="unoHeaHigMin"),
                    Text(
                      extent={{-98,-56},{-70,-64}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonMax"),
                    Text(
                      extent={{-100,-76},{-70,-84}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonMin"),
                    Text(
                      extent={{-98,-96},{-66,-104}},
                      lineColor={255,127,0},
                      pattern=LinePattern.Dash,
                      textString="totHotZon"),
                    Text(
                      extent={{-98,-112},{-48,-124}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="maxHigUnoCoo"),
                    Text(
                      visible=have_winSen,
                      extent={{-98,8},{-68,-4}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="uWinSta")}),
               Documentation(info="<html>
<p>
This block outputs VAV system operation mode. It is implemented according to
ASHRAE guideline G36, PART 5.C.6 (zone group operating modes).
The block has the modes listed below.
</p>
<h4>Occupied Mode</h4>
<p>
A Zone Group is in the <i>occupied mode</i> when
occupancy input <code>uOcc</code> is true. This input shall be retrieved from
other sequences that specifies occupancy variation and time remaining to the
next occupied period <code>tNexOcc</code>.
</p>
<h4>Warmup Mode</h4>
<p>
Warmup mode shall start based on the zone with the longest calculated warm up
time <code>warUpTim</code> requirement, but no earlier than 3 hours before
the start of the scheduled occupied period, and shall end at the scheduled
occupied start time. Zones where the window switch indicates that a window
is open shall be ignored. Note that for each zone, the optimal warm-up time
<code>warUpTim</code> shall be obtained from an <i>Optimal Start</i>
sequences, computed in a separate block.
The figure below shows the sequence.
</p>
<p align=\"center\">
<img alt=\"Image of warm-up mode definition\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/OperationMode/Warm-upModeDefinition.png\"/>
</p>
<h4>Cool-Down Mode</h4>
<p>
Cool-down mode shall start based on the zone with the longest calculated
cool-down time <code>cooDowTim</code> requirement, but no earlier than 3 hours
before the start of the scheduled occupied period, and shall end at the
scheduled occupied start time. Zones where the window switch indicates that a
window is open shall be ignored. Note that the each zone <code>cooDowTim</code>
shall be obtained from an <i>Optimal Start</i> sequences, computed in a
separate block.
</p>
<p align=\"center\">
<img alt=\"Image of cool-down mode definition\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/OperationMode/Cool-downModeDefinition.png\"/>
</p>
<h4>Setback Mode</h4>
<p>
During <i>unoccupied mode</i>, if any 5 zones (or all zones, if fewer than 5)
in the zone group fall below their unoccupied heating setpoints
<code>TZonHeaSetUno</code>, the zone group shall enter <i>setback mode</i> until
all spaces in the zone group are <i>1.1</i> &deg;C (<i>2</i> &deg;F) above their
unoccupied setpoints.
</p>
<p align=\"center\">
<img alt=\"Image of setback mode definition\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/OperationMode/SetbackModeDefinition.png\"/>
</p>
<h4>Freeze Protection Setback Mode</h4>
<p>
During <i>unoccupied Mode</i>, if any single zone falls below <i>4.4</i> &deg;C
(<i>40</i> &deg;F), the zone group shall enter <i>setback mode</i> until all zones
are above <i>7.2</i> &deg;C (<i>45</i> &deg;F), and a Level 3 alarm
<code>yFreProSta</code> shall be set.
</p>
<h4>Setup Mode</h4>
<p>
During <i>unoccupied mode</i>, if any 5 zones (or all zones, if fewer than 5)
in the zone group rise above their unoccupied cooling setpoints <code>TZonCooSetUno</code>,
the zone group shall enter <i>setup mode</i> until all spaces in the zone group
are <i>1.1</i> &deg;C (<i>2</i> &deg;F) below their unoccupied setpoints. Zones
where the window switch indicates that a window is open shall be ignored.
</p>
<p align=\"center\">
<img alt=\"Image of setup mode definition\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/OperationMode/SetupModeDefinition.png\"/>
</p>
<h4>Unoccupied Mode</h4>
<p>
<i>Unoccupied mode</i> shall be active if the zone group is not in any other mode.
</p>
</html>",            revisions="<html>
<ul>
<li>
March 09, 2020, by Jianjun Hu:<br/>
Reimplemented to remove the vector-valued calculations.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1709\">#1709</a>.
</li>
<li>
April 13, 2019, by Michael Wetter:<br/>
Corrected wrong time in the documentation of the parameters.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1409\">#1409</a>.
</li>
<li>
June 19, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
            end OperationMode;

            block TrimAndRespond "Block to inplement trim and respond logic"
              parameter Real iniSet  "Initial setpoint";
              parameter Real minSet  "Minimum setpoint";
              parameter Real maxSet  "Maximum setpoint";
              parameter Real delTim(
                final unit="s",
                final quantity="Time",
                final min=100*1E-15)  "Delay time";
              parameter Real samplePeriod(
                final unit="s",
                final quantity="Time",
                final min=1E-3)
                "Sample period of component";
              parameter Integer numIgnReq  "Number of ignored requests";
              parameter Real triAmo  "Trim amount";
              parameter Real resAmo  "Respond amount (must have opposite sign of triAmo)";
              parameter Real maxRes  "Maximum response per time interval (must have same sign as resAmo)";

              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput numOfReq
                "Number of requests from zones/systems" annotation (Placement(
                    transformation(extent={{-260,-70},{-220,-30}}),
                    iconTransformation(extent={{-140,-100},{-100,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uDevSta
                "On/Off status of the associated device" annotation (Placement(
                    transformation(extent={{-260,150},{-220,190}}),
                    iconTransformation(extent={{-140,60},{-100,100}})));

              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y
                "Setpoint that have been reset" annotation (Placement(
                    transformation(extent={{220,150},{260,190}}),
                    iconTransformation(extent={{100,-20},{140,20}})));

              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay tim(final
                  delayTime=delTim + samplePeriod, final delayOnInit=true)
                "Send an on signal after some delay time" annotation (Placement(
                    transformation(extent={{-200,160},{-180,180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqualThreshold
                greThr
                "Check if the real requests is more than ignored requests setting"
                annotation (Placement(transformation(extent={{20,-60},{40,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch netRes
                "Net setpoint reset value" annotation (Placement(transformation(
                      extent={{160,-20},{180,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                resAmoCon(final k=resAmo) "Respond amount constant" annotation
                (Placement(transformation(extent={{-200,-140},{-180,-120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro
                "Products of net requests and respond amount value" annotation
                (Placement(transformation(extent={{-20,-110},{0,-90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro1
                "Product of trim and respond amount" annotation (Placement(
                    transformation(extent={{-160,-110},{-140,-90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro2
                "Product of respond and maximum amount" annotation (Placement(
                    transformation(extent={{-160,-180},{-140,-160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.UnitDelay uniDel(final
                  samplePeriod=samplePeriod, final y_start=iniSet)
                "Output the input signal with a unit delay" annotation (
                  Placement(transformation(extent={{-100,96},{-80,116}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                "Switch between initial setpoint and reseted setpoint"
                annotation (Placement(transformation(extent={{160,180},{180,160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                "Before instant (device ON + delTim + samplePeriod), the setpoint should not be trimmed"
                annotation (Placement(transformation(extent={{120,0},{140,20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi2
                "Reinitialize setpoint to initial setting when device become OFF"
                annotation (Placement(transformation(extent={{100,130},{120,150}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi3
                "Logical switch" annotation (Placement(transformation(extent={{
                        120,-160},{140,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.Sampler sampler(final
                  samplePeriod=samplePeriod) "Sample number of requests"
                annotation (Placement(transformation(extent={{-160,-60},{-140,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessEqualThreshold
                lesEquThr1 "Check if trim and response amount have same sign"
                annotation (Placement(transformation(extent={{-120,-110},{-100,
                        -90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqualThreshold
                greEquThr
                "Check if trim and response amount have opposite sign"
                annotation (Placement(transformation(extent={{-120,-180},{-100,
                        -160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqualThreshold
                greEquThr1 "Check if response amount have positive sign"
                annotation (Placement(transformation(extent={{20,-160},{40,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai(final k=-1)
                "Convert results back to negative" annotation (Placement(
                    transformation(extent={{80,-190},{100,-170}})));

            protected
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                iniSetCon(k=iniSet) "Initial setpoint" annotation (Placement(
                    transformation(extent={{-100,180},{-80,200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                numIgnReqCon(k=numIgnReq) "Number of ignored requests"
                annotation (Placement(transformation(extent={{-160,-20},{-140,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                triAmoCon(k=triAmo) "Trim amount constant" annotation (
                  Placement(transformation(extent={{-200,-90},{-180,-70}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                maxResCon(k=maxRes) "Maximum response per time interval"
                annotation (Placement(transformation(extent={{-200,-210},{-180,
                        -190}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                maxSetCon(k=maxSet) "Maximum setpoint constant" annotation (
                  Placement(transformation(extent={{-40,60},{-20,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                zerTri(k=0)
                "Zero reset amount during time range from (device ON) to (device ON + delTim + timSet)"
                annotation (Placement(transformation(extent={{60,-20},{80,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.IntegerToReal intToRea
                "Convert integer input to real output" annotation (Placement(
                    transformation(extent={{-200,-60},{-180,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add difReqIgnReq(k1=-1)
                "Difference between ignored request number and the real request number"
                annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1
                "Increase setpoint by amount of value defined from reset logic"
                annotation (Placement(transformation(extent={{-40,90},{-20,110}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2
                "Net reset value" annotation (Placement(transformation(extent={
                        {120,-96},{140,-76}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min minInp
                "Total response should not be more than maximum response"
                annotation (Placement(transformation(extent={{20,-130},{40,-110}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min min1
                "Reset setpoint should not be higher than the maximum setpoint"
                annotation (Placement(transformation(extent={{0,90},{20,110}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2
                "After (device ON + delTim + timSta), when request number becomes more than ignored requests number"
                annotation (Placement(transformation(extent={{120,-40},{140,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                "Logical Not" annotation (Placement(transformation(extent={{-100,
                        130},{-80,150}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                minSetCon(k=minSet) "Minimum setpoint constant"
                annotation (Placement(transformation(extent={{0,60},{20,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Max maxInp
                "Reset setpoint should not be lower than the minimum setpoint"
                annotation (Placement(transformation(extent={{40,90},{60,110}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.Assert assMes(final
                  message=
                    "Trim amount 'triAmo' and respond amount 'resAmo' must have opposite signs.")
                "Generate alarm message" annotation (Placement(transformation(
                      extent={{-80,-110},{-60,-90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.Assert assMes2(final
                  message=
                    "Respond amount 'resAmo' and maximum respond amount 'maxRes' must have same sign.")
                "Generate alarm message" annotation (Placement(transformation(
                      extent={{-80,-180},{-60,-160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs
                "Absolute value of real input" annotation (Placement(
                    transformation(extent={{-120,-140},{-100,-120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs1
                "Absolute value of real input" annotation (Placement(
                    transformation(extent={{-120,-210},{-100,-190}})));

            equation
              connect(numIgnReqCon.y, difReqIgnReq.u1)
                annotation (Line(points={{-138,-10},{-120,-10},{-120,-24},{-102,-24}},
                  color={0,0,127}));
              connect(difReqIgnReq.y, greThr.u)
                annotation (Line(points={{-78,-30},{-40,-30},{-40,-50},{18,-50}},
                  color={0,0,127}));
              connect(pro.y, minInp.u1)
                annotation (Line(points={{2,-100},{10,-100},{10,-114},{18,-114}},
                  color={0,0,127}));
              connect(triAmoCon.y, add2.u1)
                annotation (Line(points={{-178,-80},{118,-80}},
                  color={0,0,127}));
              connect(add2.y, netRes.u1)
                annotation (Line(points={{142,-86},{150,-86},{150,-38},{158,-38}},
                  color={0,0,127}));
              connect(iniSetCon.y, swi.u3)
                annotation (Line(points={{-78,190},{80,190},{80,178},{158,178}},
                  color={0,0,127}));
              connect(swi.y, y)
                annotation (Line(points={{182,170},{240,170}},
                  color={0,0,127}));
              connect(maxSetCon.y, min1.u2)
                annotation (Line(points={{-18,70},{-10,70},{-10,94},{-2,94}},
                  color={0,0,127}));
              connect(add1.y, min1.u1)
                annotation (Line(points={{-18,100},{-10,100},{-10,106},{-2,106}},
                  color={0,0,127}));
              connect(uniDel.y, add1.u1)
                annotation (Line(points={{-78,106},{-42,106}},
                  color={0,0,127}));
              connect(sampler.y, difReqIgnReq.u2)
                annotation (Line(points={{-138,-50},{-120,-50},{-120,-36},{-102,-36}},
                  color={0,0,127}));
              connect(triAmoCon.y, swi1.u1)
                annotation (Line(points={{-178,-80},{0,-80},{0,18},{118,18}},
                  color={0,0,127}));
              connect(zerTri.y, swi1.u3)
                annotation (Line(points={{82,-10},{100,-10},{100,2},{118,2}},
                  color={0,0,127}));
              connect(greThr.y, and2.u2)
                annotation (Line(points={{42,-50},{60,-50},{60,-38},{118,-38}},
                  color={255,0,255}));
              connect(and2.y, netRes.u2)
                annotation (Line(points={{142,-30},{158,-30}},
                  color={255,0,255}));
              connect(iniSetCon.y, swi2.u1)
                annotation (Line(points={{-78,190},{80,190},{80,148},{98,148}},
                  color={0,0,127}));
              connect(swi2.y, swi.u1)
                annotation (Line(points={{122,140},{140,140},{140,162},{158,162}},
                  color={0,0,127}));
              connect(swi2.y, uniDel.u)
                annotation (Line(points={{122,140},{140,140},{140,160},{-120,160},{-120,106},
                      {-102,106}},        color={0,0,127}));
              connect(uDevSta, not1.u)
                annotation (Line(points={{-240,170},{-210,170},{-210,140},{-102,140}},
                  color={255,0,255}));
              connect(not1.y, swi2.u2)
                annotation (Line(points={{-78,140},{98,140}},
                  color={255,0,255}));
              connect(min1.y, maxInp.u1)
                annotation (Line(points={{22,100},{30,100},{30,106},{38,106}},
                  color={0,0,127}));
              connect(minSetCon.y, maxInp.u2)
                annotation (Line(points={{22,70},{30,70},{30,94},{38,94}},
                  color={0,0,127}));
              connect(numOfReq, intToRea.u)
                annotation (Line(points={{-240,-50},{-202,-50}}, color={255,127,0}));
              connect(intToRea.y, sampler.u)
                annotation (Line(points={{-178,-50},{-162,-50}}, color={0,0,127}));
              connect(difReqIgnReq.y, pro.u1)
                annotation (Line(points={{-78,-30},{-40,-30},{-40,-94},{-22,-94}},
                  color={0,0,127}));
              connect(uDevSta, tim.u)
                annotation (Line(points={{-240,170},{-202,170}}, color={255,0,255}));
              connect(tim.y, swi.u2)
                annotation (Line(points={{-178,170},{158,170}}, color={255,0,255}));
              connect(tim.y, swi1.u2)
                annotation (Line(points={{-178,170},{-140,170},{-140,10},{118,10}},
                  color={255,0,255}));
              connect(and2.u1, tim.y)
                annotation (Line(points={{118,-30},{-20,-30},{-20,10},{-140,10},{-140,170},
                  {-178,170}}, color={255,0,255}));
              connect(maxInp.y, swi2.u3)
                annotation (Line(points={{62,100},{80,100},{80,132},{98,132}}, color={0,0,127}));
              connect(triAmoCon.y, pro1.u1)
                annotation (Line(points={{-178,-80},{-170,-80},{-170,-94},{-162,-94}},
                  color={0,0,127}));
              connect(resAmoCon.y, pro1.u2)
                annotation (Line(points={{-178,-130},{-170,-130},{-170,-106},{-162,-106}},
                  color={0,0,127}));
              connect(pro1.y, lesEquThr1.u)
                annotation (Line(points={{-138,-100},{-122,-100}}, color={0,0,127}));
              connect(lesEquThr1.y, assMes.u)
                annotation (Line(points={{-98,-100},{-82,-100}}, color={255,0,255}));
              connect(resAmoCon.y, pro2.u1)
                annotation (Line(points={{-178,-130},{-170,-130},{-170,-164},{-162,-164}},
                  color={0,0,127}));
              connect(maxResCon.y, pro2.u2)
                annotation (Line(points={{-178,-200},{-170,-200},{-170,-176},{-162,-176}},
                  color={0,0,127}));
              connect(pro2.y, greEquThr.u)
                annotation (Line(points={{-138,-170},{-122,-170}}, color={0,0,127}));
              connect(greEquThr.y, assMes2.u)
                annotation (Line(points={{-98,-170},{-82,-170}}, color={255,0,255}));
              connect(resAmoCon.y, abs.u)
                annotation (Line(points={{-178,-130},{-122,-130}}, color={0,0,127}));
              connect(abs.y, pro.u2)
                annotation (Line(points={{-98,-130},{-40,-130},{-40,-106},{-22,-106}},
                  color={0,0,127}));
              connect(maxResCon.y, abs1.u)
                annotation (Line(points={{-178,-200},{-122,-200}}, color={0,0,127}));
              connect(abs1.y, minInp.u2)
                annotation (Line(points={{-98,-200},{-20,-200},{-20,-126},{18,-126}},
                  color={0,0,127}));
              connect(minInp.y, swi3.u1)
                annotation (Line(points={{42,-120},{60,-120},{60,-142},{118,-142}},
                  color={0,0,127}));
              connect(resAmoCon.y, greEquThr1.u)
                annotation (Line(points={{-178,-130},{-170,-130},{-170,-150},{18,-150}},
                  color={0,0,127}));
              connect(greEquThr1.y, swi3.u2)
                annotation (Line(points={{42,-150},{118,-150}}, color={255,0,255}));
              connect(netRes.y, add1.u2)
                annotation (Line(points={{182,-30},{200,-30},{200,36},{-60,36},{-60,94},{-42,
                      94}},  color={0,0,127}));
              connect(swi1.y, netRes.u3)
                annotation (Line(points={{142,10},{150,10},{150,-22},{158,-22}}, color={0,0,127}));
              connect(minInp.y, gai.u)
                annotation (Line(points={{42,-120},{60,-120},{60,-180},{78,-180}}, color={0,0,127}));
              connect(gai.y, swi3.u3)
                annotation (Line(points={{102,-180},{110,-180},{110,-158},{118,-158}},
                  color={0,0,127}));
              connect(swi3.y, add2.u2)
                annotation (Line(points={{142,-150},{160,-150},{160,-120},{100,-120},
                  {100,-92},{118,-92}}, color={0,0,127}));

            annotation (
              defaultComponentName = "triRes",
              Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                   graphics={Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={223,211,169},
                    lineThickness=5.0,
                    borderPattern=BorderPattern.Raised,
                    fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-114,146},{106,108}},
                      lineColor={0,0,255},
                      textString="%name"),
                    Text(
                      extent={{-88,58},{90,-42}},
                      lineColor={192,192,192},
                      textString="Trim & Respond")}),
               Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-220,-220},{220,
                        220}}),
                       graphics={
                    Rectangle(
                      extent={{-218,28},{218,-218}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-218,218},{218,42}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Text(
                      extent={{-214,122},{-124,98}},
                      lineColor={0,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Check device status,
Count time"),             Text(
                      extent={{-216,22},{-110,-6}},
                      lineColor={0,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Reset setpoint based
on request number")}),
               Documentation(info="<html>
<p>
This block implements the trim and respond logic according to ASHRAE guideline G36,
PART 5.A.15 (trim and respond setpoint reset logic).
</p>
<p>
The trim and respond logic shall reset setpoint within the range <code>minSet</code> to
<code>maxSet</code>.
When the associated device is off (<code>uDevSta=false</code>), the setpoint
shall be <code>iniSet</code>.
The reset logic shall be active while the associated device is proven
on (<code>uDevSta=true</code>), starting <code>delTim</code> after initial
device start command.
When active, every time step <code>samplePeriod</code>, trim the setpoint by
<code>triAmo</code>.
If there are more than <code>numIgnReq</code> requests, respond by changing
the setpoint by <code>resAmo*(numOfReq-numIgnReq)</code>, i.e., the number of
requests minus the number of ignored requests, but no more than <code>maxRes</code>.
</p>
In other words, every time step <code>samplePeriod</code>:
<ul>
<li>Change setpoint by <code>triAmo</code>; </li>
<li>If <code>numOfReq > numIgnReq</code>, <i>also</i> change setpoint by <code>resAmo*(numOfReq
-numIgnReq)</code> but no more than <code>maxRes</code>.
</li>
</ul>

<p align=\"center\">
<img alt=\"Image of set point reset\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/Generic/TrimRespond.png\"/>
</p>
</html>",             revisions="<html>
<ul>
<li>
April 13, 2020, by Jianjun Hu:<br/>
Corrected to delay the true initial device status.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1876\">#1876</a>.
</li>
<li>
August 28, 2019, by Jianjun Hu:<br/>
Added assertions and corrected implementation when response amount is negative.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1530\">#1503</a>.
</li>
<li>
July 10, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
            end TrimAndRespond;

            block ZoneStatus "Block that outputs zone temperature status"

              parameter Real bouLim(
                final unit="K",
                final displayUnit="K",
                final quantity="TemperatureDifference",
                final min=0.5) = 1.1
                "Value limit to indicate the end of setback or setup mode";
              parameter Boolean have_winSen=false
                "Check if the zone has window status sensor";

              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput cooDowTim(final
                  unit="s", final quantity="Time")
                "Cool-down time retrieved from optimal cool-down block"
                annotation (Placement(transformation(extent={{-180,200},{-140,
                        240}}), iconTransformation(extent={{-140,70},{-100,110}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput warUpTim(final
                  unit="s", final quantity="Time")
                "Warm-up time retrieved from optimal warm-up block" annotation
                (Placement(transformation(extent={{-180,140},{-140,180}}),
                    iconTransformation(extent={{-140,50},{-100,90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uWinSta if
                have_winSen "Window status: true=open, false=close" annotation
                (Placement(transformation(extent={{-180,100},{-140,140}}),
                    iconTransformation(extent={{-140,30},{-100,70}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonHeaSetOcc(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Occupied heating setpoint temperature" annotation (Placement(
                    transformation(extent={{-180,50},{-140,90}}),
                    iconTransformation(extent={{-140,10},{-100,50}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonCooSetOcc(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Occupied cooling setpoint temperature" annotation (Placement(
                    transformation(extent={{-180,0},{-140,40}}),
                    iconTransformation(extent={{-140,-10},{-100,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonMax(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Maximum zone temperature in the zone group" annotation (
                  Placement(transformation(extent={{-180,-40},{-140,0}}),
                    iconTransformation(extent={{-140,-30},{-100,10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZon(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Single zone temperature" annotation (Placement(transformation(
                      extent={{-180,-80},{-140,-40}}), iconTransformation(
                      extent={{-140,-50},{-100,-10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonMin(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Minimum zone temperature in the zone group" annotation (
                  Placement(transformation(extent={{-180,-130},{-140,-90}}),
                    iconTransformation(extent={{-140,-70},{-100,-30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonHeaSetUno(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Unoccupied heating setpoint temperature" annotation (Placement(
                    transformation(extent={{-180,-170},{-140,-130}}),
                    iconTransformation(extent={{-140,-90},{-100,-50}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonCooSetUno(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Unoccupied cooling setpoint temperature" annotation (Placement(
                    transformation(extent={{-180,-260},{-140,-220}}),
                    iconTransformation(extent={{-140,-110},{-100,-70}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yCooTim(final
                  unit="s", final quantity="Time") "Cool-down time" annotation
                (Placement(transformation(extent={{140,200},{180,240}}),
                    iconTransformation(extent={{100,70},{140,110}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yWarTim(final
                  unit="s", final quantity="Time") "Warm-up time" annotation (
                  Placement(transformation(extent={{140,140},{180,180}}),
                    iconTransformation(extent={{100,50},{140,90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput yOccHeaHigMin
                "True when the occupied heating setpoint temperature is higher than the minimum zone temperature"
                annotation (Placement(transformation(extent={{140,50},{180,90}}),
                    iconTransformation(extent={{100,10},{140,50}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput yMaxHigOccCoo
                "True when the maximum zone temperature is higher than the occupied cooling setpoint"
                annotation (Placement(transformation(extent={{140,0},{180,40}}),
                    iconTransformation(extent={{100,-10},{140,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput yLowUnoHea
                "True when zone temperature is lower than unoccupied heating setpoint"
                annotation (Placement(transformation(extent={{140,-80},{180,-40}}),
                    iconTransformation(extent={{100,-30},{140,10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput yUnoHeaHigMin
                "True when the unoccupied heating setpoint is higher than minimum zone temperature"
                annotation (Placement(transformation(extent={{140,-130},{180,-90}}),
                    iconTransformation(extent={{100,-70},{140,-30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput yMaxHigUnoCoo
                "True when the maximum zone temperature is higher than unoccupied cooling setpoint"
                annotation (Placement(transformation(extent={{140,-190},{180,-150}}),
                    iconTransformation(extent={{100,-90},{140,-50}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput yHigUnoCoo
                "True when the zone temperature is higher than the unoccupied cooling setpoint"
                annotation (Placement(transformation(extent={{140,-240},{180,-200}}),
                    iconTransformation(extent={{100,-110},{140,-70}})));

            protected
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro
                "Decide if the cool down time of one zone should be ignored: if window is open, then output zero, otherwise, output cool-down time from optimal cool-down block"
                annotation (Placement(transformation(extent={{80,210},{100,230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro1
                "Decide if the warm-up time of one zone should be ignored: if window is open, then output zero, otherwise, output warm-up time from optimal warm-up block"
                annotation (Placement(transformation(extent={{80,150},{100,170}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(final k2=
                    -1)
                "Calculate differential between minimum zone temperature and the heating setpoint"
                annotation (Placement(transformation(extent={{-20,60},{0,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys(
                final pre_y_start=false,
                final uLow=-0.1,
                final uHigh=0.1)
                "Hysteresis that outputs if the system should run in warm-up mode"
                annotation (Placement(transformation(extent={{20,60},{40,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(final k1=
                    -1)
                "Calculate differential between maximum zone temperature and the cooling setpoint"
                annotation (Placement(transformation(extent={{-20,10},{0,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys1(
                final pre_y_start=false,
                final uLow=-0.1,
                final uHigh=0.1)
                "Hysteresis that outputs if the system should run in cool-down mode"
                annotation (Placement(transformation(extent={{20,10},{40,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2(final k1=
                    -1) "Calculate zone temperature difference to setpoint"
                annotation (Placement(transformation(extent={{40,-70},{60,-50}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys2(
                final pre_y_start=false,
                final uLow=-0.1,
                final uHigh=0.1)
                "Hysteresis that outputs if the zone temperature is lower then setpoint"
                annotation (Placement(transformation(extent={{80,-70},{100,-50}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add3(final k2=
                    -1)
                "Calculate the difference between minimum zone temperature and unoccupied heating setpoint"
                annotation (Placement(transformation(extent={{40,-120},{60,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys3(
                final uLow=-0.5*bouLim,
                final uHigh=0.5*bouLim,
                final pre_y_start=false)
                "Hysteresis that outputs if the unoccupied heating setpoint is higher than minimum zone temperature by a given limit"
                annotation (Placement(transformation(extent={{80,-120},{100,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add5(final k2=
                    -1) "Calculate zone temperature difference to setpoint"
                annotation (Placement(transformation(extent={{40,-230},{60,-210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys5(
                final pre_y_start=false,
                final uLow=-0.1,
                final uHigh=0.1)
                "Hysteresis that outputs if the zone temperature is higher than setpoint"
                annotation (Placement(transformation(extent={{80,-230},{100,-210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add4(final k2=
                    -1)
                "Calculate the difference between maximum zone temperature and unoccupied cooling setpoint"
                annotation (Placement(transformation(extent={{40,-180},{60,-160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys4(
                final pre_y_start=false,
                final uLow=-0.5*bouLim,
                final uHigh=0.5*bouLim)
                "Hysteresis that outputs if the maximum zone temperature is higher than unoccupied cooling setpoint by a given limit"
                annotation (Placement(transformation(extent={{80,-180},{100,-160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                "Logical not" annotation (Placement(transformation(extent={{-20,
                        110},{0,130}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea
                "Convert Boolean to Real number" annotation (Placement(
                    transformation(extent={{20,110},{40,130}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                "Decide if the temperature difference to setpoint should be ignored: if the zone window is open, then output setpoint temperature, otherwise, output zone temperature"
                annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                "Decide if the temperature difference to setpoint should be ignored: if the zone window is open, then output setpoint temperature, otherwise, output zone temperature"
                annotation (Placement(transformation(extent={{-20,-230},{0,-210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant con(final k=
                    false) if not have_winSen "Constant false" annotation (
                  Placement(transformation(extent={{-128,130},{-108,150}})));

            equation
              connect(cooDowTim, pro.u1) annotation (Line(points={{-160,220},{-60,220},{-60,
                      226},{78,226}}, color={0,0,127}));
              connect(warUpTim, pro1.u1) annotation (Line(points={{-160,160},{-60,160},{-60,
                      166},{78,166}}, color={0,0,127}));
              connect(booToRea.y, pro.u2) annotation (Line(points={{42,120},{60,120},{60,214},
                      {78,214}}, color={0,0,127}));
              connect(booToRea.y, pro1.u2) annotation (Line(points={{42,120},{60,120},{60,154},
                      {78,154}}, color={0,0,127}));
              connect(TZonHeaSetOcc, add.u1) annotation (Line(points={{-160,70},{-60,70},{-60,
                      76},{-22,76}}, color={0,0,127}));
              connect(TZonMin, add.u2) annotation (Line(points={{-160,-110},{-60,-110},{-60,
                      64},{-22,64}}, color={0,0,127}));
              connect(add.y, hys.u)
                annotation (Line(points={{2,70},{18,70}}, color={0,0,127}));
              connect(TZonCooSetOcc, add1.u1) annotation (Line(points={{-160,20},{-80,20},{-80,
                      26},{-22,26}}, color={0,0,127}));
              connect(TZonMax, add1.u2) annotation (Line(points={{-160,-20},{-80,-20},{-80,14},
                      {-22,14}}, color={0,0,127}));
              connect(add1.y, hys1.u)
                annotation (Line(points={{2,20},{18,20}}, color={0,0,127}));
              connect(uWinSta, not1.u)
                annotation (Line(points={{-160,120},{-22,120}}, color={255,0,255}));
              connect(uWinSta, swi.u2) annotation (Line(points={{-160,120},{-100,120},{-100,
                      -60},{-22,-60}}, color={255,0,255}));
              connect(TZonHeaSetUno, swi.u1) annotation (Line(points={{-160,-150},{-40,-150},
                      {-40,-52},{-22,-52}}, color={0,0,127}));
              connect(TZon, swi.u3) annotation (Line(points={{-160,-60},{-120,-60},{-120,-68},
                      {-22,-68}}, color={0,0,127}));
              connect(swi.y, add2.u1) annotation (Line(points={{2,-60},{20,-60},{20,-54},{38,
                      -54}}, color={0,0,127}));
              connect(TZonHeaSetUno, add2.u2) annotation (Line(points={{-160,-150},{20,-150},
                      {20,-66},{38,-66}}, color={0,0,127}));
              connect(add2.y, hys2.u)
                annotation (Line(points={{62,-60},{78,-60}}, color={0,0,127}));
              connect(TZonMin, add3.u2) annotation (Line(points={{-160,-110},{-60,-110},{-60,
                      -116},{38,-116}}, color={0,0,127}));
              connect(TZonHeaSetUno, add3.u1) annotation (Line(points={{-160,-150},{20,-150},
                      {20,-104},{38,-104}}, color={0,0,127}));
              connect(add3.y, hys3.u)
                annotation (Line(points={{62,-110},{78,-110}}, color={0,0,127}));
              connect(uWinSta, swi1.u2) annotation (Line(points={{-160,120},{-100,120},{-100,
                      -220},{-22,-220}}, color={255,0,255}));
              connect(TZonCooSetUno, swi1.u1) annotation (Line(points={{-160,-240},{-60,-240},
                      {-60,-212},{-22,-212}}, color={0,0,127}));
              connect(TZon, swi1.u3) annotation (Line(points={{-160,-60},{-120,-60},{-120,-228},
                      {-22,-228}}, color={0,0,127}));
              connect(swi1.y, add5.u1) annotation (Line(points={{2,-220},{20,-220},{20,-214},
                      {38,-214}}, color={0,0,127}));
              connect(TZonCooSetUno, add5.u2) annotation (Line(points={{-160,-240},{20,-240},
                      {20,-226},{38,-226}}, color={0,0,127}));
              connect(add5.y, hys5.u)
                annotation (Line(points={{62,-220},{78,-220}}, color={0,0,127}));
              connect(TZonMax, add4.u1) annotation (Line(points={{-160,-20},{-80,-20},{-80,-164},
                      {38,-164}}, color={0,0,127}));
              connect(TZonCooSetUno, add4.u2) annotation (Line(points={{-160,-240},{-60,-240},
                      {-60,-176},{38,-176}}, color={0,0,127}));
              connect(add4.y, hys4.u)
                annotation (Line(points={{62,-170},{78,-170}}, color={0,0,127}));
              connect(not1.y, booToRea.u)
                annotation (Line(points={{2,120},{18,120}}, color={255,0,255}));
              connect(hys.y, yOccHeaHigMin)
                annotation (Line(points={{42,70},{160,70}}, color={255,0,255}));
              connect(hys1.y, yMaxHigOccCoo)
                annotation (Line(points={{42,20},{160,20}}, color={255,0,255}));
              connect(pro.y, yCooTim)
                annotation (Line(points={{102,220},{160,220}}, color={0,0,127}));
              connect(pro1.y, yWarTim)
                annotation (Line(points={{102,160},{160,160}}, color={0,0,127}));
              connect(hys2.y, yLowUnoHea)
                annotation (Line(points={{102,-60},{160,-60}}, color={255,0,255}));
              connect(hys3.y,yUnoHeaHigMin)
                annotation (Line(points={{102,-110},{160,-110}}, color={255,0,255}));
              connect(hys4.y, yMaxHigUnoCoo)
                annotation (Line(points={{102,-170},{160,-170}}, color={255,0,255}));
              connect(hys5.y, yHigUnoCoo)
                annotation (Line(points={{102,-220},{160,-220}}, color={255,0,255}));
              connect(con.y, not1.u) annotation (Line(points={{-106,140},{-100,140},{-100,120},
                      {-22,120}}, color={255,0,255}));
              connect(con.y, swi.u2) annotation (Line(points={{-106,140},{-100,140},{-100,-60},
                      {-22,-60}}, color={255,0,255}));
              connect(con.y, swi1.u2) annotation (Line(points={{-106,140},{-100,140},{-100,-220},
                      {-22,-220}}, color={255,0,255}));

            annotation (
              defaultComponentName = "zonSta",
              Diagram(
                    coordinateSystem(preserveAspectRatio=false, extent={{-140,-260},{140,260}})),
               Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                    graphics={
                    Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-96,98},{-46,82}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="cooDowTim"),
                    Text(
                      extent={{-98,76},{-50,64}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="warUpTim"),
                    Text(
                      extent={{-96,-84},{-32,-98}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonCooSetUno"),
                    Text(
                      extent={{-96,38},{-30,20}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonHeaSetOcc"),
                    Text(
                      extent={{-96,16},{-28,4}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonCooSetOcc"),
                    Text(
                      extent={{-120,144},{100,106}},
                      lineColor={0,0,255},
                      textString="%name"),
                    Text(
                      extent={{-100,-4},{-58,-14}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonMax"),
                    Text(
                      extent={{-100,-24},{-74,-34}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZon"),
                    Text(
                      extent={{-100,-44},{-58,-54}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonMin"),
                    Text(
                      extent={{-96,-64},{-32,-78}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonHeaSetUno"),
                    Text(
                      visible=have_winSen,
                      extent={{-98,56},{-60,46}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uWinSta"),
                    Text(
                      extent={{60,100},{98,84}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="yCooTim"),
                    Text(
                      extent={{60,80},{98,64}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="yWarTim"),
                    Text(
                      extent={{30,40},{96,22}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="yOccHeaHigMin"),
                    Text(
                      extent={{30,20},{96,2}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="yMaxHigOccCoo"),
                    Text(
                      extent={{46,0},{96,-16}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="yLowUnoHea"),
                    Text(
                      extent={{30,-38},{96,-56}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="yUnoHeaHigMin"),
                    Text(
                      extent={{30,-58},{96,-76}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="yMaxHigUnoCoo"),
                    Text(
                      extent={{46,-80},{96,-96}},
                      lineColor={255,0,255},
                      pattern=LinePattern.Dash,
                      textString="yHigUnoCoo")}),
               Documentation(info="<html>
<p>
This block outputs single zone status. It includes outputs as following:
</p>
<ul>
<li>
the times for cooling-down (<code>yCooTim</code>) and warm-up (<code>yWarTim</code>) the zone,
</li>
<li>
<code>yOccHeaHigMin</code>: if the zone occupied heating setpoint <code>TZonHeaSetOcc</code> 
is higher than the minimum zone temperature <code>TZonMin</code> of the zone group (if the 
zone is in a multiple zone system), or the zone temperature 
(<code>TZonMin</code> = <code>TZon</code>) (if it is in a single zone system),
</li>
<li>
<code>yMaxHigOccCoo</code>: if the maximum zone temperature <code>TZonMax</code> of the zone 
group (if the zone is in a multiple zone system), or the zone temperature 
(<code>TZonMax</code> = <code>TZon</code>) (if it is in a single zone system), is higher 
than the zone occupied cooling setpoint <code>TZonCooSetOcc</code>,
</li>
<li>
<code>yLowUnoHea</code>: if the zone temperature <code>TZon</code> is lower than
the unoccupied heating setpoint <code>TZonHeaSetUno</code>,
</li>
<li>
<code>yUnoHeaHigMin</code>: if the zone unoccupied heating setpoint <code>TZonHeaSetUno</code> 
is higher than the minimum zone temperature <code>TZonMin</code> of the zone group (if the 
zone is in a multiple zone system), or the zone temperature 
(<code>TZonMin</code> = <code>TZon</code>) (if it is in a single zone system), 
</li>
<li>
<code>yMaxHigUnoCoo</code>: if the maximum zone temperature <code>TZonMax</code> of the zone 
group (if the zone is in a multiple zone system), or the zone temperature 
(<code>TZonMax</code> = <code>TZon</code>) (if it is in a single zone system), is higher 
than the zone unoccupied cooling setpoint <code>TZonCooSetUno</code>,
</li>
<li>
<code>yHigUnoCoo</code>: if the zone temperature <code>TZon</code> is higher than
the unoccupied cooling setpoint <code>TZonCooSetUno</code>,
</li>
</ul>
</html>",            revisions="<html>
<ul>
<li>
January 15, 2020, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
            end ZoneStatus;

            package Validation "Collection of validation models"

              model OperationMode "Validate block for selecting operation mode"

                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
                  final offset=0,
                  final height=6.2831852,
                  final duration=24*3600) "Block that generates ramp signal"
                  annotation (Placement(transformation(extent={{-100,-80},{-80,
                          -60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
                  "Block that outputs the sine of the input" annotation (
                    Placement(transformation(extent={{-60,-80},{-40,-60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar(final k=
                      12.5, final p=273.15 + 22.5) "Zone temperarure"
                  annotation (Placement(transformation(extent={{-20,-80},{0,-60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonHeaSetUno(final k=273.15 + 12)
                  "Unoccupied heating setpoint" annotation (Placement(
                      transformation(extent={{-60,-170},{-40,-150}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonCooSetUno(final k=273.15 + 30)
                  "Unoccupied cooling setpoint" annotation (Placement(
                      transformation(extent={{-60,-210},{-40,-190}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonHeaSetOcc(final k=273.15 + 20)
                  "Occupied heating setpoint" annotation (Placement(
                      transformation(extent={{-60,-50},{-40,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonCooSetOcc(final k=273.15 + 24)
                  "Occupied cooling setpoint" annotation (Placement(
                      transformation(extent={{-60,-110},{-40,-90}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  warUpTim(final k=1800) "Warm-up time" annotation (Placement(
                      transformation(extent={{-60,-10},{-40,10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  cooDowTim(final k=1800) "Cooling down time" annotation (
                    Placement(transformation(extent={{-60,20},{-40,40}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                  uWinSta(final k=false) "Window on/off status" annotation (
                    Placement(transformation(extent={{-10,-10},{10,10}}, origin
                        ={-50,-130})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                  occTim(final table=[0,0; occSta,1; occEnd,0; 24*3600,0],
                    final smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments)
                  "Occupancy schedule" annotation (Placement(transformation(
                        extent={{-140,50},{-120,70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.ModelTime
                  modTim "Standard time" annotation (Placement(transformation(
                        extent={{-160,230},{-140,250}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  con(final k=24*3600) "One day in second" annotation (
                    Placement(transformation(extent={{-160,130},{-140,150}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division div
                  "Output first input divided by second input" annotation (
                    Placement(transformation(extent={{-120,210},{-100,230}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round rou(final n=0)
                  "Round real number to 0 digit" annotation (Placement(
                      transformation(extent={{-80,210},{-60,230}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai(k=24*3600)
                  "Begin time of each day" annotation (Placement(transformation(
                        extent={{-40,210},{-20,230}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessEqual lesEqu
                  "Check if it is beginning of next day" annotation (Placement(
                      transformation(extent={{0,210},{20,230}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar1(final p=-1,
                    final k=1) "Add parameter" annotation (Placement(
                      transformation(extent={{-40,180},{-20,200}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai1(final k=
                      24*3600) "Begin of day" annotation (Placement(
                      transformation(extent={{0,180},{20,200}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                  "Beginning of current day" annotation (Placement(
                      transformation(extent={{40,210},{60,230}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add curTim(final k2=
                      -1) "Current time " annotation (Placement(transformation(
                        extent={{80,230},{100,250}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2(final k2=
                      -1) "Left time to beginning of current day occupancy "
                  annotation (Placement(transformation(extent={{80,150},{100,
                          170}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  occStaTim(final k=occSta) "Occupancy start" annotation (
                    Placement(transformation(extent={{-140,90},{-120,110}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(final k2=
                      -1) "Left time to the end of current day" annotation (
                    Placement(transformation(extent={{0,130},{20,150}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar2(final p=
                      occSta, final k=1) "Left time to next occupancy"
                  annotation (Placement(transformation(extent={{40,130},{60,150}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessEqual lesEqu1
                  "Check if current time has already passed occupancy start time"
                  annotation (Placement(transformation(extent={{0,90},{20,110}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                  "Time to next occupancy" annotation (Placement(transformation(
                        extent={{120,90},{140,110}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqualThreshold
                  occ(final threshold=0.5) "Occupied status" annotation (
                    Placement(transformation(extent={{-100,50},{-80,70}})));
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.OperationMode
                  opeModSel(final have_winSen=true, final numZon=1)
                  "Operation mode selection" annotation (Placement(
                      transformation(extent={{130,0},{150,20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual greEqu
                  "True when zone occupied heating setpoint temperature is larger than zone temperature"
                  annotation (Placement(transformation(extent={{40,-50},{60,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual greEqu1
                  "True when zone occupied heating setpoint temperature is larger than zone temperature"
                  annotation (Placement(transformation(extent={{40,-100},{60,-80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual greEqu2
                  "True when the zone temperature is lower than unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{40,-170},{60,-150}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                  booToInt "Convert boolean to integer" annotation (Placement(
                      transformation(extent={{80,-170},{100,-150}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual greEqu3
                  "True when the zone temperature is lower than unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{40,-210},{60,-190}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                  booToInt1 "Convert boolean to integer" annotation (Placement(
                      transformation(extent={{80,-210},{100,-190}})));

              protected
                final parameter Real occSta(
                  final unit="s",
                  final quantity="Time") = 7*3600 "Occupancy start time";
                final parameter Real occEnd(
                  final unit="s",
                  final quantity="Time") =  19*3600 "Occupancy end time";

              equation
                connect(ramp1.y, sin1.u)
                  annotation (Line(points={{-78,-70},{-62,-70}}, color={0,0,127}));
                connect(sin1.y, addPar.u)
                  annotation (Line(points={{-38,-70},{-22,-70}},color={0,0,127}));
                connect(modTim.y, div.u1)
                  annotation (Line(points={{-138,240},{-130,240},{-130,226},{-122,226}},
                    color={0,0,127}));
                connect(con.y, div.u2)
                  annotation (Line(points={{-138,140},{-130,140},{-130,214},{-122,214}}, color={0,0,127}));
                connect(div.y, rou.u)
                  annotation (Line(points={{-98,220},{-82,220}}, color={0,0,127}));
                connect(rou.y, gai.u)
                  annotation (Line(points={{-58,220},{-42,220}}, color={0,0,127}));
                connect(gai.y, lesEqu.u1)
                  annotation (Line(points={{-18,220},{-2,220}}, color={0,0,127}));
                connect(modTim.y, lesEqu.u2)
                  annotation (Line(points={{-138,240},{-10,240},{-10,212},{-2,212}}, color={0,0,127}));
                connect(rou.y, addPar1.u)
                  annotation (Line(points={{-58,220},{-50,220},{-50,190},{-42,190}}, color={0,0,127}));
                connect(addPar1.y, gai1.u)
                  annotation (Line(points={{-18,190},{-2,190}}, color={0,0,127}));
                connect(lesEqu.y, swi.u2)
                  annotation (Line(points={{22,220},{38,220}}, color={255,0,255}));
                connect(gai.y, swi.u1)
                  annotation (Line(points={{-18,220},{-14,220},{-14,250},{30,250},{30,228},{38,
                        228}}, color={0,0,127}));
                connect(gai1.y, swi.u3)
                  annotation (Line(points={{22,190},{30,190},{30,212},{38,212}}, color={0,0,127}));
                connect(modTim.y, curTim.u1)
                  annotation (Line(points={{-138,240},{-10,240},{-10,246},{78,246}}, color={0,0,127}));
                connect(swi.y, curTim.u2)
                  annotation (Line(points={{62,220},{70,220},{70,234},{78,234}}, color={0,0,127}));
                connect(occStaTim.y, add2.u1)
                  annotation (Line(points={{-118,100},{-100,100},{-100,166},{78,166}},
                                                                                   color={0,0,127}));
                connect(con.y, add1.u1)
                  annotation (Line(points={{-138,140},{-130,140},{-130,146},{-2,146}},
                                                                                   color={0,0,127}));
                connect(add1.y, addPar2.u)
                  annotation (Line(points={{22,140},{38,140}},
                                                             color={0,0,127}));
                connect(occStaTim.y, lesEqu1.u2)
                  annotation (Line(points={{-118,100},{-100,100},{-100,92},{-2,92}},
                                                                                   color={0,0,127}));
                connect(curTim.y, lesEqu1.u1)
                  annotation (Line(points={{102,240},{140,240},{140,120},{-20,120},{-20,100},{
                        -2,100}},
                              color={0,0,127}));
                connect(lesEqu1.y, swi1.u2)
                  annotation (Line(points={{22,100},{118,100}},
                                                              color={255,0,255}));
                connect(add2.y, swi1.u1)
                  annotation (Line(points={{102,160},{110,160},{110,108},{118,108}},
                                                                                 color={0,0,127}));
                connect(addPar2.y, swi1.u3)
                  annotation (Line(points={{62,140},{100,140},{100,92},{118,92}},
                                                                                color={0,0,127}));
                connect(occTim.y[1], occ.u)
                  annotation (Line(points={{-118,60},{-102,60}},   color={0,0,127}));
                connect(curTim.y, add2.u2)
                  annotation (Line(points={{102,240},{140,240},{140,180},{60,180},{60,154},{78,
                        154}},color={0,0,127}));
                connect(curTim.y, add1.u2)
                  annotation (Line(points={{102,240},{140,240},{140,120},{-20,120},{-20,134},{
                        -2,134}},
                              color={0,0,127}));
                connect(occ.y, opeModSel.uOcc) annotation (Line(points={{-78,60},{80,60},{80,
                        22},{128,22}}, color={255,0,255}));
                connect(swi1.y, opeModSel.tNexOcc) annotation (Line(points={{142,100},{150,
                        100},{150,40},{72,40},{72,20},{128,20}}, color={0,0,127}));
                connect(cooDowTim.y, opeModSel.maxCooDowTim) annotation (Line(points={{-38,30},
                        {64,30},{64,18},{128,18}}, color={0,0,127}));
                connect(warUpTim.y, opeModSel.maxWarUpTim) annotation (Line(points={{-38,0},{
                        -20,0},{-20,16},{128,16}}, color={0,0,127}));
                connect(TZonHeaSetOcc.y, greEqu.u1)
                  annotation (Line(points={{-38,-40},{38,-40}}, color={0,0,127}));
                connect(addPar.y, greEqu.u2) annotation (Line(points={{2,-70},{20,-70},{20,-48},
                        {38,-48}}, color={0,0,127}));
                connect(greEqu.y, opeModSel.occHeaHigMin) annotation (Line(points={{62,-40},{
                        70,-40},{70,14},{128,14}}, color={255,0,255}));
                connect(addPar.y, greEqu1.u1) annotation (Line(points={{2,-70},{20,-70},{20,-90},
                        {38,-90}}, color={0,0,127}));
                connect(TZonCooSetOcc.y, greEqu1.u2) annotation (Line(points={{-38,-100},{0,-100},
                        {0,-98},{38,-98}}, color={0,0,127}));
                connect(greEqu1.y, opeModSel.maxHigOccCoo) annotation (Line(points={{62,-90},
                        {74,-90},{74,12},{128,12}}, color={255,0,255}));
                connect(uWinSta.y, opeModSel.uWinSta) annotation (Line(points={{-38,-130},{78,
                        -130},{78,10},{128,10}}, color={255,0,255}));
                connect(TZonHeaSetUno.y, greEqu2.u1)
                  annotation (Line(points={{-38,-160},{38,-160}}, color={0,0,127}));
                connect(addPar.y, greEqu2.u2) annotation (Line(points={{2,-70},{20,-70},{20,-168},
                        {38,-168}}, color={0,0,127}));
                connect(greEqu2.y, booToInt.u)
                  annotation (Line(points={{62,-160},{78,-160}}, color={255,0,255}));
                connect(booToInt.y, opeModSel.totColZon) annotation (Line(points={{102,-160},
                        {108,-160},{108,8},{128,8}}, color={255,127,0}));
                connect(greEqu2.y, opeModSel.unoHeaHigMin) annotation (Line(points={{62,-160},
                        {70,-160},{70,-140},{100,-140},{100,6},{128,6}}, color={255,0,255}));
                connect(addPar.y, opeModSel.TZonMax) annotation (Line(points={{2,-70},{82,-70},
                        {82,4},{128,4}}, color={0,0,127}));
                connect(addPar.y, opeModSel.TZonMin) annotation (Line(points={{2,-70},{82,-70},
                        {82,2},{128,2}}, color={0,0,127}));
                connect(addPar.y, greEqu3.u1) annotation (Line(points={{2,-70},{20,-70},{20,-200},
                        {38,-200}}, color={0,0,127}));
                connect(TZonCooSetUno.y, greEqu3.u2) annotation (Line(points={{-38,-200},{0,-200},
                        {0,-208},{38,-208}}, color={0,0,127}));
                connect(greEqu3.y, booToInt1.u)
                  annotation (Line(points={{62,-200},{78,-200}}, color={255,0,255}));
                connect(greEqu3.y, opeModSel.maxHigUnoCoo) annotation (Line(points={{62,-200},
                        {70,-200},{70,-180},{120,-180},{120,-2},{128,-2}}, color={255,0,255}));
                connect(booToInt1.y, opeModSel.totHotZon) annotation (Line(points={{102,-200},
                        {114,-200},{114,0},{128,0}}, color={255,127,0}));

              annotation (
                experiment(StopTime=86400, Tolerance=1e-6),
                __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/Generic/SetPoints/Validation/OperationMode.mos"
                      "Simulate and plot"),
                  Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.OperationMode\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.OperationMode</a>
for a change of zone temperature and occupancy schedule.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 21, 2019, by Jianjun Hu:<br/>
Reimplemented occupancy schedule block to avoid use block that is not in CDL. 
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1389\">issue 1389</a>.
</li>
<li>
June 19, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),        Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                       graphics={
                      Ellipse(lineColor = {75,138,73},
                              fillColor={255,255,255},
                              fillPattern = FillPattern.Solid,
                              extent = {{-100,-100},{100,100}}),
                      Polygon(lineColor = {0,0,255},
                              fillColor = {75,138,73},
                              pattern = LinePattern.None,
                              fillPattern = FillPattern.Solid,
                              points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                  Diagram(coordinateSystem(extent={{-160,-280},{160,280}})));
              end OperationMode;

              model TrimAndRespond "Model validates the trim and respond block"
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.TrimAndRespond
                  trimRespondLogic(
                  final iniSet=120,
                  final minSet=37,
                  final maxSet=370,
                  final delTim=300,
                  final samplePeriod=120,
                  final numIgnReq=2,
                  final triAmo=-10,
                  final resAmo=15,
                  final maxRes=37) "Block implementing trim and respond logic"
                  annotation (Placement(transformation(extent={{70,60},{90,80}})));
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.TrimAndRespond
                  trimRespondLogic1(
                  final iniSet=120,
                  final minSet=37,
                  final maxSet=370,
                  final delTim=300,
                  final samplePeriod=120,
                  final numIgnReq=2,
                  final triAmo=10,
                  final resAmo=-15,
                  final maxRes=-37) "Block implementing trim and respond logic"
                  annotation (Placement(transformation(extent={{70,10},{90,30}})));
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.TrimAndRespond
                  trimRespondLogic2(
                  final iniSet=120,
                  final minSet=37,
                  final maxSet=370,
                  final delTim=300,
                  final samplePeriod=120,
                  final numIgnReq=2,
                  final triAmo=-10,
                  final resAmo=15,
                  final maxRes=37) "Block implementing trim and respond logic"
                  annotation (Placement(transformation(extent={{70,-40},{90,-20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                  con(final k=true) "Logic true indicating device ON"
                  annotation (Placement(transformation(extent={{20,80},{40,100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine sine(final
                    amplitude=6, final freqHz=1/5400)
                  "Block generates sine signal" annotation (Placement(
                      transformation(extent={{-80,40},{-60,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs
                  "Block generates absolute value of input" annotation (
                    Placement(transformation(extent={{-52,40},{-32,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine sine1(final
                    amplitude=6, freqHz=1/5400) "Block generates sine signal"
                  annotation (Placement(transformation(extent={{-88,-90},{-68,-70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs1
                  "Block generates absolute value of input" annotation (
                    Placement(transformation(extent={{-10,-90},{10,-70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(final
                    period=3600, final width=0.18333333)
                  "Generate pulse signal of type Boolean" annotation (Placement(
                      transformation(extent={{-88,-20},{-68,0}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                  "Logical not" annotation (Placement(transformation(extent={{
                          20,-20},{40,0}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                  "Switch between two Real signals" annotation (Placement(
                      transformation(extent={{-48,-50},{-28,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  con1(final k=0) "Zero request when device is OFF" annotation
                  (Placement(transformation(extent={{-88,-50},{-68,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(final n=0)
                  "Round real number to given digits" annotation (Placement(
                      transformation(extent={{-20,40},{0,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                  reaToInt1 "Convert real to integer" annotation (Placement(
                      transformation(extent={{20,40},{40,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(final n=0)
                  "Round real number to given digits" annotation (Placement(
                      transformation(extent={{20,-90},{40,-70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger
                  reaToInt2 "Convert real to integer" annotation (Placement(
                      transformation(extent={{20,-50},{40,-30}})));

              equation
                connect(con.y, trimRespondLogic.uDevSta)
                  annotation (Line(points={{42,90},{50,90},{50,78},{68,78}},
                    color={255,0,255}));
                connect(sine.y, abs.u)
                  annotation (Line(points={{-58,50},{-54,50}}, color={0,0,127}));
                connect(not1.y,trimRespondLogic2. uDevSta)
                  annotation (Line(points={{42,-10},{60,-10},{60,-22},{68,-22}},
                    color={255,0,255}));
                connect(con1.y, swi.u1)
                  annotation (Line(points={{-66,-40},{-62,-40},{-62,-32},{-50,-32}},
                    color={0,0,127}));
                connect(sine1.y, swi.u3)
                  annotation (Line(points={{-66,-80},{-58,-80},{-58,-48},{-50,-48}},
                    color={0,0,127}));
                connect(swi.y, abs1.u)
                  annotation (Line(points={{-26,-40},{-20,-40},{-20,-80},{-12,-80}},
                    color={0,0,127}));
                connect(booPul.y, swi.u2)
                  annotation (Line(points={{-66,-10},{-58,-10},{-58,-40},{-50,-40}},
                    color={255,0,255}));
                connect(booPul.y, not1.u)
                  annotation (Line(points={{-66,-10},{18,-10}}, color={255,0,255}));
                connect(abs.y, round2.u)
                  annotation (Line(points={{-30,50},{-22,50}}, color={0,0,127}));
                connect(round2.y, reaToInt1.u)
                  annotation (Line(points={{2,50},{18,50}}, color={0,0,127}));
                connect(reaToInt1.y, trimRespondLogic.numOfReq)
                  annotation (Line(points={{42,50},{60,50},{60,62},{68,62}},
                    color={255,127,0}));
                connect(abs1.y, round1.u)
                  annotation (Line(points={{12,-80},{18,-80}},color={0,0,127}));
                connect(round1.y, reaToInt2.u)
                  annotation (Line(points={{42,-80},{50,-80},{50,-60},{8,-60},{8,-40},
                    {18,-40}}, color={0,0,127}));
                connect(reaToInt2.y,trimRespondLogic2. numOfReq)
                  annotation (Line(points={{42,-40},{60,-40},{60,-38},{68,-38}},
                    color={255,127,0}));
                connect(con.y,trimRespondLogic1. uDevSta)
                  annotation (Line(points={{42,90},{50,90},{50,28},{68,28}}, color={255,0,255}));
                connect(reaToInt1.y,trimRespondLogic1. numOfReq)
                  annotation (Line(points={{42,50},{60,50},{60,12},{68,12}}, color={255,127,0}));

              annotation (experiment(StopTime=7200.0, Tolerance=1e-06),
                __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/Generic/SetPoints/Validation/TrimAndRespond.mos"
                  "Simulate and plot"),
                  Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.TrimAndRespond\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.TrimAndRespond</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
August 28, 2019, by Jianjun Hu:<br/>
Added more validation of negative response amount.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1530\">#1503</a>.
</li>
<li>
July 10, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),        Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                       graphics={
                      Ellipse(lineColor = {75,138,73},
                              fillColor={255,255,255},
                              fillPattern = FillPattern.Solid,
                              extent = {{-100,-100},{100,100}}),
                      Polygon(lineColor = {0,0,255},
                              fillColor = {75,138,73},
                              pattern = LinePattern.None,
                              fillPattern = FillPattern.Solid,
                              points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                  Diagram(coordinateSystem(extent={{-100,-120},{100,120}})));
              end TrimAndRespond;

              model ZoneStatus
                "Validate block for checking temperatures in the zone"

                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.ZoneStatus
                  noWinZonSta
                  "Status of zone when there is no window operation sensor"
                  annotation (Placement(transformation(extent={{120,120},{140,
                          140}})));
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.ZoneStatus
                  witWinZonSta(final have_winSen=true)
                  "Status of zone when there is window operation sensor"
                  annotation (Placement(transformation(extent={{120,40},{140,60}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
                  final offset=0,
                  final height=6.2831852,
                  final duration=24*3600) "Block that generates ramp signal"
                  annotation (Placement(transformation(extent={{-80,-10},{-60,
                          10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
                  "Block that outputs the sine of the input" annotation (
                    Placement(transformation(extent={{-40,-10},{-20,10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter maxZonTem(final k=
                      13.5, final p=273.15 + 22.5)
                  "Maximum zone temperature in the group" annotation (Placement(
                      transformation(extent={{0,-10},{20,10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonHeaSetUno(final k=273.15 + 12)
                  "Unoccupied heating setpoint" annotation (Placement(
                      transformation(extent={{0,-120},{20,-100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonCooSetUno(final k=273.15 + 30)
                  "Unoccupied cooling setpoint" annotation (Placement(
                      transformation(extent={{0,-160},{20,-140}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonHeaSetOcc(final k=273.15 + 20)
                  "Occupied heating setpoint" annotation (Placement(
                      transformation(extent={{-80,60},{-60,80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonCooSetOcc(final k=273.15 + 24)
                  "Occupied cooling setpoint" annotation (Placement(
                      transformation(extent={{-80,30},{-60,50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  warUpTim(final k=1800) "Warm-up time" annotation (Placement(
                      transformation(extent={{-80,90},{-60,110}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  cooDowTim(final k=1800) "Cooling down time" annotation (
                    Placement(transformation(extent={{-80,120},{-60,140}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse uWinSta(
                  width=0.3,
                  period=43200,
                  startTime=1800) "Window on/off status" annotation (Placement(
                      transformation(extent={{-10,-10},{10,10}}, origin={-110,
                          20})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
                  final offset=0,
                  final height=6.2831852,
                  final duration=24*3600) "Block that generates ramp signal"
                  annotation (Placement(transformation(extent={{-80,-50},{-60,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin2
                  "Block that outputs the sine of the input" annotation (
                    Placement(transformation(extent={{-40,-50},{-20,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter zonTem(final k=
                      12.5, final p=273.15 + 22.5) "Current zone temperature"
                  annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp3(
                  final offset=0,
                  final height=6.2831852,
                  final duration=24*3600) "Block that generates ramp signal"
                  annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin3
                  "Block that outputs the sine of the input" annotation (
                    Placement(transformation(extent={{-40,-90},{-20,-70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter minZonTem(final k=
                      12, final p=273.15 + 22.5)
                  "Minimum zone temperature in the group" annotation (Placement(
                      transformation(extent={{0,-90},{20,-70}})));

              equation
                connect(ramp1.y, sin1.u)
                  annotation (Line(points={{-58,0},{-42,0}},     color={0,0,127}));
                connect(sin1.y, maxZonTem.u)
                  annotation (Line(points={{-18,0},{-2,0}},     color={0,0,127}));
                connect(cooDowTim.y, noWinZonSta.cooDowTim) annotation (Line(points={{-58,130},
                        {-20,130},{-20,139},{118,139}}, color={0,0,127}));
                connect(warUpTim.y, noWinZonSta.warUpTim) annotation (Line(points={{-58,100},{
                        -14,100},{-14,137},{118,137}}, color={0,0,127}));
                connect(TZonHeaSetOcc.y, noWinZonSta.TZonHeaSetOcc) annotation (Line(points={{-58,70},
                        {-8,70},{-8,133},{118,133}},       color={0,0,127}));
                connect(TZonCooSetOcc.y, noWinZonSta.TZonCooSetOcc) annotation (Line(points={{-58,40},
                        {-2,40},{-2,131},{118,131}},     color={0,0,127}));
                connect(ramp2.y,sin2. u)
                  annotation (Line(points={{-58,-40},{-42,-40}}, color={0,0,127}));
                connect(sin2.y, zonTem.u)
                  annotation (Line(points={{-18,-40},{-2,-40}}, color={0,0,127}));
                connect(maxZonTem.y, noWinZonSta.TZonMax) annotation (Line(points={{22,0},{40,
                        0},{40,129},{118,129}}, color={0,0,127}));
                connect(zonTem.y, noWinZonSta.TZon) annotation (Line(points={{22,-40},{46,-40},
                        {46,127},{118,127}}, color={0,0,127}));
                connect(ramp3.y,sin3. u)
                  annotation (Line(points={{-58,-80},{-42,-80}}, color={0,0,127}));
                connect(sin3.y, minZonTem.u)
                  annotation (Line(points={{-18,-80},{-2,-80}},   color={0,0,127}));
                connect(minZonTem.y, noWinZonSta.TZonMin) annotation (Line(points={{22,-80},{52,
                        -80},{52,125},{118,125}},   color={0,0,127}));
                connect(TZonHeaSetUno.y, noWinZonSta.TZonHeaSetUno) annotation (Line(points={{22,-110},
                        {58,-110},{58,123},{118,123}},        color={0,0,127}));
                connect(TZonCooSetUno.y, noWinZonSta.TZonCooSetUno) annotation (Line(points={{22,-150},
                        {64,-150},{64,121},{118,121}},        color={0,0,127}));
                connect(cooDowTim.y, witWinZonSta.cooDowTim) annotation (Line(points={{-58,130},
                        {-20,130},{-20,59},{118,59}},color={0,0,127}));
                connect(warUpTim.y, witWinZonSta.warUpTim) annotation (Line(points={{-58,100},
                        {-14,100},{-14,57},{118,57}}, color={0,0,127}));
                connect(uWinSta.y, witWinZonSta.uWinSta) annotation (Line(points={{-98,20},{-20,
                        20},{-20,55},{118,55}},  color={255,0,255}));
                connect(TZonHeaSetOcc.y, witWinZonSta.TZonHeaSetOcc) annotation (Line(points={{-58,70},
                        {-8,70},{-8,53},{118,53}},          color={0,0,127}));
                connect(TZonCooSetOcc.y, witWinZonSta.TZonCooSetOcc) annotation (Line(points={{-58,40},
                        {-2,40},{-2,51},{118,51}},        color={0,0,127}));
                connect(maxZonTem.y, witWinZonSta.TZonMax) annotation (Line(points={{22,0},{40,
                        0},{40,49},{118,49}},    color={0,0,127}));
                connect(zonTem.y, witWinZonSta.TZon) annotation (Line(points={{22,-40},{46,-40},
                        {46,47},{118,47}}, color={0,0,127}));
                connect(minZonTem.y, witWinZonSta.TZonMin) annotation (Line(points={{22,-80},{
                        52,-80},{52,45},{118,45}}, color={0,0,127}));
                connect(TZonHeaSetUno.y, witWinZonSta.TZonHeaSetUno) annotation (Line(points={{22,-110},
                        {58,-110},{58,43},{118,43}},         color={0,0,127}));
                connect(TZonCooSetUno.y, witWinZonSta.TZonCooSetUno) annotation (Line(points={{22,-150},
                        {64,-150},{64,41},{118,41}},         color={0,0,127}));

              annotation (
                experiment(StopTime=86400, Tolerance=1e-6),
                __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/Generic/SetPoints/Validation/ZoneStatus.mos"
                      "Simulate and plot"),
                  Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.ZoneStatus\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.ZoneStatus</a>
for checking zone temperature status.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 10, 2020, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),        Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                       graphics={
                      Ellipse(lineColor = {75,138,73},
                              fillColor={255,255,255},
                              fillPattern = FillPattern.Solid,
                              extent = {{-100,-100},{100,100}}),
                      Polygon(lineColor = {0,0,255},
                              fillColor = {75,138,73},
                              pattern = LinePattern.None,
                              fillPattern = FillPattern.Solid,
                              points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                  Diagram(coordinateSystem(extent={{-160,-180},{160,160}})));
              end ZoneStatus;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Polygon(
                      origin={8.0,14.0},
                      lineColor={78,138,73},
                      fillColor={78,138,73},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
            end Validation;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains generic setpoint sequences for
either AHU or terminal units control.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Ellipse(
                    origin={10.0,10.0},
                    lineColor={128,128,128},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    extent={{-80.0,0.0},{-20.0,60.0}}),
                  Ellipse(
                    origin={10.0,10.0},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{0.0,0.0},{60.0,60.0}}),
                  Ellipse(
                    origin={10.0,10.0},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{0.0,-80.0},{60.0,-20.0}}),
                  Ellipse(
                    origin={10.0,10.0},
                    fillColor={76,76,76},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{-80.0,-80.0},{-20.0,-20.0}})}));
          end SetPoints;

          package Validation "Collection of validation models"

            model FreezeProtectionMixedAir
              "Validation model for the mixed air temperature based freeze protection block"

              parameter Real TFreSet(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")= 273.15 + 4
                "Freeze protection set point temperature";

              hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.FreezeProtectionMixedAir
                freProTMix(final TFreSet=TFreSet)
                "Freeze protection signal based on mixed air temperature"
                annotation (Placement(transformation(extent={{0,0},{20,20}})));

              CDL.Continuous.Sources.Sine sin1(
                amplitude=20,
                freqHz=1/1800,
                startTime=0,
                offset=TFreSet - 1)
                "Sine shaped mixed air temperature input signal"
                annotation (Placement(transformation(extent={{-40,2},{-20,20}})));

            equation
              connect(sin1.y, freProTMix.TMix)
              annotation (Line(points={{-18,11},{-10,11},{-10,10},{-2,10}}, color={0,0,127}));
              annotation (
              experiment(StopTime=1800.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/Generic/Validation/FreezeProtectionMixedAir.mos"
                "Simulate and plot"),
                Icon(graphics={Ellipse(
                      lineColor={75,138,73},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid,
                      extent={{-100,-100},{100,100}}), Polygon(
                      lineColor={0,0,255},
                      fillColor={75,138,73},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-60,-60},{60,60}})),
                Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.FreezeProtectionMixedAir\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.FreezeProtectionMixedAir</a>
for mixed air temperature <code>TMix</code> signal.
</p>
</html>",   revisions="<html>
<ul>
<li>
November 07, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
            end FreezeProtectionMixedAir;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Polygon(
                    origin={8.0,14.0},
                    lineColor={78,138,73},
                    fillColor={78,138,73},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
          end Validation;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains generic sequences that would be needed for both AHU and
terminal units control.
</p>
</html>"),Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Ellipse(
                  origin={10.0,10.0},
                  lineColor={128,128,128},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  extent={{-80.0,0.0},{-20.0,60.0}}),
                Ellipse(
                  origin={10.0,10.0},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{0.0,0.0},{60.0,60.0}}),
                Ellipse(
                  origin={10.0,10.0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{0.0,-80.0},{60.0,-20.0}}),
                Ellipse(
                  origin={10.0,10.0},
                  fillColor={76,76,76},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{-80.0,-80.0},{-20.0,-20.0}})}));
        end Generic;

        package TerminalUnits "Control sequences for terminal units"

          block Controller "Controller for room VAV box"

            parameter Real samplePeriod(
              final unit="s",
              final quantity="Time")
              "Sample period of component, set to the same value as the trim and respond that process yPreSetReq";
            parameter Real V_flow_nominal(
              final unit="m3/s",
              final quantity="VolumeFlowRate")
              "Volume flow rate of this thermal zone";
            parameter Real AFlo(
              final unit="m2",
              final quantity="Area") "Area of the zone";

            parameter
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController controllerTypeCoo=
                hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
              "Type of controller"
              annotation (Dialog(group="Cooling loop signal"));

            parameter Real kCoo(final unit="1/K") = 0.1
              "Gain for cooling control loop signal"
              annotation(Dialog(group="Cooling loop signal"));

            parameter Real TiCoo(
              final unit="s",
              final quantity="Time")=900
              "Time constant of integrator block for cooling control loop signal"
              annotation(Dialog(group="Cooling loop signal",
                enable=controllerTypeCoo == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                     or controllerTypeCoo == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

            parameter Real TdCoo(
              final unit="s",
              final quantity="Time")=0.1
              "Time constant of derivative block for cooling control loop signal"
              annotation (Dialog(group="Cooling loop signal",
                enable=controllerTypeCoo == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                     or controllerTypeCoo == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

            parameter
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController controllerTypeHea=
                hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
              "Type of controller"
              annotation (Dialog(group="Heating loop signal"));
            parameter Real kHea(final unit="1/K")=0.1
              "Gain for heating control loop signal"
              annotation(Dialog(group="Heating loop signal"));

            parameter Real TiHea(
              final unit="s",
              final quantity="Time")=900
              "Time constant of integrator block for heating control loop signal"
              annotation(Dialog(group="Heating loop signal",
              enable=controllerTypeHea == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                     or controllerTypeHea == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

            parameter Real TdHea(
              final unit="s",
              final quantity="Time")=0.1
              "Time constant of derivative block for heating control loop signal"
              annotation (Dialog(group="Heating loop signal",
                enable=controllerTypeHea == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                     or controllerTypeHea == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

            parameter
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController controllerTypeVal=
                hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
              "Type of controller" annotation (Dialog(group="Valve"));

            parameter Real kVal=0.5
              "Gain of controller for valve control"
              annotation (Dialog(group="Valve"));

            parameter Real TiVal(
              final unit="s",
              final quantity="Time")=300
              "Time constant of integrator block for valve control"
              annotation(Dialog(group="Valve",
              enable=controllerTypeVal == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                     or controllerTypeVal == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

            parameter Real TdVal(
              final unit="s",
              final quantity="Time")=0.1
              "Time constant of derivative block for valve control"
              annotation (Dialog(group="Valve",
                enable=controllerTypeVal == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                     or controllerTypeVal == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

            parameter
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController controllerTypeDam=
                hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
              "Type of controller" annotation (Dialog(group="Damper"));

            parameter Real kDam(final unit="1")=0.5
              "Gain of controller for damper control"
              annotation (Dialog(group="Damper"));

            parameter Real TiDam(
              final unit="s",
              final quantity="Time")=300
              "Time constant of integrator block for damper control"
              annotation (Dialog(group="Damper",
                enable=controllerTypeDam == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                     or controllerTypeDam == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

            parameter Real TdDam(
              final unit="s",
              final quantity="Time")=0.1
              "Time constant of derivative block for damper control"
              annotation (Dialog(group="Damper",
                enable=controllerTypeDam == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                     or controllerTypeDam == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

            parameter Boolean have_occSen=false
              "Set to true if the zone has occupancy sensor"
              annotation (Dialog(tab="Airflow setpoint", group="Zone sensors"));
            parameter Boolean have_winSen=false
              "Set to true if the zone has window status sensor"
              annotation (Dialog(tab="Airflow setpoint", group="Zone sensors"));
            parameter Boolean have_CO2Sen=false
              "Set to true if the zone has CO2 sensor"
              annotation (Dialog(tab="Airflow setpoint", group="Zone sensors"));
            parameter Real VDisCooSetMax_flow(
              final unit="m3/s",
              final quantity="VolumeFlowRate")=V_flow_nominal
              "Zone maximum cooling airflow setpoint"
              annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
            parameter Real VDisSetMin_flow(
              final unit="m3/s",
              final quantity="VolumeFlowRate")=0.15*V_flow_nominal
              "Zone minimum airflow setpoint"
              annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
            parameter Real VDisHeaSetMax_flow(
              final unit="m3/s",
              final quantity="VolumeFlowRate")=V_flow_nominal
              "Zone maximum heating airflow setpoint"
              annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
            parameter Real VDisConMin_flow(
              final unit="m3/s",
              final quantity="VolumeFlowRate")=0.1*V_flow_nominal
              "VAV box controllable minimum"
              annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
            parameter Real VOutPerAre_flow(final unit = "m3/(s.m2)")=3e-4
              "Outdoor air rate per unit area"
              annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
            parameter Real VOutPerPer_flow(
              final unit="m3/s",
              final quantity="VolumeFlowRate")=2.5e-3
              "Outdoor air rate per person"
              annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
            parameter Real CO2Set=894 "CO2 setpoint in ppm"
              annotation (Dialog(tab="Airflow setpoint", group="Nominal conditions"));
            parameter Real dTDisZonSetMax(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=11
              "Zone maximum discharge air temperature above heating setpoint"
              annotation (Dialog(tab="Damper and valve", group="Parameters"));
            parameter Real TDisMin(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=283.15
              "Lowest discharge air temperature"
              annotation (Dialog(tab="Damper and valve", group="Parameters"));
            parameter Boolean have_heaWatCoi=true
              "Flag, true if there is a hot water coil"
              annotation (Dialog(tab="System requests", group="Parameters"));
            parameter Boolean have_heaPla=false
              "Flag, true if there is a boiler plant"
              annotation (Dialog(tab="System requests", group="Parameters"));
            parameter Real errTZonCoo_1(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=2.8
              "Limit value of difference between zone temperature and cooling setpoint
    for generating 3 cooling SAT reset requests"
              annotation (Dialog(tab="System requests", group="Parameters"));
            parameter Real errTZonCoo_2(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=1.7
              "Limit value of difference between zone temperature and cooling setpoint
    for generating 2 cooling SAT reset requests"
              annotation (Dialog(tab="System requests", group="Parameters"));
            parameter Real errTDis_1(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=17
              "Limit value of difference between discharge air temperature and its setpoint
    for generating 3 hot water reset requests"
              annotation (Dialog(tab="System requests", group="Parameters"));
            parameter Real errTDis_2(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=8.3
              "Limit value of difference between discharge air temperature and its setpoint
    for generating 2 hot water reset requests"
              annotation (Dialog(tab="System requests", group="Parameters"));
            parameter Real durTimTem(
              final unit="s",
              final quantity="Time")=120
              "Duration time of zone temperature exceeds setpoint"
              annotation (Dialog(tab="System requests", group="Duration times"));
            parameter Real durTimFlo(
              final unit="s",
              final quantity="Time")=60
              "Duration time of airflow rate less than setpoint"
              annotation (Dialog(tab="System requests", group="Duration times"));
            parameter Real durTimDisAir(
              final unit="s",
              final quantity="Time")=300
              "Duration time of discharge air temperature is less than setpoint"
              annotation (Dialog(tab="System requests", group="Duration times"));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonHeaSet(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              final displayUnit="degC")
              "Setpoint temperature for room for heating" annotation (Placement(
                  transformation(extent={{-180,140},{-140,180}}),
                  iconTransformation(extent={{-140,80},{-100,120}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonCooSet(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              final displayUnit="degC")
              "Setpoint temperature for room for cooling" annotation (Placement(
                  transformation(extent={{-180,100},{-140,140}}),
                  iconTransformation(extent={{-140,60},{-100,100}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZon(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              final displayUnit="degC") "Measured room temperature" annotation
              (Placement(transformation(extent={{-180,-34},{-140,6}}),
                  iconTransformation(extent={{-140,-20},{-100,20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TDis(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              final displayUnit="degC")
              "Measured supply air temperature after heating coil" annotation (
                Placement(transformation(extent={{-180,-130},{-140,-90}}),
                  iconTransformation(extent={{-140,-80},{-100,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VDis_flow(final
                unit="m3/s", final quantity="VolumeFlowRate")
              "Measured discharge airflow rate" annotation (Placement(
                  transformation(extent={{-180,-70},{-140,-30}}),
                  iconTransformation(extent={{-140,-40},{-100,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSupAHU(
              final quantity="ThermodynamicTemperature",
              final unit="K",
              final displayUnit="degC") "AHU supply air temperature"
              annotation (Placement(transformation(extent={{-180,-160},{-140,-120}}),
                  iconTransformation(extent={{-140,-100},{-100,-60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput ppmCO2 if
              have_CO2Sen "Measured CO2 concentration" annotation (Placement(
                  transformation(extent={{-180,60},{-140,100}}),
                  iconTransformation(extent={{-140,40},{-100,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput nOcc if
              have_occSen "Number of occupants" annotation (Placement(
                  transformation(extent={{-180,30},{-140,70}}),
                  iconTransformation(extent={{-140,20},{-100,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uWin if
              have_winSen "Window status, true if open, false if closed"
              annotation (Placement(transformation(extent={{-180,0},{-140,40}}),
                  iconTransformation(extent={{-140,0},{-100,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uOpeMod
              "Zone operation mode" annotation (Placement(transformation(extent
                    ={{-180,-190},{-140,-150}}), iconTransformation(extent={{-140,
                      -120},{-100,-80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput yDam_actual
              "Actual VAV damper position" annotation (Placement(transformation(
                    extent={{-180,-100},{-140,-60}}), iconTransformation(extent
                    ={{-140,-60},{-100,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yVal(
              final min=0,
              final max=1,
              final unit="1") "Signal for heating coil valve" annotation (
                Placement(transformation(extent={{140,-40},{180,0}}),
                  iconTransformation(extent={{100,-10},{140,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yDam(
              final min=0,
              final max=1,
              final unit="1") "Signal for VAV damper" annotation (Placement(
                  transformation(extent={{140,60},{180,100}}),
                  iconTransformation(extent={{100,40},{140,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput yZonTemResReq
              "Zone cooling supply air temperature reset request" annotation (
                Placement(transformation(extent={{140,-100},{180,-60}}),
                  iconTransformation(extent={{100,-60},{140,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput yZonPreResReq
              "Zone static pressure reset requests" annotation (Placement(
                  transformation(extent={{140,-140},{180,-100}}),
                  iconTransformation(extent={{100,-100},{140,-60}})));

            hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow
              actAirSet(
              final AFlo=AFlo,
              final have_occSen=have_occSen,
              final have_winSen=have_winSen,
              final have_CO2Sen=have_CO2Sen,
              final VDisCooSetMax_flow=VDisCooSetMax_flow,
              final VDisSetMin_flow=VDisSetMin_flow,
              final VDisHeaSetMax_flow=VDisHeaSetMax_flow,
              final VDisConMin_flow=VDisConMin_flow,
              final VOutPerAre_flow=VOutPerAre_flow,
              final VOutPerPer_flow=VOutPerPer_flow,
              final CO2Set=CO2Set) "Active airflow rate setpoint" annotation (
                Placement(transformation(extent={{-40,60},{-20,80}})));
            hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.DamperValves
              damVal(
              final controllerTypeVal=controllerTypeVal,
              final kVal=kVal,
              final TiVal=TiVal,
              final TdVal=TdVal,
              final controllerTypeDam=controllerTypeDam,
              final kDam=kDam,
              final TiDam=TiDam,
              final TdDam=TdDam,
              final dTDisZonSetMax=dTDisZonSetMax,
              final TDisMin=TDisMin,
              V_flow_nominal=max(VDisCooSetMax_flow, VDisHeaSetMax_flow))
              "Damper and valve controller"
              annotation (Placement(transformation(extent={{20,-20},{40,0}})));
            hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SystemRequests
              sysReq(
              final samplePeriod=samplePeriod,
              final have_heaWatCoi=have_heaWatCoi,
              final have_heaPla=have_heaPla,
              final errTZonCoo_1=errTZonCoo_1,
              final errTZonCoo_2=errTZonCoo_2,
              final errTDis_1=errTDis_1,
              final errTDis_2=errTDis_2,
              final durTimTem=durTimTem,
              final durTimFlo=durTimFlo,
              final durTimDisAir=durTimDisAir) "Number of system requests"
              annotation (Placement(transformation(extent={{80,-100},{100,-80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conHeaLoo(
              final controllerType=controllerTypeHea,
              final k=kHea,
              final Ti=TiHea,
              final Td=TdHea,
              final yMax=1,
              final yMin=0,
              reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter)
              "Heating loop signal" annotation (Placement(transformation(extent
                    ={{-110,150},{-90,170}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conCooLoo(
              final controllerType=controllerTypeCoo,
              final k=kCoo,
              final Ti=TiCoo,
              final Td=TdCoo,
              final yMax=1,
              final yMin=0,
              reverseAction=true,
              reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter)
              "Cooling loop signal" annotation (Placement(transformation(extent
                    ={{-110,110},{-90,130}})));

          protected
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal isUnOcc
              "Output true if unoccupied" annotation (Placement(transformation(
                    extent={{-18,-160},{2,-140}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conIntUn(final k=
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.unoccupied)
              "Constant signal for unoccupied mode" annotation (Placement(
                  transformation(extent={{-60,-160},{-40,-140}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not isNotUn
              "Output true if not unoccupied" annotation (Placement(
                  transformation(extent={{20,-160},{40,-140}})));

          equation
            connect(sysReq.TZonCooSet, TZonCooSet)
              annotation (Line(points={{78,-82},{-120,-82},{-120,120},{-160,120}},
                color={0,0,127}));
            connect(sysReq.TZon, TZon)
              annotation (Line(points={{78,-84},{0,-84},{0,-14},{-160,-14}},
                color={0,0,127}));
            connect(sysReq.VDisSet_flow, damVal.VDisSet_flow)
              annotation (Line(points={{78,-88},{64,-88},{64,-2},{42,-2}},
                color={0,0,127}));
            connect(sysReq.VDis_flow, VDis_flow)
              annotation (Line(points={{78,-90},{34,-90},{34,-50},{-160,-50}},
                color={0,0,127}));
            connect(sysReq.TDisHeaSet, damVal.TDisHeaSet)
              annotation (Line(points={{78,-94},{58,-94},{58,-18},{42,-18}},
                color={0,0,127}));
            connect(damVal.yDam, yDam)
              annotation (Line(points={{42,-6},{120,-6},{120,80},{160,80}},
                color={0,0,127}));
            connect(damVal.yHeaVal, yVal)
              annotation (Line(points={{42,-14},{120,-14},{120,-20},{160,-20}},
                color={0,0,127}));
            connect(damVal.TDis, TDis)
              annotation (Line(points={{26,-22},{26,-110},{-160,-110}},
                                                                     color={0,0,127}));
            connect(sysReq.TDis, TDis)
              annotation (Line(points={{78,-96},{26,-96},{26,-110},{-160,-110}},
                color={0,0,127}));
            connect(damVal.yHeaVal, sysReq.uHeaVal)
              annotation (Line(points={{42,-14},{50,-14},{50,-98},{78,-98}},
                                                                       color={0,0,127}));
            connect(TZon, damVal.TZon) annotation (Line(points={{-160,-14},{18,-14}},
                             color={0,0,127}));
            connect(damVal.TSup, TSupAHU) annotation (Line(points={{18,-8},{-80,-8},{-80,-140},
                    {-160,-140}},color={0,0,127}));
            connect(actAirSet.VActCooMax_flow, damVal.VActCooMax_flow) annotation (Line(points={{-18,78},
                    {0,78},{0,-4},{18,-4}},      color={0,0,127}));
            connect(actAirSet.VActCooMin_flow, damVal.VActCooMin_flow) annotation (Line(points={{-18,75},
                    {-2,75},{-2,-2},{18,-2}},      color={0,0,127}));
            connect(actAirSet.VActMin_flow, damVal.VActMin_flow) annotation (Line(points={{-18,72},
                    {-4,72},{-4,-6},{18,-6}}, color={0,0,127}));
            connect(actAirSet.VActHeaMin_flow, damVal.VActHeaMin_flow) annotation (Line(points={{-18,69},
                    {-6,69},{-6,-16},{18,-16}},  color={0,0,127}));
            connect(actAirSet.VActHeaMax_flow, damVal.VActHeaMax_flow) annotation (Line(points={{-18,66},
                    {-8,66},{-8,-18},{18,-18}},  color={0,0,127}));
            connect(damVal.THeaSet, TZonHeaSet)
              annotation (Line(points={{18,-10},{-124,-10},{-124,160},{-160,160}},
                color={0,0,127}));
            connect(actAirSet.VActCooMax_flow, damVal.VActCooMax_flow)
              annotation (Line(points={{-18,78},{0,78},{0,-4},{18,-4}},
                color={0,0,127}));
            connect(actAirSet.VActCooMin_flow, damVal.VActCooMin_flow)
              annotation (Line(points={{-18,75},{-2,75},{-2,-2},{18,-2}},
                color={0,0,127}));
            connect(actAirSet.VActMin_flow, damVal.VActMin_flow)
              annotation (Line(points={{-18,72},{-4,72},{-4,-6},{18,-6}},
                color={0,0,127}));
            connect(actAirSet.VActHeaMin_flow, damVal.VActHeaMin_flow)
              annotation (Line(points={{-18,69},{-6,69},{-6,-16},{18,-16}},
                color={0,0,127}));
            connect(actAirSet.VActHeaMax_flow, damVal.VActHeaMax_flow)
              annotation (Line(points={{-18,66},{-8,66},{-8,-18},{18,-18}},
                color={0,0,127}));
            connect(actAirSet.uOpeMod, uOpeMod)
              annotation (Line(points={{-42,78},{-112,78},{-112,-170},{-160,-170}},
                color={255,127,0}));
            connect(sysReq.yZonTemResReq, yZonTemResReq)
              annotation (Line(points={{102,-83},{120,-83},{120,-80},{160,-80}},
                color={255,127,0}));
            connect(sysReq.yZonPreResReq, yZonPreResReq)
              annotation (Line(points={{102,-88},{120,-88},{120,-120},{160,-120}},
                color={255,127,0}));
            connect(actAirSet.ppmCO2, ppmCO2)
              annotation (Line(points={{-42,74},{-60,74},{-60,80},{-160,80}},
                color={0,0,127}));
            connect(actAirSet.nOcc, nOcc)
              annotation (Line(points={{-42,66},{-60,66},{-60,50},{-160,50}},
                color={0,0,127}));
            connect(actAirSet.uWin, uWin)
              annotation (Line(points={{-42,62},{-56,62},{-56,20},{-160,20}},
                color={255,0,255}));
            connect(TZonHeaSet, conHeaLoo.u_s)
              annotation (Line(points={{-160,160},{-112,160}}, color={0,0,127}));
            connect(TZonCooSet, conCooLoo.u_s)
              annotation (Line(points={{-160,120},{-112,120}}, color={0,0,127}));
            connect(TZon, conHeaLoo.u_m)
              annotation (Line(points={{-160,-14},{-122,-14},{-122,140},{-100,140},{-100,148}},
                             color={0,0,127}));
            connect(TZon, conCooLoo.u_m)
              annotation (Line(points={{-160,-14},{-122,-14},{-122,100},{-100,100},{-100,108}},
                             color={0,0,127}));
            connect(conCooLoo.y, damVal.uCoo)
              annotation (Line(points={{-88,120},{8,120},{8,0},{18,0}},
                color={0,0,127}));
            connect(conHeaLoo.y, damVal.uHea)
              annotation (Line(points={{-88,160},{12,160},{12,-12},{18,-12}},
                color={0,0,127}));
            connect(conCooLoo.y, sysReq.uCoo)
              annotation (Line(points={{-88,120},{8,120},{8,-86},{78,-86}},
                color={0,0,127}));
            connect(damVal.uOpeMod, uOpeMod) annotation (Line(points={{18,-20},{-112,-20},
                    {-112,-170},{-160,-170}},
                                            color={255,127,0}));
            connect(conIntUn.y, isUnOcc.u1)
              annotation (Line(points={{-38,-150},{-20,-150}}, color={255,127,0}));
            connect(uOpeMod, isUnOcc.u2) annotation (Line(points={{-160,-170},{-32,-170},{
                    -32,-158},{-20,-158}}, color={255,127,0}));
            connect(isUnOcc.y, isNotUn.u)
              annotation (Line(points={{4,-150},{18,-150}},   color={255,0,255}));
            connect(isNotUn.y, conCooLoo.trigger) annotation (Line(points={{42,-150},{60,-150},
                    {60,-120},{-116,-120},{-116,104},{-106,104},{-106,108}}, color={255,0,
                    255}));
            connect(isNotUn.y, conHeaLoo.trigger) annotation (Line(points={{42,-150},{60,-150},
                    {60,-120},{-116,-120},{-116,142},{-106,142},{-106,148}}, color={255,0,
                    255}));
            connect(sysReq.yDam_actual,yDam_actual)  annotation (Line(points={{78,-92},{-124,
                    -92},{-124,-80},{-160,-80}}, color={0,0,127}));

          annotation (defaultComponentName="terUniCon",
            Icon(graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-100,-54},{-78,-64}},
                    lineColor={0,0,127},
                    textString="TDis"),
                  Text(
                    extent={{-100,-70},{-70,-82}},
                    lineColor={0,0,127},
                    textString="TSup"),
                  Text(
                    extent={{70,18},{98,4}},
                    lineColor={0,0,127},
                    textString="yVal"),
                  Text(
                    extent={{68,70},{96,56}},
                    lineColor={0,0,127},
                    textString="yDam"),
                  Text(
                    extent={{-98,100},{-46,88}},
                    lineColor={0,0,127},
                    textString="TZonHeaSet"),
                  Text(
                    extent={{-98,-14},{-68,-26}},
                    lineColor={0,0,127},
                    textString="VDis_flow"),
                  Text(
                    extent={{-120,160},{114,108}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-96,6},{-74,-8}},
                    lineColor={0,0,127},
                    textString="TZon"),
                  Text(
                    extent={{-100,84},{-46,74}},
                    lineColor={0,0,127},
                    textString="TZonCooSet"),
                  Text(
                    extent={{-100,-86},{-52,-98}},
                    lineColor={0,0,127},
                    textString="uOpeMod"),
                  Text(
                    visible=have_occSen,
                    extent={{-100,36},{-74,26}},
                    lineColor={0,0,127},
                    textString="nOcc"),
                  Text(
                    visible=have_CO2Sen,
                    extent={{-96,60},{-58,42}},
                    lineColor={0,0,127},
                    textString="ppmCO2"),
                  Text(
                    visible=have_winSen,
                    extent={{-100,14},{-72,4}},
                    lineColor={0,0,127},
                    textString="uWin"),
                  Text(
                    extent={{22,-20},{96,-58}},
                    lineColor={0,0,127},
                    textString="yZonTemResReq"),
                  Text(
                    extent={{24,-62},{96,-96}},
                    lineColor={0,0,127},
                    textString="yZonPreResReq"),
                  Text(
                    extent={{-98,-34},{-50,-44}},
                    lineColor={0,0,127},
                    textString="uDam_actual")}),
              Diagram(coordinateSystem(extent={{-140,-180},{140,180}})),
          Documentation(info="<html>
<p>
Controller for terminal box of VAV system with reheat according to ASHRAE
Guideline 36, Part 5.E. It outputs damper position <code>yDam</code>,
hot water valve position <code>yVal</code>, AHU cooling supply temperature
setpoint reset request <code>yZonTemResReq</code>, and static pressure setpoint
reset request <code>yZonPreResReq</code>.
</p>
<p>The sequence consists of four subsequences. </p>
<h4>a. Heating and cooling control loop</h4>
<p>
The subsequence is implementd according to Part 5.B.5. The measured zone
temperature <code>TZon</code>, zone setpoints temperatures <code>TZonHeaSet</code> and
<code>TZonCooSet</code> are inputs to the block <code>conHeaLoo</code> and 
<code>conCooLoo</code> to generate the control loop signal. 
</p>
<h4>b. Active airflow setpoint calculation</h4>
<p>
This sequence sets the active maximum and minimum airflow according to
Part 5.E.3-5. Depending on operation modes <code>uOpeMod</code>, it sets the
airflow rate limits for cooling and heating supply. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow</a>.
</p>
<h4>c. Damper and valve control</h4>
<p>
This sequence sets the damper and valve position for VAV reheat terminal unit.
The implementation is according to Part 5.E.6. According to heating and cooling
control loop signal, it calculates the discharge air temperature setpoint
<code>TDisHeaSet</code>. Along with the defined maximum and minimum airflow, measured
zone temperature, the sequence outputs <code>yDam</code>, <code>yVal</code>,
<code>TDisHeaSet</code> and discharge airflow rate setpoint <code>VDisSet_flow</code>.
See <a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.DamperValves\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.DamperValves</a>.
</p>
<h4>d. System reset requests generation</h4>
<p>
According to Part 5.E.9, this sequence outputs the system reset requests, i.e.
cooling supply air temperature reset requests <code>yZonTemResReq</code>,
static pressure reset requests <code>yZonPreResReq</code>, hot water reset
requests <code>yHeaValResReq</code>, and the boiler plant reset requests
<code>yHeaPlaReq</code>. See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SystemRequests\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SystemRequests</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 18, 2020, by Jianjun Hu:<br/>
Added actual VAV damper position as the input for generating system request.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1873\">issue 1873</a>.
</li>
<li>
March 06, 2020, by Jianjun Hu:<br/>
Added default component name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1809\">issue 1809</a>.
</li>
<li>
November 15, 2017, by Michael Wetter:<br/>
Added integrator reset.
</li>
<li>
October 27, 2017, by Jianjun Hu:<br/>
Moved it from example package.
</li>
<li>
September 25, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end Controller;

          block ModeAndSetPoints
            "Output zone setpoint with operation mode selection"

            parameter Real TZonHeaOn(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=293.15
              "Heating setpoint during on";
            parameter Real TZonHeaOff(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=285.15
              "Heating setpoint during off";
            parameter Real TZonCooOn(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=297.15
              "Cooling setpoint during on";
            parameter Real TZonCooOff(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=303.15
              "Cooling setpoint during off";
            parameter Real preWarCooTim(
              final unit="s",
              final quantity="Time")=10800
              "Maximum cool-down/warm-up time"
              annotation (Dialog(tab="Operation mode", group="Parameters"));
            parameter Real bouLim(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=1.1
              "Value limit to indicate the end of setback/setup mode"
              annotation (Dialog(tab="Operation mode", group="Parameters"));
            parameter Real TZonFreProOn(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=277.55
              "Threshold zone temperature value to activate freeze protection mode"
              annotation (Dialog(tab="Operation mode", group="Parameters"));
            parameter Real TZonFreProOff(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=280.35
              "Threshold zone temperature value to finish the freeze protection mode"
              annotation (Dialog(tab="Operation mode", group="Parameters"));
            parameter Real warCooTim(
              final unit="s",
              final quantity="Time")=1800
              "Defined cool-down/warm-up time"
              annotation (Dialog(tab="Operation mode", group="Test setting"));
            parameter Boolean have_occSen=false
              "Check if the zone has occupancy sensor"
              annotation (Dialog(tab="Setpoint adjust", group="Sensors"));
            parameter Boolean have_winSen=false
              "Check if the zone has window status sensor"
              annotation (Dialog(tab="Setpoint adjust", group="Sensors"));
            parameter Boolean cooAdj=false
              "Flag, set to true if both cooling and heating setpoint are adjustable separately"
              annotation (Dialog(tab="Setpoint adjust", group="Adjustable settings"));
            parameter Boolean heaAdj=false
              "Flag, set to true if heating setpoint is adjustable"
              annotation (Dialog(tab="Setpoint adjust", group="Adjustable settings"));
            parameter Boolean sinAdj=false
              "Flag, set to true if both cooling and heating setpoint are adjustable through a single common knob"
              annotation (Dialog(tab="Setpoint adjust", group="Adjustable settings"));
            parameter Boolean ignDemLim=true
              "Flag, set to true to exempt individual zone from demand limit setpoint adjustment"
              annotation (Dialog(tab="Setpoint adjust", group="Adjustable settings"));
            parameter Real TZonCooOnMax(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=300.15
              "Maximum cooling setpoint during on"
              annotation (Dialog(tab="Setpoint adjust", group="Limits"));
            parameter Real TZonCooOnMin(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=295.15
              "Minimum cooling setpoint during on"
              annotation (Dialog(tab="Setpoint adjust", group="Limits"));
            parameter Real TZonHeaOnMax(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=295.15
              "Maximum heating setpoint during on"
              annotation (Dialog(tab="Setpoint adjust", group="Limits"));
            parameter Real TZonHeaOnMin(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=291.15
              "Minimum heating setpoint during on"
              annotation (Dialog(tab="Setpoint adjust", group="Limits"));
            parameter Real TZonCooSetWinOpe(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=322.15
              "Cooling setpoint when window is open"
              annotation (Dialog(tab="Setpoint adjust", group="Limits"));
            parameter Real TZonHeaSetWinOpe(
              final unit="K",
              final displayUnit="degC",
              final quantity="ThermodynamicTemperature")=277.15
              "Heating setpoint when window is open"
              annotation (Dialog(tab="Setpoint adjust", group="Limits"));
            parameter Real incTSetDem_1(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=0.56
              "Cooling setpoint increase value when cooling demand limit level 1 is imposed"
              annotation (Dialog(tab="Setpoint adjust", group="Demands settings"));
            parameter Real incTSetDem_2(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=1.1
              "Cooling setpoint increase value when cooling demand limit level 2 is imposed"
              annotation (Dialog(tab="Setpoint adjust", group="Demands settings"));
            parameter Real incTSetDem_3(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=2.2
              "Cooling setpoint increase value when cooling demand limit level 3 is imposed"
              annotation (Dialog(tab="Setpoint adjust", group="Demands settings"));
            parameter Real decTSetDem_1(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=0.56
              "Heating setpoint decrease value when heating demand limit level 1 is imposed"
              annotation (Dialog(tab="Setpoint adjust", group="Demands settings"));
            parameter Real decTSetDem_2(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=1.1
              "Heating setpoint decrease value when heating demand limit level 2 is imposed"
              annotation (Dialog(tab="Setpoint adjust", group="Demands settings"));
            parameter Real decTSetDem_3(
              final unit="K",
              final displayUnit="K",
              final quantity="TemperatureDifference")=2.2
              "Heating setpoint decrease value when heating demand limit level 3 is imposed"
              annotation (Dialog(tab="Setpoint adjust", group="Demands settings"));
            parameter Integer cooDemLimLevCon=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.cooling0
              "Cooling demand limit level"
              annotation (Dialog(tab="Setpoint adjust"));
            parameter Integer heaDemLimLevCon=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.heating0
              "Heating demand limit level"
              annotation (Dialog(tab="Setpoint adjust"));
            parameter Boolean winStaCon=false
              "Window status, set to true if window is open"
              annotation (Dialog(tab="Setpoint adjust"));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput tNexOcc(final
                unit="s", quantity="Time") "Time to next occupied period"
              annotation (Placement(transformation(extent={{-200,120},{-160,160}}),
                  iconTransformation(extent={{-140,70},{-100,110}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uOcc
              "Current occupancy period, true if it is in occupant period"
              annotation (Placement(transformation(extent={{-200,-10},{-160,
                      30.5}}), iconTransformation(extent={{-140,40},{-100,80.5}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZon(final
                unit="K", quantity="ThermodynamicTemperature")
              "Measured zone temperatures" annotation (Placement(transformation(
                    extent={{-200,-70},{-160,-30}}), iconTransformation(extent=
                      {{-140,10},{-100,50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput setAdj(final
                unit="K", quantity="ThermodynamicTemperature") if (cooAdj or
              sinAdj) "Setpoint adjustment value" annotation (Placement(
                  transformation(extent={{-20,-20},{20,20}}, origin={-180,-80}),
                  iconTransformation(extent={{-140,-20},{-100,20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput heaSetAdj(final
                unit="K", quantity="ThermodynamicTemperature") if heaAdj
              "Heating setpoint adjustment value" annotation (Placement(
                  transformation(extent={{-20,-20},{20,20}}, origin={-180,-120}),
                  iconTransformation(extent={{-140,-50},{-100,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uOccSen if
              have_occSen "Occupancy sensor (occupied=true, unoccupied=false)"
              annotation (Placement(transformation(extent={{-200,-180},{-160,-140}}),
                  iconTransformation(extent={{-140,-80},{-100,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uWinSta if
              have_winSen "Window status (open=true, close=false)" annotation (
                Placement(transformation(extent={{-200,-220},{-160,-180}}),
                  iconTransformation(extent={{-140,-110},{-100,-70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TZonCooSet(final
                unit="K", quantity="ThermodynamicTemperature")
              "Cooling setpoint temperature" annotation (Placement(
                  transformation(extent={{160,90},{200,130}}),
                  iconTransformation(extent={{100,50},{140,90}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TZonHeaSet(final
                unit="K", quantity="ThermodynamicTemperature")
              "Heating setpoint temperature" annotation (Placement(
                  transformation(extent={{160,40},{200,80}}),
                  iconTransformation(extent={{100,-20},{140,20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput yOpeMod
              "Operation mode" annotation (Placement(transformation(extent={{
                      160,-30},{200,10}}), iconTransformation(extent={{100,-90},
                      {140,-50}})));

          protected
            hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.SetPoints.ZoneTemperatures
              TZonSet(
              final have_occSen=have_occSen,
              final have_winSen=have_winSen,
              final cooAdj=cooAdj,
              final heaAdj=heaAdj,
              final sinAdj=sinAdj,
              final ignDemLim=ignDemLim,
              final TZonCooOnMax=TZonCooOnMax,
              final TZonCooOnMin=TZonCooOnMin,
              final TZonHeaOnMax=TZonHeaOnMax,
              final TZonHeaOnMin=TZonHeaOnMin,
              final TZonCooSetWinOpe=TZonCooSetWinOpe,
              final TZonHeaSetWinOpe=TZonHeaSetWinOpe,
              final incTSetDem_1=incTSetDem_1,
              final incTSetDem_2=incTSetDem_2,
              final incTSetDem_3=incTSetDem_3,
              final decTSetDem_1=decTSetDem_1,
              final decTSetDem_2=decTSetDem_2,
              final decTSetDem_3=decTSetDem_3) "Zone set point temperature"
              annotation (Placement(transformation(extent={{80,-100},{120,-60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant cooDemLimLev(final k=
                  cooDemLimLevCon) "Cooling demand limit level" annotation (
                Placement(transformation(extent={{0,-150},{20,-130}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant heaDemLimLev(final k=
                  heaDemLimLevCon) "Heating demand limit level" annotation (
                Placement(transformation(extent={{0,-210},{20,-190}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TSetRooHeaOn(final k=
                  TZonHeaOn) "Heating on setpoint" annotation (Placement(
                  transformation(extent={{-120,140},{-100,160}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TSetRooHeaOff(final k=
                  TZonHeaOff) "Heating off set point" annotation (Placement(
                  transformation(extent={{-120,60},{-100,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TSetRooCooOn(final k=
                  TZonCooOn) "Cooling on setpoint" annotation (Placement(
                  transformation(extent={{-120,100},{-100,120}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TSetRooCooOff(final k=
                  TZonCooOff) "Cooling off set point" annotation (Placement(
                  transformation(extent={{-120,20},{-100,40}})));
            hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.OperationMode
              opeModSel(
              final have_winSen=have_winSen,
              final numZon=1,
              final preWarCooTim=preWarCooTim,
              final TZonFreProOn=TZonFreProOn,
              final TZonFreProOff=TZonFreProOff) "Operation mode selector"
              annotation (Placement(transformation(extent={{40,-20},{60,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant tCooDowHeaUp(final k=
                  warCooTim)
              "Cool down and heat up time (simplified as constant)" annotation
              (Placement(transformation(extent={{-120,180},{-100,200}})));
            hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Generic.SetPoints.ZoneStatus
              zonSta(final have_winSen=have_winSen)
              "Check zone temperature status" annotation (Placement(
                  transformation(extent={{-60,40},{-40,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
              colZon "Check if the zone is cold zone"
              annotation (Placement(transformation(extent={{-20,10},{0,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
              hotZon "Check if the zone is hot zone" annotation (Placement(
                  transformation(extent={{-20,-50},{0,-30}})));

          equation
            connect(TZonSet.uCooDemLimLev,cooDemLimLev. y)
              annotation (Line(points={{78,-94},{36,-94},{36,-140},{22,-140}},
                color={255,127,0}));
            connect(heaDemLimLev.y,TZonSet. uHeaDemLimLev)
              annotation (Line(points={{22,-200},{40,-200},{40,-98},{78,-98}},
                color={255,127,0}));
            connect(TZonSet.TZonCooSet, TZonCooSet)
              annotation (Line(points={{122,-72},{132,-72},{132,110},{180,110}},
                color={0,0,127}));
            connect(TZonSet.TZonHeaSet, TZonHeaSet)
              annotation (Line(points={{122,-80},{140,-80},{140,60},{180,60}},
                color={0,0,127}));
            connect(setAdj, TZonSet.setAdj)
              annotation (Line(points={{-180,-80},{-100,-80},{-100,-83},{78,-83}},
                color={0,0,127}));
            connect(heaSetAdj, TZonSet.heaSetAdj)
              annotation (Line(points={{-180,-120},{-100,-120},{-100,-87},{78,-87}},
                color={0,0,127}));
            connect(TZonSet.uOccSen, uOccSen)
              annotation (Line(points={{94,-102},{94,-160},{-180,-160}},
                color={255,0,255}));
            connect(TZonSet.uWinSta, uWinSta)
              annotation (Line(points={{106,-102},{106,-170},{-72,-170},{-72,-200},{-180,-200}},
                color={255,0,255}));
            connect(tCooDowHeaUp.y, zonSta.cooDowTim) annotation (Line(points={{-98,190},{
                    -74,190},{-74,59},{-62,59}}, color={0,0,127}));
            connect(tCooDowHeaUp.y, zonSta.warUpTim) annotation (Line(points={{-98,190},{-74,
                    190},{-74,57},{-62,57}}, color={0,0,127}));
            connect(uWinSta, zonSta.uWinSta) annotation (Line(points={{-180,-200},{-72,-200},
                    {-72,55},{-62,55}}, color={255,0,255}));
            connect(TSetRooHeaOn.y, zonSta.TZonHeaSetOcc) annotation (Line(points={{-98,150},
                    {-76,150},{-76,53},{-62,53}}, color={0,0,127}));
            connect(TSetRooCooOn.y, zonSta.TZonCooSetOcc) annotation (Line(points={{-98,110},
                    {-78,110},{-78,51},{-62,51}}, color={0,0,127}));
            connect(TZon, zonSta.TZonMax) annotation (Line(points={{-180,-50},{-68,-50},{-68,
                    49},{-62,49}}, color={0,0,127}));
            connect(TZon, zonSta.TZon) annotation (Line(points={{-180,-50},{-68,-50},{-68,
                    47},{-62,47}}, color={0,0,127}));
            connect(TZon, zonSta.TZonMin) annotation (Line(points={{-180,-50},{-68,-50},{-68,
                    45},{-62,45}}, color={0,0,127}));
            connect(TSetRooHeaOff.y, zonSta.TZonHeaSetUno) annotation (Line(points={{-98,70},
                    {-80,70},{-80,43},{-62,43}}, color={0,0,127}));
            connect(TSetRooCooOff.y, zonSta.TZonCooSetUno) annotation (Line(points={{-98,30},
                    {-66,30},{-66,41},{-62,41}}, color={0,0,127}));
            connect(uOcc, opeModSel.uOcc) annotation (Line(points={{-180,10.25},{-136,10.25},
                    {-136,2},{38,2}}, color={255,0,255}));
            connect(tNexOcc, opeModSel.tNexOcc) annotation (Line(points={{-180,140},{-140,
                    140},{-140,0},{38,0}},   color={0,0,127}));
            connect(zonSta.yCooTim, opeModSel.maxCooDowTim) annotation (Line(points={{-38,59},
                    {30,59},{30,-2},{38,-2}},     color={0,0,127}));
            connect(zonSta.yWarTim, opeModSel.maxWarUpTim) annotation (Line(points={{-38,57},
                    {28,57},{28,-4},{38,-4}}, color={0,0,127}));
            connect(zonSta.yOccHeaHigMin, opeModSel.occHeaHigMin) annotation (Line(points={{-38,53},
                    {26,53},{26,-6},{38,-6}},          color={255,0,255}));
            connect(zonSta.yMaxHigOccCoo, opeModSel.maxHigOccCoo) annotation (Line(points={{-38,51},
                    {24,51},{24,-8},{38,-8}},          color={255,0,255}));
            connect(zonSta.yUnoHeaHigMin, opeModSel.unoHeaHigMin) annotation (Line(points={{-38,45},
                    {22,45},{22,-14},{38,-14}},          color={255,0,255}));
            connect(TZon, opeModSel.TZonMax) annotation (Line(points={{-180,-50},{-68,-50},
                    {-68,-16},{38,-16}}, color={0,0,127}));
            connect(TZon, opeModSel.TZonMin) annotation (Line(points={{-180,-50},{-68,-50},
                    {-68,-18},{38,-18}}, color={0,0,127}));
            connect(zonSta.yMaxHigUnoCoo, opeModSel.maxHigUnoCoo) annotation (Line(points={{-38,43},
                    {20,43},{20,-22},{38,-22}},          color={255,0,255}));
            connect(zonSta.yLowUnoHea, colZon.u) annotation (Line(points={{-38,49},{-26,49},
                    {-26,20},{-22,20}}, color={255,0,255}));
            connect(zonSta.yHigUnoCoo, hotZon.u) annotation (Line(points={{-38,41},{-28,41},
                    {-28,-40},{-22,-40}}, color={255,0,255}));
            connect(colZon.y, opeModSel.totColZon) annotation (Line(points={{2,20},{18,20},
                    {18,-12},{38,-12}}, color={255,127,0}));
            connect(hotZon.y, opeModSel.totHotZon) annotation (Line(points={{2,-40},{18,-40},
                    {18,-20},{38,-20}}, color={255,127,0}));
            connect(opeModSel.yOpeMod, TZonSet.uOpeMod) annotation (Line(points={{62,-10},
                    {70,-10},{70,-62},{78,-62}}, color={255,127,0}));
            connect(opeModSel.yOpeMod, yOpeMod)
              annotation (Line(points={{62,-10},{180,-10}}, color={255,127,0}));
            connect(TSetRooCooOn.y, TZonSet.TZonCooSetOcc) annotation (Line(points={{-98,110},
                    {-78,110},{-78,-67},{78,-67}}, color={0,0,127}));
            connect(TSetRooCooOff.y, TZonSet.TZonCooSetUno) annotation (Line(points={{-98,30},
                    {-74,30},{-74,-71.2},{78,-71.2}},     color={0,0,127}));
            connect(TSetRooHeaOn.y, TZonSet.TZonHeaSetOcc) annotation (Line(points={{-98,150},
                    {-76,150},{-76,-75.2},{78,-75.2}}, color={0,0,127}));
            connect(TSetRooHeaOff.y, TZonSet.TZonHeaSetUno) annotation (Line(points={{-98,70},
                    {-80,70},{-80,-79},{78,-79}},     color={0,0,127}));

            connect(uWinSta, opeModSel.uWinSta) annotation (Line(points={{-180,-200},{-72,
                    -200},{-72,-10},{38,-10}}, color={255,0,255}));
          annotation (defaultComponentName="modSetPoi",
            Diagram(coordinateSystem(extent={{-160,-220},{160,220}})),
            Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                 graphics={Text(
                  extent={{-100,140},{98,102}},
                  textString="%name",
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-98,98},{-48,82}},
                    lineColor={0,0,127},
                    pattern=LinePattern.Dash,
                    textString="tNexOcc"),
                  Text(
                    extent={{-100,70},{-68,56}},
                    lineColor={255,0,255},
                    pattern=LinePattern.Dash,
                    textString="uOcc"),
                  Text(
                    extent={{-100,40},{-62,24}},
                    lineColor={0,0,127},
                    pattern=LinePattern.Dash,
                    textString="TZon"),
                  Text(
                    visible=cooAdj or sinAdj,
                    extent={{-100,12},{-56,-8}},
                    lineColor={0,0,127},
                    pattern=LinePattern.Dash,
                    textString="setAdj"),
                  Text(
                    visible=heaAdj,
                    extent={{-98,-20},{-34,-40}},
                    lineColor={0,0,127},
                    pattern=LinePattern.Dash,
                    textString="heaSetAdj"),
                  Text(
                    visible=have_occSen,
                    extent={{-98,-50},{-50,-68}},
                    lineColor={255,0,255},
                    pattern=LinePattern.Dash,
                    textString="uOccSen"),
                  Text(
                    visible=have_winSen,
                    extent={{-98,-80},{-56,-98}},
                    lineColor={255,0,255},
                    pattern=LinePattern.Dash,
                    textString="uWinSta"),
                  Text(
                    extent={{34,80},{98,64}},
                    lineColor={0,0,127},
                    pattern=LinePattern.Dash,
                    textString="TZonCooSet"),
                  Text(
                    extent={{34,10},{98,-6}},
                    lineColor={0,0,127},
                    pattern=LinePattern.Dash,
                    textString="TZonHeaSet"),
                  Text(
                    extent={{36,-60},{100,-76}},
                    lineColor={255,127,0},
                    pattern=LinePattern.Dash,
                    textString="yOpeMod")}),
          Documentation(info="<html>
<p>
Block that outputs the zone setpoint temperature (<code>TZonCooSet</code>, <code>TZonHeaSet</code>)
and system operation mode (<code>yOpeMod</code>). When operation mode is in freeze
protection setback mode, it also outputs a level 3 freeze protection alarm
<code>yFreProSta</code>. The sequences are implemented according to ASHRAE
Guideline 36, Part 5.B.3 and 5.C.6.
</p>
<p>The sequence consists of the following two subsequences.</p>
<h4>Operation mode selector</h4>
<p>
The subsequence outputs one of seven types of system operation mode (occupied, warmup,
cool-down, setback, freeze protection setback, setup, unoccupied) according
to current time, the time to next occupied hours <code>tNexOcc</code> and
current zone temperature <code>TZon</code>.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.OperationMode\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic.SetPoints.OperationMode</a>.
</p>
<h4>Zone setpoint temperature reset</h4>
<p>
This sequence is implemented according to Part 5.B.3. It sets the zone temperature setpoint
according to the globally specified setpoints, the local setpoint adjustments, the demand
limits adjustment, the window status and the occupancy status.
See
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.SetPoints.ZoneTemperatures\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.SetPoints.ZoneTemperatures</a>.
</p>
<h4>Usage</h4>
<p>
This version is for a single zone only to be used in the Single Zone VAV sequence.
For multizone systems, use
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 11, 2020, by Jianjun Hu:<br/>
Reimplemented to avoid vector-valued calculations.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1709\">issue 1709</a>.
</li>
<li>
October 24, 2018, by David Blum:<br/>
First implementation.
</li>
</ul>
</html>"));
          end ModeAndSetPoints;

          package Reheat "Sequences for VAV reheat terminal unit"

            block DamperValves
              "Output signals for controlling VAV reheat box damper and valve position"

              parameter Real dTDisZonSetMax(
                final unit="K",
                final displayUnit="K",
                final quantity="TemperatureDifference")=11
                "Zone maximum discharge air temperature above heating setpoint";
              parameter Real TDisMin(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")=283.15
                "Lowest discharge air temperature";

              parameter
                hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController controllerTypeVal=
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                "Type of controller" annotation (Dialog(group="Valve"));

              parameter Real kVal(final unit="1/K")=0.5
                "Gain of controller for valve control"
                annotation(Dialog(group="Valve"));

              parameter Real TiVal(
                final unit="s",
                final quantity="Time")=300
                "Time constant of integrator block for valve control"
                annotation(Dialog(group="Valve",
                enable=controllerTypeVal == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                       or controllerTypeVal == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

              parameter Real TdVal(
                final unit="s",
                final quantity="Time")=0.1
                "Time constant of derivative block for valve control"
                annotation (Dialog(group="Valve",
                  enable=controllerTypeVal == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                       or controllerTypeVal == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

              parameter Boolean have_pressureIndependentDamper = true
                "True: the VAV damper is pressure independent (with built-in flow controller)"
                annotation(Dialog(group="Damper"));

              parameter
                hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController controllerTypeDam=
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                "Type of controller" annotation (Dialog(group="Damper"));

              parameter Real kDam(final unit="1")=0.5
                "Gain of controller for damper control"
                annotation(Dialog(group="Damper"));

              parameter Real TiDam(
                final unit="s",
                final quantity="Time")=300
                "Time constant of integrator block for damper control"
                annotation(Dialog(group="Damper",
                enable=controllerTypeDam == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                       or controllerTypeDam == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

              parameter Real TdDam(
                final unit="s",
                final quantity="Time")=0.1
                "Time constant of derivative block for damper control"
                annotation (Dialog(group="Damper",
                  enable=controllerTypeDam == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                       or controllerTypeDam == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID));

              parameter Real V_flow_nominal(
                final unit="m3/s",
                final quantity="VolumeFlowRate",
                final min=1E-10)
                "Nominal volume flow rate, used to normalize control error"
                annotation(Dialog(group="Damper"));

              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uHea(
                final min=0,
                final max=1,
                final unit="1") "Heating control signal" annotation (Placement(
                    transformation(extent={{-360,-160},{-320,-120}}),
                    iconTransformation(extent={{-140,-40},{-100,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uCoo(
                final min=0,
                final max=1,
                final unit="1") "Cooling control signal" annotation (Placement(
                    transformation(extent={{-360,260},{-320,300}}),
                    iconTransformation(extent={{-140,80},{-100,120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VActCooMax_flow(
                final min=0,
                final unit="m3/s",
                final quantity="VolumeFlowRate")
                "Active cooling maximum airflow rate" annotation (Placement(
                    transformation(extent={{-360,180},{-320,220}}),
                    iconTransformation(extent={{-140,40},{-100,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VActCooMin_flow(
                final min=0,
                final unit="m3/s",
                final quantity="VolumeFlowRate")
                "Active cooling minimum airflow rate" annotation (Placement(
                    transformation(extent={{-360,220},{-320,260}}),
                    iconTransformation(extent={{-140,60},{-100,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VActMin_flow(
                final min=0,
                final unit="m3/s",
                final quantity="VolumeFlowRate") "Active minimum airflow rate"
                annotation (Placement(transformation(extent={{-360,50},{-320,90}}),
                    iconTransformation(extent={{-140,20},{-100,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VActHeaMin_flow(
                final min=0,
                final unit="m3/s",
                final quantity="VolumeFlowRate")
                "Active heating minimum airflow rate" annotation (Placement(
                    transformation(extent={{-360,-300},{-320,-260}}),
                    iconTransformation(extent={{-140,-80},{-100,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VActHeaMax_flow(
                final min=0,
                final unit="m3/s",
                final quantity="VolumeFlowRate")
                "Active heating maximum airflow rate" annotation (Placement(
                    transformation(extent={{-360,-330},{-320,-290}}),
                    iconTransformation(extent={{-140,-100},{-100,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VDis_flow(
                final min=0,
                final unit="m3/s",
                final quantity="VolumeFlowRate") if not
                have_pressureIndependentDamper
                "Measured discharge airflow rate airflow rate" annotation (
                  Placement(transformation(extent={{-360,320},{-320,360}}),
                    iconTransformation(
                    extent={{-20,-20},{20,20}},
                    rotation=90,
                    origin={40,-120})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSup(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Supply air temperature from central air handler" annotation (
                  Placement(transformation(extent={{-360,-50},{-320,-10}}),
                    iconTransformation(extent={{-140,0},{-100,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput THeaSet(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Zone heating setpoint temperature" annotation (Placement(
                    transformation(extent={{-360,-80},{-320,-40}}),
                    iconTransformation(extent={{-140,-20},{-100,20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZon(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Measured zone temperature" annotation (Placement(
                    transformation(extent={{-360,-270},{-320,-230}}),
                    iconTransformation(extent={{-140,-60},{-100,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TDis(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Measured discharge air temperature" annotation (Placement(
                    transformation(extent={{-360,110},{-320,150}}),
                    iconTransformation(
                    extent={{-20,-20},{20,20}},
                    rotation=90,
                    origin={-40,-120})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uOpeMod
                "Zone operation mode" annotation (Placement(transformation(
                      extent={{-360,-370},{-320,-330}}), iconTransformation(
                      extent={{-140,-120},{-100,-80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yDam(
                final min=0,
                final max=1,
                final unit="1") "Signal for VAV damper" annotation (Placement(
                    transformation(extent={{320,20},{360,60}}),
                    iconTransformation(extent={{100,20},{140,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput yHeaVal(
                final min=0,
                final max=1,
                final unit="1") "Reheater valve position" annotation (Placement(
                    transformation(extent={{320,-40},{360,0}}),
                    iconTransformation(extent={{100,-60},{140,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VDisSet_flow(
                final min=0,
                final unit="m3/s",
                final quantity="VolumeFlowRate") "Discharge airflow setpoint"
                annotation (Placement(transformation(extent={{320,240},{360,280}}),
                    iconTransformation(extent={{100,60},{140,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TDisHeaSet(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Discharge airflow setpoint temperature for heating"
                annotation (Placement(transformation(extent={{320,-160},{360,-120}}),
                    iconTransformation(extent={{100,-100},{140,-60}})));

              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                "Logical not" annotation (Placement(transformation(extent={{-220,
                        40},{-200,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not2
                "Logical not" annotation (Placement(transformation(extent={{-220,
                        0},{-200,20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not4
                "Logical not" annotation (Placement(transformation(extent={{-202,
                        120},{-182,140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2
                "Check if current zone state is deadband" annotation (Placement(
                    transformation(extent={{-80,40},{-60,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and4
                "Logical and" annotation (Placement(transformation(extent={{-60,
                        200},{-40,220}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line lin
                "Active airflow setpoint for cooling" annotation (Placement(
                    transformation(extent={{-160,270},{-140,290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line conTDisHeaSet
                "Discharge air temperature for heating" annotation (Placement(
                    transformation(extent={{-120,-82},{-100,-62}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line lin3
                "Active airflow setpoint for heating" annotation (Placement(
                    transformation(extent={{-80,-310},{-60,-290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conVal(
                final controllerType=controllerTypeVal,
                final k=kVal,
                final Ti=TiVal,
                final Td=TdVal,
                final yMax=1,
                final yMin=0,
                u_s(final unit="K", displayUnit="degC"),
                u_m(final unit="K", displayUnit="degC"),
                reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter)
                "Hot water valve controller" annotation (Placement(
                    transformation(extent={{34,-90},{54,-70}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conDam(
                final controllerType=controllerTypeDam,
                final k=kDam,
                final Ti=TiDam,
                final Td=TdDam,
                final yMax=1,
                final yMin=0,
                final reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter,

                final y_reset=0) if not have_pressureIndependentDamper
                "Damper position controller" annotation (Placement(
                    transformation(extent={{280,220},{300,240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                "Output active cooling airflow according to cooling control signal"
                annotation (Placement(transformation(extent={{140,260},{160,280}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                "Output active airflow when it is in deadband state"
                annotation (Placement(transformation(extent={{132,40},{152,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi2
                "Acitive heating airflow rate" annotation (Placement(
                    transformation(extent={{80,-260},{100,-240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi4
                "Output active heating airflow according to heating control signal"
                annotation (Placement(transformation(extent={{140,-260},{160,-240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi5
                "Output active cooling airflow " annotation (Placement(
                    transformation(extent={{60,200},{80,220}})));

            protected
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                conZer(final k=0) "Constant zero" annotation (Placement(
                    transformation(extent={{-280,300},{-260,320}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                conZer1(final k=0) "Constant zero" annotation (Placement(
                    transformation(extent={{100,240},{120,260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                conZer2(final k=0) "Constant zero" annotation (Placement(
                    transformation(extent={{-80,-2},{-60,18}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                conZer3(final k=0) "Constant zero" annotation (Placement(
                    transformation(extent={{-260,-110},{-240,-90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                conZer6(final k=0) "Constant zero" annotation (Placement(
                    transformation(extent={{80,-310},{100,-290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                conOne(final k=1) "Constant one" annotation (Placement(
                    transformation(extent={{-220,300},{-200,320}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                conOne2(final k=1) "Constant real value" annotation (Placement(
                    transformation(extent={{-180,-340},{-160,-320}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                conHal(final k=0.5) "Constant real value" annotation (Placement(
                    transformation(extent={{-200,-110},{-180,-90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                conHal1(final k=0.5) "Constant real value" annotation (
                  Placement(transformation(extent={{-260,-340},{-240,-320}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar(final p=
                    dTDisZonSetMax, final k=1)
                "Maximum heating discharge temperature" annotation (Placement(
                    transformation(extent={{-260,-70},{-240,-50}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar1(final k=1,
                  final p=2.8) "Zone temperature pluTZonSets 2.8 degC"
                annotation (Placement(transformation(extent={{-260,-260},{-240,
                        -240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys2(final
                  uHigh=0.05, final uLow=0.01)
                "Check if cooling control signal is greater than zero"
                annotation (Placement(transformation(extent={{-280,220},{-260,
                        240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys3(final
                  uHigh=0.05, final uLow=0.01)
                "Check if heating control signal is greater than 0" annotation
                (Placement(transformation(extent={{-260,-220},{-240,-200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys4(final
                  uLow=TDisMin - 0.1, final uHigh=TDisMin + 0.1)
                "Check if discharge air temperature is greater than lowest discharge air temperature"
                annotation (Placement(transformation(extent={{-240,120},{-220,
                        140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys6(final
                  uLow=-0.1, final uHigh=0.1)
                "Check if supply air temperature is greater than room temperature"
                annotation (Placement(transformation(extent={{-120,190},{-100,
                        210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys7(final
                  uLow=-0.1, final uHigh=0.1)
                "Check if discharge air temperature is greater than room temperature plus 2.8 degC"
                annotation (Placement(transformation(extent={{-80,-260},{-60,-240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(final k2=
                    -1)
                "Calculate temperature difference between discharge air and room plus 2.8 degC"
                annotation (Placement(transformation(extent={{-120,-260},{-100,
                        -240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2(final k2=
                    -1)
                "Calculate temperature difference between AHU supply air and room "
                annotation (Placement(transformation(extent={{-160,190},{-140,
                        210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueHoldWithReset truHol2(duration=
                    600) "Check if the true input holds for certain time"
                annotation (Placement(transformation(extent={{-222,-220},{-202,
                        -200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay truDel3(delayTime
                  =600) "Check if the true input holds for certain time"
                annotation (Placement(transformation(extent={{-160,120},{-140,
                        140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay truDel4(delayTime
                  =600) "Check if the true input holds for certain time"
                annotation (Placement(transformation(extent={{-240,220},{-220,
                        240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal isUno
                "Output true if the operation mode is unoccupied" annotation (
                  Placement(transformation(extent={{220,-322},{240,-302}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant unOcc(final k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.unoccupied)
                "Constant signal for unoccupied mode" annotation (Placement(
                    transformation(extent={{170,-322},{190,-302}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch watValPosUno
                "Output hot water valve position" annotation (Placement(
                    transformation(extent={{280,-30},{300,-10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch damPosUno
                "Output damper position" annotation (Placement(transformation(
                      extent={{280,60},{300,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not5
                "Negation of input signal" annotation (Placement(transformation(
                      extent={{200,-260},{220,-240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                lowDisAirTem(final k=TDisMin)
                "Lowest allowed discharge air temperature" annotation (
                  Placement(transformation(extent={{-68,-108},{-48,-88}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi6
                "Output hot water valve position in case of low discharge air temperature"
                annotation (Placement(transformation(extent={{-30,-90},{-10,-70}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or2
                "Logical not" annotation (Placement(transformation(extent={{-68,
                        -64},{-48,-44}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not3
                "Logical not" annotation (Placement(transformation(extent={{-120,
                        120},{-100,140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi3
                "Output hot water valve position in case of low discharge air temperature"
                annotation (Placement(transformation(extent={{104,-82},{124,-62}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not6
                "Negation of input signal" annotation (Placement(transformation(
                      extent={{-40,-192},{-20,-172}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1
                "Check if it is not in heating mode and the discharge temperature is not too low"
                annotation (Placement(transformation(extent={{20,-56},{40,-36}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add3
                "Active airflow setpoint" annotation (Placement(transformation(
                      extent={{200,250},{220,270}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add4
                "Active airflow set point" annotation (Placement(transformation(
                      extent={{180,40},{200,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division VDis_flowNor if not
                have_pressureIndependentDamper
                "Normalized discharge volume flow rate" annotation (Placement(
                    transformation(extent={{240,150},{260,170}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                nomFlow(final k=V_flow_nominal) "Nominal volume flow rate"
                annotation (Placement(transformation(extent={{200,200},{220,220}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division VDisSet_flowNor
                "Normalized setpoint for discharge volume flow rate"
                annotation (Placement(transformation(extent={{240,220},{260,240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai(final k=1)
                if have_pressureIndependentDamper
                "Block that can be disabled so remove the connection"
                annotation (Placement(transformation(extent={{220,120},{240,140}})));

            equation
              connect(uCoo, lin.u)
                annotation (Line(points={{-340,280},{-162,280}}, color={0,0,127}));
              connect(conZer.y, lin.x1)
                annotation (Line(points={{-258,310},{-240,310},{-240,288},{-162,288}},
                  color={0,0,127}));
              connect(VActCooMin_flow, lin.f1)
                annotation (Line(points={{-340,240},{-300,240},{-300,284},{-162,284}},
                  color={0,0,127}));
              connect(conOne.y, lin.x2)
                annotation (Line(points={{-198,310},{-180,310},{-180,276},{-162,276}},
                  color={0,0,127}));
              connect(VActCooMax_flow, lin.f2)
                annotation (Line(points={{-340,200},{-180,200},{-180,272},{-162,272}},
                  color={0,0,127}));
              connect(uCoo, hys2.u)
                annotation (Line(points={{-340,280},{-290,280},{-290,230},{-282,230}},
                  color={0,0,127}));
              connect(conZer1.y, swi.u3)
                annotation (Line(points={{122,250},{130,250},{130,262},{138,262}},
                  color={0,0,127}));
              connect(VActMin_flow, swi1.u1)
                annotation (Line(points={{-340,70},{30,70},{30,58},{130,58}},
                  color={0,0,127}));
              connect(and2.y, swi1.u2)
                annotation (Line(points={{-58,50},{130,50}}, color={255,0,255}));
              connect(conZer2.y, swi1.u3)
                annotation (Line(points={{-58,8},{-20,8},{-20,42},{130,42}},
                  color={0,0,127}));
              connect(uHea, hys3.u)
                annotation (Line(points={{-340,-140},{-280,-140},{-280,-210},{-262,-210}},
                  color={0,0,127}));
              connect(conZer3.y, conTDisHeaSet.x1)
                annotation (Line(points={{-238,-100},{-220,-100},{-220,-64},{-122,-64}},
                  color={0,0,127}));
              connect(TSup, conTDisHeaSet.f1)
                annotation (Line(points={{-340,-30},{-160,-30},{-160,-68},{-122,-68}},
                  color={0,0,127}));
              connect(uHea, conTDisHeaSet.u)
                annotation (Line(points={{-340,-140},{-140,-140},{-140,-72},{-122,-72}},
                  color={0,0,127}));
              connect(conHal.y, conTDisHeaSet.x2)
                annotation (Line(points={{-178,-100},{-160,-100},{-160,-76},{-122,-76}},
                  color={0,0,127}));
              connect(addPar.y, conTDisHeaSet.f2)
                annotation (Line(points={{-238,-60},{-136,-60},{-136,-80},{-122,-80}},
                  color={0,0,127}));
              connect(THeaSet, addPar.u)
                annotation (Line(points={{-340,-60},{-262,-60}}, color={0,0,127}));
              connect(uHea, lin3.u)
                annotation (Line(points={{-340,-140},{-280,-140},{-280,-300},{-82,-300}},
                  color={0,0,127}));
              connect(conHal1.y, lin3.x1)
                annotation (Line(points={{-238,-330},{-200,-330},{-200,-292},{-82,-292}},
                  color={0,0,127}));
              connect(conOne2.y, lin3.x2)
                annotation (Line(points={{-158,-330},{-140,-330},{-140,-304},{-82,-304}},
                  color={0,0,127}));
              connect(VActHeaMax_flow, lin3.f2)
                annotation (Line(points={{-340,-310},{-120,-310},{-120,-308},{-82,-308}},
                  color={0,0,127}));
              connect(VActHeaMin_flow, lin3.f1)
                annotation (Line(points={{-340,-280},{-120,-280},{-120,-296},{-82,-296}},
                  color={0,0,127}));
              connect(TZon, addPar1.u)
                annotation (Line(points={{-340,-250},{-262,-250}}, color={0,0,127}));
              connect(lin3.y, swi2.u1)
                annotation (Line(points={{-58,-300},{40,-300},{40,-242},{78,-242}},
                  color={0,0,127}));
              connect(VActHeaMin_flow, swi2.u3)
                annotation (Line(points={{-340,-280},{60,-280},{60,-258},{78,-258}},
                  color={0,0,127}));
              connect(TDis, hys4.u)
                annotation (Line(points={{-340,130},{-242,130}},
                  color={0,0,127}));
              connect(swi2.y, swi4.u1)
                annotation (Line(points={{102,-250},{112,-250},{112,-242},{138,-242}},
                  color={0,0,127}));
              connect(conZer6.y, swi4.u3)
                annotation (Line(points={{102,-300},{120,-300},{120,-258},{138,-258}},
                  color={0,0,127}));
              connect(VActMin_flow, swi5.u1)
                annotation (Line(points={{-340,70},{30,70},{30,218},{58,218}},
                  color={0,0,127}));
              connect(and4.y, swi5.u2)
                annotation (Line(points={{-38,210},{58,210}},color={255,0,255}));
              connect(lin.y, swi5.u3)
                annotation (Line(points={{-138,280},{40,280},{40,202},{58,202}},
                  color={0,0,127}));
              connect(swi5.y, swi.u1)
                annotation (Line(points={{82,210},{94,210},{94,278},{138,278}},
                  color={0,0,127}));
              connect(hys4.y, not4.u)
                annotation (Line(points={{-218,130},{-204,130}}, color={255,0,255}));
              connect(TSup, add2.u1)
                annotation (Line(points={{-340,-30},{-300,-30},{-300,180},{-176,180},{-176,206},
                      {-162,206}},        color={0,0,127}));
              connect(TZon, add2.u2)
                annotation (Line(points={{-340,-250},{-296,-250},{-296,176},{-172,176},{-172,
                      194},{-162,194}},   color={0,0,127}));
              connect(add2.y, hys6.u)
                annotation (Line(points={{-138,200},{-122,200}}, color={0,0,127}));
              connect(hys6.y, and4.u2)
                annotation (Line(points={{-98,200},{-80,200},{-80,202},{-62,202}},
                  color={255,0,255}));
              connect(conTDisHeaSet.y, add1.u1)
                annotation (Line(points={{-98,-72},{-80,-72},{-80,-220},{-140,-220},{-140,-244},
                      {-122,-244}},          color={0,0,127}));
              connect(addPar1.y, add1.u2)
                annotation (Line(points={{-238,-250},{-140,-250},{-140,-256},{-122,-256}},
                  color={0,0,127}));
              connect(add1.y, hys7.u)
                annotation (Line(points={{-98,-250},{-82,-250}},
                  color={0,0,127}));
              connect(conTDisHeaSet.y, TDisHeaSet)
                annotation (Line(points={{-98,-72},{-80,-72},{-80,-140},{340,-140}},
                  color={0,0,127}));
              connect(hys3.y, truHol2.u)
                annotation (Line(points={{-238,-210},{-224,-210}}, color={255,0,255}));
              connect(truHol2.y, swi4.u2)
                annotation (Line(points={{-200,-210},{120,-210},{120,-250},{138,-250}},
                  color={255,0,255}));
              connect(hys2.y, truDel4.u)
                annotation (Line(points={{-258,230},{-242,230}}, color={255,0,255}));
              connect(truDel4.y, and4.u1)
                annotation (Line(points={{-218,230},{-80,230},{-80,210},{-62,210}},
                  color={255,0,255}));
              connect(truDel4.y, swi.u2)
                annotation (Line(points={{-218,230},{-20,230},{-20,270},{138,270}},
                  color={255,0,255}));
              connect(truHol2.y, not2.u)
                annotation (Line(points={{-200,-210},{-180,-210},{-180,-128},{-280,-128},{-280,
                      10},{-222,10}}, color={255,0,255}));
              connect(truDel4.y, not1.u)
                annotation (Line(points={{-218,230},{-200,230},{-200,184},{-304,184},{-304,50},
                      {-222,50}}, color={255,0,255}));
              connect(not1.y, and2.u1)
                annotation (Line(points={{-198,50},{-82,50}}, color={255,0,255}));
              connect(not2.y, and2.u2)
                annotation (Line(points={{-198,10},{-180,10},{-180,42},{-82,42}},
                  color={255,0,255}));
              connect(conVal.u_m, TDis) annotation (Line(points={{44,-92},{44,-124},{-308,-124},
                      {-308,130},{-340,130}}, color={0,0,127}));
              connect(hys7.y, swi2.u2)
                annotation (Line(points={{-58,-250},{78,-250}}, color={255,0,255}));
              connect(unOcc.y, isUno.u1)
                annotation (Line(points={{192,-312},{218,-312}}, color={255,127,0}));
              connect(isUno.u2, uOpeMod) annotation (Line(points={{218,-320},{200,-320},{200,
                      -350},{-340,-350}}, color={255,127,0}));
              connect(isUno.y, watValPosUno.u2) annotation (Line(points={{242,-312},{266,-312},
                      {266,-20},{278,-20}}, color={255,0,255}));
              connect(conZer2.y, watValPosUno.u1) annotation (Line(points={{-58,8},{-20,8},{
                      -20,-12},{278,-12}},  color={0,0,127}));
              connect(watValPosUno.y, yHeaVal)
                annotation (Line(points={{302,-20},{340,-20}}, color={0,0,127}));
              connect(conZer2.y, damPosUno.u1) annotation (Line(points={{-58,8},{-20,8},{-20,
                      -12},{250,-12},{250,78},{278,78}}, color={0,0,127}));
              connect(conDam.y, damPosUno.u3) annotation (Line(points={{302,230},{310,230},{
                      310,100},{272,100},{272,62},{278,62}}, color={0,0,127}));
              connect(damPosUno.y, yDam) annotation (Line(points={{302,70},{308,70},{308,40},
                      {340,40}}, color={0,0,127}));
              connect(isUno.y, damPosUno.u2) annotation (Line(points={{242,-312},{266,-312},
                      {266,70},{278,70}}, color={255,0,255}));
              connect(isUno.y, not5.u) annotation (Line(points={{242,-312},{266,-312},{266,-280},
                      {180,-280},{180,-250},{198,-250}}, color={255,0,255}));
              connect(not5.y, conDam.trigger) annotation (Line(points={{222,-250},{232,-250},
                      {232,170},{284,170},{284,178}}, color={255,0,255}));
              connect(truHol2.y, or2.u2) annotation (Line(points={{-200,-210},{-88,-210},{-88,
                      -62},{-70,-62}},     color={255,0,255}));
              connect(truDel3.y, not3.u)
                annotation (Line(points={{-138,130},{-122,130}}, color={255,0,255}));
              connect(not3.y, or2.u1) annotation (Line(points={{-98,130},{-88,130},{-88,-54},
                      {-70,-54}}, color={255,0,255}));
              connect(or2.y, swi6.u2) annotation (Line(points={{-46,-54},{-40,-54},{-40,-80},
                      {-32,-80}}, color={255,0,255}));
              connect(conTDisHeaSet.y, swi6.u1)
                annotation (Line(points={{-98,-72},{-32,-72}}, color={0,0,127}));
              connect(swi6.u3, lowDisAirTem.y) annotation (Line(points={{-32,-88},{-40,-88},
                      {-40,-98},{-46,-98}}, color={0,0,127}));
              connect(swi3.y, watValPosUno.u3) annotation (Line(points={{126,-72},{200,-72},
                      {200,-28},{278,-28}}, color={0,0,127}));
              connect(truHol2.y, not6.u) annotation (Line(points={{-200,-210},{-60,-210},{-60,
                      -182},{-42,-182}}, color={255,0,255}));
              connect(not6.y, and1.u2) annotation (Line(points={{-18,-182},{0,-182},{0,-54},
                      {18,-54}},color={255,0,255}));
              connect(and1.y, swi3.u2) annotation (Line(points={{42,-46},{64,-46},{64,-72},{
                      102,-72}}, color={255,0,255}));
              connect(conVal.y, swi3.u3)
                annotation (Line(points={{56,-80},{102,-80}},   color={0,0,127}));
              connect(swi3.u1, conZer2.y) annotation (Line(points={{102,-64},{76,-64},{76,-12},
                      {-20,-12},{-20,8},{-58,8}}, color={0,0,127}));
              connect(not3.y, and1.u1) annotation (Line(points={{-98,130},{0,130},{0,-46},{18,
                      -46}}, color={255,0,255}));
              connect(not4.y, truDel3.u)
                annotation (Line(points={{-180,130},{-162,130}}, color={255,0,255}));
              connect(not5.y, conVal.trigger) annotation (Line(points={{222,-250},{232,-250},
                      {232,-132},{38,-132},{38,-92}},  color={255,0,255}));
              connect(swi6.y, conVal.u_s)
                annotation (Line(points={{-8,-80},{32,-80}},   color={0,0,127}));
              connect(swi1.y, add4.u1) annotation (Line(points={{154,50},{168,50},{168,56},{
                      178,56}}, color={0,0,127}));
              connect(swi4.y, add4.u2) annotation (Line(points={{162,-250},{170,-250},{170,44},
                      {178,44}}, color={0,0,127}));
              connect(swi.y, add3.u1) annotation (Line(points={{162,270},{180,270},{180,266},
                      {198,266}}, color={0,0,127}));
              connect(add4.y, add3.u2) annotation (Line(points={{202,50},{220,50},{220,80},{
                      180,80},{180,254},{198,254}}, color={0,0,127}));
              connect(add3.y, VDisSet_flow)
                annotation (Line(points={{222,260},{340,260}}, color={0,0,127}));
              connect(VDis_flow, VDis_flowNor.u1) annotation (Line(points={{-340,340},{190,340},
                      {190,166},{238,166}}, color={0,0,127}));
              connect(nomFlow.y, VDis_flowNor.u2) annotation (Line(points={{222,210},{230,210},
                      {230,154},{238,154}}, color={0,0,127}));
              connect(VDis_flowNor.y, conDam.u_m)
                annotation (Line(points={{262,160},{290,160},{290,218}}, color={0,0,127}));
              connect(nomFlow.y, VDisSet_flowNor.u2) annotation (Line(points={{222,210},{230,
                      210},{230,224},{238,224}},                     color={0,0,127}));
              connect(add3.y, VDisSet_flowNor.u1) annotation (Line(points={{222,260},{230,260},
                      {230,236},{238,236}}, color={0,0,127}));
              connect(VDisSet_flowNor.y, conDam.u_s)
                annotation (Line(points={{262,230},{278,230}}, color={0,0,127}));
              connect(VDisSet_flowNor.y, gai.u) annotation (Line(points={{262,230},{270,230},
                      {270,180},{210,180},{210,130},{218,130}}, color={0,0,127}));
              connect(gai.y, damPosUno.u3) annotation (Line(points={{242,130},{272,130},{272,
                      62},{278,62}}, color={0,0,127}));

            annotation (
              defaultComponentName="damVal",
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-320,-360},{320,360}}),
                    graphics={
                    Rectangle(
                      extent={{-298,318},{158,182}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-298,-22},{158,-118}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-298,158},{158,102}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-298,72},{158,-4}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-298,-162},{158,-338}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Text(
                      extent={{-40,318},{154,280}},
                      lineColor={0,0,127},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Right,
                      textString="Active airflow setpoint
in cooling state"), Text(
                      extent={{32,136},{216,104}},
                      lineColor={0,0,127},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Left,
                      textString="Override if TDis is lower than TDisMin
(e.g., AHU overcools)"),
                    Text(
                      extent={{-52,42},{154,0}},
                      lineColor={0,0,127},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Right,
                      textString="Active airflow setpoint
in deadband state"),Text(
                      extent={{88,-26},{150,-44}},
                      lineColor={0,0,127},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Right,
                      textString="Valve control"),
                    Text(
                      extent={{-44,-164},{154,-200}},
                      lineColor={0,0,127},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Right,
                      textString="Active airflow setpoint
in heating state")}),
              Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                   graphics={
                    Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-100,140},{100,100}},
                      lineColor={0,0,255},
                      textString="%name"),
                    Text(
                      extent={{-98,68},{-62,54}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="VActCooMax_flow"),
                    Text(
                      extent={{-98,88},{-62,74}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="VActCooMin_flow"),
                    Text(
                      extent={{-98,-76},{-60,-90}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="VActHeaMax_flow"),
                    Text(
                      extent={{-98,-54},{-62,-66}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="VActHeaMin_flow"),
                    Text(
                      extent={{-98,44},{-70,38}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="VActMin_flow"),
                    Text(
                      extent={{-100,102},{-80,96}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uCoo"),
                    Text(
                      extent={{-100,-18},{-80,-24}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uHea"),
                    Text(
                      extent={{-100,2},{-76,-4}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="THeaSet"),
                    Text(
                      extent={{-100,24},{-80,16}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TSup"),
                    Text(
                      extent={{-11.5,3.5},{11.5,-3.5}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TDis",
                      origin={-41.5,-89.5},
                      rotation=90),
                    Text(
                      extent={{-100,-36},{-80,-42}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZon"),
                    Text(
                      visible=not have_pressureIndependentDamper,
                      extent={{-11.5,4.5},{11.5,-4.5}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      origin={39.5,-85.5},
                      rotation=90,
                      textString="VDis_flow"),
                    Text(
                      extent={{72,44},{98,34}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="yDam",
                      horizontalAlignment=TextAlignment.Right),
                    Text(
                      extent={{66,-34},{98,-48}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      horizontalAlignment=TextAlignment.Right,
                      textString="yHeaVal"),
                    Line(points={{-50,64},{-50,-48},{62,-48}}, color={95,95,95}),
                    Line(
                      points={{-50,14},{-26,-18},{-2,-18},{-2,-22},{14,-22},{14,-16},{62,48}},
                      color={0,0,255},
                      thickness=0.5),
                    Line(
                      points={{-2,-22},{-2,-48}},
                      color={215,215,215},
                      pattern=LinePattern.Dash),
                    Line(
                      points={{-26,-18},{-26,36}},
                      color={215,215,215},
                      pattern=LinePattern.Dash),
                    Line(
                      points={{-26,36},{-50,36}},
                      color={95,95,95},
                      thickness=0.5),
                    Line(
                      points={{-26,36},{-2,-48}},
                      color={95,95,95},
                      thickness=0.5),
                Polygon(
                  points={{-64,-58},{-42,-52},{-42,-64},{-64,-58}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Line(points={{-2,-58},{-60,-58}}, color={95,95,95}),
                Line(points={{16,-58},{78,-58}},  color={95,95,95}),
                Polygon(
                  points={{80,-58},{58,-52},{58,-64},{80,-58}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                    Text(
                      extent={{60,88},{98,76}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      horizontalAlignment=TextAlignment.Right,
                      textString="VDisSet_flow"),
                    Text(
                      extent={{60,-74},{98,-86}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      horizontalAlignment=TextAlignment.Right,
                      textString="TDisHeaSet"),
                    Text(
                      extent={{-98,-96},{-78,-102}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uOpeMod")}),
              Documentation(info="<html>
<p>
This sequence sets the damper and valve position for VAV reheat terminal unit.
The implementation is according to ASHRAE Guideline 36 (G36), PART 5.E.6. The
calculation is done following the steps below.
</p>
<ol>
<li>
<p>
When the zone state is cooling (<code>uCoo>0</code>), then the cooling loop output
<code>uCoo</code> shall be mapped to the airflow
setpoint from the cooling minimum <code>VActCooMin_flow</code> to the cooling maximum
<code>VActCooMax_flow</code> airflow setpoints. The hot water valve is closed (<code>yHeaVal=0</code>)
unless the discharge air temperature <code>TDis</code> is below the minimum
setpoint (10 &deg;C).</p>
</li>
<li>
<p>If supply air temperature <code>TSup</code> from the AHU is greater than
room temperature <code>TZon</code>, cooling supply airflow setpoint shall be
no higher than the minimum.
</p>
</li>
<li>
<p>
When the zone state is Deadband (<code>uCoo=0</code> and <code>uHea=0</code>), then
the active airflow setpoint shall be the minimum airflow setpoint <code>VActMin_flow</code>.
Hot water valve is closed unless the discharge air temperature is below the minimum
setpoint (10 &deg;C).
</p>
</li>
<li>
<p>
When the zone state is Heating (<code>uHea>0</code>), then
the heating loop shall maintain space temperature at the heating setpoint
as follows:</p>
<ul>
<li>From 0-50%, the heating loop output <code>uHea</code> shall reset the
discharge temperature setpoint from current AHU SAT setpoint <code>TSup</code>
to a maximum of <code>dTDisZonSetMax</code> above space temperature setpoint. The airflow
setpoint shall be the heating minimum <code>VActHeaMin_flow</code>.</li>
<li>From 50-100%, if the discharge air temperature <code>TDis</code> is
greater than room temperature plus 2.8 Kelvin, the heating loop output <code>uHea</code>
shall reset the airflow setpoint from the heating minimum airflow setpoint
<code>VActHeaMin_flow</code> to the heating maximum airflow setpoint
<code>VActHeaMax_flow</code>.</li>
</ul>
</li>
<li>
<p>The hot water valve (or modulating electric heating coil) shall be modulated
to maintain the discharge temperature at setpoint.
</p>
</li>
<li>
<p>
The VAV damper shall be modulated by a control loop to maintain the measured
airflow at the active setpoint.
</p>
</li>
</ol>

<p>The sequences of controlling damper and valve position for VAV reheat terminal
unit are described in the following figure below.</p>
<p align=\"center\">
<img alt=\"Image of damper and valve control for VAV reheat terminal unit\"
src=\"modelica://Buildings/Resources/Images/Controls/OBC/ASHRAE/G36_PR1/TerminalUnits/Reheat/DamperValves.png\"/>
</p>
</html>",             revisions="<html>
<ul>
<li>
April 18, 2020, by Jianjun Hu:<br/>
Added option to check if the VAV damper is pressure independent.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1873\">#1873</a>.
</li>
<li>
March 11, 2020, by Jianjun Hu:<br/>
Replaced multisum block with add blocks, replaced gain block used for normalization
with division block.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1830\">#1830</a>.
</li>
<li>
September 10, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
            end DamperValves;

            block SystemRequests
              "Output system requests for VAV reheat terminal unit control"

              parameter Real samplePeriod(
                final unit="s",
                final quantity="Time")=120
                "Sample period of component, set to the same value as the trim and respond that process yPreSetReq";

              parameter Boolean have_heaWatCoi
                "Flag, true if there is a hot water coil";
              parameter Boolean have_heaPla "Flag, true if there is a boiler plant";

              parameter Real errTZonCoo_1(
                final unit="K",
                final displayUnit="K",
                final quantity="TemperatureDifference")=2.8
                "Limit value of difference between zone temperature and cooling setpoint
    for generating 3 cooling SAT reset requests";
              parameter Real errTZonCoo_2(
                final unit="K",
                final displayUnit="K",
                final quantity="TemperatureDifference")=1.7
                "Limit value of difference between zone temperature and cooling setpoint
    for generating 2 cooling SAT reset requests";
              parameter Real errTDis_1(
                final unit="K",
                final displayUnit="K",
                final quantity="TemperatureDifference")=17
                "Limit value of difference between discharge air temperature and its setpoint
    for generating 3 hot water reset requests";
              parameter Real errTDis_2(
                final unit="K",
                final displayUnit="K",
                final quantity="TemperatureDifference")=8.3
                "Limit value of difference between discharge air temperature and its setpoint
    for generating 2 hot water reset requests";

              parameter Real durTimTem(
                final unit="s",
                final quantity="Time")=120
                "Duration time of zone temperature exceeds setpoint"
                annotation(Dialog(group="Duration times"));
              parameter Real durTimFlo(
                final unit="s",
                final quantity="Time")=60
                "Duration time of airflow rate less than setpoint"
                annotation(Dialog(group="Duration times"));
              parameter Real durTimDisAir(
                final unit="s",
                final quantity="Time")=300
                "Duration time of discharge air temperature is less than setpoint"
                annotation(Dialog(group="Duration times"));

              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZon(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature") "Zone temperature" annotation (
                  Placement(transformation(extent={{-220,150},{-180,190}}),
                    iconTransformation(extent={{-140,40},{-100,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonCooSet(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Zone cooling setpoint temperature" annotation (Placement(transformation(
                      extent={{-220,420},{-180,460}}), iconTransformation(extent={{-140,60},
                        {-100,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uCoo(
                final min=0,
                final max=1,
                final unit="1") "Cooling loop signal" annotation (Placement(transformation(
                      extent={{-220,70},{-180,110}}), iconTransformation(extent={{-140,20},{
                        -100,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VDis_flow(
                final min=0,
                final unit="m3/s",
                final quantity="VolumeFlowRate") "Measured discharge airflow rate"
                annotation (Placement(transformation(extent={{-220,-90},{-180,-50}}),
                    iconTransformation(extent={{-140,-20},{-100,20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput VDisSet_flow(
                final min=0,
                final unit="m3/s",
                quantity="VolumeFlowRate") "Discharge airflow rate setpoint" annotation (
                  Placement(transformation(extent={{-220,10},{-180,50}}),
                    iconTransformation(extent={{-140,0},{-100,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput yDam_actual(
                final min=0,
                final max=1,
                final unit="1") "Actual damper position" annotation (Placement(
                    transformation(extent={{-220,-170},{-180,-130}}), iconTransformation(
                      extent={{-140,-40},{-100,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TDisHeaSet(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature") if have_heaWatCoi
                "Discharge airflow setpoint temperature for heating" annotation (Placement(
                    transformation(extent={{-220,-230},{-180,-190}}), iconTransformation(
                      extent={{-140,-60},{-100,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TDis(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature") if have_heaWatCoi
                "Measured discharge airflow temperature" annotation (Placement(
                    transformation(extent={{-220,-310},{-180,-270}}), iconTransformation(
                      extent={{-140,-80},{-100,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput uHeaVal(
                final min=0,
                final max=1,
                final unit="1") if have_heaWatCoi "Heating valve position" annotation (
                  Placement(transformation(extent={{-220,-370},{-180,-330}}),
                    iconTransformation(extent={{-140,-100},{-100,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput yZonPreResReq
                "Zone static pressure reset requests" annotation (Placement(transformation(
                      extent={{180,-60},{220,-20}}), iconTransformation(extent={{100,0},{140,
                        40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput yZonTemResReq
                "Zone cooling supply air temperature reset request" annotation (Placement(
                    transformation(extent={{180,180},{220,220}}), iconTransformation(extent=
                       {{100,50},{140,90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput yHeaValResReq if
                have_heaWatCoi "Hot water reset requests" annotation (Placement(
                    transformation(extent={{180,-260},{220,-220}}), iconTransformation(
                      extent={{100,-60},{140,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput yHeaPlaReq if (
                have_heaWatCoi and have_heaPla) "Heating plant request" annotation (
                  Placement(transformation(extent={{180,-450},{220,-410}}),
                    iconTransformation(extent={{100,-110},{140,-70}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys(final uLow=
                    errTZonCoo_1 - 0.1, final uHigh=errTZonCoo_1 + 0.1)
                "Check if zone temperature is greater than cooling setpoint by errTZonCoo_1"
                annotation (Placement(transformation(extent={{-60,190},{-40,210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys3(final uLow=
                    errTZonCoo_2 - 0.1, final uHigh=errTZonCoo_2 + 0.1)
                "Check if zone temperature is greater than cooling setpoint by errTZonCoo_2"
                annotation (Placement(transformation(extent={{-60,130},{-40,150}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys4(final uLow=0.85,
                  final uHigh=0.95) "Check if damper position is greater than 0.95"
                annotation (Placement(transformation(extent={{-60,-160},{-40,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys5(final uLow=0.85,
                  final uHigh=0.95) "Check if cooling loop signal is greater than 0.95"
                annotation (Placement(transformation(extent={{-60,80},{-40,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys7(final uHigh=
                   0.01, final uLow=0.005)
                "Check if discharge airflow setpoint is greater than 0"
                annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys8(final uLow=-0.1,
                  final uHigh=0.1) if have_heaWatCoi
                "Check if discharge air temperature is errTDis_1 less than setpoint"
                annotation (Placement(transformation(extent={{-40,-250},{-20,-230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys9(final uLow=-0.1,
                  final uHigh=0.1) if have_heaWatCoi
                "Check if discharge air temperature is errTDis_2 less than setpoint"
                annotation (Placement(transformation(extent={{-40,-310},{-20,-290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys10(final uLow=
                   0.85, final uHigh=0.95) if have_heaWatCoi
                "Check if valve position is greater than 0.95"
                annotation (Placement(transformation(extent={{-140,-360},{-120,-340}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys11(final
                  uHigh=0.95, final uLow=0.1) if (have_heaWatCoi and have_heaPla)
                "Check if valve position is greater than 0.95"
                annotation (Placement(transformation(extent={{-140,-440},{-120,-420}})));

            protected
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.Sampler samTZonCooSet(final
                  samplePeriod=samplePeriod) "Sample current cooling setpoint"
                annotation (Placement(transformation(extent={{-160,430},{-140,450}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.UnitDelay uniDel(final
                  samplePeriod=samplePeriod) "Delay value to record input value"
                annotation (Placement(transformation(extent={{-80,450},{-60,470}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs
                "Absolute change of the setpoint temperature"
                annotation (Placement(transformation(extent={{100,400},{120,420}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triSam
                "Sample the setpoint changed value when there is change"
                annotation (Placement(transformation(extent={{-120,270},{-100,290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Edge edg
                "Instants when input becomes true"
                annotation (Placement(transformation(extent={{-60,290},{-40,310}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch lat
                "Maintains an on signal until conditions changes"
                annotation (Placement(transformation(extent={{-60,330},{-40,350}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch lat1
                "Maintains an on signal until conditions changes"
                annotation (Placement(transformation(extent={{60,260},{80,280}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Timer tim "Calculate time"
                annotation (Placement(transformation(extent={{0,330},{20,350}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual gre
                "Check if the suppression time has passed"
                annotation (Placement(transformation(extent={{60,330},{80,350}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual gre1
                "Check if current model time is greater than the sample period"
                annotation (Placement(transformation(extent={{-80,400},{-60,420}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys2(final uLow=0.05,
                  final uHigh=0.15) "Check if there is setpoint change"
                annotation (Placement(transformation(extent={{-120,330},{-100,350}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min supTim
                "Suppression time"
                annotation (Placement(transformation(extent={{0,270},{20,290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.ModelTime modTim
                "Time of the model"
                annotation (Placement(transformation(extent={{-140,400},{-120,420}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai(final k=540)
                "Convert change of degC to change of degF and find out suppression time (5 min/degF))"
                annotation (Placement(transformation(extent={{-80,270},{-60,290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai1(final k=0)
                "50% of setpoint"
                annotation (Placement(transformation(extent={{-100,-50},{-80,-30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai2(final k=0)
                "70% of setpoint"
                annotation (Placement(transformation(extent={{-100,-98},{-80,-78}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(final k1=-1)
                "Calculate difference of previous and current setpoints"
                annotation (Placement(transformation(extent={{-20,430},{0,450}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2(final k1=-1)
                "Calculate difference between zone temperature and cooling setpoint"
                annotation (Placement(transformation(extent={{-100,190},{-80,210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add3(final k1=-1)
                "Calculate difference between zone temperature and cooling setpoint"
                annotation (Placement(transformation(extent={{-100,130},{-80,150}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add6(final k2=-1) if
                have_heaWatCoi
                "Calculate difference of discharge temperature (plus errTDis_1) and its setpoint"
                annotation (Placement(transformation(extent={{-80,-250},{-60,-230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add7(final k2=-1) if
                have_heaWatCoi
                "Calculate difference of discharge temperature (plus errTDis_2) and its setpoint"
                annotation (Placement(transformation(extent={{-80,-310},{-60,-290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar(final k=1,
                  final p=errTDis_1) if have_heaWatCoi
                "Discharge temperature plus errTDis_1"
                annotation (Placement(transformation(extent={{-140,-272},{-120,-252}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar1(final k=1,
                  final p=errTDis_2) if have_heaWatCoi
                "Discharge temperature plus errTDis_2"
                annotation (Placement(transformation(extent={{-140,-330},{-120,-310}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
                "Convert real to integer value"
                annotation (Placement(transformation(extent={{140,190},{160,210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
                "Convert real to integer value"
                annotation (Placement(transformation(extent={{140,-50},{160,-30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt2 if
                have_heaWatCoi "Convert real to integer value"
                annotation (Placement(transformation(extent={{140,-250},{160,-230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt3 if (
                have_heaWatCoi and have_heaPla) "Convert real to integer value"
                annotation (Placement(transformation(extent={{140,-440},{160,-420}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1 "Logical and"
                annotation (Placement(transformation(extent={{40,130},{60,150}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2 "Logical and"
                annotation (Placement(transformation(extent={{40,190},{60,210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and3 "Logical and"
                annotation (Placement(transformation(extent={{40,-50},{60,-30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and4 "Logical and"
                annotation (Placement(transformation(extent={{40,-110},{60,-90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant con(final k=
                    samplePeriod) "Sample period time"
                annotation (Placement(transformation(extent={{-140,370},{-120,390}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant conZer(final k=0)
                "Constant zero"
                annotation (Placement(transformation(extent={{-20,370},{0,390}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant thrCooResReq(final k=3)
                "Constant 3"
                annotation (Placement(transformation(extent={{40,220},{60,240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant twoCooResReq(final k=2)
                "Constant 2"
                annotation (Placement(transformation(extent={{40,160},{60,180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant oneCooResReq(final k=1)
                "Constant 1"
                annotation (Placement(transformation(extent={{40,100},{60,120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant zerCooReq(final k=0)
                "Constant 0"
                annotation (Placement(transformation(extent={{40,60},{60,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant thrPreResReq(final k=3)
                "Constant 3"
                annotation (Placement(transformation(extent={{40,-20},{60,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant twoPreResReq(final k=2)
                "Constant 2"
                annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant zerPreResReq(final k=0)
                "Constant 0"
                annotation (Placement(transformation(extent={{40,-180},{60,-160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant onePreResReq(final k=1)
                "Constant 1"
                annotation (Placement(transformation(extent={{40,-140},{60,-120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant thrHeaResReq(final k=3) if
                   have_heaWatCoi "Constant 3"
                annotation (Placement(transformation(extent={{40,-220},{60,-200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant twoHeaResReq(final k=2) if
                   have_heaWatCoi "Constant 2"
                annotation (Placement(transformation(extent={{40,-280},{60,-260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant oneHeaResReq(final k=1) if
                   have_heaWatCoi "Constant 1"
                annotation (Placement(transformation(extent={{40,-340},{60,-320}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant zerHeaResReq(final k=0) if
                   have_heaWatCoi "Constant 0"
                annotation (Placement(transformation(extent={{40,-380},{60,-360}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant zerBoiPlaReq(final k=0) if
                   (have_heaWatCoi and have_heaPla) "Constant 0"
                annotation (Placement(transformation(extent={{40,-460},{60,-440}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant oneBoiPlaReq(final k=1) if
                   (have_heaWatCoi and have_heaPla) "Constant 1"
                annotation (Placement(transformation(extent={{40,-420},{60,-400}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant maxSupTim(k=1800)
                "Maximum suppression time 30 minutes"
                annotation (Placement(transformation(extent={{-80,240},{-60,260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant con5(k=true)
                "Constant true"
                annotation (Placement(transformation(extent={{60,290},{80,310}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                "Use setpoint different value when half sample period time has passed"
                annotation (Placement(transformation(extent={{40,400},{60,420}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                "Output 3 or other request "
                annotation (Placement(transformation(extent={{100,190},{120,210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi2
                "Output 2 or other request "
                annotation (Placement(transformation(extent={{100,130},{120,150}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi3
                "Output 0 or 1 request "
                annotation (Placement(transformation(extent={{100,80},{120,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi4
                "Output 3 or other request "
                annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi5
                "Output 2 or other request "
                annotation (Placement(transformation(extent={{100,-110},{120,-90}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi6
                "Output 0 or 1 request "
                annotation (Placement(transformation(extent={{100,-160},{120,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi7 if have_heaWatCoi
                "Output 3 or other request "
                annotation (Placement(transformation(extent={{100,-250},{120,-230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi8 if have_heaWatCoi
                "Output 2 or other request "
                annotation (Placement(transformation(extent={{100,-310},{120,-290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi9 if have_heaWatCoi
                "Output 0 or 1 request "
                annotation (Placement(transformation(extent={{100,-360},{120,-340}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi10 if (
                have_heaWatCoi and have_heaPla) "Output 0 or 1 request "
                annotation (Placement(transformation(extent={{100,-440},{120,-420}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueHoldWithReset truHol(duration=
                    samplePeriod) "Hold true signal for sample period of time"
                annotation (Placement(transformation(extent={{120,330},{140,350}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.LogicalSwitch logSwi
                "Logical switch"
                annotation (Placement(transformation(extent={{120,300},{140,280}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay tim1(delayTime=
                    durTimTem) "Check if it is more than durTimTem"
                annotation (Placement(transformation(extent={{-20,190},{0,210}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay tim2(delayTime=
                    durTimTem) "Check if it is more than durTimTem"
                annotation (Placement(transformation(extent={{-20,130},{0,150}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay tim3(delayTime=
                    durTimFlo) "Check if it is more than durTimFlo"
                annotation (Placement(transformation(extent={{-20,20},{0,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay tim4(delayTime=
                    durTimDisAir) if have_heaWatCoi "Check if it is more than durTimDisAir"
                annotation (Placement(transformation(extent={{0,-250},{20,-230}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay tim5(delayTime=
                    durTimDisAir) if have_heaWatCoi "Check if it is more than durTimDisAir"
                annotation (Placement(transformation(extent={{0,-310},{20,-290}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.Sampler sampler(final
                  samplePeriod=samplePeriod)
                "Sample input signal, as the output signal will go to the trim and respond which also samples at samplePeriod"
                annotation (Placement(transformation(extent={{-160,-50},{-140,-30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.Sampler sampler1(final
                  samplePeriod=samplePeriod)
                "Sample input signal, as the output signal will go to the trim and respond which also samples at samplePeriod"
                annotation (Placement(transformation(extent={{-160,-80},{-140,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.Sampler sampler2(final
                  samplePeriod=samplePeriod)
                "Sample input signal, as the output signal will go to the trim and respond which also samples at samplePeriod"
                annotation (Placement(transformation(extent={{-160,-160},{-140,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.Sampler sampler4(final
                  samplePeriod=samplePeriod)
                "Sample input signal, as the output signal will go to the trim and respond which also samples at samplePeriod"
                annotation (Placement(transformation(extent={{-160,80},{-140,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual greEqu
                "Check if discharge airflow is less than 50% of setpoint"
                annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual greEqu1
                "Check if discharge airflow is less than 70% of setpoint"
                annotation (Placement(transformation(extent={{-60,-110},{-40,-90}})));

            equation
              connect(add2.y, hys.u)
                annotation (Line(points={{-78,200},{-62,200}},   color={0,0,127}));
              connect(TZonCooSet, samTZonCooSet.u)
                annotation (Line(points={{-200,440},{-162,440}}, color={0,0,127}));
              connect(samTZonCooSet.y, uniDel.u)
                annotation (Line(points={{-138,440},{-100,440},{-100,460},{-82,460}},
                  color={0,0,127}));
              connect(triSam.y, gai.u)
                annotation (Line(points={{-98,280},{-82,280}},color={0,0,127}));
              connect(hys2.y, lat.u)
                annotation (Line(points={{-98,340},{-62,340}}, color={255,0,255}));
              connect(lat.y, tim.u)
                annotation (Line(points={{-38,340},{-2,340}}, color={255,0,255}));
              connect(tim.y, gre.u1)
                annotation (Line(points={{22,340},{58,340}}, color={0,0,127}));
              connect(edg.y, triSam.trigger)
                annotation (Line(points={{-38,300},{-20,300},{-20,264},{-110,264},{-110,268.2}},
                  color={255,0,255}));
              connect(lat.y, edg.u)
                annotation (Line(points={{-38,340},{-20,340},{-20,318},{-80,318},{-80,300},{
                      -62,300}},
                  color={255,0,255}));
              connect(edg.y, lat1.clr)
                annotation (Line(points={{-38,300},{-20,300},{-20,264},{58,264}}, color={255,0,255}));
              connect(modTim.y, gre1.u1)
                annotation (Line(points={{-118,410},{-82,410}},  color={0,0,127}));
              connect(con.y, gre1.u2)
                annotation (Line(points={{-118,380},{-100,380},{-100,402},{-82,402}},
                  color={0,0,127}));
              connect(uniDel.y, add1.u1)
                annotation (Line(points={{-58,460},{-40,460},{-40,446},{-22,446}},
                  color={0,0,127}));
              connect(samTZonCooSet.y, add1.u2)
                annotation (Line(points={{-138,440},{-40,440},{-40,434},{-22,434}},
                  color={0,0,127}));
              connect(gre1.y, swi.u2)
                annotation (Line(points={{-58,410},{38,410}}, color={255,0,255}));
              connect(add1.y, swi.u1)
                annotation (Line(points={{2,440},{20,440},{20,418},{38,418}},
                  color={0,0,127}));
              connect(conZer.y, swi.u3)
                annotation (Line(points={{2,380},{20,380},{20,402},{38,402}}, color={0,0,127}));
              connect(swi.y, abs.u)
                annotation (Line(points={{62,410},{98,410}},
                  color={0,0,127}));
              connect(abs.y, triSam.u)
                annotation (Line(points={{122,410},{140,410},{140,360},{-140,360},{-140,280},
                      {-122,280}}, color={0,0,127}));
              connect(abs.y, hys2.u)
                annotation (Line(points={{122,410},{140,410},{140,360},{-140,360},{-140,340},
                      {-122,340}}, color={0,0,127}));
              connect(and2.y, swi1.u2)
                annotation (Line(points={{62,200},{98,200}}, color={255,0,255}));
              connect(thrCooResReq.y, swi1.u1)
                annotation (Line(points={{62,230},{80,230},{80,208},{98,208}}, color={0,0,127}));
              connect(add3.y, hys3.u)
                annotation (Line(points={{-78,140},{-62,140}}, color={0,0,127}));
              connect(twoCooResReq.y, swi2.u1)
                annotation (Line(points={{62,170},{80,170},{80,148},{98,148}},
                  color={0,0,127}));
              connect(swi2.y, swi1.u3)
                annotation (Line(points={{122,140},{140,140},{140,180},{80,180},{80,192},{98,
                      192}}, color={0,0,127}));
              connect(and1.y, swi2.u2)
                annotation (Line(points={{62,140},{98,140}}, color={255,0,255}));
              connect(hys5.y, swi3.u2)
                annotation (Line(points={{-38,90},{98,90}}, color={255,0,255}));
              connect(oneCooResReq.y, swi3.u1)
                annotation (Line(points={{62,110},{80,110},{80,98},{98,98}},
                  color={0,0,127}));
              connect(swi3.y, swi2.u3)
                annotation (Line(points={{122,90},{140,90},{140,120},{80,120},{80,132},{98,132}},
                             color={0,0,127}));
              connect(zerCooReq.y, swi3.u3)
                annotation (Line(points={{62,70},{80,70},{80,82},{98,82}},
                  color={0,0,127}));
              connect(swi1.y, reaToInt.u)
                annotation (Line(points={{122,200},{138,200}}, color={0,0,127}));
              connect(reaToInt.y, yZonTemResReq)
                annotation (Line(points={{162,200},{200,200}}, color={255,127,0}));
              connect(and3.y, swi4.u2)
                annotation (Line(points={{62,-40},{98,-40}}, color={255,0,255}));
              connect(thrPreResReq.y, swi4.u1)
                annotation (Line(points={{62,-10},{80,-10},{80,-32},{98,-32}},
                  color={0,0,127}));
              connect(and4.y, swi5.u2)
                annotation (Line(points={{62,-100},{98,-100}}, color={255,0,255}));
              connect(twoPreResReq.y, swi5.u1)
                annotation (Line(points={{62,-70},{80,-70},{80,-92},{98,-92}},
                  color={0,0,127}));
              connect(swi5.y, swi4.u3)
                annotation (Line(points={{122,-100},{122,-70},{88,-70},{88,-48},
                      {98,-48}},
                             color={0,0,127}));
              connect(hys4.y, swi6.u2)
                annotation (Line(points={{-38,-150},{98,-150}},  color={255,0,255}));
              connect(onePreResReq.y, swi6.u1)
                annotation (Line(points={{62,-130},{80,-130},{80,-142},{98,-142}},
                  color={0,0,127}));
              connect(zerPreResReq.y, swi6.u3)
                annotation (Line(points={{62,-170},{80,-170},{80,-158},{98,-158}},
                  color={0,0,127}));
              connect(reaToInt1.y, yZonPreResReq)
                annotation (Line(points={{162,-40},{200,-40}}, color={255,127,0}));
              connect(TDis, addPar.u)
                annotation (Line(points={{-200,-290},{-160,-290},{-160,-262},{-142,-262}},
                  color={0,0,127}));
              connect(addPar.y, add6.u2)
                annotation (Line(points={{-118,-262},{-108,-262},{-108,-246},{-82,-246}},
                  color={0,0,127}));
              connect(TDisHeaSet, add6.u1)
                annotation (Line(points={{-200,-210},{-100,-210},{-100,-234},{-82,-234}},
                  color={0,0,127}));
              connect(add6.y, hys8.u)
                annotation (Line(points={{-58,-240},{-42,-240}}, color={0,0,127}));
              connect(addPar1.y, add7.u2)
                annotation (Line(points={{-118,-320},{-108,-320},{-108,-306},{-82,-306}},
                  color={0,0,127}));
              connect(add7.y, hys9.u)
                annotation (Line(points={{-58,-300},{-42,-300}}, color={0,0,127}));
              connect(hys9.y, tim5.u)
                annotation (Line(points={{-18,-300},{-2,-300}}, color={255,0,255}));
              connect(thrHeaResReq.y, swi7.u1)
                annotation (Line(points={{62,-210},{80,-210},{80,-232},{98,-232}},
                  color={0,0,127}));
              connect(twoHeaResReq.y, swi8.u1)
                annotation (Line(points={{62,-270},{80,-270},{80,-292},{98,-292}},
                  color={0,0,127}));
              connect(swi8.y, swi7.u3)
                annotation (Line(points={{122,-300},{140,-300},{140,-260},{80,-260},{80,-248},
                      {98,-248}},
                              color={0,0,127}));
              connect(TDis, addPar1.u)
                annotation (Line(points={{-200,-290},{-160,-290},{-160,-320},{-142,-320}},
                  color={0,0,127}));
              connect(TDisHeaSet, add7.u1)
                annotation (Line(points={{-200,-210},{-100,-210},{-100,-294},{-82,-294}},
                  color={0,0,127}));
              connect(uHeaVal, hys10.u)
                annotation (Line(points={{-200,-350},{-142,-350}}, color={0,0,127}));
              connect(hys10.y, swi9.u2)
                annotation (Line(points={{-118,-350},{98,-350}}, color={255,0,255}));
              connect(oneHeaResReq.y, swi9.u1)
                annotation (Line(points={{62,-330},{80,-330},{80,-342},{98,-342}},
                  color={0,0,127}));
              connect(zerHeaResReq.y, swi9.u3)
                annotation (Line(points={{62,-370},{80,-370},{80,-358},{98,-358}},
                  color={0,0,127}));
              connect(swi9.y, swi8.u3)
                annotation (Line(points={{122,-350},{140,-350},{140,-320},{80,-320},{80,-308},
                      {98,-308}},
                              color={0,0,127}));
              connect(swi7.y, reaToInt2.u)
                annotation (Line(points={{122,-240},{138,-240}}, color={0,0,127}));
              connect(reaToInt2.y, yHeaValResReq)
                annotation (Line(points={{162,-240},{200,-240}}, color={255,127,0}));
              connect(uHeaVal, hys11.u)
                annotation (Line(points={{-200,-350},{-160,-350},{-160,-430},{-142,-430}},
                  color={0,0,127}));
              connect(hys11.y, swi10.u2)
                annotation (Line(points={{-118,-430},{98,-430}}, color={255,0,255}));
              connect(oneBoiPlaReq.y, swi10.u1)
                annotation (Line(points={{62,-410},{80,-410},{80,-422},{98,-422}},
                  color={0,0,127}));
              connect(zerBoiPlaReq.y, swi10.u3)
                annotation (Line(points={{62,-450},{80,-450},{80,-438},{98,-438}},
                  color={0,0,127}));
              connect(swi10.y, reaToInt3.u)
                annotation (Line(points={{122,-430},{138,-430}}, color={0,0,127}));
              connect(reaToInt3.y,yHeaPlaReq)
                annotation (Line(points={{162,-430},{200,-430}}, color={255,127,0}));
              connect(gre.y, truHol.u)
                annotation (Line(points={{82,340},{118,340}}, color={255,0,255}));
              connect(truHol.y, lat.clr)
                annotation (Line(points={{142,340},{160,340},{160,320},{-80,320},{-80,334},{
                      -62,334}},        color={255,0,255}));
              connect(gre.y, lat1.u)
                annotation (Line(points={{82,340},{100,340},{100,322},{44,322},{44,270},{58,
                      270}},
                  color={255,0,255}));
              connect(lat.y, logSwi.u2)
                annotation (Line(points={{-38,340},{-20,340},{-20,318},{100,318},{100,290},{
                      118,290}},
                              color={255,0,255}));
              connect(con5.y, logSwi.u3)
                annotation (Line(points={{82,300},{104,300},{104,298},{118,298}},
                  color={255,0,255}));
              connect(lat1.y, logSwi.u1)
                annotation (Line(points={{82,270},{100,270},{100,282},{118,282}},
                  color={255,0,255}));
              connect(logSwi.y, and2.u1)
                annotation (Line(points={{142,290},{160,290},{160,258},{20,258},{20,200},{38,
                      200}}, color={255,0,255}));
              connect(logSwi.y, and1.u1)
                annotation (Line(points={{142,290},{160,290},{160,258},{20,258},{20,140},{38,
                      140}}, color={255,0,255}));
              connect(gai.y, supTim.u1)
                annotation (Line(points={{-58,280},{-40,280},{-40,286},{-2,286}},
                  color={0,0,127}));
              connect(maxSupTim.y, supTim.u2)
                annotation (Line(points={{-58,250},{-40,250},{-40,274},{-2,274}},
                  color={0,0,127}));
              connect(supTim.y, gre.u2)
                annotation (Line(points={{22,280},{40,280},{40,332},{58,332}}, color={0,0,127}));
              connect(tim5.y, swi8.u2)
                annotation (Line(points={{22,-300},{98,-300}}, color={255,0,255}));
              connect(hys8.y, tim4.u)
                annotation (Line(points={{-18,-240},{-2,-240}}, color={255,0,255}));
              connect(tim4.y, swi7.u2)
                annotation (Line(points={{22,-240},{98,-240}}, color={255,0,255}));
              connect(hys7.y, tim3.u)
                annotation (Line(points={{-38,30},{-22,30}},  color={255,0,255}));
              connect(tim3.y, and3.u1)
                annotation (Line(points={{2,30},{20,30},{20,-40},{38,-40}},
                  color={255,0,255}));
              connect(tim3.y, and4.u1)
                annotation (Line(points={{2,30},{20,30},{20,-100},{38,-100}},
                  color={255,0,255}));
              connect(hys3.y, tim2.u)
                annotation (Line(points={{-38,140},{-22,140}}, color={255,0,255}));
              connect(tim2.y, and1.u2)
                annotation (Line(points={{2,140},{12,140},{12,132},{38,132}},
                  color={255,0,255}));
              connect(hys.y, tim1.u)
                annotation (Line(points={{-38,200},{-22,200}}, color={255,0,255}));
              connect(tim1.y, and2.u2)
                annotation (Line(points={{2,200},{10,200},{10,192},{38,192}},
                  color={255,0,255}));
              connect(sampler.u, VDisSet_flow)
                annotation (Line(points={{-162,-40},{-170,-40},{-170,30},{-200,30}},
                  color={0,0,127}));
              connect(sampler.y, gai1.u)
                annotation (Line(points={{-138,-40},{-102,-40}}, color={0,0,127}));
              connect(sampler.y, gai2.u)
                annotation (Line(points={{-138,-40},{-128,-40},{-128,-88},{-102,-88}},
                  color={0,0,127}));
              connect(sampler1.u, VDis_flow)
                annotation (Line(points={{-162,-70},{-200,-70}}, color={0,0,127}));
              connect(yDam_actual, sampler2.u)
                annotation (Line(points={{-200,-150},{-162,-150}}, color={0,0,127}));
              connect(sampler2.y, hys4.u)
                annotation (Line(points={{-138,-150},{-62,-150}},  color={0,0,127}));
              connect(uCoo, sampler4.u)
                annotation (Line(points={{-200,90},{-162,90}}, color={0,0,127}));
              connect(sampler4.y, hys5.u)
                annotation (Line(points={{-138,90},{-62,90}}, color={0,0,127}));
              connect(samTZonCooSet.y, add2.u1)
                annotation (Line(points={{-138,440},{-128,440},{-128,426},{-150,426},{-150,206},
                      {-102,206}},        color={0,0,127}));
              connect(samTZonCooSet.y, add3.u1)
                annotation (Line(points={{-138,440},{-128,440},{-128,426},{-150,426},{-150,206},
                      {-112,206},{-112,146},{-102,146}},        color={0,0,127}));
              connect(hys7.u, VDisSet_flow)
                annotation (Line(points={{-62,30},{-200,30}}, color={0,0,127}));
              connect(add2.u2, TZon)
                annotation (Line(points={{-102,194},{-150,194},{-150,170},{-200,170}},
                  color={0,0,127}));
              connect(add3.u2, TZon)
                annotation (Line(points={{-102,134},{-150,134},{-150,170},{-200,170}},
                  color={0,0,127}));
              connect(greEqu.u1, gai1.y)
                annotation (Line(points={{-62,-40},{-78,-40}}, color={0,0,127}));
              connect(greEqu.u2, sampler1.y)
                annotation (Line(points={{-62,-48},{-72,-48},{-72,-70},{-138,-70}},
                  color={0,0,127}));
              connect(greEqu.y, and3.u2)
                annotation (Line(points={{-38,-40},{0,-40},{0,-48},{38,-48}},
                  color={255,0,255}));
              connect(gai2.y, greEqu1.u1)
                annotation (Line(points={{-78,-88},{-76,-88},{-76,-100},{-62,-100}},
                  color={0,0,127}));
              connect(sampler1.y, greEqu1.u2)
                annotation (Line(points={{-138,-70},{-132,-70},{-132,-108},{-62,-108}},
                  color={0,0,127}));
              connect(greEqu1.y, and4.u2)
                annotation (Line(points={{-38,-100},{0,-100},{0,-108},{38,-108}},
                  color={255,0,255}));

              connect(reaToInt1.u, swi6.y) annotation (Line(points={{138,-40},{
                      136,-40},{136,-150},{122,-150}}, color={0,0,127}));
              connect(swi5.u3, swi4.y) annotation (Line(points={{98,-108},{92,
                      -108},{92,-60},{120,-60},{120,-48},{122,-48},{122,-40}},
                    color={0,0,127}));
            annotation (
              defaultComponentName="sysReqRehBox",
              Diagram(coordinateSystem(preserveAspectRatio=
                        false, extent={{-180,-460},{180,480}}),
                  graphics={
                    Rectangle(
                      extent={{-158,478},{158,262}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-158,238},{158,62}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-156,38},{160,-178}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-158,-202},{158,-378}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-158,-402},{158,-458}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Text(
                      extent={{18,480},{140,456}},
                      lineColor={0,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Time-based suppression"),
                    Text(
                      extent={{-150,82},{-28,58}},
                      lineColor={0,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Cooling SAT reset requests"),
                    Text(
                      extent={{-152,-156},{-8,-184}},
                      lineColor={0,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Static pressure reset requests"),
                    Text(
                      extent={{-152,-360},{-26,-380}},
                      lineColor={0,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Hot water reset requests"),
                    Text(
                      extent={{-150,-440},{-12,-462}},
                      lineColor={0,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="Boiler plant reset requests")}),
                 Icon(graphics={
                    Text(
                      extent={{-100,140},{100,100}},
                      lineColor={0,0,255},
                      textString="%name"),
                    Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-98,90},{-62,76}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonCooSet"),
                    Text(
                      extent={{-100,66},{-72,56}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZon"),
                    Text(
                      extent={{-100,46},{-72,36}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uCoo"),
                    Text(
                      extent={{-98,30},{-52,14}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="VDisSet_flow"),
                    Text(
                      extent={{-98,6},{-64,-4}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="VDis_flow"),
                    Text(
                      extent={{-98,-14},{-70,-24}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uDam"),
                    Text(
                      extent={{-98,-32},{-52,-48}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      visible = (have_heaWatCoi or have_heaPla),
                      textString="TDisHeaSet"),
                    Text(
                      extent={{-98,-56},{-64,-66}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      visible = (have_heaWatCoi or have_heaPla),
                      textString="TDis"),
                    Text(
                      extent={{-98,-76},{-64,-86}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      visible = (have_heaWatCoi or have_heaPla),
                      textString="uHeaVal"),
                    Text(
                      extent={{42,82},{98,62}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      horizontalAlignment=TextAlignment.Right,
                      textString="yZonTemResReq"),
                    Text(
                      extent={{42,32},{98,12}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      horizontalAlignment=TextAlignment.Right,
                      textString="yZonPreResReq"),
                    Text(
                      extent={{42,-28},{98,-48}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      horizontalAlignment=TextAlignment.Right,
                      visible = have_heaWatCoi,
                      textString="yHeaValResReq"),
                    Text(
                      extent={{58,-84},{98,-100}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      horizontalAlignment=TextAlignment.Right,
                      visible = (have_heaWatCoi or have_heaPla),
                      textString="yHeaPlaReq")}),
              Documentation(info="<html>
<p>
This sequence outputs the system reset requests, i.e.,
</p>
<ul>
<li>
the cooling supply air temperature
reset requests <code>yZonTemResReq</code>,
</li>
<li>
the static pressure reset requests
<code>yZonPreResReq</code>,
</li>
<li>
the hot water reset requests <code>yHeaValResReq</code>, and
</li>
<li>
the boiler plant reset requests <code>yHeaPlaReq</code>.
</li>
</ul>
<p>
The calculations are according to ASHRAE
Guideline 36 (G36), PART 5.E.9, in the steps shown below.
</p>
<h4>a. Cooling SAT reset requests <code>yZonTemResReq</code></h4>
<ol>
<li>
If the zone temperature <code>TZon</code> exceeds the zone cooling setpoint
<code>TZonCooSet</code> by 2.8 &deg;C (5 &deg;F)) for 2 minutes and after suppression
period due to setpoint change per G36 Part 5.A.20, send 3 requests
(<code>yZonTemResReq=3</code>).
</li>
<li>
Else if the zone temperature <code>TZon</code> exceeds the zone cooling setpoint
<code>TZonCooSet</code> by 1.7 &deg;C (3 &deg;F) for 2 minutes and after suppression
period due to setpoint change per G36 Part 5.A.20, send 2 requests
(<code>yZonTemResReq=3</code>).
</li>
<li>
Else if the cooling loop <code>uCoo</code> is greater than 95%, send 1 request
(<code>yZonTemResReq=1</code>) until <code>uCoo</code> is less than 85%.
</li>
<li>
Else if <code>uCoo</code> is less than 95%, send 0 request (<code>yZonTemResReq=0</code>).
</li>
</ol>
<h4>b. Static pressure reset requests <code>yZonPreResReq</code></h4>
<ol>
<li>
If the measured airflow <code>VDis_flow</code> is less than 50% of setpoint
<code>VDisSet_flow</code> while it is greater than zero for 1 minute, send 3 requests
(<code>yZonPreResReq=3</code>).
</li>
<li>
Else if the measured airflow <code>VDis_flow</code> is less than 70% of setpoint
<code>VDisSet_flow</code> while it is greater than zero for 1 minute, send 2 requests
(<code>yZonPreResReq=2</code>).
</li>
<li>
Else if the damper position <code>uDam</code> is greater than 95%, send 1 request
(<code>yZonPreResReq=1</code>) until <code>uDam</code> is less than 85%.
</li>
<li>
Else if <code>uDam</code> is less than 95%, send 0 request (<code>yZonPreResReq=0</code>).
</li>
</ol>
<h4>c. If there is a hot water coil (<code>have_heaWatCoi=true</code>),
hot water reset requests <code>yHeaValResReq</code></h4>
<ol>
<li>
If the discharge air temperature <code>TDis</code> is 17 &deg;C (30 &deg;F)
less than the setpoint <code>TDisHeaSet</code> for 5 minutes, send 3 requests
(<code>yHeaValResReq=3</code>).
</li>
<li>
Else if the discharge air temperature <code>TDis</code> is 8.3 &deg;C (15 &deg;F)
less than the setpoint <code>TDisHeaSet</code> for 5 minutes, send 2 requests
(<code>yHeaValResReq=2</code>).
</li>
<li>
Else if the hot water valve position <code>uHeaVal</code> is greater than 95%, send 1 request
(<code>yHeaValResReq=1</code>) until <code>uHeaVal</code> is less than 85%.
</li>
<li>
Else if <code>uHeaVal</code> is less than 95%, send 0 request (<code>yHeaValResReq=0</code>).
</li>
</ol>
<h4>d. If there is hot water coil (<code>have_heaWatCoi=true</code>) and a boiler plant
(<code>have_boiPla=true</code>), send the boiler plant that serves the zone a boiler
plant requests <code>yHeaPlaReq</code> as follows:</h4>
<ol>
<li>
If the hot water valve position <code>uHeaVal</code> is greater than 95%, send 1 request
(<code>yHeaPlaReq=1</code>) until <code>uHeaVal</code> is less than 10%.
</li>
<li>
Else if <code>uHeaVal</code> is less than 95%, send 0 request (<code>yHeaPlaReq=0</code>).
</li>
</ol>
<h4>Implementation</h4>
<p>
Some input signals are time sampled, because the output that is generated
from these inputs are used in the trim and respond logic, which
is also time sampled. However, signals that use a delay are not
sampled, as sampling were to change the dynamic response.
</p>
</html>",             revisions="<html>
<ul>
<li>
September 13, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
            end SystemRequests;

            package SetPoints "Output setpoints for terminal unit control"

              block ActiveAirFlow
                "Output the active airflow setpoint for VAV reheat terminal unit"

                parameter Boolean have_occSen
                  "Set to true if the zone has occupancy sensor"
                  annotation(Dialog(group="Zone sensors"));
                parameter Boolean have_winSen
                  "Set to true if the zone has window status sensor"
                  annotation(Dialog(group="Zone sensors"));
                parameter Boolean have_CO2Sen
                  "Set to true if the zone has CO2 sensor"
                  annotation(Dialog(group="Zone sensors"));
                parameter Real VDisCooSetMax_flow(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Zone maximum cooling airflow setpoint"
                  annotation(Dialog(group="Nominal condition"));
                parameter Real VDisSetMin_flow(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Zone minimum airflow setpoint"
                  annotation(Dialog(group="Nominal condition"));
                parameter Real VDisHeaSetMax_flow(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "Zone maximum heating airflow setpoint"
                  annotation(Dialog(group="Nominal condition"));
                parameter Real VDisConMin_flow(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")
                  "VAV box controllable minimum"
                  annotation(Dialog(group="Nominal condition"));
                parameter Real AFlo(
                  final unit="m2",
                  final quantity="Area") "Area of the zone"
                  annotation(Dialog(group="Nominal condition"));
                parameter Real VOutPerAre_flow(
                  final unit = "m3/(s.m2)")=3e-4
                  "Outdoor air rate per unit area"
                  annotation(Dialog(group="Nominal condition"));
                parameter Real VOutPerPer_flow(
                  final unit="m3/s",
                  final quantity="VolumeFlowRate")=2.5e-3
                  "Outdoor air rate per person"
                  annotation(Dialog(group="Nominal condition"));
                parameter Real CO2Set = 894 "CO2 setpoint in ppm"
                  annotation(Dialog(group="Nominal condition"));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput nOcc(final
                    unit="1") if have_occSen "Number of occupants" annotation (
                    Placement(transformation(extent={{-320,-300},{-280,-260}}),
                      iconTransformation(extent={{-140,-60},{-100,-20}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput ppmCO2 if
                  have_CO2Sen "Detected CO2 conventration" annotation (
                    Placement(transformation(extent={{-320,-200},{-280,-160}}),
                      iconTransformation(extent={{-140,20},{-100,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uWin if
                  have_winSen "Window status, true if open, false if closed"
                  annotation (Placement(transformation(extent={{-320,-520},{-280,
                          -480}}), iconTransformation(extent={{-140,-100},{-100,
                          -60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uOpeMod
                  "Zone operation mode" annotation (Placement(transformation(
                        extent={{-320,-130},{-280,-90}}), iconTransformation(
                        extent={{-140,60},{-100,100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VOccDisMin_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") "Occupied minimum airflow "
                  annotation (Placement(transformation(extent={{280,-310},{320,
                          -270}}), iconTransformation(extent={{100,-100},{140,-60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VActCooMax_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") "Active cooling maximum"
                  annotation (Placement(transformation(extent={{280,150},{320,
                          190}}), iconTransformation(extent={{100,60},{140,100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VActCooMin_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") "Active cooling minimum"
                  annotation (Placement(transformation(extent={{280,120},{320,
                          160}}), iconTransformation(extent={{100,30},{140,70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VActMin_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") "Active minimum" annotation
                  (Placement(transformation(extent={{280,90},{320,130}}),
                      iconTransformation(extent={{100,0},{140,40}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VActHeaMin_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") "Active heating minimum"
                  annotation (Placement(transformation(extent={{280,50},{320,90}}),
                      iconTransformation(extent={{100,-30},{140,10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput VActHeaMax_flow(
                  final min=0,
                  final unit="m3/s",
                  final quantity="VolumeFlowRate") "Active heating maximum"
                  annotation (Placement(transformation(extent={{280,10},{320,50}}),
                      iconTransformation(extent={{100,-60},{140,-20}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai(final k=
                      VOutPerPer_flow) if have_occSen "Outdoor air per person"
                  annotation (Placement(transformation(extent={{-140,-330},{-120,
                          -310}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add breZon if
                  have_occSen "Breathing zone airflow" annotation (Placement(
                      transformation(extent={{-80,-350},{-60,-330}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line co2ConLoo if
                  have_CO2Sen
                  "Maintain CO2 concentration at setpoint, reset 0% at (setpoint-200) and 100% at setpoint"
                  annotation (Placement(transformation(extent={{-140,-190},{-120,
                          -170}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line lin1 if
                  have_CO2Sen
                  "Reset occupied minimum airflow setpoint from 0% at VDisSetMin_flow and 100% at VDisCooSetMax_flow"
                  annotation (Placement(transformation(extent={{20,-130},{40,-110}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Greater gre
                  "Check if zone minimum airflow setpoint Vmin is less than the allowed controllable VDisConMin_flow"
                  annotation (Placement(transformation(extent={{-20,-460},{0,-440}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterThreshold
                  greThr1
                  "Check if zone minimum airflow setpoint VDisSetMin_flow is non-zero"
                  annotation (Placement(transformation(extent={{-80,-410},{-60,
                          -390}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                  "Reset occupied minimum airflow according to occupancy"
                  annotation (Placement(transformation(extent={{80,-290},{100,-270}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                  "Reset occupied minimum airflow according to window status"
                  annotation (Placement(transformation(extent={{200,-510},{220,
                          -490}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi2
                  "Reset occupied minimum airflow setpoint according to minimum controllable airflow"
                  annotation (Placement(transformation(extent={{140,-410},{160,
                          -390}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi3 if
                  have_CO2Sen
                  "Switch between zero signal and CO2 control loop signal depending on the operation mode"
                  annotation (Placement(transformation(extent={{-80,-100},{-60,
                          -120}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1
                  "Logical and" annotation (Placement(transformation(extent={{
                          40,-410},{60,-390}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                  "Logical not" annotation (Placement(transformation(extent={{
                          80,-410},{100,-390}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not2 if
                  have_winSen "Logical not" annotation (Placement(
                      transformation(extent={{-240,-510},{-220,-490}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys(final
                    uLow=0.25, final uHigh=0.75) if have_occSen
                  "Check if the zone becomes unpopulated" annotation (Placement(
                      transformation(extent={{-140,-290},{-120,-270}})));

              protected
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  minZonAir1(final k=VDisSetMin_flow) if not have_CO2Sen
                  "Zone minimum airflow setpoint" annotation (Placement(
                      transformation(extent={{20,-60},{40,-40}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  maxZonCooAir(final k=VDisCooSetMax_flow) if have_CO2Sen
                  "Zone maximum cooling airflow setpoint" annotation (Placement(
                      transformation(extent={{-80,-190},{-60,-170}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  breZonAre(final k=VOutPerAre_flow*AFlo) if have_occSen
                  "Area component of the breathing zone outdoor airflow"
                  annotation (Placement(transformation(extent={{-140,-370},{-120,
                          -350}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  conVolMin(final k=VDisConMin_flow)
                  "VAV box controllable minimum" annotation (Placement(
                      transformation(extent={{-80,-440},{-60,-420}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  minZonAir(final k=VDisSetMin_flow)
                  "Zone minimum airflow setpoint" annotation (Placement(
                      transformation(extent={{-240,-60},{-220,-40}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  setCO1(final k=CO2Set - 200) if have_CO2Sen
                  "CO2 setpoints minus 200" annotation (Placement(
                      transformation(extent={{-240,-140},{-220,-120}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  setCO2(final k=CO2Set) if have_CO2Sen "CO2 setpoints"
                  annotation (Placement(transformation(extent={{-240,-210},{-220,
                          -190}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  zerFlo(final k=0) "Zero airflow when window is open"
                  annotation (Placement(transformation(extent={{140,-540},{160,
                          -520}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                  con(final k=true) if not have_occSen "Constant true"
                  annotation (Placement(transformation(extent={{-80,-270},{-60,
                          -250}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant
                  con1(final k=true) if not have_winSen "Constant true"
                  annotation (Placement(transformation(extent={{40,-490},{60,-470}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  zerCon(final k=0) "Output zero" annotation (Placement(
                      transformation(extent={{-240,-170},{-220,-150}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  zerCon1(final k=0) if have_CO2Sen "Output zero" annotation (
                    Placement(transformation(extent={{-80,-90},{-60,-70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  zerCon2(final k=0) if have_CO2Sen "Output zero" annotation (
                    Placement(transformation(extent={{-140,-90},{-120,-70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  zerCon3(final k=0) if not have_occSen "Output zero"
                  annotation (Placement(transformation(extent={{0,-350},{20,-330}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  oneCon(final k=1) if have_CO2Sen "Output one" annotation (
                    Placement(transformation(extent={{-240,-240},{-220,-220}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  oneCon1(final k=1) if have_CO2Sen "Output one" annotation (
                    Placement(transformation(extent={{-80,-160},{-60,-140}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  cooMaxAir(final k=VDisCooSetMax_flow)
                  "Cooling maximum airflow" annotation (Placement(
                      transformation(extent={{-240,-20},{-220,0}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  heaMaxAir(final k=VDisHeaSetMax_flow) "Heat maximum airflow"
                  annotation (Placement(transformation(extent={{-180,-20},{-160,
                          0}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  zerCon6(final k=0) "Output zero" annotation (Placement(
                      transformation(extent={{-240,170},{-220,190}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  conInt(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                  "Occupied mode" annotation (Placement(transformation(extent={
                          {-240,-100},{-220,-80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  conInt1(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.coolDown)
                  "Cool down mode" annotation (Placement(transformation(extent=
                          {{-240,290},{-220,310}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  conInt2(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.setUp)
                  "Setup mode" annotation (Placement(transformation(extent={{-240,
                          220},{-220,240}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  conInt3(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                  "Warm up mode" annotation (Placement(transformation(extent={{
                          -20,290},{0,310}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  conInt4(final k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.setBack)
                  "Setback mode" annotation (Placement(transformation(extent={{
                          -20,220},{0,240}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu
                  "Check if current operation mode is occupied mode"
                  annotation (Placement(transformation(extent={{-140,-120},{-120,
                          -100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu1
                  "Check if current operation mode is cool-down mode"
                  annotation (Placement(transformation(extent={{-180,290},{-160,
                          310}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu2
                  "Check if current operation mode is setup mode" annotation (
                    Placement(transformation(extent={{-180,220},{-160,240}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu3
                  "Check if current operation mode is warmup mode" annotation (
                    Placement(transformation(extent={{40,290},{60,310}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu4
                  "Check if current operation mode is setback mode" annotation
                  (Placement(transformation(extent={{40,220},{60,240}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi4
                  "Select cooling maximum based on operation mode" annotation (
                    Placement(transformation(extent={{-100,290},{-80,310}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi8
                  "Select heating maximum based on operation mode" annotation (
                    Placement(transformation(extent={{-100,260},{-80,280}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi9
                  "Select cooling maximum based on operation mode" annotation (
                    Placement(transformation(extent={{-100,220},{-80,240}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi17
                  "Select heating minimum based on operation mode" annotation (
                    Placement(transformation(extent={{120,290},{140,310}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi18
                  "Select heating maximum based on operation mode" annotation (
                    Placement(transformation(extent={{120,260},{140,280}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi22
                  "Select heating minimum based on operation mode" annotation (
                    Placement(transformation(extent={{120,220},{140,240}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi23
                  "Select heating maximum based on operation mode" annotation (
                    Placement(transformation(extent={{120,190},{140,210}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi24
                  "Select cooling maximum based on operation mode" annotation (
                    Placement(transformation(extent={{-100,150},{-80,170}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi25
                  "Select cooling minimum based on operation mode" annotation (
                    Placement(transformation(extent={{-100,120},{-80,140}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi26
                  "Select minimum based on operation mode" annotation (
                    Placement(transformation(extent={{-100,90},{-80,110}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi27
                  "Select heating minimum based on operation mode" annotation (
                    Placement(transformation(extent={{-100,60},{-80,80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi28
                  "Select heating maximum based on operation mode" annotation (
                    Placement(transformation(extent={{-100,30},{-80,50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Max maxInp
                  "Find greater input" annotation (Placement(transformation(
                        extent={{-100,-20},{-80,0}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2
                  "Add real input" annotation (Placement(transformation(extent=
                          {{200,170},{220,190}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add actCooMaxAir
                  "Active cooling maximum airflow" annotation (Placement(
                      transformation(extent={{240,160},{260,180}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1
                  "Add real input" annotation (Placement(transformation(extent=
                          {{200,80},{220,100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add actHeaMinAir
                  "Active heating minimum airflow" annotation (Placement(
                      transformation(extent={{240,60},{260,80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add3
                  "Add real input" annotation (Placement(transformation(extent=
                          {{180,40},{200,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add actHeaMaxAir1
                  "Active heating maximum airflow" annotation (Placement(
                      transformation(extent={{240,20},{260,40}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add4
                  "Add real input" annotation (Placement(transformation(extent=
                          {{180,0},{200,20}})));

              equation
                connect(conVolMin.y, gre.u1)
                  annotation (Line(points={{-58,-430},{-40,-430},{-40,-450},{-22,-450}},
                    color={0,0,127}));
                connect(setCO1.y, co2ConLoo.x1)
                  annotation (Line(points={{-218,-130},{-160,-130},{-160,-172},{-142,-172}},
                    color={0,0,127}));
                connect(zerCon.y, co2ConLoo.f1)
                  annotation (Line(points={{-218,-160},{-180,-160},{-180,-176},{-142,-176}},
                    color={0,0,127}));
                connect(ppmCO2, co2ConLoo.u)
                  annotation (Line(points={{-300,-180},{-142,-180}},
                    color={0,0,127}));
                connect(setCO2.y, co2ConLoo.x2)
                  annotation (Line(points={{-218,-200},{-180,-200},{-180,-184},{-142,-184}},
                    color={0,0,127}));
                connect(oneCon.y, co2ConLoo.f2)
                  annotation (Line(points={{-218,-230},{-160,-230},{-160,-188},{-142,-188}},
                    color={0,0,127}));
                connect(zerCon1.y, lin1.x1)
                  annotation (Line(points={{-58,-80},{0,-80},{0,-112},{18,-112}},
                    color={0,0,127}));
                connect(oneCon1.y, lin1.x2)
                  annotation (Line(points={{-58,-150},{-20,-150},{-20,-124},{18,-124}},
                    color={0,0,127}));
                connect(maxZonCooAir.y, lin1.f2)
                  annotation (Line(points={{-58,-180},{0,-180},{0,-128},{18,-128}},
                    color={0,0,127}));
                connect(minZonAir.y, lin1.f1)
                  annotation (Line(points={{-218,-50},{-20,-50},{-20,-116},{18,-116}},
                    color={0,0,127}));
                connect(intEqu.y, swi3.u2)
                  annotation (Line(points={{-118,-110},{-82,-110}},
                    color={255,0,255}));
                connect(co2ConLoo.y, swi3.u1)
                  annotation (Line(points={{-118,-180},{-100,-180},{-100,-118},{-82,-118}},
                    color={0,0,127}));
                connect(swi3.y, lin1.u)
                  annotation (Line(points={{-58,-110},{-40,-110},{-40,-120},{18,-120}},
                    color={0,0,127}));
                connect(zerCon2.y, swi3.u3)
                  annotation (Line(points={{-118,-80},{-100,-80},{-100,-102},{-82,-102}},
                    color={0,0,127}));
                connect(uOpeMod, intEqu.u2)
                  annotation (Line(points={{-300,-110},{-180,-110},{-180,-118},{-142,-118}},
                    color={255,127,0}));
                connect(conInt.y, intEqu.u1)
                  annotation (Line(points={{-218,-90},{-160,-90},{-160,-110},{-142,-110}},
                    color={255,127,0}));
                connect(nOcc, gai.u)
                  annotation (Line(points={{-300,-280},{-160,-280},{-160,-320},{-142,-320}},
                    color={0,0,127}));
                connect(breZonAre.y, breZon.u2)
                  annotation (Line(points={{-118,-360},{-100,-360},{-100,-346},{-82,-346}},
                    color={0,0,127}));
                connect(gai.y, breZon.u1)
                  annotation (Line(points={{-118,-320},{-100,-320},{-100,-334},{-82,-334}},
                    color={0,0,127}));
                connect(breZon.y, swi.u3)
                  annotation (Line(points={{-58,-340},{-20,-340},{-20,-288},{78,-288}},
                    color={0,0,127}));
                connect(lin1.y, swi.u1)
                  annotation (Line(points={{42,-120},{60,-120},{60,-272},{78,-272}},
                    color={0,0,127}));
                connect(minZonAir.y, greThr1.u)
                  annotation (Line(points={{-218,-50},{-200,-50},{-200,-400},{-82,-400}},
                    color={0,0,127}));
                connect(minZonAir.y, gre.u2)
                  annotation (Line(points={{-218,-50},{-200,-50},{-200,-458},{-22,-458}},
                    color={0,0,127}));
                connect(gre.y,and1. u2)
                  annotation (Line(points={{2,-450},{20,-450},{20,-408},{38,-408}},
                    color={255,0,255}));
                connect(greThr1.y,and1. u1)
                  annotation (Line(points={{-58,-400},{38,-400}}, color={255,0,255}));
                connect(and1.y, not1.u)
                  annotation (Line(points={{62,-400},{78,-400}}, color={255,0,255}));
                connect(not1.y, swi2.u2)
                  annotation (Line(points={{102,-400},{138,-400}}, color={255,0,255}));
                connect(conVolMin.y, swi2.u3)
                  annotation (Line(points={{-58,-430},{120,-430},{120,-408},{138,-408}},
                    color={0,0,127}));
                connect(swi.y, swi2.u1)
                  annotation (Line(points={{102,-280},{120,-280},{120,-392},{138,-392}},
                    color={0,0,127}));
                connect(uWin, not2.u)
                  annotation (Line(points={{-300,-500},{-242,-500}}, color={255,0,255}));
                connect(not2.y, swi1.u2)
                  annotation (Line(points={{-218,-500},{198,-500}}, color={255,0,255}));
                connect(zerFlo.y, swi1.u3)
                  annotation (Line(points={{162,-530},{180,-530},{180,-508},{198,-508}},
                    color={0,0,127}));
                connect(swi2.y, swi1.u1)
                  annotation (Line(points={{162,-400},{180,-400},{180,-492},{198,-492}},
                    color={0,0,127}));
                connect(swi1.y, VOccDisMin_flow)
                  annotation (Line(points={{222,-500},{240,-500},{240,-290},{300,-290}},
                    color={0,0,127}));
                connect(con.y, swi.u2)
                  annotation (Line(points={{-58,-260},{-40,-260},{-40,-280},{78,-280}},
                    color={255,0,255}));
                connect(minZonAir1.y, swi.u1)
                  annotation (Line(points={{42,-50},{60,-50},{60,-272},{78,-272}},
                    color={0,0,127}));
                connect(con1.y, swi1.u2)
                  annotation (Line(points={{62,-480},{80,-480},{80,-500},{198,-500}},
                    color={255,0,255}));
                connect(zerCon3.y, swi.u3)
                  annotation (Line(points={{22,-340},{40,-340},{40,-288},{78,-288}},
                    color={0,0,127}));
                connect(intEqu.y, swi24.u2)
                  annotation (Line(points={{-118,-110},{-110,-110},{-110,160},{-102,160}},
                    color={255,0,255}));
                connect(intEqu.y, swi25.u2)
                  annotation (Line(points={{-118,-110},{-110,-110},{-110,130},{-102,130}},
                    color={255,0,255}));
                connect(intEqu.y, swi26.u2)
                  annotation (Line(points={{-118,-110},{-110,-110},{-110,100},{-102,100}},
                    color={255,0,255}));
                connect(intEqu.y, swi27.u2)
                  annotation (Line(points={{-118,-110},{-110,-110},{-110,70},{-102,70}},
                    color={255,0,255}));
                connect(intEqu.y, swi28.u2)
                  annotation (Line(points={{-118,-110},{-110,-110},{-110,40},{-102,40}},
                    color={255,0,255}));
                connect(cooMaxAir.y, swi24.u1)
                  annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{-140,16},{-140,168},
                    {-102,168}}, color={0,0,127}));
                connect(heaMaxAir.y, maxInp.u2)
                  annotation (Line(points={{-158,-10},{-120,-10},{-120,-16},{-102,-16}},
                    color={0,0,127}));
                connect(maxInp.y, swi28.u1)
                  annotation (Line(points={{-78,-10},{-60,-10},{-60,22},{-124,22},{-124,48},
                    {-102,48}},   color={0,0,127}));
                connect(zerCon6.y, swi24.u3)
                  annotation (Line(points={{-218,180},{-120,180},{-120,152},{-102,152}},
                    color={0,0,127}));
                connect(zerCon6.y, swi25.u3)
                  annotation (Line(points={{-218,180},{-120,180},{-120,122},{-102,122}},
                    color={0,0,127}));
                connect(zerCon6.y, swi26.u3)
                  annotation (Line(points={{-218,180},{-120,180},{-120,92},{-102,92}},
                    color={0,0,127}));
                connect(zerCon6.y, swi27.u3)
                  annotation (Line(points={{-218,180},{-120,180},{-120,62},{-102,62}},
                    color={0,0,127}));
                connect(zerCon6.y, swi28.u3)
                  annotation (Line(points={{-218,180},{-120,180},{-120,32},{-102,32}},
                    color={0,0,127}));
                connect(uOpeMod, intEqu1.u2)
                  annotation (Line(points={{-300,-110},{-180,-110},{-180,-32},{-200,-32},
                    {-200,292},{-182,292}}, color={255,127,0}));
                connect(uOpeMod, intEqu2.u2)
                  annotation (Line(points={{-300,-110},{-180,-110},{-180,-32},{-200,-32},
                    {-200,222},{-182,222}}, color={255,127,0}));
                connect(uOpeMod, intEqu4.u2)
                  annotation (Line(points={{-300,-110},{-180,-110},{-180,-32},{20,-32},
                    {20,222},{38,222}}, color={255,127,0}));
                connect(uOpeMod, intEqu3.u2)
                  annotation (Line(points={{-300,-110},{-180,-110},{-180,-32},{20,-32},
                    {20,292},{38,292}}, color={255,127,0}));
                connect(conInt1.y, intEqu1.u1)
                  annotation (Line(points={{-218,300},{-182,300}}, color={255,127,0}));
                connect(conInt2.y, intEqu2.u1)
                  annotation (Line(points={{-218,230},{-182,230}}, color={255,127,0}));
                connect(conInt4.y, intEqu4.u1)
                  annotation (Line(points={{2,230},{38,230}}, color={255,127,0}));
                connect(conInt3.y, intEqu3.u1)
                  annotation (Line(points={{2,300},{38,300}}, color={255,127,0}));
                connect(cooMaxAir.y, swi4.u1)
                  annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{-140,16},{-140,308},
                        {-102,308}}, color={0,0,127}));
                connect(heaMaxAir.y, swi8.u1)
                  annotation (Line(points={{-158,-10},{-134,-10},{-134,278},{-102,278}},
                    color={0,0,127}));
                connect(intEqu1.y, swi4.u2)
                  annotation (Line(points={{-158,300},{-102,300}}, color={255,0,255}));
                connect(intEqu1.y, swi8.u2)
                  annotation (Line(points={{-158,300},{-112,300},{-112,270},{-102,270}},
                    color={255,0,255}));
                connect(zerCon6.y, swi4.u3)
                  annotation (Line(points={{-218,180},{-120,180},{-120,292},{-102,292}},
                    color={0,0,127}));
                connect(zerCon6.y, swi8.u3)
                  annotation (Line(points={{-218,180},{-120,180},{-120,262},{-102,262}},
                    color={0,0,127}));
                connect(cooMaxAir.y, swi9.u1)
                  annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{-140,16},{-140,238},
                        {-102,238}}, color={0,0,127}));
                connect(intEqu2.y, swi9.u2)
                  annotation (Line(points={{-158,230},{-102,230}}, color={255,0,255}));
                connect(zerCon6.y, swi9.u3)
                  annotation (Line(points={{-218,180},{-120,180},{-120,222},{-102,222}},
                    color={0,0,127}));
                connect(intEqu3.y, swi17.u2)
                  annotation (Line(points={{62,300},{118,300}},
                    color={255,0,255}));
                connect(intEqu3.y, swi18.u2)
                  annotation (Line(points={{62,300},{108,300},{108,270},{118,270}},
                    color={255,0,255}));
                connect(intEqu4.y, swi22.u2)
                  annotation (Line(points={{62,230},{118,230}},
                    color={255,0,255}));
                connect(intEqu4.y, swi23.u2)
                  annotation (Line(points={{62,230},{108,230},{108,200},{118,200}},
                    color={255,0,255}));
                connect(heaMaxAir.y, swi17.u1)
                  annotation (Line(points={{-158,-10},{-134,-10},{-134,10},{86,10},{86,308},{118,
                        308}},  color={0,0,127}));
                connect(cooMaxAir.y, swi18.u1)
                  annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{80,16},{80,278},{118,
                        278}},  color={0,0,127}));
                connect(zerCon6.y, swi17.u3)
                  annotation (Line(points={{-218,180},{100,180},{100,292},{118,292}},
                    color={0,0,127}));
                connect(zerCon6.y, swi18.u3)
                  annotation (Line(points={{-218,180},{100,180},{100,262},{118,262}},
                    color={0,0,127}));
                connect(zerCon6.y, swi22.u3)
                  annotation (Line(points={{-218,180},{100,180},{100,222},{118,222}},
                    color={0,0,127}));
                connect(zerCon6.y, swi23.u3)
                  annotation (Line(points={{-218,180},{100,180},{100,192},{118,192}},
                    color={0,0,127}));
                connect(heaMaxAir.y, swi22.u1)
                  annotation (Line(points={{-158,-10},{-134,-10},{-134,10},{86,10},{86,238},{118,
                        238}},  color={0,0,127}));
                connect(cooMaxAir.y, swi23.u1)
                  annotation (Line(points={{-218,-10},{-204,-10},{-204,16},{80,16},{80,208},{118,
                        208}},  color={0,0,127}));
                connect(swi1.y, swi25.u1)
                  annotation (Line(points={{222,-500},{240,-500},{240,-28},{-128,-28},{-128,138},
                        {-102,138}}, color={0,0,127}));
                connect(swi1.y, swi26.u1)
                  annotation (Line(points={{222,-500},{240,-500},{240,-28},{-128,-28},{-128,108},
                        {-102,108}}, color={0,0,127}));
                connect(swi1.y, swi27.u1)
                  annotation (Line(points={{222,-500},{240,-500},{240,-28},{-128,-28},{-128,78},
                        {-102,78}}, color={0,0,127}));
                connect(swi1.y, maxInp.u1)
                  annotation (Line(points={{222,-500},{240,-500},{240,-28},{-128,-28},{-128,-4},
                        {-102,-4}}, color={0,0,127}));
                connect(nOcc, hys.u)
                  annotation (Line(points={{-300,-280},{-142,-280}}, color={0,0,127}));
                connect(hys.y, swi.u2)
                  annotation (Line(points={{-118,-280},{78,-280}}, color={255,0,255}));
                connect(add2.y, actCooMaxAir.u1) annotation (Line(points={{222,180},{230,180},
                        {230,176},{238,176}}, color={0,0,127}));
                connect(swi4.y, add2.u1) annotation (Line(points={{-78,300},{-40,300},{-40,186},
                        {198,186}}, color={0,0,127}));
                connect(swi9.y, add2.u2) annotation (Line(points={{-78,230},{-60,230},{-60,174},
                        {198,174}}, color={0,0,127}));
                connect(swi24.y, actCooMaxAir.u2) annotation (Line(points={{-78,160},{100,160},
                        {100,164},{238,164}}, color={0,0,127}));
                connect(actCooMaxAir.y, VActCooMax_flow)
                  annotation (Line(points={{262,170},{300,170}}, color={0,0,127}));
                connect(swi25.y, VActCooMin_flow) annotation (Line(points={{-78,130},{100,130},
                        {100,140},{300,140}}, color={0,0,127}));
                connect(swi26.y, VActMin_flow) annotation (Line(points={{-78,100},{100,100},{100,
                        110},{300,110}}, color={0,0,127}));
                connect(swi17.y, add1.u1) annotation (Line(points={{142,300},{178,300},{178,96},
                        {198,96}}, color={0,0,127}));
                connect(swi22.y, add1.u2) annotation (Line(points={{142,230},{166,230},{166,84},
                        {198,84}}, color={0,0,127}));
                connect(swi27.y, actHeaMinAir.u2) annotation (Line(points={{-78,70},{220,70},{
                        220,64},{238,64}}, color={0,0,127}));
                connect(add1.y, actHeaMinAir.u1) annotation (Line(points={{222,90},{230,90},{230,
                        76},{238,76}}, color={0,0,127}));
                connect(actHeaMinAir.y, VActHeaMin_flow)
                  annotation (Line(points={{262,70},{300,70}}, color={0,0,127}));
                connect(swi8.y, add3.u1) annotation (Line(points={{-78,270},{-50,270},{-50,56},
                        {178,56}}, color={0,0,127}));
                connect(swi28.y, add3.u2) annotation (Line(points={{-78,40},{-50,40},{-50,44},
                        {178,44}}, color={0,0,127}));
                connect(swi18.y, add4.u1) annotation (Line(points={{142,270},{172,270},{172,16},
                        {178,16}}, color={0,0,127}));
                connect(swi23.y, add4.u2) annotation (Line(points={{142,200},{160,200},{160,4},
                        {178,4}}, color={0,0,127}));
                connect(actHeaMaxAir1.y, VActHeaMax_flow)
                  annotation (Line(points={{262,30},{300,30}}, color={0,0,127}));
                connect(add3.y, actHeaMaxAir1.u1) annotation (Line(points={{202,50},{220,50},{
                        220,36},{238,36}}, color={0,0,127}));
                connect(add4.y, actHeaMaxAir1.u2) annotation (Line(points={{202,10},{220,10},{
                        220,24},{238,24}}, color={0,0,127}));

              annotation (
                defaultComponentName="actAirSet_RehBox",
                Diagram(
                      coordinateSystem(preserveAspectRatio=false, extent={{-280,-560},{280,340}}),
                      graphics={                   Rectangle(
                        extent={{-258,-62},{258,-238}},
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None), Rectangle(
                        extent={{-258,-250},{258,-374}},
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None), Rectangle(
                        extent={{-258,-380},{258,-462}},
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None), Text(
                        extent={{92,-58},{290,-94}},
                        pattern=LinePattern.None,
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Occupied min airflow:
reset based on CO2 control"),
                     Text(extent={{116,-234},{332,-294}},
                        pattern=LinePattern.None,
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        lineColor={0,0,255},
                        textString="Occupied min airflow:
reset based on occupancy",
                        horizontalAlignment=TextAlignment.Left),
                      Text(extent={{-252,-422},{28,-454}},
                        pattern=LinePattern.None,
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Occupied min airflow:
define based on controllable minimum"),            Rectangle(
                        extent={{-256,-484},{260,-552}},
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None),
                      Text(extent={{-190,-492},{32,-564}},
                        pattern=LinePattern.None,
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Occupied min airflow:
reset based on window status"),                    Rectangle(
                        extent={{-258,318},{258,-18}},
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        pattern=LinePattern.None), Text(
                        extent={{32,18},{254,-26}},
                        pattern=LinePattern.None,
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid,
                        lineColor={0,0,255},
                        horizontalAlignment=TextAlignment.Left,
                        textString="Define active setpoints
according to operation modes")}),
                   Icon(
                      graphics={Rectangle(
                        extent={{-100,100},{100,-100}},
                        lineColor={0,0,0},
                        fillColor={210,210,210},
                        fillPattern=FillPattern.Solid),
                      Text(
                        extent={{-100,140},{100,100}},
                        lineColor={0,0,255},
                        textString="%name"),
                      Text(
                        extent={{-62,66},{58,-56}},
                        lineColor={0,0,0},
                        textString="actAirSet"),
                      Text(
                        visible=have_CO2Sen,
                        extent={{-98,48},{-70,36}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="CO2"),
                      Text(
                        visible=have_occSen,
                        extent={{-98,-32},{-70,-44}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="nOcc"),
                      Text(
                        extent={{-94,90},{-48,72}},
                        lineColor={255,127,0},
                        pattern=LinePattern.Dash,
                        textString="uOpeMod"),
                      Text(
                        visible=have_winSen,
                        extent={{-98,-74},{-72,-84}},
                        lineColor={255,0,255},
                        pattern=LinePattern.Dash,
                        textString="uWin"),
                      Text(
                        extent={{62,88},{98,74}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActCooMax_flow"),
                      Text(
                        extent={{62,58},{98,44}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActCooMin_flow"),
                      Text(
                        extent={{72,24},{98,14}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActMin_flow"),
                      Text(
                        extent={{62,-2},{98,-16}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActHeaMin_flow"),
                      Text(
                        extent={{62,-32},{98,-46}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VActHeaMax_flow"),
                      Text(
                        extent={{62,-72},{98,-86}},
                        lineColor={0,0,127},
                        pattern=LinePattern.Dash,
                        textString="VOccDisMin_flow")}),
              Documentation(info="<html>
<p>
This atomic sequence sets the active maximum and minimum setpoints <code>VActCooMax_flow</code>,
<code>VActCooMin_flow</code>, <code>VActMin_flow</code>, <code>VActHeaMin_flow</code>,
<code>VActHeaMax_flow</code> for VAV reheat terminal unit according to ASHRAE
Guideline 36 (G36), PART 5.E.3-5.
</p>
<h4>1. Information provided by designer</h4>
<p>According to G36 PART 3.1.B.2, following VAV box design information should be
provided:</p>
<ul>
<li>Zone maximum cooling airflow setpoint <code>VDisCooSetMax_flow</code></li>
<li>Zone minimum airflow setpoint <code>VDisSetMin_flow</code></li>
<li>Zone maximum heating airflow setpoint <code>VDisHeaSetMax_flow</code></li>
</ul>

<h4>2. Occupied minimum airflow <code>VOccDisMin_flow</code></h4>
<p>The <code>VOccDisMin_flow</code> shall be equal to zone minimum airflow setpoint
<code>VDisSetMin_flow</code> except as follows:</p>
<ul>
<li>
If the zone has an occupancy sensor, <code>VOccDisMin_flow</code> shall be equal to
minimum breathing zone outdoor airflow (if ventilation is according to ASHRAE
Standard 62.1-2013) or zone minimum outdoor airflow for building area
(if ventilation is according to California Title 24) when the room is unpopulated.
</li>
<li>
If the zone has a window switch, <code>VOccDisMin_flow</code> shall be zero when the
window is open.
</li>
<li>
If <code>VDisSetMin_flow</code> is non-zero and less than the lowest possible airflow setpoint
allowed by the controls <code>VDisConMin_flow</code>, <code>VOccDisMin_flow</code> shall be set
equal to <code>VDisConMin_flow</code>.
</li>
<li>
If the zone has a CO2 sensor, then following steps are applied for calculating
<code>VOccDisMin_flow</code>. (1) During occupied mode, a P-only loop shall maintain
CO2 concentration at setpoint, reset 0% at (CO2 setpoint <code>CO2Set</code> -
200 ppm) and 100% at <code>CO2Set</code>. If ventilation outdoor airflow is controlled
in accordance with ASHRAE Standard 62.1-2013, the loop output shall reset the
<code>VOccDisMin_flow</code> from <code>VDisSetMin_flow</code> at 0% loop output up to <code>VDisCooSetMax_flow</code>
at 100% loop output; (2) Loop is diabled and output set to zero when the zone is
not in occupied mode.
</li>
</ul>

<h4>3. Active maximum and minimum setpoints</h4>
<p>The setpoints shall vary depending on the mode of the zone group.</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Setpoint</th> <th>Occupied</th><th>Cool-down</th>
<th>Setup</th><th>Warmup</th><th>Setback</th><th>Unoccupied</th></tr>
<tr><td>Cooling maximum (<code>VActCooMax_flow</code>)</td><td><code>VDisCooSetMax_flow</code></td>
<td><code>VDisCooSetMax_flow</code></td><td><code>VDisCooSetMax_flow</code></td>
<td>0</td><td>0</td><td>0</td></tr>
<tr><td>Cooling minimum (<code>VActCooMin_flow</code>)</td><td><code>VOccDisMin_flow</code></td>
<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>Minimum (<code>VActMin_flow</code>)</td><td><code>VOccDisMin_flow</code></td><td>0</td>
<td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>Heating minimum (<code>VActHeaMin_flow</code>)</td><td><code>VOccDisMin_flow</code></td>
<td>0</td><td>0</td><td><code>VDisHeaSetMax_flow</code></td><td><code>VDisHeaSetMax_flow</code></td>
<td>0</td></tr>
<tr><td>Heating maximum (<code>VActHeaMax_flow</code>)</td><td>max(<code>VDisHeaSetMax_flow,VOccDisMin_flow</code>)</td>
<td><code>VDisHeaSetMax_flow</code></td><td>0</td><td><code>VDisCooSetMax_flow</code></td><td><code>VDisCooSetMax_flow</code></td>
<td>0</td></tr>
</table>
<br/>
</html>",               revisions="<html>
<ul>
<li>
March 11, 2020, by Jianjun Hu:<br/>
Replaced multisum block with add blocks.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1830\">#1830</a>.
</li>
<li>
February 27, 2020, by Jianjun Hu:<br/>
Used hysteresis to check occupancy.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1788\">#1788</a>.
</li>
<li>
September 7, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
              end ActiveAirFlow;

              package Validation "Collection of validation models"

                model ActiveAirFlow
                  "Validate the model for calculating active airflow setpoint for VAV terminal unit with reheat"
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow
                    actAirSet_RehBox(
                    VDisCooSetMax_flow=0.075,
                    VDisSetMin_flow=0.017,
                    VDisHeaSetMax_flow=0.05,
                    VDisConMin_flow=0.01,
                    AFlo=40,
                    have_occSen=true,
                    have_winSen=true,
                    have_CO2Sen=true)
                    "Output the active airflow setpoint for VAV reheat terminal unit"
                    annotation (Placement(transformation(extent={{60,60},{80,80}})));
                  hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow
                    actAirSet_RehBox1(
                    VDisCooSetMax_flow=0.075,
                    VDisSetMin_flow=0.017,
                    VDisHeaSetMax_flow=0.05,
                    VDisConMin_flow=0.01,
                    AFlo=40,
                    have_occSen=true,
                    have_winSen=true,
                    have_CO2Sen=true)
                    "Output the active airflow setpoint for VAV reheat terminal unit"
                    annotation (Placement(transformation(extent={{60,0},{80,20}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp
                    coCon(
                    height=400,
                    duration=86400,
                    offset=500) "CO2 concentration" annotation (Placement(
                        transformation(extent={{-40,60},{-20,80}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine
                    sine(
                    amplitude=2,
                    freqHz=1/86400,
                    offset=2) "occNum" annotation (Placement(transformation(
                          extent={{-80,20},{-60,40}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse winSta(
                    startTime=0,
                    width=0.2,
                    period=90000) "Generate signal indicating window status"
                    annotation (Placement(transformation(extent={{-40,-90},{-20,
                            -70}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    conInt(k=1) "Occupied mode index" annotation (Placement(
                        transformation(extent={{-40,-20},{-20,0}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                    conInt1(k=2) "Cool-down mode index" annotation (Placement(
                        transformation(extent={{-40,-50},{-20,-30}})));
                  hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
                    "Round real number to given digits" annotation (Placement(
                        transformation(extent={{-40,20},{-20,40}})));

                equation
                  connect(coCon.y,actAirSet_RehBox. ppmCO2)
                    annotation (Line(points={{-18,70},{-8,70},{-8,74},{58,74}},
                      color={0,0,127}));
                  connect(winSta.y,actAirSet_RehBox. uWin)
                    annotation (Line(points={{-18,-80},{4,-80},{4,62},{58,62}},
                      color={255,0,255}));
                  connect(conInt.y, actAirSet_RehBox.uOpeMod)
                    annotation (Line(points={{-18,-10},{0,-10},{0,78},{58,78}},
                      color={255,127,0}));
                  connect(coCon.y, actAirSet_RehBox1.ppmCO2)
                    annotation (Line(points={{-18,70},{-8,70},{-8,14},{58,14}},
                      color={0,0,127}));
                  connect(conInt1.y, actAirSet_RehBox1.uOpeMod)
                    annotation (Line(points={{-18,-40},{8,-40},{8,18},{58,18}},
                      color={255,127,0}));
                  connect(winSta.y, actAirSet_RehBox1.uWin)
                    annotation (Line(points={{-18,-80},{4,-80},{4,2},{58,2}},
                      color={255,0,255}));
                  connect(sine.y, round1.u)
                    annotation (Line(points={{-58,30},{-42,30}}, color={0,0,127}));
                  connect(round1.y, actAirSet_RehBox.nOcc) annotation (Line(points={{-18,30},{-4,
                          30},{-4,66},{58,66}}, color={0,0,127}));
                  connect(round1.y, actAirSet_RehBox1.nOcc) annotation (Line(points={{-18,30},{-4,
                          30},{-4,6},{58,6}}, color={0,0,127}));

                annotation (
                  experiment(StopTime=86400, Tolerance=1e-6),
                  __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/TerminalUnits/Reheat/SetPoints/Validation/ActiveAirFlow.mos"
                        "Simulate and plot"),
                  Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints.ActiveAirFlow</a>
for calculating active minimum and maximum airflow setpoint used in a VAV reheat
terminal unit control.
</p>
</html>",                 revisions="<html>
<ul>
<li>
February 28, 2020, by Jianjun Hu:<br/>
Changed occupant number input.
</li>
<li>
September 07, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),          Icon(graphics={
                        Ellipse(lineColor = {75,138,73},
                                fillColor={255,255,255},
                                fillPattern = FillPattern.Solid,
                                extent = {{-100,-100},{100,100}}),
                        Polygon(lineColor = {0,0,255},
                                fillColor = {75,138,73},
                                pattern = LinePattern.None,
                                fillPattern = FillPattern.Solid,
                                points = {{-36,60},{64,0},{-36,-60},{-36,60}}),
                                   Ellipse(
                          lineColor={75,138,73},
                          fillColor={255,255,255},
                          fillPattern=FillPattern.Solid,
                          extent={{-100,-100},{100,100}}), Polygon(
                          lineColor={0,0,255},
                          fillColor={75,138,73},
                          pattern=LinePattern.None,
                          fillPattern=FillPattern.Solid,
                          points={{-36,58},{64,-2},{-36,-62},{-36,58}})}));
                end ActiveAirFlow;
              annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SetPoints</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),      Icon(graphics={
                      Rectangle(
                        lineColor={200,200,200},
                        fillColor={248,248,248},
                        fillPattern=FillPattern.HorizontalCylinder,
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Rectangle(
                        lineColor={128,128,128},
                        extent={{-100.0,-100.0},{100.0,100.0}},
                        radius=25.0),
                      Polygon(
                        origin={8.0,14.0},
                        lineColor={78,138,73},
                        fillColor={78,138,73},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
              end Validation;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains sequences generating setpoints for terminal units.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                  Text(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    textString="S")}));
            end SetPoints;

            package Validation "Collection of validation models"

              model DamperValves
                "Validate model for controlling damper and valve position of VAV reheat terminal unit"

                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.DamperValves
                  damVal(kDam=1, V_flow_nominal=2)
                  "Output signal for controlling VAV reheat box damper and valve position"
                  annotation (Placement(transformation(extent={{60,40},{80,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp uHea(
                  duration=36000,
                  height=-1,
                  offset=1,
                  startTime=0) "Heating control signal" annotation (Placement(
                      transformation(extent={{-40,-30},{-20,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp uCoo(
                  height=1,
                  duration=36000,
                  offset=0,
                  startTime=50400) "Cooling control signal" annotation (
                    Placement(transformation(extent={{-80,-10},{-60,10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  THeaSet(k=273.15 + 20) "Zone heating setpoint temperature"
                  annotation (Placement(transformation(extent={{-80,-50},{-60,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZon(k=273.15 + 22) "Zone temperature" annotation (Placement(
                      transformation(extent={{-80,-90},{-60,-70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TSup(k=273.15 + 13) "AHU supply air temperature" annotation (
                    Placement(transformation(extent={{-40,-70},{-20,-50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  VActMin_flow(k=0.01) "Active minimum airflow setpoint"
                  annotation (Placement(transformation(extent={{-40,10},{-20,30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  VActHeaMin_flow(k=0.015)
                  "Active heating minimum airflow setpoint" annotation (
                    Placement(transformation(extent={{-80,30},{-60,50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  VActHeaMax_flow(k=0.05)
                  "Active heating maximum airflow setpoint" annotation (
                    Placement(transformation(extent={{-40,50},{-20,70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  VActCooMin_flow(k=0.015)
                  "Active cooling minimum airflow setpoint" annotation (
                    Placement(transformation(extent={{-80,70},{-60,90}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  VActCooMax_flow(k=0.075)
                  "Active cooling maximum airflow setpoint" annotation (
                    Placement(transformation(extent={{20,70},{40,90}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine VDis_flow(
                  offset=0.015,
                  amplitude=0.002,
                  freqHz=1/86400) "Discharge airflow rate" annotation (
                    Placement(transformation(extent={{20,-70},{40,-50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TDis(k=273.15 + 25) "Discharge air temperature" annotation (
                    Placement(transformation(extent={{20,-30},{40,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  occSig(k=hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                  "Occupied signal" annotation (Placement(transformation(extent
                        ={{20,10},{40,30}})));

              equation
                connect(VDis_flow.y, damVal.VDis_flow)
                  annotation (Line(points={{41,-60},{74,-60},{74,37}}, color={0,0,127}));
                connect(TDis.y, damVal.TDis)
                  annotation (Line(points={{41,-20},{66,-20},{66,37}}, color={0,0,127}));
                connect(VActCooMax_flow.y, damVal.VActCooMax_flow)
                  annotation (Line(points={{41,80},{50,80},{50,59},{59,59}}, color={0,0,127}));
                connect(VActCooMin_flow.y, damVal.VActCooMin_flow)
                  annotation (Line(points={{-59,80},{-2,80},{-2,57},{59,57}}, color={0,0,127}));
                connect(VActHeaMax_flow.y, damVal.VActHeaMax_flow)
                  annotation (Line(points={{-19,60},{-4,60},{-4,55},{59,55}}, color={0,0,127}));
                connect(VActHeaMin_flow.y, damVal.VActHeaMin_flow)
                  annotation (Line(points={{-59,40},{-4,40},{-4,53},{59,53}}, color={0,0,127}));
                connect(VActMin_flow.y, damVal.VActMin_flow)
                  annotation (Line(points={{-19,20},{-2,20},{-2,51},{59,51}}, color={0,0,127}));
                connect(uCoo.y, damVal.uCoo)
                  annotation (Line(points={{-59,0},{0,0},{0,49},{59,49}}, color={0,0,127}));
                connect(uHea.y, damVal.uHea)
                  annotation (Line(points={{-19,-20},{2,-20},{2,47},{59,47}}, color={0,0,127}));
                connect(THeaSet.y, damVal.THeaSet)
                  annotation (Line(points={{-59,-40},{4,-40},{4,45},{59,45}}, color={0,0,127}));
                connect(TSup.y, damVal.TSup)
                  annotation (Line(points={{-19,-60},{6,-60},{6,43},{59,43}}, color={0,0,127}));
                connect(TZon.y, damVal.TZon)
                  annotation (Line(points={{-59,-80},{8,-80},{8,41},{59,41}}, color={0,0,127}));
                connect(occSig.y, damVal.uOpeMod)
                  annotation (Line(points={{41,20},{50,20},{50,39},{59,39}}, color={255,127,0}));

              annotation (
                experiment(StopTime=86400, Tolerance=1e-6),
                __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/TerminalUnits/Reheat/Validation/DamperValves.mos"
                      "Simulate and plot"),
                Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.DamperValves\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.DamperValves</a>
for damper and valve control of VAV reheat terminal unit.
</p>
</html>",               revisions="<html>
<ul>
<li>
Spetember 10, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),        Icon(graphics={
                      Ellipse(lineColor = {75,138,73},
                              fillColor={255,255,255},
                              fillPattern = FillPattern.Solid,
                              extent = {{-100,-100},{100,100}}),
                      Polygon(lineColor = {0,0,255},
                              fillColor = {75,138,73},
                              pattern = LinePattern.None,
                              fillPattern = FillPattern.Solid,
                              points = {{-36,60},{64,0},{-36,-60},{-36,60}}),
                                 Ellipse(
                        lineColor={75,138,73},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid,
                        extent={{-100,-100},{100,100}}), Polygon(
                        lineColor={0,0,255},
                        fillColor={75,138,73},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        points={{-36,58},{64,-2},{-36,-62},{-36,58}})}));
              end DamperValves;

              model SystemRequests
                "Validation of model that generates system requests"

                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SystemRequests
                  sysReq_RehBox(have_heaPla=true, have_heaWatCoi=true)
                  "Block outputs system requests" annotation (Placement(
                      transformation(extent={{60,60},{80,80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine sine(freqHz=1/
                      7200, offset=296.15) "Generate data for setpoint"
                  annotation (Placement(transformation(extent={{-60,80},{-40,
                          100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.UnitDelay TZonCooSet(
                    samplePeriod=1800) "Cooling setpoint temperature"
                  annotation (Placement(transformation(extent={{-20,80},{0,100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine TZon(
                  freqHz=1/7200,
                  amplitude=2,
                  offset=299.15) "Zone temperature" annotation (Placement(
                      transformation(extent={{-60,50},{-40,70}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp uCoo(
                  height=0.9,
                  duration=7200,
                  offset=0.1) "Cooling loop signal" annotation (Placement(
                      transformation(extent={{-20,30},{0,50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp disAirSet(
                  height=0.9,
                  duration=7200,
                  offset=0.1) "Discharge airflow rate setpoint" annotation (
                    Placement(transformation(extent={{-60,10},{-40,30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp disAirRate(
                  duration=7200,
                  offset=0.1,
                  height=0.3) "Discharge airflow rate" annotation (Placement(
                      transformation(extent={{-20,-10},{0,10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp damPos(
                  duration=7200,
                  height=0.7,
                  offset=0.3) "Damper position" annotation (Placement(
                      transformation(extent={{-60,-30},{-40,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine sine1(freqHz=1/
                      7200, offset=305.15) "Generate data for setpoint"
                  annotation (Placement(transformation(extent={{-90,-50},{-70,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.UnitDelay TDisHeaSet(
                    samplePeriod=1800) "Discharge air setpoint temperature"
                  annotation (Placement(transformation(extent={{-20,-50},{0,-30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine TDis(
                  freqHz=1/7200,
                  amplitude=2,
                  offset=293.15) "Discharge air temperature" annotation (
                    Placement(transformation(extent={{-60,-70},{-40,-50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp valPos(
                  duration=7200,
                  height=1,
                  offset=0) "Hot water valve position" annotation (Placement(
                      transformation(extent={{-20,-90},{0,-70}})));

              equation
                connect(sine.y, TZonCooSet.u)
                  annotation (Line(points={{-38,90},{-22,90}}, color={0,0,127}));
                connect(TZonCooSet.y, sysReq_RehBox.TZonCooSet) annotation (Line(points={{2,90},{
                        46,90},{46,78},{58,78}},  color={0,0,127}));
                connect(TZon.y, sysReq_RehBox.TZon)
                  annotation (Line(points={{-38,60},{16,60},{16,76},{58,76}},
                    color={0,0,127}));
                connect(uCoo.y, sysReq_RehBox.uCoo)
                  annotation (Line(points={{2,40},{18,40},{18,74},{58,74}},
                    color={0,0,127}));
                connect(disAirSet.y, sysReq_RehBox.VDisSet_flow) annotation (Line(points={{-38,20},
                        {20,20},{20,72},{58,72}},     color={0,0,127}));
                connect(disAirRate.y, sysReq_RehBox.VDis_flow)
                  annotation (Line(points={{2,0},{22,0},{22,70},{58,70}}, color={0,0,127}));
                connect(damPos.y,sysReq_RehBox.yDam_actual)  annotation (Line(points={{-38,
                        -20},{24,-20},{24,68},{58,68}}, color={0,0,127}));
                connect(sine1.y, TDisHeaSet.u)
                  annotation (Line(points={{-68,-40},{-22,-40}}, color={0,0,127}));
                connect(TDisHeaSet.y, sysReq_RehBox.TDisHeaSet)
                  annotation (Line(points={{2,-40},{26,-40},{26,66},{58,66}},
                    color={0,0,127}));
                connect(TDis.y, sysReq_RehBox.TDis)
                  annotation (Line(points={{-38,-60},{28,-60},{28,64},{58,64}},
                    color={0,0,127}));
                connect(valPos.y,sysReq_RehBox.uHeaVal)
                  annotation (Line(points={{2,-80},{30,-80},{30,62},{58,62}},
                    color={0,0,127}));

              annotation (
                experiment(StopTime=7200, Tolerance=1e-6),
                __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/TerminalUnits/Reheat/Validation/SystemRequests.mos"
                      "Simulate and plot"),
                  Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SystemRequests\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat.SystemRequests</a>
for generating system requests.
</p>
</html>",               revisions="<html>
<ul>
<li>
September 13, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                          120}})),
                  Icon(coordinateSystem(extent={{-100,-100},{100,120}}), graphics={
                      Ellipse(lineColor = {75,138,73},
                              fillColor={255,255,255},
                              fillPattern = FillPattern.Solid,
                              extent = {{-100,-100},{100,100}}),
                      Polygon(lineColor = {0,0,255},
                              fillColor = {75,138,73},
                              pattern = LinePattern.None,
                              fillPattern = FillPattern.Solid,
                              points = {{-36,60},{64,0},{-36,-60},{-36,60}}),
                                 Ellipse(
                        lineColor={75,138,73},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid,
                        extent={{-100,-100},{100,100}}), Polygon(
                        lineColor={0,0,255},
                        fillColor={75,138,73},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        points={{-36,58},{64,-2},{-36,-62},{-36,58}})}));
              end SystemRequests;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Reheat</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Polygon(
                      origin={8.0,14.0},
                      lineColor={78,138,73},
                      fillColor={78,138,73},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
            end Validation;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains sequences for VAV reheat terminal unit. They are created
according to ASHRAE Guideline 36, Part 5.E.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Ellipse(
                    origin={10.0,10.0},
                    lineColor={128,128,128},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    extent={{-80.0,0.0},{-20.0,60.0}}),
                  Ellipse(
                    origin={10.0,10.0},
                    fillColor={128,128,128},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{0.0,0.0},{60.0,60.0}}),
                  Ellipse(
                    origin={10.0,10.0},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{0.0,-80.0},{60.0,-20.0}}),
                  Ellipse(
                    origin={10.0,10.0},
                    fillColor={76,76,76},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    extent={{-80.0,-80.0},{-20.0,-20.0}})}));
          end Reheat;

          package SetPoints "Generic sequences of generating setpoints for terminal units control"

            block ZoneTemperatures
              "Block outputs thermal zone cooling and heating setpoint"

              parameter Boolean have_occSen "Check if the zone has occupancy sensor"
                annotation(Dialog(group="Sensors"));
              parameter Boolean have_winSen
                "Check if the zone has window status sensor"
                annotation(Dialog(group="Sensors"));

              parameter Boolean cooAdj = false
                "Flag, set to true if both cooling and heating setpoint are adjustable separately"
                annotation(Dialog(group="Setpoint adjustable setting"));
              parameter Boolean heaAdj = false
                "Flag, set to true if heating setpoint is adjustable"
                annotation(Dialog(group="Setpoint adjustable setting"));
              parameter Boolean sinAdj = false
                "Flag, set to true if both cooling and heating setpoint are adjustable through a single common knob"
                annotation(Dialog(group="Setpoint adjustable setting",enable=not (cooAdj or heaAdj)));
              parameter Boolean ignDemLim = true
                "Flag, set to true to exempt individual zone from demand limit setpoint adjustment"
                annotation(Dialog(group="Setpoint adjustable setting"));

              parameter Real TZonCooOnMax(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")=300.15
                "Maximum cooling setpoint during on"
                annotation(Dialog(group="Setpoints limits setting"));
              parameter Real TZonCooOnMin(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")=295.15
                "Minimum cooling setpoint during on"
                annotation(Dialog(group="Setpoints limits setting"));
              parameter Real TZonHeaOnMax(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")=295.15
                "Maximum heating setpoint during on"
                annotation(Dialog(group="Setpoints limits setting"));
              parameter Real TZonHeaOnMin(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")=291.15
                "Minimum heating setpoint during on"
                annotation(Dialog(group="Setpoints limits setting"));
              parameter Real TZonCooSetWinOpe(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")=322.15
                "Cooling setpoint when window is open"
                annotation(Dialog(group="Setpoints limits setting", enable=have_winSen));
              parameter Real TZonHeaSetWinOpe(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")=277.15
                "Heating setpoint when window is open"
                annotation(Dialog(group="Setpoints limits setting", enable=have_winSen));

              parameter Real incTSetDem_1=0.56
                "Cooling setpoint increase value (degC) when cooling demand limit level 1 is imposed"
                annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
              parameter Real incTSetDem_2=1.1
                "Cooling setpoint increase value (degC) when cooling demand limit level 2 is imposed"
                annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
              parameter Real incTSetDem_3=2.2
                "Cooling setpoint increase value (degC) when cooling demand limit level 3 is imposed"
                annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
              parameter Real decTSetDem_1=0.56
                "Heating setpoint decrease value (degC) when heating demand limit level 1 is imposed"
                annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
              parameter Real decTSetDem_2=1.1
                "Heating setpoint decrease value (degC) when heating demand limit level 2 is imposed"
                annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));
              parameter Real decTSetDem_3=2.2
                "Heating setpoint decrease value (degC) when heating demand limit level 3 is imposed"
                annotation(Dialog(group="Setpoint adjustment", tab="Demand control"));

              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonCooSetOcc(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Occupied zone cooling setpoint" annotation (Placement(
                    transformation(extent={{-460,510},{-420,550}}),
                    iconTransformation(extent={{-240,110},{-200,150}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonHeaSetOcc(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Occupied zone heating setpoint" annotation (Placement(
                    transformation(extent={{-460,430},{-420,470}}),
                    iconTransformation(extent={{-240,28},{-200,68}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonCooSetUno(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Unoccupied zone cooling setpoint" annotation (Placement(
                    transformation(extent={{-460,470},{-420,510}}),
                    iconTransformation(extent={{-240,68},{-200,108}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZonHeaSetUno(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Unoccupied zone heating setpoint" annotation (Placement(
                    transformation(extent={{-460,390},{-420,430}}),
                    iconTransformation(extent={{-240,-10},{-200,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput setAdj(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature") if (cooAdj or sinAdj)
                "Setpoint adjustment value" annotation (Placement(
                    transformation(extent={{-460,330},{-420,370}}),
                    iconTransformation(extent={{-240,-50},{-200,-10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput heaSetAdj(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature") if heaAdj
                "Heating setpoint adjustment value" annotation (Placement(
                    transformation(extent={{-460,250},{-420,290}}),
                    iconTransformation(extent={{-240,-90},{-200,-50}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uOpeMod
                "AHU operation mode status signal" annotation (Placement(
                    transformation(extent={{-460,610},{-420,650}}),
                    iconTransformation(extent={{-240,160},{-200,200}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uCooDemLimLev
                "Cooling demand limit level" annotation (Placement(
                    transformation(extent={{-460,110},{-420,150}}),
                    iconTransformation(extent={{-240,-160},{-200,-120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerInput uHeaDemLimLev
                "Heating demand limit level" annotation (Placement(
                    transformation(extent={{-460,-110},{-420,-70}}),
                    iconTransformation(extent={{-240,-200},{-200,-160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uOccSen if
                have_occSen
                "Occupancy sensor (occupied=true, unoccupied=false)"
                annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                      origin={-440,-270}), iconTransformation(
                    extent={{-20,-20},{20,20}},
                    origin={-60,-220},
                    rotation=90)));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput uWinSta if
                have_winSen "Window status (open=true, close=false)"
                annotation (Placement(transformation(extent={{-460,-430},{-420,
                        -390}}), iconTransformation(
                    extent={{-20,-20},{20,20}},
                    rotation=90,
                    origin={60,-220})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TZonCooSet(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Cooling setpoint temperature" annotation (Placement(
                    transformation(extent={{340,-20},{380,20}}),
                    iconTransformation(extent={{200,60},{240,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput TZonHeaSet(
                final unit="K",
                final displayUnit="degC",
                final quantity="ThermodynamicTemperature")
                "Heating setpoint temperature" annotation (Placement(
                    transformation(extent={{340,-120},{380,-80}}),
                    iconTransformation(extent={{200,-20},{240,20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.IntegerOutput yAla
                "Alarm level" annotation (Placement(transformation(extent={{340,
                        -410},{380,-370}}), iconTransformation(extent={{200,-100},
                        {240,-60}})));

              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or2
                "Check if there is cooling/heating demand limit being imposed"
                annotation (Placement(transformation(extent={{-280,-40},{-260,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Edge edg
                "If demand limit is imposed" annotation (Placement(
                    transformation(extent={{-220,-10},{-200,10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler cooSetFre
                "Freeze current cooling setpoint when demand limit is imposed"
                annotation (Placement(transformation(extent={{-160,140},{-140,
                        160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not3
                "Logical not" annotation (Placement(transformation(extent={{-100,
                        -40},{-80,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or5
                "Check if demand limit should be ignored or if there is no demand limit"
                annotation (Placement(transformation(extent={{160,-20},{180,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or3 or1
                "Check if cooling demand limit level is imposed" annotation (
                  Placement(transformation(extent={{-40,140},{-20,160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                "Logic not" annotation (Placement(transformation(extent={{0,140},
                        {20,160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar3(final p=
                    incTSetDem_3, final k=1) "Increase setpoint by 2.2 degC"
                annotation (Placement(transformation(extent={{40,20},{60,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar1(final p=
                    incTSetDem_2, final k=1) "Increase setpoint by 1.1 degC"
                annotation (Placement(transformation(extent={{40,60},{60,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar2(final p=
                    incTSetDem_1, final k=1) "Increase setpoint by 0.56 degC"
                annotation (Placement(transformation(extent={{40,100},{60,120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro6
                "Output product of the two inputs" annotation (Placement(
                    transformation(extent={{80,140},{100,160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro
                "Output product of the two inputs" annotation (Placement(
                    transformation(extent={{80,100},{100,120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro1
                "Output product of the two inputs" annotation (Placement(
                    transformation(extent={{80,60},{100,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro2
                "Output product of the two inputs" annotation (Placement(
                    transformation(extent={{80,20},{100,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler heaSetFre
                "Freeze current heating setpoint when demand limit is imposed"
                annotation (Placement(transformation(extent={{-160,-80},{-140,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or3 or4
                "Check if heating demand limit level is imposed" annotation (
                  Placement(transformation(extent={{-40,-80},{-20,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not2
                "Logical not" annotation (Placement(transformation(extent={{0,-80},
                        {20,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro7
                "Output product of the two inputs" annotation (Placement(
                    transformation(extent={{80,-80},{100,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar6(final k=1,
                  final p=-decTSetDem_1) "Decrease setpoint by 0.56 degC"
                annotation (Placement(transformation(extent={{40,-120},{60,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar5(final k=1,
                  final p=-decTSetDem_2) "Decrease setpoint by 1.1 degC"
                annotation (Placement(transformation(extent={{40,-160},{60,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar4(final k=1,
                  final p=-decTSetDem_3) "Decrease setpoint by 2.2 degC"
                annotation (Placement(transformation(extent={{40,-200},{60,-180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro5
                "Output product of the two inputs" annotation (Placement(
                    transformation(extent={{80,-200},{100,-180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro4
                "Output product of the two inputs" annotation (Placement(
                    transformation(extent={{80,-160},{100,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product pro3
                "Output product of the two inputs" annotation (Placement(
                    transformation(extent={{80,-120},{100,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Timer tim
                "Measure unpopulated time when the zone is in occupied mode"
                annotation (Placement(transformation(extent={{-220,-280},{-200,
                        -260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueHoldWithReset truHol(duration=
                    60)
                "When the zone is unpopulated by more than 5 minute and then becomes populated, hold the change by 1 minute"
                annotation (Placement(transformation(extent={{-100,-280},{-80,-260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Edge edg1
                "Instant when the zone becomes more than 5 minutes" annotation
                (Placement(transformation(extent={{-40,-280},{-20,-260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter heaSetDec(p=-1.1,
                  final k=1)
                "Heating setpoint decrease due to the 5 minutes unpopulation under occupied mode"
                annotation (Placement(transformation(extent={{100,-320},{120,-300}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter cooSetInc(p=1.1,
                  final k=1)
                "Heating setpoint increase due to the 5 minutes unpopulation under occupied mode"
                annotation (Placement(transformation(extent={{100,-280},{120,-260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler cooSetSam
                "Sample current cooling setpoint when zone becomes unpopulated by 5 minutes"
                annotation (Placement(transformation(extent={{40,-280},{60,-260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler heaSetSam
                "Sample current heating setpoint when zone becomes unpopulated by 5 minutes"
                annotation (Placement(transformation(extent={{40,-320},{60,-300}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqualThreshold
                greThr(threshold=300)
                "Check whether the zone has been unpopulated for 5 minutes continuously during occupied mode"
                annotation (Placement(transformation(extent={{-160,-280},{-140,
                        -260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1
                "Adjust heating setpoint" annotation (Placement(transformation(
                      extent={{140,240},{160,260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2
                "Adjust cooling setpoint" annotation (Placement(transformation(
                      extent={{-200,340},{-180,360}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Limiter cooSetLim(final
                  uMax=TZonCooOnMax, final uMin=TZonCooOnMin)
                "Limit occupied zone cooling setpoint" annotation (Placement(
                    transformation(extent={{-240,-530},{-220,-510}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Limiter heaSetLim(final
                  uMax=TZonHeaOnMax, final uMin=TZonHeaOnMin)
                "Limit occupied zone heating setpoint" annotation (Placement(
                    transformation(extent={{-240,-590},{-220,-570}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar(p=-0.56,
                  final k=1) "Cooling setpoint minus 0.56 degC" annotation (
                  Placement(transformation(extent={{160,-590},{180,-570}})));

            protected
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu
                "Check if current operation mode is warm-up mode" annotation (
                  Placement(transformation(extent={{-300,600},{-280,620}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu1
                "Check if current operation mode is cool-down mode" annotation
                (Placement(transformation(extent={{-200,600},{-180,620}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu2
                "Check if current operation mode is occupied mode" annotation (
                  Placement(transformation(extent={{-98,600},{-78,620}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or3 or3
                "Current operation mode is occupied, warm-up, or cool-down mode"
                annotation (Placement(transformation(extent={{-20,600},{0,620}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt(final k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.warmUp)
                "Warm-up mode" annotation (Placement(transformation(extent={{-340,
                        570},{-320,590}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt1(final k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.coolDown)
                "Cool-down mode" annotation (Placement(transformation(extent={{
                        -240,570},{-220,590}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt2(final k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                "Occupied mode" annotation (Placement(transformation(extent={{-140,
                        570},{-120,590}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant cooSetAdjCon(k=(cooAdj
                     or sinAdj)) "Cooling setpoint adjustable" annotation (
                  Placement(transformation(extent={{-340,320},{-320,340}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                con(final k=0) "Zero adjustment" annotation (Placement(
                    transformation(extent={{-340,280},{-320,300}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                con3(final k=0) if not (cooAdj or sinAdj) "Zero adjustment"
                annotation (Placement(transformation(extent={{-340,360},{-320,
                        380}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                con4(final k=0) if not heaAdj "Zero adjustment" annotation (
                  Placement(transformation(extent={{-340,240},{-320,260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant heaSetAdjCon(final k=
                    heaAdj) "Heating setpoint adjustable" annotation (Placement(
                    transformation(extent={{-60,240},{-40,260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                con1(final k=0) "Zero adjustment" annotation (Placement(
                    transformation(extent={{-60,200},{-40,220}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant sinSetAdjCon(final k=
                    sinAdj) "Single common setpoint adjustable" annotation (
                  Placement(transformation(extent={{20,200},{40,220}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant con2(final k=
                    ignDemLim)
                "Check whether the zone should exempt from setpoint adjustment due to the demand limit"
                annotation (Placement(transformation(extent={{-160,-20},{-140,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant conTru(final k=
                    true) if not have_occSen "Constant true" annotation (
                  Placement(transformation(extent={{-380,-360},{-360,-340}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant conFal(final k=
                    false) if not have_winSen "Constant false" annotation (
                  Placement(transformation(extent={{-380,-480},{-360,-460}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant winSenCon(final k=
                    have_winSen) "Check if there is window status sensor"
                annotation (Placement(transformation(extent={{40,-480},{60,-460}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant have_occSenCon(final k=
                    have_occSen) "Check if there is occupancy sensor"
                annotation (Placement(transformation(extent={{160,-360},{180,-340}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                cooSetWinOpe(final k=TZonCooSetWinOpe)
                "Cooling setpoint when window is open" annotation (Placement(
                    transformation(extent={{-240,-480},{-220,-460}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                heaSetWinOpe(final k=TZonHeaSetWinOpe)
                "Heating setpoint when window is open" annotation (Placement(
                    transformation(extent={{-120,-480},{-100,-460}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                alaZer(k=-0.2) "Alarm level 0" annotation (Placement(
                    transformation(extent={{-180,-400},{-160,-380}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                alaFou(k=3.8) "Alarm level 4" annotation (Placement(
                    transformation(extent={{-140,-400},{-120,-380}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
                "Convert real input to integer output" annotation (Placement(
                    transformation(extent={{160,-400},{180,-380}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea
                "Convert boolean to real value" annotation (Placement(
                    transformation(extent={{-40,100},{-20,120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea1
                "Convert boolean to real value" annotation (Placement(
                    transformation(extent={{-40,60},{-20,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea6
                "Convert boolean to real value" annotation (Placement(
                    transformation(extent={{40,140},{60,160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea2
                "Convert boolean to real value" annotation (Placement(
                    transformation(extent={{-40,20},{-20,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea3
                "Convert boolean to real value" annotation (Placement(
                    transformation(extent={{-40,-120},{-20,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea4
                "Convert boolean to real value" annotation (Placement(
                    transformation(extent={{-40,-160},{-20,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea5
                "Convert boolean to real value" annotation (Placement(
                    transformation(extent={{-40,-200},{-20,-180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea7
                "Convert boolean to real value" annotation (Placement(
                    transformation(extent={{40,-80},{60,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and11
                "Check if window is open during operation modes other than occupied"
                annotation (Placement(transformation(extent={{-220,-420},{-200,
                        -400}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not5
                "Other than occupied mode" annotation (Placement(transformation(
                      extent={{-280,-400},{-260,-380}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessEqual lesEqu
                "Check if occupied cooling setpoint is less than unoccupied one"
                annotation (Placement(transformation(extent={{20,-550},{40,-530}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual greEqu1
                "Check if occupied heating setpoint is greater than unoccupied one"
                annotation (Placement(transformation(extent={{20,-610},{40,-590}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual greEqu2
                "Check whether heating setpoint exceeds cooling setpoint minus 0.56 degC"
                annotation (Placement(transformation(extent={{220,-590},{240,-570}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
                "Switch between occupied and unoccupied cooling setpoint"
                annotation (Placement(transformation(extent={{-300,520},{-280,
                        540}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                "Switch between occupied and unoccupied heating setpoint"
                annotation (Placement(transformation(extent={{-300,440},{-280,
                        460}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi2
                "Setpoint can only be adjusted in occupied mode" annotation (
                  Placement(transformation(extent={{-120,360},{-100,340}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi3
                "Setpoint can only be adjusted in occupied mode" annotation (
                  Placement(transformation(extent={{220,260},{240,240}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi4
                "If there is no cooling adjustment, zero adjust" annotation (
                  Placement(transformation(extent={{-280,320},{-260,340}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi5
                "If there is no heating adjustment, zero adjust" annotation (
                  Placement(transformation(extent={{0,240},{20,260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi6
                "If there is only one common adjust for both heating and cooling, use the adjust value from cooling one"
                annotation (Placement(transformation(extent={{80,240},{100,260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi7
                "Ensure heating setpoint being not higher than cooling setpoint minus 0.56 degC"
                annotation (Placement(transformation(extent={{280,-590},{300,-570}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi8
                "Ensure unoccupied heating setppint being lower than occupied one"
                annotation (Placement(transformation(extent={{100,-610},{120,-590}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi9
                "Ensure unoccupied cooling setppint being higher than occupied one"
                annotation (Placement(transformation(extent={{100,-550},{120,-530}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi10
                "Switch between occupied and unoccupied cooling setpoint"
                annotation (Placement(transformation(extent={{220,80},{240,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi11
                "Switch between occupied and unoccupied cooling setpoint"
                annotation (Placement(transformation(extent={{220,-140},{240,-120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi12
                "Increase cooling setpoint when the zone is unpopulated by more than 5 minutes"
                annotation (Placement(transformation(extent={{160,-280},{180,-260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi13
                "Decrease heating setpoint when the zone is unpopulated by more than 5 minutes"
                annotation (Placement(transformation(extent={{160,-320},{180,-300}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi14
                "Switch to TZonCooSetWinOpe when window is open" annotation (
                  Placement(transformation(extent={{-180,-460},{-160,-440}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi15
                "Switch to TZonHeaSetWinOpe when window is open" annotation (
                  Placement(transformation(extent={{-60,-460},{-40,-440}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi16
                "Generate level 4 alarm when window is open during modes other than occupied"
                annotation (Placement(transformation(extent={{-100,-420},{-80,-400}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi17
                "If it is occupied mode, cooling setpoint should be limited"
                annotation (Placement(transformation(extent={{-180,-550},{-160,
                        -530}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi18
                "If it is occupied mode, heating setpoint should be limited"
                annotation (Placement(transformation(extent={{-180,-610},{-160,
                        -590}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi19
                "If there is occupancy sensor, update heating setpoint according to the occupancy"
                annotation (Placement(transformation(extent={{220,-320},{240,-300}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi20
                "If there is occupancy sensor, update cooling setpoint according to the occupancy"
                annotation (Placement(transformation(extent={{220,-280},{240,-260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi21
                "If there is window status sensor, update heating setpoint according to the window status"
                annotation (Placement(transformation(extent={{160,-480},{180,-460}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi22
                "If there is window status sensor, update cooling setpoint according to the window status"
                annotation (Placement(transformation(extent={{100,-460},{120,-440}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu7
                "Check if the heating demand limit level is level 2"
                annotation (Placement(transformation(extent={{-100,-160},{-80,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt8(k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.heating3)
                "Heat demand limit level 3" annotation (Placement(
                    transformation(extent={{-160,-200},{-140,-180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu8
                "Check if the heating demand limit level is level 3"
                annotation (Placement(transformation(extent={{-100,-200},{-80,-180}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not4
                "Logical not" annotation (Placement(transformation(extent={{-340,
                        -280},{-320,-260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and10
                "Check if the zone becomes unpopulated during occupied mode"
                annotation (Placement(transformation(extent={{-280,-280},{-260,
                        -260}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt6(k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.heating1)
                "Heat demand limit level 1" annotation (Placement(
                    transformation(extent={{-160,-120},{-140,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu6
                "Check if the heating demand limit level is level 1"
                annotation (Placement(transformation(extent={{-100,-120},{-80,-100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt7(k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.heating2)
                "Heat demand limit level 2" annotation (Placement(
                    transformation(extent={{-160,-160},{-140,-140}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold intGreThr
                "Check if cooling demand limit level is higher than level zero"
                annotation (Placement(transformation(extent={{-340,-20},{-320,0}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold intGreThr1
                "Check if heating demand limit level is higher than level zero"
                annotation (Placement(transformation(extent={{-340,-60},{-320,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt3(k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.cooling1)
                "Cool demand limit level 1" annotation (Placement(
                    transformation(extent={{-160,100},{-140,120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu3
                "Check if the cooling demand limit level is level 1"
                annotation (Placement(transformation(extent={{-100,100},{-80,
                        120}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt4(k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.cooling2)
                "Cool demand limit level 2" annotation (Placement(
                    transformation(extent={{-160,62},{-140,82}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu4
                "Check if the cooling demand limit level is level 2"
                annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt5(k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.DemandLimitLevels.cooling3)
                "Cool demand limit level 3" annotation (Placement(
                    transformation(extent={{-160,20},{-140,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu5
                "Check if the cooling demand limit level is level 3"
                annotation (Placement(transformation(extent={{-100,20},{-80,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add3
                "Add real inputs" annotation (Placement(transformation(extent={
                        {120,118},{140,138}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add4
                "Add real inputs" annotation (Placement(transformation(extent={
                        {120,40},{140,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add5
                "Add real inputs" annotation (Placement(transformation(extent={
                        {160,80},{180,100}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add6
                "Add real inputs" annotation (Placement(transformation(extent={
                        {120,-100},{140,-80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add7
                "Add real inputs" annotation (Placement(transformation(extent={
                        {120,-180},{140,-160}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add8
                "Add real inputs" annotation (Placement(transformation(extent={
                        {160,-140},{180,-120}})));

            equation
              connect(uOpeMod, intEqu.u1)
                annotation (Line(points={{-440,630},{-320,630},{-320,610},{-302,610}},
                  color={255,127,0}));
              connect(uOpeMod, intEqu1.u1)
                annotation (Line(points={{-440,630},{-220,630},{-220,610},{-202,610}},
                  color={255,127,0}));
              connect(uOpeMod, intEqu2.u1)
                annotation (Line(points={{-440,630},{-120,630},{-120,610},{-100,610}},
                  color={255,127,0}));
              connect(conInt.y, intEqu.u2)
                annotation (Line(points={{-318,580},{-310,580},{-310,602},{-302,602}},
                  color={255,127,0}));
              connect(conInt1.y, intEqu1.u2)
                annotation (Line(points={{-218,580},{-210,580},{-210,602},{-202,602}},
                  color={255,127,0}));
              connect(conInt2.y, intEqu2.u2)
                annotation (Line(points={{-118,580},{-110,580},{-110,602},{-100,602}},
                  color={255,127,0}));
              connect(intEqu.y, or3.u1)
                annotation (Line(points={{-278,610},{-260,610},{-260,640},{-34,640},{-34,618},
                      {-22,618}},
                              color={255,0,255}));
              connect(intEqu1.y, or3.u2)
                annotation (Line(points={{-178,610},{-160,610},{-160,634},{-40,634},{-40,610},
                      {-22,610}},
                              color={255,0,255}));
              connect(intEqu2.y, or3.u3)
                annotation (Line(points={{-76,610},{-60,610},{-60,602},{-22,602}},
                  color={255,0,255}));
              connect(TZonCooSetOcc, swi.u1)
                annotation (Line(points={{-440,530},{-360,530},{-360,538},{-302,538}},
                  color={0,0,127}));
              connect(TZonCooSetUno, swi.u3)
                annotation (Line(points={{-440,490},{-360,490},{-360,522},{-302,522}},
                  color={0,0,127}));
              connect(TZonHeaSetOcc, swi1.u1)
                annotation (Line(points={{-440,450},{-360,450},{-360,458},{-302,458}},
                  color={0,0,127}));
              connect(TZonHeaSetUno, swi1.u3)
                annotation (Line(points={{-440,410},{-360,410},{-360,442},{-302,442}},
                  color={0,0,127}));
              connect(or3.y, swi.u2)
                annotation (Line(points={{2,610},{20,610},{20,560},{-320,560},{-320,530},{-302,
                      530}},   color={255,0,255}));
              connect(or3.y, swi1.u2)
                annotation (Line(points={{2,610},{20,610},{20,560},{-320,560},{-320,450},{-302,
                      450}},   color={255,0,255}));
              connect(cooSetAdjCon.y, swi4.u2)
                annotation (Line(points={{-318,330},{-282,330}}, color={255,0,255}));
              connect(setAdj, swi4.u1)
                annotation (Line(points={{-440,350},{-300,350},{-300,338},{-282,338}},
                  color={0,0,127}));
              connect(con3.y, swi4.u1)
                annotation (Line(points={{-318,370},{-300,370},{-300,338},{-282,338}},
                  color={0,0,127}));
              connect(con.y, swi4.u3)
                annotation (Line(points={{-318,290},{-300,290},{-300,322},{-282,322}},
                  color={0,0,127}));
              connect(swi4.y, add2.u2)
                annotation (Line(points={{-258,330},{-220,330},{-220,344},{-202,344}},
                  color={0,0,127}));
              connect(swi.y, add2.u1)
                annotation (Line(points={{-278,530},{-220,530},{-220,356},{-202,356}},
                  color={0,0,127}));
              connect(add2.y, swi2.u1)
                annotation (Line(points={{-178,350},{-160,350},{-160,342},{-122,342}},
                  color={0,0,127}));
              connect(swi.y, swi2.u3)
                annotation (Line(points={{-278,530},{-220,530},{-220,380},{-160,380},{-160,358},
                      {-122,358}},
                               color={0,0,127}));
              connect(intEqu2.y, swi2.u2)
                annotation (Line(points={{-76,610},{-60,610},{-60,380},{-140,380},{-140,350},
                      {-122,350}},
                               color={255,0,255}));
              connect(heaSetAdjCon.y, swi5.u2)
                annotation (Line(points={{-38,250},{-2,250}}, color={255,0,255}));
              connect(con1.y, swi5.u3)
                annotation (Line(points={{-38,210},{-20,210},{-20,242},{-2,242}},
                  color={0,0,127}));
              connect(swi5.y, swi6.u3)
                annotation (Line(points={{22,250},{40,250},{40,242},{78,242}},
                  color={0,0,127}));
              connect(sinSetAdjCon.y, swi6.u2)
                annotation (Line(points={{42,210},{60,210},{60,250},{78,250}},
                  color={255,0,255}));
              connect(swi6.y, add1.u2)
                annotation (Line(points={{102,250},{120,250},{120,244},{138,244}},
                  color={0,0,127}));
              connect(add1.y, swi3.u1)
                annotation (Line(points={{162,250},{180,250},{180,242},{218,242}},
                  color={0,0,127}));
              connect(heaSetAdj, swi5.u1)
                annotation (Line(points={{-440,270},{-20,270},{-20,258},{-2,258}},
                  color={0,0,127}));
              connect(con4.y, swi5.u1)
                annotation (Line(points={{-318,250},{-300,250},{-300,270},{-20,270},{-20,258},
                      {-2,258}},
                             color={0,0,127}));
              connect(swi4.y, swi6.u1)
                annotation (Line(points={{-258,330},{-220,330},{-220,280},{60,280},{60,258},
                      {78,258}},
                             color={0,0,127}));
              connect(swi1.y, add1.u1)
                annotation (Line(points={{-278,450},{120,450},{120,256},{138,256}},
                  color={0,0,127}));
              connect(swi1.y, swi3.u3)
                annotation (Line(points={{-278,450},{120,450},{120,280},{180,280},{180,258},
                      {218,258}},
                              color={0,0,127}));
              connect(intEqu2.y, swi3.u2)
                annotation (Line(points={{-76,610},{-60,610},{-60,380},{200,380},{200,250},{
                      218,250}},
                              color={255,0,255}));
              connect(uCooDemLimLev, intGreThr.u)
                annotation (Line(points={{-440,130},{-360,130},{-360,-10},{-342,-10}},
                  color={255,127,0}));
              connect(uHeaDemLimLev, intGreThr1.u)
                annotation (Line(points={{-440,-90},{-360,-90},{-360,-50},{-342,-50}},
                  color={255,127,0}));
              connect(intGreThr1.y, or2.u2)
                annotation (Line(points={{-318,-50},{-300,-50},{-300,-38},{-282,-38}},
                  color={255,0,255}));
              connect(intGreThr.y, or2.u1)
                annotation (Line(points={{-318,-10},{-300,-10},{-300,-30},{-282,-30}},
                  color={255,0,255}));
              connect(or2.y, edg.u)
                annotation (Line(points={{-258,-30},{-240,-30},{-240,0},{-222,0}},
                  color={255,0,255}));
              connect(intEqu3.y, booToRea.u)
                annotation (Line(points={{-78,110},{-42,110}}, color={255,0,255}));
              connect(intEqu4.y, booToRea1.u)
                annotation (Line(points={{-78,70},{-42,70}}, color={255,0,255}));
              connect(intEqu5.y, booToRea2.u)
                annotation (Line(points={{-78,30},{-42,30}}, color={255,0,255}));
              connect(uCooDemLimLev, intEqu3.u1)
                annotation (Line(points={{-440,130},{-120,130},{-120,110},{-102,110}},
                  color={255,127,0}));
              connect(uCooDemLimLev, intEqu4.u1)
                annotation (Line(points={{-440,130},{-120,130},{-120,70},{-102,70}},
                  color={255,127,0}));
              connect(uCooDemLimLev, intEqu5.u1)
                annotation (Line(points={{-440,130},{-120,130},{-120,30},{-102,30}},
                  color={255,127,0}));
              connect(conInt3.y, intEqu3.u2)
                annotation (Line(points={{-138,110},{-128,110},{-128,102},{-102,102}},
                  color={255,127,0}));
              connect(conInt4.y, intEqu4.u2)
                annotation (Line(points={{-138,72},{-128,72},{-128,62},{-102,62}},
                  color={255,127,0}));
              connect(conInt5.y, intEqu5.u2)
                annotation (Line(points={{-138,30},{-128,30},{-128,22},{-102,22}},
                  color={255,127,0}));
              connect(intEqu3.y, or1.u1)
                annotation (Line(points={{-78,110},{-66,110},{-66,158},{-42,158}},
                  color={255,0,255}));
              connect(intEqu4.y, or1.u2)
                annotation (Line(points={{-78,70},{-60,70},{-60,150},{-42,150}},
                  color={255,0,255}));
              connect(intEqu5.y, or1.u3)
                annotation (Line(points={{-78,30},{-54,30},{-54,142},{-42,142}},
                  color={255,0,255}));
              connect(or1.y, not1.u)
                annotation (Line(points={{-18,150},{-2,150}}, color={255,0,255}));
              connect(not1.y, booToRea6.u)
                annotation (Line(points={{22,150},{38,150}}, color={255,0,255}));
              connect(booToRea.y, pro.u2)
                annotation (Line(points={{-18,110},{0,110},{0,92},{70,92},{70,104},{78,104}},
                  color={0,0,127}));
              connect(cooSetFre.y, addPar2.u)
                annotation (Line(points={{-138,150},{-100,150},{-100,132},{20,132},{20,110},
                      {38,110}},
                             color={0,0,127}));
              connect(cooSetFre.y, addPar1.u)
                annotation (Line(points={{-138,150},{-100,150},{-100,132},{20,132},{20,70},{
                      38,70}},
                            color={0,0,127}));
              connect(cooSetFre.y, addPar3.u)
                annotation (Line(points={{-138,150},{-100,150},{-100,132},{20,132},{20,30},{
                      38,30}},
                            color={0,0,127}));
              connect(booToRea1.y, pro1.u2)
                annotation (Line(points={{-18,70},{0,70},{0,52},{72,52},{72,64},{78,64}},
                  color={0,0,127}));
              connect(booToRea2.y, pro2.u2)
                annotation (Line(points={{-18,30},{0,30},{0,12},{70,12},{70,24},{78,24}},
                  color={0,0,127}));
              connect(addPar2.y, pro.u1)
                annotation (Line(points={{62,110},{70,110},{70,116},{78,116}},
                  color={0,0,127}));
              connect(cooSetFre.y, pro6.u2)
                annotation (Line(points={{-138,150},{-100,150},{-100,132},{70,132},{70,144},
                      {78,144}},
                             color={0,0,127}));
              connect(booToRea6.y, pro6.u1)
                annotation (Line(points={{62,150},{70,150},{70,156},{78,156}},
                  color={0,0,127}));
              connect(addPar1.y, pro1.u1)
                annotation (Line(points={{62,70},{72,70},{72,76},{78,76}},
                  color={0,0,127}));
              connect(addPar3.y, pro2.u1)
                annotation (Line(points={{62,30},{70,30},{70,36},{78,36}},
                  color={0,0,127}));
              connect(or2.y, not3.u)
                annotation (Line(points={{-258,-30},{-102,-30}}, color={255,0,255}));
              connect(con2.y, or5.u1)
                annotation (Line(points={{-138,-10},{158,-10}}, color={255,0,255}));
              connect(not3.y, or5.u2)
                annotation (Line(points={{-78,-30},{-60,-30},{-60,-18},{158,-18}},
                  color={255,0,255}));
              connect(uHeaDemLimLev, intEqu6.u1)
                annotation (Line(points={{-440,-90},{-120,-90},{-120,-110},{-102,-110}},
                  color={255,127,0}));
              connect(uHeaDemLimLev, intEqu7.u1)
                annotation (Line(points={{-440,-90},{-120,-90},{-120,-150},{-102,-150}},
                  color={255,127,0}));
              connect(uHeaDemLimLev, intEqu8.u1)
                annotation (Line(points={{-440,-90},{-120,-90},{-120,-190},{-102,-190}},
                  color={255,127,0}));
              connect(conInt6.y, intEqu6.u2)
                annotation (Line(points={{-138,-110},{-130,-110},{-130,-118},{-102,-118}},
                  color={255,127,0}));
              connect(conInt7.y, intEqu7.u2)
                annotation (Line(points={{-138,-150},{-130,-150},{-130,-158},{-102,-158}},
                  color={255,127,0}));
              connect(conInt8.y, intEqu8.u2)
                annotation (Line(points={{-138,-190},{-130,-190},{-130,-198},{-102,-198}},
                  color={255,127,0}));
              connect(intEqu6.y, booToRea3.u)
                annotation (Line(points={{-78,-110},{-42,-110}}, color={255,0,255}));
              connect(intEqu7.y, booToRea4.u)
                annotation (Line(points={{-78,-150},{-42,-150}}, color={255,0,255}));
              connect(intEqu8.y, booToRea5.u)
                annotation (Line(points={{-78,-190},{-42,-190}}, color={255,0,255}));
              connect(intEqu6.y, or4.u1)
                annotation (Line(points={{-78,-110},{-66,-110},{-66,-62},{-42,-62}},
                  color={255,0,255}));
              connect(intEqu7.y, or4.u2)
                annotation (Line(points={{-78,-150},{-60,-150},{-60,-70},{-42,-70}},
                  color={255,0,255}));
              connect(intEqu8.y, or4.u3)
                annotation (Line(points={{-78,-190},{-54,-190},{-54,-78},{-42,-78}},
                  color={255,0,255}));
              connect(or4.y, not2.u)
                annotation (Line(points={{-18,-70},{-2,-70}}, color={255,0,255}));
              connect(not2.y, booToRea7.u)
                annotation (Line(points={{22,-70},{38,-70}}, color={255,0,255}));
              connect(booToRea7.y, pro7.u1)
                annotation (Line(points={{62,-70},{70,-70},{70,-64},{78,-64}},
                  color={0,0,127}));
              connect(heaSetFre.y, pro7.u2)
                annotation (Line(points={{-138,-70},{-100,-70},{-100,-88},{70,-88},{70,-76},
                      {78,-76}},
                             color={0,0,127}));
              connect(heaSetFre.y, addPar6.u)
                annotation (Line(points={{-138,-70},{-100,-70},{-100,-88},{20,-88},{20,-110},
                      {38,-110}},
                              color={0,0,127}));
              connect(heaSetFre.y, addPar5.u)
                annotation (Line(points={{-138,-70},{-100,-70},{-100,-88},{20,-88},{20,-150},
                      {38,-150}},
                              color={0,0,127}));
              connect(heaSetFre.y, addPar4.u)
                annotation (Line(points={{-138,-70},{-100,-70},{-100,-88},{20,-88},{20,-190},
                      {38,-190}},
                              color={0,0,127}));
              connect(addPar6.y, pro3.u1)
                annotation (Line(points={{62,-110},{70,-110},{70,-104},{78,-104}},
                  color={0,0,127}));
              connect(addPar5.y, pro4.u1)
                annotation (Line(points={{62,-150},{70,-150},{70,-144},{78,-144}},
                  color={0,0,127}));
              connect(addPar4.y, pro5.u1)
                annotation (Line(points={{62,-190},{70,-190},{70,-184},{78,-184}},
                  color={0,0,127}));
              connect(booToRea3.y, pro3.u2)
                annotation (Line(points={{-18,-110},{0,-110},{0,-126},{70,-126},{70,-116},{
                      78,-116}},
                              color={0,0,127}));
              connect(booToRea4.y, pro4.u2)
                annotation (Line(points={{-18,-150},{0,-150},{0,-166},{70,-166},{70,-156},{
                      78,-156}},
                              color={0,0,127}));
              connect(booToRea5.y, pro5.u2)
                annotation (Line(points={{-18,-190},{0,-190},{0,-206},{70,-206},{70,-196},{
                      78,-196}},
                              color={0,0,127}));
              connect(edg.y, cooSetFre.trigger)
                annotation (Line(points={{-198,0},{-180,0},{-180,134},{-150,134},{-150,138.2}},
                  color={255,0,255}));
              connect(edg.y, heaSetFre.trigger)
                annotation (Line(points={{-198,0},{-180,0},{-180,-86},{-150,-86},{-150,-81.8}},
                  color={255,0,255}));
              connect(or5.y, swi10.u2)
                annotation (Line(points={{182,-10},{200,-10},{200,90},{218,90}},
                  color={255,0,255}));
              connect(or5.y, swi11.u2)
                annotation (Line(points={{182,-10},{200,-10},{200,-130},{218,-130}},
                  color={255,0,255}));
              connect(swi2.y, cooSetFre.u)
                annotation (Line(points={{-98,350},{-80,350},{-80,180},{-180,180},{-180,150},
                      {-162,150}},
                               color={0,0,127}));
              connect(swi2.y, swi10.u1)
                annotation (Line(points={{-98,350},{-80,350},{-80,180},{200,180},{200,98},{218,
                      98}},
                  color={0,0,127}));
              connect(swi3.y, heaSetFre.u)
                annotation (Line(points={{242,250},{260,250},{260,186},{-186,186},{-186,-70},
                      {-162,-70}},
                               color={0,0,127}));
              connect(swi3.y, swi11.u1)
                annotation (Line(points={{242,250},{260,250},{260,186},{-186,186},{-186,-48},
                      {208,-48},{208,-122},{218,-122}},
                                                    color={0,0,127}));
              connect(uOccSen, not4.u)
                annotation (Line(points={{-440,-270},{-342,-270}}, color={255,0,255}));
              connect(conTru.y, not4.u)
                annotation (Line(points={{-358,-350},{-350,-350},{-350,-270},{-342,-270}},
                  color={255,0,255}));
              connect(and10.y, tim.u)
                annotation (Line(points={{-258,-270},{-222,-270}}, color={255,0,255}));
              connect(tim.y, greThr.u)
                annotation (Line(points={{-198,-270},{-162,-270}}, color={0,0,127}));
              connect(greThr.y, truHol.u)
                annotation (Line(points={{-138,-270},{-102,-270}}, color={255,0,255}));
              connect(truHol.y, edg1.u)
                annotation (Line(points={{-78,-270},{-42,-270}}, color={255,0,255}));
              connect(edg1.y, cooSetSam.trigger)
                annotation (Line(points={{-18,-270},{0,-270},{0,-288},{50,-288},{50,-281.8}},
                  color={255,0,255}));
              connect(edg1.y, heaSetSam.trigger)
                annotation (Line(points={{-18,-270},{0,-270},{0,-330},{50,-330},{50,-321.8}},
                  color={255,0,255}));
              connect(cooSetSam.y, cooSetInc.u)
                annotation (Line(points={{62,-270},{98,-270}}, color={0,0,127}));
              connect(heaSetSam.y, heaSetDec.u)
                annotation (Line(points={{62,-310},{98,-310}}, color={0,0,127}));
              connect(cooSetInc.y, swi12.u1)
                annotation (Line(points={{122,-270},{136,-270},{136,-262},{158,-262}},
                  color={0,0,127}));
              connect(heaSetDec.y, swi13.u1)
                annotation (Line(points={{122,-310},{136,-310},{136,-302},{158,-302}},
                  color={0,0,127}));
              connect(truHol.y, swi12.u2)
                annotation (Line(points={{-78,-270},{-60,-270},{-60,-250},{140,-250},{140,-270},
                      {158,-270}},
                               color={255,0,255}));
              connect(truHol.y, swi13.u2)
                annotation (Line(points={{-78,-270},{-60,-270},{-60,-250},{140,-250},{140,-310},
                      {158,-310}},
                               color={255,0,255}));
              connect(swi11.y, swi13.u3)
                annotation (Line(points={{242,-130},{260,-130},{260,-240},{144,-240},{144,-318},
                      {158,-318}},
                               color={0,0,127}));
              connect(swi10.y, swi12.u3)
                annotation (Line(points={{242,90},{264,90},{264,-244},{148,-244},{148,-278},
                      {158,-278}},
                               color={0,0,127}));
              connect(intEqu2.y, and10.u1)
                annotation (Line(points={{-76,610},{-60,610},{-60,380},{280,380},{280,-220},
                      {-300,-220},{-300,-270},{-282,-270}},
                                                        color={255,0,255}));
              connect(not4.y, and10.u2)
                annotation (Line(points={{-318,-270},{-308,-270},{-308,-278},{-282,-278}},
                  color={255,0,255}));
              connect(swi11.y, heaSetSam.u)
                annotation (Line(points={{242,-130},{260,-130},{260,-240},{20,-240},{20,-310},
                      {38,-310}},
                              color={0,0,127}));
              connect(swi10.y, cooSetSam.u)
                annotation (Line(points={{242,90},{264,90},{264,-244},{24,-244},{24,-270},{38,
                      -270}}, color={0,0,127}));
              connect(have_occSenCon.y, swi20.u2)
                annotation (Line(points={{182,-350},{200,-350},{200,-270},{218,-270}},
                  color={255,0,255}));
              connect(have_occSenCon.y, swi19.u2)
                annotation (Line(points={{182,-350},{200,-350},{200,-310},{218,-310}},
                  color={255,0,255}));
              connect(swi12.y, swi20.u1)
                annotation (Line(points={{182,-270},{196,-270},{196,-262},{218,-262}},
                  color={0,0,127}));
              connect(swi13.y, swi19.u1)
                annotation (Line(points={{182,-310},{196,-310},{196,-302},{218,-302}},
                  color={0,0,127}));
              connect(swi10.y, swi20.u3)
                annotation (Line(points={{242,90},{264,90},{264,-244},{208,-244},{208,-278},
                      {218,-278}},
                               color={0,0,127}));
              connect(swi11.y, swi19.u3)
                annotation (Line(points={{242,-130},{260,-130},{260,-240},{204,-240},{204,-318},
                      {218,-318}},
                               color={0,0,127}));
              connect(intEqu2.y, not5.u)
                annotation (Line(points={{-76,610},{-60,610},{-60,380},{280,380},{280,-220},
                      {-300,-220},{-300,-390},{-282,-390}},
                                                        color={255,0,255}));
              connect(uWinSta, and11.u2)
                annotation (Line(points={{-440,-410},{-260,-410},{-260,-418},{-222,-418}},
                  color={255,0,255}));
              connect(not5.y, and11.u1)
                annotation (Line(points={{-258,-390},{-240,-390},{-240,-410},{-222,-410}},
                  color={255,0,255}));
              connect(and11.y, swi16.u2)
                annotation (Line(points={{-198,-410},{-102,-410}}, color={255,0,255}));
              connect(alaFou.y, swi16.u1)
                annotation (Line(points={{-118,-390},{-112,-390},{-112,-402},{-102,-402}},
                  color={0,0,127}));
              connect(alaZer.y, swi16.u3)
                annotation (Line(points={{-158,-390},{-150,-390},{-150,-418},{-102,-418}},
                  color={0,0,127}));
              connect(swi16.y, reaToInt.u)
                annotation (Line(points={{-78,-410},{-64,-410},{-64,-390},{158,-390}},
                  color={0,0,127}));
              connect(uWinSta, swi14.u2)
                annotation (Line(points={{-440,-410},{-260,-410},{-260,-432},{-200,-432},
                  {-200,-450},{-182,-450}}, color={255,0,255}));
              connect(uWinSta, swi15.u2)
                annotation (Line(points={{-440,-410},{-260,-410},{-260,-432},{-80,-432},
                  {-80,-450},{-62,-450}}, color={255,0,255}));
              connect(cooSetWinOpe.y, swi14.u1)
                annotation (Line(points={{-218,-470},{-204,-470},{-204,-442},{-182,-442}},
                  color={0,0,127}));
              connect(heaSetWinOpe.y, swi15.u1)
                annotation (Line(points={{-98,-470},{-84,-470},{-84,-442},{-62,-442}},
                  color={0,0,127}));
              connect(winSenCon.y, swi22.u2)
                annotation (Line(points={{62,-470},{80,-470},{80,-450},{98,-450}},
                  color={255,0,255}));
              connect(winSenCon.y, swi21.u2)
                annotation (Line(points={{62,-470},{158,-470}}, color={255,0,255}));
              connect(swi19.y, swi15.u3)
                annotation (Line(points={{242,-310},{260,-310},{260,-432},{-76,-432},{-76,-458},
                      {-62,-458}},
                               color={0,0,127}));
              connect(swi19.y, swi21.u3)
                annotation (Line(points={{242,-310},{260,-310},{260,-432},{140,-432},{140,-478},
                      {158,-478}},
                               color={0,0,127}));
              connect(swi20.y, swi14.u3)
                annotation (Line(points={{242,-270},{256,-270},{256,-428},{-196,-428},{-196,
                      -458},{-182,-458}},
                                color={0,0,127}));
              connect(swi20.y, swi22.u3)
                annotation (Line(points={{242,-270},{256,-270},{256,-428},{84,-428},{84,-458},
                      {98,-458}},
                              color={0,0,127}));
              connect(swi14.y, swi22.u1)
                annotation (Line(points={{-158,-450},{-140,-450},{-140,-424},{88,-424},{88,-442},
                      {98,-442}},
                              color={0,0,127}));
              connect(swi15.y, swi21.u1)
                annotation (Line(points={{-38,-450},{-20,-450},{-20,-420},{144,-420},{144,-462},
                      {158,-462}},
                               color={0,0,127}));
              connect(conFal.y, and11.u2)
                annotation (Line(points={{-358,-470},{-340,-470},{-340,-410},{-260,-410},{-260,
                      -418},{-222,-418}},
                                color={255,0,255}));
              connect(conFal.y, swi14.u2)
                annotation (Line(points={{-358,-470},{-340,-470},{-340,-410},{-260,-410},{-260,
                      -432},{-200,-432},{-200,-450},{-182,-450}},
                                                        color={255,0,255}));
              connect(conFal.y, swi15.u2)
                annotation (Line(points={{-358,-470},{-340,-470},{-340,-410},{-260,-410},{-260,
                      -432},{-80,-432},{-80,-450},{-62,-450}},
                                                     color={255,0,255}));
              connect(swi22.y, cooSetLim.u)
                annotation (Line(points={{122,-450},{136,-450},{136,-500},{-260,-500},{-260,
                      -520},{-242,-520}},
                                color={0,0,127}));
              connect(swi21.y, heaSetLim.u)
                annotation (Line(points={{182,-470},{200,-470},{200,-496},{-264,-496},{-264,
                      -580},{-242,-580}},
                                color={0,0,127}));
              connect(cooSetLim.y, swi17.u1)
                annotation (Line(points={{-218,-520},{-192,-520},{-192,-532},{-182,-532}},
                  color={0,0,127}));
              connect(heaSetLim.y, swi18.u1)
                annotation (Line(points={{-218,-580},{-192,-580},{-192,-592},{-182,-592}},
                  color={0,0,127}));
              connect(swi22.y, swi17.u3)
                annotation (Line(points={{122,-450},{136,-450},{136,-500},{-198,-500},{-198,
                      -548},{-182,-548}},
                                color={0,0,127}));
              connect(swi21.y, swi18.u3)
                annotation (Line(points={{182,-470},{200,-470},{200,-496},{-204,-496},{-204,
                      -608},{-182,-608}},
                                color={0,0,127}));
              connect(intEqu2.y, swi17.u2)
                annotation (Line(points={{-76,610},{-60,610},{-60,380},{280,380},{280,-220},
                      {-300,-220},{-300,-540},{-182,-540}},
                                                        color={255,0,255}));
              connect(intEqu2.y, swi18.u2)
                annotation (Line(points={{-76,610},{-60,610},{-60,380},{280,380},{280,-220},
                      {-300,-220},{-300,-600},{-182,-600}},
                                                        color={255,0,255}));
              connect(swi17.y,lesEqu. u1)
                annotation (Line(points={{-158,-540},{18,-540}}, color={0,0,127}));
              connect(lesEqu.y, swi9.u2)
                annotation (Line(points={{42,-540},{98,-540}}, color={255,0,255}));
              connect(swi18.y, greEqu1.u1)
                annotation (Line(points={{-158,-600},{18,-600}}, color={0,0,127}));
              connect(greEqu1.y, swi8.u2)
                annotation (Line(points={{42,-600},{98,-600}}, color={255,0,255}));
              connect(swi17.y, swi9.u1)
                annotation (Line(points={{-158,-540},{-100,-540},{-100,-520},{80,-520},{80,-532},
                      {98,-532}},       color={0,0,127}));
              connect(swi18.y, swi8.u1)
                annotation (Line(points={{-158,-600},{-100,-600},{-100,-580},{80,-580},{80,-592},
                      {98,-592}},       color={0,0,127}));
              connect(TZonCooSetUno,lesEqu. u2)
                annotation (Line(points={{-440,490},{-400,490},{-400,-560},{0,-560},
                  {0,-548},{18,-548}}, color={0,0,127}));
              connect(TZonCooSetUno, swi9.u3)
                annotation (Line(points={{-440,490},{-400,490},{-400,-560},{80,-560},
                  {80,-548},{98,-548}}, color={0,0,127}));
              connect(TZonHeaSetUno, greEqu1.u2)
                annotation (Line(points={{-440,410},{-406,410},{-406,-620},{0,-620},
                  {0,-608},{18,-608}}, color={0,0,127}));
              connect(TZonHeaSetUno, swi8.u3)
                annotation (Line(points={{-440,410},{-406,410},{-406,-620},{80,-620},
                  {80,-608},{98,-608}}, color={0,0,127}));
              connect(swi9.y, addPar.u)
                annotation (Line(points={{122,-540},{140,-540},{140,-580},{158,-580}},
                  color={0,0,127}));
              connect(greEqu2.y, swi7.u2)
                annotation (Line(points={{242,-580},{278,-580}}, color={255,0,255}));
              connect(swi8.y, greEqu2.u1)
                annotation (Line(points={{122,-600},{206,-600},{206,-580},{218,-580}},
                  color={0,0,127}));
              connect(addPar.y, greEqu2.u2)
                annotation (Line(points={{182,-580},{200,-580},{200,-588},{218,-588}},
                  color={0,0,127}));
              connect(swi8.y, swi7.u3)
                annotation (Line(points={{122,-600},{260,-600},{260,-588},{278,-588}},
                  color={0,0,127}));
              connect(addPar.y, swi7.u1)
                annotation (Line(points={{182,-580},{200,-580},{200,-560},{260,-560},{260,-572},
                      {278,-572}},        color={0,0,127}));
              connect(swi7.y, TZonHeaSet)
                annotation (Line(points={{302,-580},{320,-580},{320,-100},{360,-100}},
                  color={0,0,127}));
              connect(swi9.y, TZonCooSet)
                annotation (Line(points={{122,-540},{300,-540},{300,0},{360,0}},
                  color={0,0,127}));
              connect(reaToInt.y, yAla)
                annotation (Line(points={{182,-390},{360,-390}}, color={255,127,0}));

              connect(pro6.y, add3.u1) annotation (Line(points={{102,150},{110,150},{110,
                      134},{118,134}}, color={0,0,127}));
              connect(pro.y, add3.u2) annotation (Line(points={{102,110},{110,110},{110,122},
                      {118,122}}, color={0,0,127}));
              connect(pro1.y, add4.u1) annotation (Line(points={{102,70},{110,70},{110,56},
                      {118,56}}, color={0,0,127}));
              connect(pro2.y, add4.u2) annotation (Line(points={{102,30},{110,30},{110,44},
                      {118,44}}, color={0,0,127}));
              connect(add3.y, add5.u1) annotation (Line(points={{142,128},{150,128},{150,96},
                      {158,96}}, color={0,0,127}));
              connect(add4.y, add5.u2) annotation (Line(points={{142,50},{150,50},{150,84},
                      {158,84}}, color={0,0,127}));
              connect(add5.y, swi10.u3) annotation (Line(points={{182,90},{190,90},{190,82},
                      {218,82}}, color={0,0,127}));
              connect(pro7.y, add6.u1) annotation (Line(points={{102,-70},{110,-70},{110,
                      -84},{118,-84}}, color={0,0,127}));
              connect(pro3.y, add6.u2) annotation (Line(points={{102,-110},{110,-110},{110,
                      -96},{118,-96}}, color={0,0,127}));
              connect(pro4.y, add7.u1) annotation (Line(points={{102,-150},{110,-150},{110,
                      -164},{118,-164}}, color={0,0,127}));
              connect(pro5.y, add7.u2) annotation (Line(points={{102,-190},{110,-190},{110,
                      -176},{118,-176}}, color={0,0,127}));
              connect(add6.y, add8.u1) annotation (Line(points={{142,-90},{150,-90},{150,
                      -124},{158,-124}}, color={0,0,127}));
              connect(add7.y, add8.u2) annotation (Line(points={{142,-170},{150,-170},{150,
                      -136},{158,-136}}, color={0,0,127}));
              connect(add8.y, swi11.u3) annotation (Line(points={{182,-130},{190,-130},{190,
                      -138},{218,-138}}, color={0,0,127}));
            annotation (
              defaultComponentName="TZonSet",
              Icon(coordinateSystem(extent={{-200,-200},{200,200}}),
                   graphics={
                    Rectangle(
                    extent={{-200,-200},{200,200}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-196,146},{-118,116}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonCooSetOcc"),
                    Text(
                      extent={{-194,62},{-112,38}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonHeaSetOcc"),
                    Text(
                      extent={{-194,22},{-114,0}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonHeaSetUno"),
                    Text(
                      extent={{-192,106},{-112,74}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonCooSetUno"),
                    Text(
                      visible=heaAdj,
                      extent={{-196,-58},{-126,-78}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="heaSetAdj"),
                    Text(
                      visible=cooAdj or sinAdj,
                      extent={{-194,-16},{-152,-34}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="setAdj"),
                    Text(
                      extent={{-194,190},{-130,172}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uOpeMod"),
                    Text(
                      extent={{-190,-122},{-88,-156}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uCooDemLimLev"),
                    Text(
                      extent={{-192,-170},{-92,-190}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uHeaDemLimLev"),
                    Text(
                      extent={{-28.5,8.5},{28.5,-8.5}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uOccSen",
                      visible = have_occSen,
                      origin={-60.5,-164.5},
                      rotation=90),
                    Text(
                      extent={{-26.5,9.5},{26.5,-9.5}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="uWinSta",
                      visible = have_winSen,
                      origin={60.5,-164.5},
                      rotation=90),
                    Text(
                      extent={{158,-68},{200,-86}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="yAla"),
                    Text(
                      extent={{142,86},{194,70}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonCooSet"),
                    Text(
                      extent={{142,10},{196,-8}},
                      lineColor={0,0,127},
                      pattern=LinePattern.Dash,
                      textString="TZonHeaSet"),
                    Text(
                      extent={{-156,286},{124,208}},
                      lineColor={0,0,255},
                      textString="%name")}),
              Diagram(coordinateSystem(
                    preserveAspectRatio=false,
                    extent={{-420,-620},{340,640}}), graphics={
                    Rectangle(
                      extent={{-412,636},{330,558}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-412,548},{330,402}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-412,390},{330,186}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-412,174},{332,-212}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-412,-228},{330,-366}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-412,-376},{330,-490}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{-412,-502},{-138,-614}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Text(
                      extent={{124,632},{322,596}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Operation mode recognition"),
                    Text(
                      extent={{176,550},{324,506}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Setpoints recognition"),
                    Text(
                      extent={{132,382},{324,332}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      textString="Local setpoints adjustment"),
                    Text(
                      extent={{-288,-264},{-36,-358}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Left,
                      textString="Adjust setpoints due to occupancy"),
                    Text(
                      extent={{-34,-384},{252,-430}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Left,
                      textString="Adjust setpoints due to window status"),
                    Rectangle(
                      extent={{-126,-504},{122,-614}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Rectangle(
                      extent={{134,-504},{330,-614}},
                      lineColor={0,0,0},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      pattern=LinePattern.None),
                    Text(
                      extent={{-394,-540},{-184,-584}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Left,
                      textString="Setpoints limited
in the range"),     Text(
                      extent={{-124,-526},{76,-594}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Left,
                      textString="Limit occupied by
unoccupied"),       Text(
                      extent={{34,-478},{298,-564}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Right,
                      textString="Confine cooling setpoint
by heating one"),   Text(
                      extent={{74,192},{326,98}},
                      lineColor={0,0,255},
                      fillColor={215,215,215},
                      fillPattern=FillPattern.Solid,
                      horizontalAlignment=TextAlignment.Right,
                      textString="Demand limit setpoints
adjustment")}),
              Documentation(info="<html>
<p>
This sequence sets the thermal zone cooling and heating setpoints. The implementation
is according to the ASHRAE Guideline 36 (G36), PART 5.B.3. The calculation is done
following the steps below.
</p>
<h4>Each zone shall have separate occupied and unoccupied heating and cooling
setpoints.</h4>
<h4>The active setpoints shall be determined by the Operation Mode of the zone
group.</h4>
<ul>
<li>The setpoints shall be the occupied setpoints during Occupied, Warm up, and
Cool-down modes.</li>
<li>The setpoints shall be the unoccupied setpoints during Unoccupied, Setback,
and Setup modes.</li>
</ul>
<h4>The software shall prevent</h4>
<ul>
<li>The heating setpoint from exceeding the cooling setpoint minus 0.56 &deg;C
(1 &deg;F).</li>
<li>The unoccupied heating setpoint from exceeding the occupied heating
setpoint.</li>
<li>The unoccupied cooling setpoint from being less than occupied cooling
setpoint.</li>
</ul>
<h4>Where the zone has a local setpoint adjustment knob/button </h4>
<ul>
<li>The setpoint adjustment offsets established by the occupant shall be software
points that are persistent (e.g. not reset daily), but the actual offset used
in control logic shall be adjusted based on limits and modes as described below.</li>
<li>The adjustment shall be capable of being limited in softare. (a. As a default,
the active occupied cooling setpoint shall be limited between 22 &deg;C
(72 &deg;F) and 27 &deg;C (80 &deg;F); b. As a default, the active occupied
heating setpoint shall be limited between 18 &deg;C (65 &deg;F) and 22 &deg;C
(72 &deg;F);)</li>
<li>The active heating and cooling setpoint shall be independently adjustable,
respecting the limits and anti-overlap logic described above. If zone thermostat
provides only a single setpoint adjustment, then the adjustment shall move both
the same amount, within the limits described above.</li>
<li>The adjustment shall only affect occupied setpoints in Occupied mode, and
shall have no impact on setpoints in all other modes.</li>
<li>At the onset of demand limiting, the local setpoint adjustment value shall
be frozen. Further adjustment of the setpoint by local controls shall be suspended
for the duration of the demand limit event.</li>
</ul>
<h4>Cooling demand limit setpoint adjustment</h4>
<p>The active cooling setpoints for all zones shall be increased when a demand limit
is imposed on the associated zone group. The operator shall have the ability
to exempt individual zones from this adjustment through the normal
Building Automation System (BAS) user interface. Changes due to demand limits
are not cumulative.</p>
<ul>
<li>At Demand Limit Level 1, increase setpoint by 0.56 &deg;C (1 &deg;F).</li>
<li>At Demand Limit Level 2, increase setpoint by 1.1 &deg;C (2 &deg;F).</li>
<li>At Demand Limit Level 1, increase setpoint by 2.2 &deg;C (4 &deg;F).</li>
</ul>
<h4>Heating demand limit setpoint adjustment</h4>
<p>The active heating setpoints for all zones shall be decreased when a demand limit
is imposed on the associated zone group. The operator shall have the ability
to exempt individual zones from this adjustment through the normal BAS user
interface. Changes due to demand limits are not cumulative.</p>
<ul>
<li>At Demand Limit Level 1, decrease setpoint by 0.56 &deg;C (1 &deg;F).</li>
<li>At Demand Limit Level 2, decrease setpoint by 1.1 &deg;C (2 &deg;F).</li>
<li>At Demand Limit Level 1, decrease setpoint by 2.2 &deg;C (4 &deg;F).</li>
</ul>
<h4>Window switches</h4>
<p>For zones that have operable windows with indicator switches, when the window
switch indicates the window is open, the heating setpoint shall be temporarily
set to 4.4 &deg;C (40 &deg;F) and the cooling setpoint shall be temporarily
set to 49 &deg;C (120 &deg;F). When the window switch indicates the window is
open during other than Occupied Mode, a Level 4 alarm shall be generated.</p>
<h4>h. Occupancy sensor</h4>
<ul>
<li>When the switch indicates the space has been unpopulated for 5 minutes
continuously during the Occupied Mode, the active heating setpoint shall be
decreased by 1.1 &deg;C (2 &deg;F) and the cooling setpoint shall be increased
by 1.1 &deg;C (2 &deg;F).</li>
<li>When the switch indicated that the space has been populated for 1 minute
continuously, the active heating and cooling setpoints shall be restored to
their previously values.</li>
</ul>
<p>Hierarchy of setpoint adjustments: the following adjustment restrictions
shall prevail in order from highest to lowest priority.</p>
<ul>
<li>Setpoint overlap restriction</li>
<li>Absolute limits on local setpoint adjustment</li>
<li>Window swtiches</li>
<li>Demand limit (a. Occupancy sensors; b. Local setpoint adjustment)</li>
<li>Scheduled setpoints based on zone group mode</li>
</ul>

</html>",             revisions="<html>
<ul>
<li>
October 11, 2017, by Michael Wetter:<br/>
Removed wrong conditional on <code>yAla</code>.
</li>
<li>
August 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
            end ZoneTemperatures;

            package Validation "Collection of validation models"

              model ZoneTemperatures "Validate block for zone set point"
                hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.SetPoints.ZoneTemperatures
                  TZonSet(
                  have_occSen=true,
                  sinAdj=false,
                  cooAdj=true,
                  have_winSen=true,
                  heaAdj=true)
                  "Block that determines the thermal zone setpoints"
                  annotation (Placement(transformation(extent={{60,40},{100,80}})));

                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonCooSetOcc(k=297.15) "Occupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-100,80},{-80,
                          100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonHeaSetOcc(k=293.15) "Occupied heating setpoint"
                  annotation (Placement(transformation(extent={{-60,80},{-40,
                          100}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonCooSetUno(k=303.15) "Unoccupied cooling setpoint"
                  annotation (Placement(transformation(extent={{-100,40},{-80,
                          60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  TZonHeaSetUno(k=287.15) "Unoccupied heating setpoint"
                  annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine cooSetAdj(freqHz=1/
                      28800) "Cooling setpoint adjustment" annotation (
                    Placement(transformation(extent={{-100,10},{-80,30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine heaSetAdj(freqHz=1/
                      28800, amplitude=0.5) "Heating setpoint adjustment"
                  annotation (Placement(transformation(extent={{-100,-30},{-80,
                          -10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  cooDemLimLev(k=0) "Cooling demand limit level" annotation (
                    Placement(transformation(extent={{-140,-70},{-120,-50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant
                  heaDemLimLev(k=0) "Heating demand limit level" annotation (
                    Placement(transformation(extent={{-60,-70},{-40,-50}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram(duration=
                      28800) "Generate ramp output" annotation (Placement(
                      transformation(extent={{-140,-100},{-120,-80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterThreshold
                  greThr(threshold=0.75) "Check if input is greater than 0.75"
                  annotation (Placement(transformation(extent={{-100,-100},{-80,
                          -80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
                  booToInt(integerTrue=1, integerFalse=7)
                  "Convert boolean input to integer output" annotation (
                    Placement(transformation(extent={{-20,-100},{0,-80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse winSta(period=
                      14400, startTime=1200)
                  "Generate signal indicating window status" annotation (
                    Placement(transformation(extent={{40,-30},{60,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse occSta(period=
                      14400, width=0.95)
                  "Generate signal indicating occupancy status" annotation (
                    Placement(transformation(extent={{40,10},{60,30}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
                  "Logical not" annotation (Placement(transformation(extent={{-60,
                          -100},{-40,-80}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                  zerAdj(k=0) "Zero adjustment" annotation (Placement(
                      transformation(extent={{-140,-10},{-120,10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
                  "Switch to zero adjustment when window is open" annotation (
                    Placement(transformation(extent={{-40,-30},{-20,-10}})));
                hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi2
                  "Switch to zero adjustment when window is open" annotation (
                    Placement(transformation(extent={{-40,10},{-20,30}})));

              equation
                connect(ram.y, greThr.u)
                  annotation (Line(points={{-118,-90},{-102,-90}}, color={0,0,127}));
                connect(greThr.y, not1.u)
                  annotation (Line(points={{-78,-90},{-62,-90}}, color={255,0,255}));
                connect(not1.y, booToInt.u)
                  annotation (Line(points={{-38,-90},{-22,-90}}, color={255,0,255}));
                connect(TZonCooSetOcc.y, TZonSet.TZonCooSetOcc) annotation (Line(points={{-78,90},
                        {-72,90},{-72,108},{30,108},{30,73},{58,73}}, color={0,0,127}));
                connect(TZonHeaSetOcc.y, TZonSet.TZonHeaSetOcc) annotation (Line(points={{-38,90},
                        {26,90},{26,64.8},{58,64.8}},
                                                  color={0,0,127}));
                connect(TZonCooSetUno.y, TZonSet.TZonCooSetUno) annotation (Line(points={{-78,50},
                        {-72,50},{-72,68.8},{58,68.8}},
                                                    color={0,0,127}));
                connect(TZonHeaSetUno.y, TZonSet.TZonHeaSetUno) annotation (Line(points={{-38,50},
                        {-32,50},{-32,61},{58,61}}, color={0,0,127}));
                connect(cooDemLimLev.y, TZonSet.uCooDemLimLev)
                  annotation (Line(points={{-118,-60},{-100,-60},{-100,-40},{22,-40},{22,46},
                        {58,46}},     color={255,127,0}));
                connect(heaDemLimLev.y, TZonSet.uHeaDemLimLev)
                  annotation (Line(points={{-38,-60},{26,-60},{26,42},{58,42}},
                    color={255,127,0}));
                connect(booToInt.y, TZonSet.uOpeMod)
                  annotation (Line(points={{2,-90},{18,-90},{18,78},{58,78}},
                    color={255,127,0}));
                connect(occSta.y, TZonSet.uOccSen)
                  annotation (Line(points={{62,20},{74,20},{74,38}},
                    color={255,0,255}));
                connect(winSta.y, TZonSet.uWinSta)
                  annotation (Line(points={{62,-20},{86,-20},{86,38}}, color={255,0,255}));
                connect(winSta.y, swi2.u2)
                  annotation (Line(points={{62,-20},{86,-20},{86,0},{-60,0},{-60,20},{-42,20}},
                               color={255,0,255}));
                connect(winSta.y, swi1.u2)
                  annotation (Line(points={{62,-20},{86,-20},{86,0},{-60,0},{-60,-20},{-42,
                        -20}},  color={255,0,255}));
                connect(zerAdj.y, swi2.u1)
                  annotation (Line(points={{-118,0},{-64,0},{-64,28},{-42,28}},
                    color={0,0,127}));
                connect(zerAdj.y, swi1.u1)
                  annotation (Line(points={{-118,0},{-64,0},{-64,-12},{-42,-12}},
                    color={0,0,127}));
                connect(cooSetAdj.y, swi2.u3)
                  annotation (Line(points={{-78,20},{-68,20},{-68,12},{-42,12}},
                    color={0,0,127}));
                connect(heaSetAdj.y, swi1.u3)
                  annotation (Line(points={{-78,-20},{-68,-20},{-68,-28},{-42,-28}},
                    color={0,0,127}));
                connect(swi2.y, TZonSet.setAdj)
                  annotation (Line(points={{-18,20},{-2,20},{-2,57},{58,57}},
                    color={0,0,127}));
                connect(swi1.y, TZonSet.heaSetAdj)
                  annotation (Line(points={{-18,-20},{2,-20},{2,53},{58,53}},
                    color={0,0,127}));
                annotation (
                experiment(StopTime=28800, Tolerance=1e-6),
                __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/TerminalUnits/SetPoints/Validation/ZoneTemperatures.mos"
                      "Simulate and plot"),
                  Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.SetPoints.ZoneTemperatures\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.SetPoints.ZoneTemperatures</a>
for a change of zone setpoint temperature.
</p>
</html>",               revisions="<html>
<ul>
<li>
August 19, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),        Diagram(coordinateSystem(extent={{-140,-120},{120,120}})),
                  Icon(graphics={
                      Ellipse(lineColor = {75,138,73},
                              fillColor={255,255,255},
                              fillPattern = FillPattern.Solid,
                              extent = {{-100,-100},{100,100}}),
                      Polygon(lineColor = {0,0,255},
                              fillColor = {75,138,73},
                              pattern = LinePattern.None,
                              fillPattern = FillPattern.Solid,
                              points = {{-36,60},{64,0},{-36,-60},{-36,60}}),
                                 Ellipse(
                        lineColor={75,138,73},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid,
                        extent={{-100,-100},{100,100}}), Polygon(
                        lineColor={0,0,255},
                        fillColor={75,138,73},
                        pattern=LinePattern.None,
                        fillPattern=FillPattern.Solid,
                        points={{-36,58},{64,-2},{-36,-62},{-36,58}})}));
              end ZoneTemperatures;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.SetPoints\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.SetPoints</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),    Icon(graphics={
                    Rectangle(
                      lineColor={200,200,200},
                      fillColor={248,248,248},
                      fillPattern=FillPattern.HorizontalCylinder,
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Rectangle(
                      lineColor={128,128,128},
                      extent={{-100.0,-100.0},{100.0,100.0}},
                      radius=25.0),
                    Polygon(
                      origin={8.0,14.0},
                      lineColor={78,138,73},
                      fillColor={78,138,73},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
            end Validation;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains generic sequences for generating setpoints for various
terminal units control, according to ASHRAE Guideline 36, Part 5.B.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  textString="S")}));
          end SetPoints;

          package Validation "Collection of validation models"

            model Controller "Validate model for controlling VAV terminal box with reheat"

              hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.Controller
                con(
                AFlo=50,
                samplePeriod=120,
                V_flow_nominal=(50*3/3600)*6)
                "Controller for VAV terminal unit with reheat" annotation (
                  Placement(transformation(extent={{40,60},{60,80}})));
              hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.Controller
                con1(
                AFlo=50,
                samplePeriod=120,
                V_flow_nominal=(50*3/3600)*6,
                have_occSen=true,
                have_winSen=true,
                have_CO2Sen=true)
                "Controller for VAV terminal unit with reheat"
                annotation (Placement(transformation(extent={{40,0},{60,20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                TSetRooCoo(k=273.15 + 24) "Room cooling setpoint " annotation (
                  Placement(transformation(extent={{-60,90},{-40,110}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp disAirFlo(
                offset=0.02,
                height=0.0168,
                duration=3600) "Discharge airflow rate" annotation (Placement(
                    transformation(extent={{-100,50},{-80,70}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp TZon(
                height=6,
                offset=273.15 + 17,
                duration=3600) "Measured room temperature" annotation (
                  Placement(transformation(extent={{-60,20},{-40,40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp TDis(
                height=4,
                duration=3600,
                offset=273.15 + 18) "Terminal unit discharge air temperature"
                annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp TSup(
                height=4,
                duration=3600,
                offset=273.15 + 14) "AHU supply air temperature" annotation (
                  Placement(transformation(extent={{-60,-30},{-40,-10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant opeMod(final k=
                    hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.Types.OperationModes.occupied)
                "AHU operation mode is Occupied" annotation (Placement(
                    transformation(extent={{-20,-60},{0,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                TSetRooHea(k=273.15 + 20) "Room heating setpoint" annotation (
                  Placement(transformation(extent={{-100,90},{-80,110}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ppmCO2(
                duration=3600,
                height=800,
                offset=200) "CO2 concentration" annotation (Placement(
                    transformation(extent={{-20,-100},{0,-80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse winSta(period=
                    3600) "WIndow status" annotation (Placement(transformation(
                      extent={{40,-100},{60,-80}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp nOcc(
                height=5,
                duration=4800,
                offset=0) "Number of occupants" annotation (Placement(
                    transformation(extent={{-100,-80},{-80,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round rou(n=0)
                "Round the input" annotation (Placement(transformation(extent={
                        {-60,-80},{-40,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.ZeroOrderHold zerOrdHol(final
                  samplePeriod=2) "Mimic damper position" annotation (Placement(
                    transformation(extent={{80,58},{100,78}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.ZeroOrderHold zerOrdHol1(final
                  samplePeriod=2) "Mimic damper position" annotation (Placement(
                    transformation(extent={{80,0},{100,20}})));

            equation
              connect(TSetRooHea.y,con.TZonHeaSet)
                annotation (Line(points={{-78,100},{-70,100},{-70,74},{-14,74},{-14,80},{38,
                      80}},   color={0,0,127}));
              connect(TSetRooCoo.y, con.TZonCooSet)
                annotation (Line(points={{-38,100},{-28,100},{-28,78},{38,78}},
                  color={0,0,127}));
              connect(disAirFlo.y, con.VDis_flow)
                annotation (Line(points={{-78,60},{-8,60},{-8,68},{38,68}},
                              color={0,0,127}));
              connect(TZon.y, con.TZon)
                annotation (Line(points={{-38,30},{-2,30},{-2,70},{38,70}},
                  color={0,0,127}));
              connect(TDis.y, con.TDis)
                annotation (Line(points={{-78,0},{-20,0},{-20,64},{38,64}},
                  color={0,0,127}));
              connect(TSup.y, con.TSupAHU)
                annotation (Line(points={{-38,-20},{4,-20},{4,62},{38,62}},
                  color={0,0,127}));
              connect(opeMod.y, con.uOpeMod)
                annotation (Line(points={{2,-50},{10,-50},{10,60},{38,60}},
                  color={255,127,0}));
              connect(nOcc.y, rou.u)
                annotation (Line(points={{-78,-70},{-62,-70}}, color={0,0,127}));
              connect(rou.y, con1.nOcc)
                annotation (Line(points={{-38,-70},{16,-70},{16,14},{38,14}},
                  color={0,0,127}));
              connect(ppmCO2.y, con1.ppmCO2)
                annotation (Line(points={{2,-90},{20,-90},{20,16},{38,16}},
                  color={0,0,127}));
              connect(winSta.y, con1.uWin)
                annotation (Line(points={{62,-90},{80,-90},{80,-50},{26,-50},{26,12},{38,12}},
                              color={255,0,255}));
              connect(TSetRooHea.y,con1.TZonHeaSet)
                annotation (Line(points={{-78,100},{-70,100},{-70,74},{-14,74},{-14,20},{38,
                      20}},   color={0,0,127}));
              connect(TSetRooCoo.y, con1.TZonCooSet)
                annotation (Line(points={{-38,100},{-28,100},{-28,18},{38,18}},
                  color={0,0,127}));
              connect(disAirFlo.y, con1.VDis_flow)
                annotation (Line(points={{-78,60},{-8,60},{-8,8},{38,8}},
                              color={0,0,127}));
              connect(TZon.y, con1.TZon)
                annotation (Line(points={{-38,30},{-2,30},{-2,10},{38,10}},
                  color={0,0,127}));
              connect(TDis.y, con1.TDis)
                annotation (Line(points={{-78,0},{-20,0},{-20,4},{38,4}},
                  color={0,0,127}));
              connect(TSup.y, con1.TSupAHU)
                annotation (Line(points={{-38,-20},{4,-20},{4,2},{38,2}},
                  color={0,0,127}));
              connect(opeMod.y, con1.uOpeMod)
                annotation (Line(points={{2,-50},{10,-50},{10,0},{38,0}},
                  color={255,127,0}));
              connect(con.yDam, zerOrdHol.u) annotation (Line(points={{62,76},{70,76},{70,68},
                      {78,68}}, color={0,0,127}));
              connect(con1.yDam, zerOrdHol1.u) annotation (Line(points={{62,16},{70,16},{70,
                      10},{78,10}}, color={0,0,127}));
              connect(zerOrdHol.y,con.yDam_actual)  annotation (Line(points={{102,68},{110,
                      68},{110,100},{20,100},{20,66},{38,66}}, color={0,0,127}));
              connect(zerOrdHol1.y,con1.yDam_actual)  annotation (Line(points={{102,10},{
                      110,10},{110,40},{30,40},{30,6},{38,6}}, color={0,0,127}));

            annotation (experiment(StopTime=3600.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/TerminalUnits/Validation/Controller.mos"
                "Simulate and plot"),
                Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Controller\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.Controller</a>.
</p>
</html>",             revisions="<html>
<ul>
<li>
October 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                     graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}}),
                               Ellipse(
                      lineColor={75,138,73},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid,
                      extent={{-100,-100},{100,100}}), Polygon(
                      lineColor={0,0,255},
                      fillColor={75,138,73},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
                Diagram(coordinateSystem(extent={{-120,-120},{120,120}})));
            end Controller;

            model ModeAndSetPoints
              "Validation models of reseting the zone setpoint temperature"

              hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints
                setPoi(cooAdj=true, heaAdj=true)
                "Output resetted zone setpoint remperature" annotation (
                  Placement(transformation(extent={{20,70},{40,90}})));
              hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints
                setPoi1(have_occSen=true, have_winSen=true)
                "Output resetted zone setpoint remperature" annotation (
                  Placement(transformation(extent={{20,30},{40,50}})));

              hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSch
                "Occupancy schedule" annotation (Placement(transformation(
                      extent={{-90,72},{-70,92}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine heaSetAdj(freqHz=1/
                    28800, amplitude=0.5) "Heating setpoint adjustment"
                annotation (Placement(transformation(extent={{-46,0},{-26,20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine cooSetAdj(freqHz=1/
                    28800) "Cooling setpoint adjustment" annotation (Placement(
                    transformation(extent={{-46,40},{-26,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine TZon1(
                amplitude=5,
                offset=18 + 273.15,
                freqHz=1/86400) "Zone 1 temperature" annotation (Placement(
                    transformation(extent={{-88,40},{-68,60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine TZon2(
                offset=18 + 273.15,
                freqHz=1/86400,
                amplitude=7.5) "Zone 2 temperature" annotation (Placement(
                    transformation(extent={{-88,0},{-68,20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant winSta1(k=false)
                "Window status" annotation (Placement(transformation(extent={{-88,
                        -80},{-68,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant winSta2(k=true)
                "Window status" annotation (Placement(transformation(extent={{-46,
                        -80},{-26,-60}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant occSen1(k=false)
                "Occupancy sensor" annotation (Placement(transformation(extent=
                        {{-88,-40},{-68,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant occSen2(k=true)
                "Occupancy sensor" annotation (Placement(transformation(extent=
                        {{-46,-40},{-26,-20}})));
              hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints
                setPoi3(have_occSen=true, have_winSen=true)
                "Output resetted zone setpoint remperature" annotation (
                  Placement(transformation(extent={{20,-60},{40,-40}})));
              hil_flexlab_model.Controls_HIL.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints
                setPoi2(cooAdj=true, heaAdj=true)
                "Output resetted zone setpoint remperature" annotation (
                  Placement(transformation(extent={{20,-20},{40,0}})));

            equation
              connect(cooSetAdj.y, setPoi.setAdj)
                annotation (Line(points={{-24,50},{-20,50},{-20,80},{18,80}},
                  color={0,0,127}));
              connect(heaSetAdj.y, setPoi.heaSetAdj)
                annotation (Line(points={{-24,10},{-16,10},{-16,77},{18,77}},
                  color={0,0,127}));

              connect(occSen2.y, setPoi3.uOccSen) annotation (Line(points={{-24,-30},{-2,-30},
                      {-2,-56},{18,-56}},      color={255,0,255}));
              connect(winSta2.y, setPoi3.uWinSta) annotation (Line(points={{-24,-70},{-2,-70},
                      {-2,-59},{18,-59}},      color={255,0,255}));
              connect(setPoi3.TZon, TZon2.y) annotation (Line(points={{18,-47},{6,-47},{6,-6},
                      {-20,-6},{-20,-8},{-60,-8},{-60,10},{-66,10}},     color={0,0,127}));
              connect(setPoi2.TZon, TZon2.y) annotation (Line(points={{18,-7},{6,-7},{6,-6},
                      {-20,-6},{-20,-8},{-60,-8},{-60,10},{-66,10}},     color={0,0,127}));
              connect(cooSetAdj.y, setPoi2.setAdj) annotation (Line(points={{-24,50},{-20,50},
                      {-20,0},{10,0},{10,-10},{18,-10}},   color={0,0,127}));
              connect(heaSetAdj.y, setPoi2.heaSetAdj) annotation (Line(points={{-24,10},{12,
                      10},{12,-13},{18,-13}},    color={0,0,127}));
              connect(TZon1.y, setPoi.TZon) annotation (Line(points={{-66,50},{-60,50},{-60,
                      83},{18,83}},     color={0,0,127}));
              connect(setPoi1.TZon, setPoi.TZon) annotation (Line(points={{18,43},{-12,43},{
                      -12,32},{-60,32},{-60,83},{18,83}},  color={0,0,127}));
              connect(occSch.tNexOcc, setPoi.tNexOcc)
                annotation (Line(points={{-69,88},{-26,88},{-26,89},{18,89}},
                                                            color={0,0,127}));
              connect(occSch.tNexOcc, setPoi1.tNexOcc) annotation (Line(points={{-69,88},{4,
                      88},{4,49},{18,49}},    color={0,0,127}));
              connect(setPoi2.tNexOcc, setPoi1.tNexOcc) annotation (Line(points={{18,-1},{4,
                      -1},{4,49},{18,49}},    color={0,0,127}));
              connect(setPoi3.tNexOcc, setPoi1.tNexOcc) annotation (Line(points={{18,-41},{4,
                      -41},{4,49},{18,49}},    color={0,0,127}));
              connect(occSch.occupied, setPoi.uOcc) annotation (Line(points={{-69,76},{-26,76},
                      {-26,86.025},{18,86.025}},         color={255,0,255}));
              connect(occSch.occupied, setPoi1.uOcc) annotation (Line(points={{-69,76},{-6,76},
                      {-6,46.025},{18,46.025}},        color={255,0,255}));
              connect(occSch.occupied, setPoi2.uOcc) annotation (Line(points={{-69,76},{-6,76},
                      {-6,-3.975},{18,-3.975}},          color={255,0,255}));
              connect(occSch.occupied, setPoi3.uOcc) annotation (Line(points={{-69,76},{-6,76},
                      {-6,-43.975},{18,-43.975}},        color={255,0,255}));
              connect(occSen1.y, setPoi1.uOccSen) annotation (Line(points={{-66,-30},{-58,-30},
                      {-58,-14},{-10,-14},{-10,34},{18,34}},      color={255,0,255}));
              connect(winSta1.y, setPoi1.uWinSta) annotation (Line(points={{-66,-70},{-60,-70},
                      {-60,-48},{0,-48},{0,31},{18,31}},      color={255,0,255}));
            annotation (experiment(StopTime=86400.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/ASHRAE/G36_PR1/TerminalUnits/Validation/ModeAndSetPoints.mos"
                "Simulate and plot"),
                Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits.ModeAndSetPoints</a>.
</p>
</html>",             revisions="<html>
<ul>
<li>
October 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),   Diagram(
                    coordinateSystem(preserveAspectRatio=false), graphics={Text(
                      extent={{50,86},{126,76}},
                      lineColor={85,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="No window status sensor
No occupancy sensor
Zone 1"),                          Text(
                      extent={{48,44},{102,36}},
                      lineColor={85,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="No local setpoint adjustment
Zone 1"),                          Text(
                      extent={{46,-46},{100,-54}},
                      lineColor={85,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="No local setpoint adjustment
Zone 2"),                                                                  Text(
                      extent={{48,-4},{124,-14}},
                      lineColor={85,0,255},
                      horizontalAlignment=TextAlignment.Left,
                      textString="No window status sensor
No occupancy sensor
Zone 2")}),     Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}}),
                               Ellipse(
                      lineColor={75,138,73},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid,
                      extent={{-100,-100},{100,100}}), Polygon(
                      lineColor={0,0,255},
                      fillColor={75,138,73},
                      pattern=LinePattern.None,
                      fillPattern=FillPattern.Solid,
                      points={{-36,58},{64,-2},{-36,-62},{-36,58}})}));
            end ModeAndSetPoints;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Polygon(
                    origin={8.0,14.0},
                    lineColor={78,138,73},
                    fillColor={78,138,73},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
          end Validation;
          annotation (
        Documentation(info="<html>
<p>
This package contains control sequences for terminal units.
</p>
</html>"),         Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  extent={{-70,60},{-30,20}},
                  lineColor={0,0,127},
                  lineThickness=0.5),
                Rectangle(
                  extent={{-70,-20},{-30,-60}},
                  lineColor={0,0,127},
                  lineThickness=0.5),
                Rectangle(
                  extent={{30,20},{70,-20}},
                  lineColor={0,0,127},
                  lineThickness=0.5),
                Line(
                  points={{-30,40},{0,40},{0,10},{30,10}},
                  color={0,0,127},
                  thickness=0.5),
                Line(
                  points={{-30,-40},{0,-40},{0,-10},{30,-10}},
                  color={0,0,127},
                  thickness=0.5)}));
        end TerminalUnits;

        package Types "Package with type definitions for control sequences"

          package DemandLimitLevels "Demand limit levels"
            constant Integer cooling0 = 0 "Cooling demand limit level 0";
            constant Integer cooling1 = 1 "Cooling demand limit level 1";
            constant Integer cooling2 = 2 "Cooling demand limit level 2";
            constant Integer cooling3 = 3 "Cooling demand limit level 3";
            constant Integer heating0 = 0 "Heating demand limit level 0";
            constant Integer heating1 = 1 "Heating demand limit level 1";
            constant Integer heating2 = 2 "Heating demand limit level 2";
            constant Integer heating3 = 3 "Heating demand limit level 3";

            annotation (
            Documentation(info="<html>
<p>
This package provides constants for indicating different cooling or heating
demand limit level for zone setpoint adjustment, PART 5.B.3.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 16, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),           Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0)}));
          end DemandLimitLevels;

          package FreezeProtectionStages "Package with constants that indicate the freeze protection stages"
            constant Integer stage0 = 0 "Freeze protection is deactivated";
            constant Integer stage1 = 1 "First stage of freeze protection";
            constant Integer stage2 = 2 "Second stage of freeze protection";
            constant Integer stage3 = 3 "Third stage of freeze protection";

          annotation (
          Documentation(info="<html>
<p>
This package provides constants that indicate the
freeze protection stages.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 14, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),           Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0)}));
          end FreezeProtectionStages;

          package OperationModes "Zone group operating modes"
            constant Integer coolDown = 2 "Cool-down";
            constant Integer freezeProtection = 6 "Freeze protection";
            constant Integer occupied = 1 "Occupied";
            constant Integer setBack = 5 "Set-back";
            constant Integer setUp =  3 "Set-up";
            constant Integer unoccupied = 7 "Unoccupied";
            constant Integer warmUp =  4 "Warm-up";

            annotation (
            Documentation(info="<html>
<p>
This package provides constants for indicating different system operation
modes.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 17, 2017, by Michael Wetter:<br/>
Reordered constants because the file <code>package.order</code> has
the constants listed alphabetically.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/802\">issue 802</a>.
</li>
<li>
July 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),           Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0)}));
          end OperationModes;

          package ZoneStates "AHU Zone States"
            constant Integer cooling = 3 "Output of the space cooling control loop is nonzero";
            constant Integer deadband = 2 "When not in either heating or cooling";
            constant Integer heating = 1 "Output of the space heating control loop is nonzero";

          annotation (
          Documentation(info="<html>
<p>
This package provides constants that indicate the
AHU zone state.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 18, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"),           Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0)}));
          end ZoneStates;
          annotation (Documentation(info="<html>
<p>
This package provides type definitions used in Guideline 36 control sequences.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),                  Polygon(
                  origin={-12.167,-23},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},
                      {14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,
                      -30},{4.167,20},{12.167,65}},
                  smooth=Smooth.Bezier,
                  lineColor={0,0,0}), Polygon(
                  origin={2.7403,1.6673},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,
                    10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,
                    4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
                  smooth=Smooth.Bezier)}));
        end Types;
      annotation (Documentation(info="<html>
<p>
This package contains control sequences from
ASHRAE Guideline 36 (G36).
All sequences are created using blocks from the
<a href=\"modelica://Buildings.Controls.OBC.CDL\">
Buildings.Controls.OBC.CDL</a> library, following the
<a href=\"http://obc.lbl.gov/specification/cdl.html\">
CDL specification</a>.
</p>
<p>
The G36 library is structured as follows:
<ul>
<li><a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.AHUs</a> contains control sequences
for generating controller setpoints such as for the supply air temperature,
and actuation signals for mechanical elements of an AHU such as for the outdoor air damper
position.
</li>
<li><a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Types\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Types</a> is a library of constants
that are used to indicate the operation mode, such as freeze
protections status and demand response status.
</li>
<li><a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.Generic</a> contains sequences that
are utilized across various parts of an HVAC system,
such as for AHU and for terminal unit control.
</li>
<li><a href=\"modelica://Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits\">
Buildings.Controls.OBC.ASHRAE.G36_PR1.TerminalUnits</a> contains control
sequences for terminal units, such as setpoints for the minimal zone airflow rates and
actuator signals for the terminal unit dampers.
</li>
</ul>
<h4>Implementation of PID controllers</h4>
<p>
For the PID controllers, the implementation in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.LimPID\">
Buildings.Controls.OBC.CDL.Continuous.LimPID</a>
is used.
Hence, the PID controllers are in the standard form
</p>
<p align=\"center\" style=\"font-style:italic;\">
y(t) = k &nbsp; ( e(t) + 1 &frasl; T<sub>i</sub> &nbsp; &int; e(s) ds + T<sub>d</sub> de(t)&frasl;dt ),
</p>
<p>
where
<i>y(t)</i> is the control signal,
<i>e(t) = u<sub>s</sub>(t) - u<sub>m</sub>(t)</i> is the control error,
with <i>u<sub>s</sub>(t)</i> being the set point and <i>u<sub>m</sub>(t)</i> being
the measured quantity,
<i>k</i> is the gain,
<i>T<sub>i</sub></i> is the time constant of the integral term and
<i>T<sub>d</sub></i> is the time constant of the derivative term.
</p>
<p>
Note that the units of <i>k</i> are the inverse of the units of the control error,
while the units of <i>T<sub>i</sub></i> and <i>T<sub>d</sub></i> are seconds.
As the units of flow rates and pressure can vary between orders of magnitude,
for example depening on whether <i>cfm</i>, <i>m<sup>3</sup>&frasl;s</i> or
<i>m<sup>3</sup>&frasl;h</i> are used for flow measurements, the control
error is normalized as follows:
<ul>
<li>
For temperatures, no normalization is used, and the units of <i>k</i> are
<i>1/Kelvin</i>. No normalization is used because <i>1</i> Kelvin is <i>1.8</i>
Fahrenheit, and hence these are of the same order of magnitude.
</li>
<li>
For air flow rate control, the design flow rate is used to normalize the
control error, and hence <i>k</i> is unitless.
This also allows to use the same control gain for flows of different magnitudes,
for example for a VAV box of a large and a small room, provided the rooms
have similar transient response.
</li>
<li>
For pressure control, the pressure difference is used to normalize the
control error, and hence <i>k</i> is unitless.
</li>
</ul>
<p>
Guideline 36 is specific as the where a P or a PI controller should be
used. These recommendations are used as the default control configuration.
However, all controllers can be configured as P, PI or PID controller.
This allows to configure a PI controller as a P controller as part of the
tuning process.
</p>
<h4>References</h4>
<p>
<i>ASHRAE Guideline 36P, High Performance Sequences of Operation for HVAC
systems</i>. First Public Review Draft (June 2016)
</p>
</html>"),       Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Ellipse(
                origin={10.0,10.0},
                fillColor={76,76,76},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{-80.0,-80.0},{-20.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,-80.0},{60.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                fillColor={128,128,128},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,0.0},{60.0,60.0}}),
              Ellipse(
                origin={10.0,10.0},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-80.0,0.0},{-20.0,60.0}})}));
      end G36_PR1;
    annotation (Documentation(info="<html>
<p>
This package contains control sequences
that are published in ASHRAE reports.
</p>
</html>"),     Icon(graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Ellipse(
              origin={10.0,10.0},
              fillColor={76,76,76},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-80.0,-80.0},{-20.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,-80.0},{60.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,0.0},{60.0,60.0}}),
            Ellipse(
              origin={10.0,10.0},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-80.0,0.0},{-20.0,60.0}})}));
    end ASHRAE;

    package CDL "Package with blocks, examples and validation tests for control description language"

      package Constants "Package with constants"
        // Machine dependent constants
        final constant Real eps=1E-15
          "Biggest number such that 1.0 + eps = 1.0";
        final constant Real small=1E-60
          "Smallest number such that small and -small are representable on the machine";
        final constant Real pi=2*Modelica.Math.asin(1.0)
          "Constant number pi, 3.14159265358979";

        annotation (
          Documentation(info="<html>
<p>
This package provides often needed constants.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
            Polygon(
              origin={-9.2597,25.6673},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},
              {-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={-19.9923,-8.3993},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},
              {6.811,-22.519},{9.986,37.145},{9.986,37.145}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={23.753,-11.5422},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},
              {16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
              smooth=Smooth.Bezier),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0)}));
      end Constants;

      package Continuous "Package with blocks for continuous variables"

        block Abs "Output the absolute value of the input"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = abs(u);

        annotation (
            defaultComponentName="abs",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Polygon(
                  points={{92,0},{70,8},{70,-8},{92,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,80},{0,0},{80,80}}),
                Line(points={{0,-14},{0,68}}, color={192,192,192}),
                Polygon(
                  points={{0,90},{-8,68},{8,68},{0,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-34,-28},{38,-76}},
                  lineColor={192,192,192},
                  textString="abs"),
                Line(points={{-88,0},{76,0}}, color={192,192,192}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = abs(u)</code>,
where
<code>u</code> is an input.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Abs;

        block Add "Output the sum of the two inputs"

          parameter Real k1=+1 "Gain for input u1";

          parameter Real k2=+1 "Gain for input u2";

          Interfaces.RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = k1*u1 + k2*u2;

        annotation (
          defaultComponentName="add2",
          Documentation(info="<html>
<p>
Block that outputs <code>y</code> as the weighted <i>sum</i> of the
two input signals <code>u1</code> and <code>u2</code>,
</p>
<pre>
    y = k1*u1 + k2*u2;
</pre>
<p>
where <code>k1</code> and <code>k2</code> are parameters.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
                Line(points={{-100,60},{-74,24},{-44,24}}, color={0,0,127}),
                Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={0,0,127}),
                Line(points={{50,0},{100,0}}, color={0,0,127}),
                Text(extent={{-40,-22},{36,46}}, textString="+"),
                Text(extent={{-100,52},{5,92}}, textString="%k1"),
                Text(extent={{-100,-92},{5,-52}}, textString="%k2"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Add;

        block AddParameter "Output the sum of an input plus a parameter"

          parameter Real p "Value to be added";

          parameter Real k "Gain of input";

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = k*u + p;

        annotation (
          defaultComponentName="addPar",
          Documentation(info="<html>
<p>
Block that outputs <code>y = k u + p</code>,
where <code>k</code> and <code>p</code> are
parameters and <code>u</code> is an input.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Line(points={{-54,66},{-28,30},{2,30}},    color={0,0,127}),
                Line(points={{-100,0},{100,0}},
                                              color={0,0,127}),
                Text(extent={{-122,58},{-17,98}},
                  textString="%p",
                  lineColor={0,0,0}),
                Polygon(
                  points={{-86,-36},{-86,36},{-34,0},{-86,-36}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-196,-84},{104,-44}},
                  lineColor={0,0,0},
                  textString="k=%k"),
                Ellipse(lineColor={0,0,127}, extent={{-12,-52},{88,48}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(extent={{-2,-22},{74,46}},  textString="+"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end AddParameter;

        block Atan "Output the arc tangent of the input"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = Modelica.Math.atan(u);

        annotation (
          defaultComponentName="atan",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Text(
                  extent={{-86,68},{-14,20}},
                  lineColor={192,192,192},
                  textString="atan"),
                Polygon(
                  points={{0,90},{-8,68},{8,68},{0,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{0,-80},{0,68}}, color={192,192,192}),
                Line(
                  points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},
                      {-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,
                      21},{9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},
                      {47,73.6},{69.5,78.6},{80,80}},
                  smooth=Smooth.Bezier),
                Line(points={{-90,0},{68,0}}, color={192,192,192}),
                Polygon(
                  points={{90,0},{68,8},{68,-8},{90,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = atan(u)</code>,
where
<code>u</code> is an input.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Atan.png\"
     alt=\"atan.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Atan;

        block Atan2 "Output atan(u1/u2) of the inputs u1 and u2"

          Interfaces.RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = Modelica.Math.atan2(u1, u2);

        annotation (
          defaultComponentName="atan2",
          Documentation(info="<html>
<p>
Block that outputs the tangent-inverse <code>y = atan2(u1, u2)</code>
of the input <code>u1</code> divided by the input <code>u2</code>.
</p>
<p>
<code>u1</code> and <code>u2</code> shall not be zero at the same time instant.
<code>Atan2</code> uses the sign of <code>u1</code> and <code>u2</code>
in order to construct the solution in the range
<i>-&pi; &le; y &le; &pi;</i>, whereas
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Atan\">
Buildings.Controls.OBC.CDL.Continuous.Atan</a>
gives a solution in the range
<i>-&pi;/2 &le; y &le; &pi;/2</i>.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Atan2.png\"
     alt=\"atan2.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),         Icon(graphics={      Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
                Line(points={{0,-80},{0,68}}, color={192,192,192}),
                Line(points={{-90,0},{68,0}}, color={192,192,192}),
                Polygon(
                  points={{90,0},{68,8},{68,-8},{90,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-80,-34.9},{-46.1,-31.4},{-29.4,-27.1},{-18.3,-21.5},{-10.3,
                      -14.5},{-2.03,-3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},
                      {62.1,33.5},{80,34.9}},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-80,45.1},{-45.9,48.7},{-29.1,52.9},{-18.1,58.6},{-10.2,
                      65.8},{-1.82,77.2},{0,80}},
                  smooth=Smooth.Bezier),
                Line(
                  points={{0,-80},{8.93,-67.2},{17.1,-59.3},{27.3,-53.6},{42.1,-49.4},
                      {69.9,-45.8},{80,-45.1}},
                  smooth=Smooth.Bezier),
                Text(
                  extent={{-90,-46},{-18,-94}},
                  lineColor={192,192,192},
                  textString="atan2"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Polygon(
                  points={{0,90},{-8,68},{8,68},{0,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Atan2;

        block Average "Output the average of its two inputs"

          Interfaces.RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}}),
                iconTransformation(extent={{-140,40},{-100,80}})));

          Interfaces.RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}}),
                iconTransformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = 0.5*(u1 + u2);

        annotation (
          defaultComponentName="ave",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Text(
                  extent={{-50,34},{52,-26}},
                  lineColor={192,192,192},
                  textString="avg()"),
                Line(points={{-8,16}}, color={0,0,0}),
                Line(
                  points={{-100,60}},
                  color={0,0,0},
                  thickness=1),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = avg(u1,u2)</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 15, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Average;

        block ChangeSign "Change sign of the input"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}}),
                iconTransformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = -u;

        annotation (
          defaultComponentName="chaSig",
          Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Line(points={{2,68},{2,-80}},     color={192,192,192}),
                Polygon(
                  points={{2,90},{-6,68},{10,68},{2,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-90,0},{82,0}},     color={192,192,192}),
                Polygon(
                  points={{90,0},{68,8},{68,-8},{90,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{2,-60},{100,-60}}),
                Line(
                  points={{-100,60}},
                  color={0,0,127},
                  thickness=1),
                Line(points={{-100,60},{2,60}}, color={0,0,0}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = -u</code>,
where <code>u</code> is an input.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 15, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end ChangeSign;

        block Cos "Output the cosine of the input"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = Modelica.Math.cos(u);

        annotation (
          defaultComponentName="cos",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Line(
                  points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
                      {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
                      {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},
                      {24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{
                      69.5,73.4},{75.2,78.6},{80,80}},
                  smooth=Smooth.Bezier),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
                Line(points={{-90,0},{68,0}}, color={192,192,192}),
                Polygon(
                  points={{90,0},{68,8},{68,-8},{90,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-36,80},{36,32}},
                  lineColor={192,192,192},
                  textString="cos"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = cos(u)</code>,
where
<code>u</code> is an input.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Cos.png\"
     alt=\"cos.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Cos;

        block Derivative "Block that approximates the derivative of the input"
          parameter Real k(unit="1") = 1 "Gains";
          parameter Modelica.SIunits.Time T(min=1E-60)=0.01
            "Time constant (T>0 required)";
          parameter Real x_start=0 "Initial or guess value of state"
            annotation (Dialog(group="Initialization"));
          parameter Real y_start=0 "Initial value of output (= state)"
            annotation(Dialog(group="Initialization"));
          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          output Real x "State of block";

        protected
          parameter Boolean zeroGain = abs(k) < 1E-17
            "= true, if gain equals to zero";
        initial equation
          if zeroGain then
             x = u;
          else
             x = u - T*y_start/k;
          end if;

        equation
          der(x) = if zeroGain then 0 else (u - x)/T;
          y = if zeroGain then 0 else (k/T)*(u - x);

        annotation (
          defaultComponentName="der",
          Documentation(info="<html>
<p>
This blocks defines the transfer function between the
input <code>u</code> and the output <code>y</code>
as <i>approximated derivative</i>:
</p>
<pre>
             k * s
     y = ------------ * u
            T * s + 1
</pre>
<p>
If <code>k=0</code>, the block reduces to <code>y=0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 21, 2020, by Michael Wetter:<br/>
Removed option to not set the initialization method or to set the initial state.
The new implementation only allows to set the initial output, from which
the initial state is computed.
<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1887\">issue 1887</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),         Icon(
            coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
          graphics={
            Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
            Line(points={{-80.0,78.0},{-80.0,-90.0}},
              color={192,192,192}),
          Polygon(lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid,
            points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
          Line(points={{-90.0,-80.0},{82.0,-80.0}},
            color={192,192,192}),
          Polygon(lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid,
            points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
          Line(origin = {-24.667,-27.333},
            points = {{-55.333,87.333},{-19.333,-40.667},{86.667,-52.667}},
            color = {0,0,127},
            smooth = Smooth.Bezier),
          Text(lineColor={192,192,192},
            extent={{-30.0,14.0},{86.0,60.0}},
            textString="DT1"),
          Text(extent={{-150.0,-150.0},{150.0,-110.0}},
            textString="k=%k"),
          Text(
            extent={{-150,150},{150,110}},
            textString="%name",
            lineColor={0,0,255}),
          Text(
            extent={{226,60},{106,10}},
            lineColor={0,0,0},
            textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Derivative;

        block Division "Output first input divided by second input"

          Interfaces.RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y=u1/u2;

        annotation (
          defaultComponentName="div",
          Documentation(info="<html>
<p>
Block that outputs <code>y = u1 / u2</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 9, 2020, by Michael Wetter:<br/>
Reformulated model to avoid stack overflow in OpenModelica.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1819\">issue 1819</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
                Line(points={{50,0},{100,0}}, color={0,0,127}),
                Line(points={{-30,0},{30,0}}),
                Ellipse(fillPattern=FillPattern.Solid, extent={{-5,20},{5,30}}),
                Ellipse(fillPattern=FillPattern.Solid, extent={{-5,-30},{5,-20}}),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Line(points={{-100,60},{-66,60},{-40,30}}, color={0,0,127}),
                Line(points={{-100,-60},{0,-60},{0,-50}}, color={0,0,127}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Division;

        block Exp "Output the exponential (base e) of the input"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = Modelica.Math.exp(u);

        annotation (
          defaultComponentName="exp",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Line(points={{-90,-80.3976},{68,-80.3976}}, color={192,192,192}),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},
                      {34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{
                      67.1,18.6},{72,38.2},{76,57.6},{80,80}}),
                Line(points={{0,-80},{0,68}}, color={192,192,192}),
                Text(
                  extent={{-86,50},{-14,2}},
                  lineColor={192,192,192},
                  textString="exp"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = exp(u)</code>,
where
<code>u</code> is an input and <code>exp()</code> is the
base-e exponential function.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Exp.png\"
     alt=\"exp.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Exp;

        block Feedback "Output difference between commanded and feedback input"

          Interfaces.RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 - u2;

        annotation (
          defaultComponentName="feedback",
          Documentation(info="<html>
<p>
Block that outputs <code>y = u1 - u2</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                Ellipse(
                  lineColor={0,0,127},
                  fillColor={235,235,235},
                  fillPattern=FillPattern.Solid,
                  extent={{-20,-20},{20,20}}),
                Line(points={{-100,0},{-20,0}},color={0,0,127}),
                Line(points={{20,0},{100,0}},color={0,0,127}),
                Line(points={{0,-20},{0,-100}},color={0,0,127}),
                Text(extent={{-14,-112},{74,-38}},
                                                textString="-"),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,48},{150,98}},
                  textString="%name"),
                Text(extent={{-100,-4},{-40,56}},
                  textString="+",
                  lineColor={0,0,0}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Feedback;

        block Gain "Output the product of a gain value with the input signal"

          parameter Real k "Gain value multiplied with input signal";

          Interfaces.RealInput u "Input signal connector"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Output signal connector"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = k*u;

        annotation (
          defaultComponentName="gai",
          Documentation(info="<html>
<p>
Block that outputs <code>y = k * u</code>,
where
<code>k</code> is a parameter and
<code>u</code> is an input.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Polygon(
                  points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,-140},{150,-100}},
                  lineColor={0,0,0},
                  textString="k=%k"),
                Text(
                  extent={{-150,144},{150,104}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Gain;

        block Greater "Output y is true, if input u1 is greater than input u2"

          Interfaces.RealInput u1 "Connector of first Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealInput u2 "Connector of second Real input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 > u2;

        annotation (
          defaultComponentName="gre",
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{32,10},{52,-10}}, lineColor={0,0,127}),
                Line(points={{-100,-80},{42,-80},{42,0}}, color={0,0,127}),
                Line(
                  points={{-54,22},{-8,2},{-54,-18}},
                  thickness=0.5),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Real input <code>u1</code>
is greater than the Real input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Greater;

        block GreaterEqual
          "Output y is true, if input u1 is greater or equal than input u2"

          Interfaces.RealInput u1 "Connector of first Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealInput u2 "Connector of second Real input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 >= u2;

        annotation (
          defaultComponentName="greEqu",
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{32,10},{52,-10}}, lineColor={0,0,127}),
                Line(points={{-100,-80},{42,-80},{42,0}}, color={0,0,127}),
                Line(
                  points={{-54,22},{-8,2},{-54,-18}},
                  thickness=0.5),
                Line(
                  points={{-52,-36},{-6,-14}},
                  thickness=0.5),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if Real the input <code>u1</code>
is greater than or equal to the Real input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end GreaterEqual;

        block GreaterEqualThreshold
          "Output y is true, if input u is greater or equal than threshold"

          parameter Real threshold=0 "Comparison with respect to threshold";

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u >= threshold;

        annotation (
          defaultComponentName="greEquThr",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Text(
                  extent={{-150,-140},{150,-110}},
                  lineColor={0,0,0},
                  textString="%threshold"),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(
                  points={{-54,22},{-8,2},{-54,-18}},
                  thickness=0.5),
                Line(
                  points={{-52,-36},{-6,-14}},
                  thickness=0.5)}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Real input is greater than or equal to
the parameter <code>threshold</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end GreaterEqualThreshold;

        block GreaterThreshold
          "Output y is true, if input u is greater than threshold"

          parameter Real threshold=0 "Comparison with respect to threshold";

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u > threshold;

        annotation (
          defaultComponentName="greThr",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,-140},{150,-110}},
                  lineColor={0,0,0},
                  textString="%threshold"),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Line(
                  points={{-54,22},{-8,2},{-54,-18}},
                  thickness=0.5)}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Real input is greater than
the parameter <code>threshold</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end GreaterThreshold;

        block Hysteresis "Transform Real to Boolean signal with Hysteresis"

          parameter Real uLow "if y=true and u<uLow, switch to y=false";

          parameter Real uHigh "if y=false and u>uHigh, switch to y=true";

          parameter Boolean pre_y_start=false "Value of pre(y) at initial time";

          Interfaces.RealInput u "Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        initial equation
          assert(uHigh > uLow, "Hysteresis limits wrong. uHigh must be larger than uLow");
          pre(y) = pre_y_start;
        equation
          y = not pre(y) and u > uHigh or pre(y) and u >= uLow;

        annotation (
          defaultComponentName="hys",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,68},{-80,-29}}, color={192,192,192}),
                Polygon(
                  points={{92,-29},{70,-21},{70,-37},{92,-29}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-79,-29},{84,-29}}, color={192,192,192}),
                Line(points={{-79,-29},{41,-29}}),
                Line(points={{-15,-21},{1,-29},{-15,-36}}),
                Line(points={{41,51},{41,-29}}),
                Line(points={{33,3},{41,22},{50,3}}),
                Line(points={{-49,51},{81,51}}),
                Line(points={{-4,59},{-19,51},{-4,43}}),
                Line(points={{-59,29},{-49,11},{-39,29}}),
                Line(points={{-49,51},{-49,-29}}),
                Text(
                  extent={{-92,-49},{-9,-92}},
                  lineColor={192,192,192},
                  textString="%uLow"),
                Text(
                  extent={{2,-49},{91,-92}},
                  lineColor={192,192,192},
                  textString="%uHigh"),
                Rectangle(extent={{-91,-49},{-8,-92}}, lineColor={192,192,192}),
                Line(points={{-49,-29},{-49,-49}}, color={192,192,192}),
                Rectangle(extent={{2,-49},{91,-92}}, lineColor={192,192,192}),
                Line(points={{41,-29},{41,-49}}, color={192,192,192}),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
          Documentation(info="<html>
<p>
Block that transforms a <code>Real</code> input signal into a <code>Boolean</code>
output signal:
</p>
<ul>
<li> When the output was <code>false</code> and the input becomes
     greater than the parameter <code>uHigh</code>, the output
     switches to <code>true</code>.
</li>
<li> When the output was <code>true</code> and the input becomes
     less than the parameter <code>uLow</code>, the output
     switches to <code>false</code>.
</li>
</ul>
<p>
The start value of the output is defined via parameter
<code>pre_y_start</code> (= value of <code>pre(y)</code> at initial time).
The default value of this parameter is <code>false</code>.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Hysteresis.png\"
     alt=\"Hysteresis.png\" />
</p>
</html>",         revisions="<html>
<ul>
<li>
October 3, 2017, by Michael Wetter:<br/>
Removed start value for parameters, and moved assertion to <code>initial equation</code>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Hysteresis;

        block HysteresisWithHold
          "Hysteresis block that optionally allows to specify a hold time"

          parameter Real uLow "if y=true and u<uLow, switch to y=false";
          parameter Real uHigh "if y=false and u>uHigh, switch to y=true";

          parameter Modelica.SIunits.Time trueHoldDuration
            "true hold duration";

          parameter Modelica.SIunits.Time falseHoldDuration = trueHoldDuration
            "false hold duration";

          Interfaces.RealInput u "Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          Continuous.Hysteresis hysteresis(
            final uLow=uLow,
            final uHigh=uHigh)
            "Transform Real to Boolean signal with Hysteresis"
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));

          Logical.TrueFalseHold truFalHol(
            final trueHoldDuration=trueHoldDuration,
            final falseHoldDuration=falseHoldDuration) "True/false hold"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));

        equation
          connect(u, hysteresis.u)
            annotation (Line(points={{-120,0},{-100,0},{-42,0}}, color={0,0,127}));

          connect(hysteresis.y, truFalHol.u)
            annotation (Line(points={{-18,0},{39,0}}, color={255,0,255}));
          connect(truFalHol.y, y)
            annotation (Line(points={{61,0},{120,0}}, color={255,0,255}));
        annotation (
          defaultComponentName="hysWitHol",
          Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-66,-40},{62,-82}},
                  lineColor={0,0,0},
                  textString="%uLow     %uHigh"),
                  Polygon(
                    points={{-22,8},{-10,2},{-22,-4},{-22,8}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-48,2},{-16,2}}),
                  Line(points={{-10,34},{-10,-36}}),
                  Line(points={{-18,2},{18,2}}),
                  Polygon(
                    points={{12,8},{24,2},{12,-4},{12,8}},
                    lineColor={0,0,0},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Rectangle(extent={{24,18},{62,-16}}, lineColor={0,0,0}),
                  Rectangle(extent={{-86,18},{-48,-16}}, lineColor={0,0,0}),
                Text(
                  extent={{-140,148},{160,108}},
                  textString="%name",
                  lineColor={0,0,255}),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
Model for a hysteresis block that optionally allows to specify a hold time.
During the hold time, the output is not allowed to switch.
</p>
<p>
When the input <code>u</code> becomes greater than <code>uHigh</code>, the
output <code>y</code> becomes <code>true</code> and remains <code>true</code>
for at least <code>trueHoldDuration</code> seconds, after which time it is allowed
to switch immediately.
</p>
<p>
When the input <code>u</code> becomes less than <code>uLow</code>, the output
<code>y</code> becomes <code>false</code> and remains <code>false</code> for
at least <code>falseHoldDuration</code> seconds, after which time it is allowed
to switch immediately.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/HysteresisWithHold.png\"
alt=\"Input and output of the block\"/>
</p>
<p>
This model for example could be used to disable an economizer, and not re-enable
it for <i>10</i> minutes, and vice versa. Using hysteresis can avoid the
distraction from the input noise.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 18, 2017, by Michael Wetter:<br/>
Refactored model to use <a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.TrueFalseHold\">
Buildings.Controls.OBC.CDL.Logical.TrueFalseHold</a>.
</li>
<li>
June 26, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
        end HysteresisWithHold;

        block IntegratorWithReset "Output the integral of the input signal"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          parameter Real k(unit="1")=1 "Integrator gain";

          parameter Real y_start=0 "Initial or guess value of output (= state)"
            annotation (Dialog(group="Initialization"));

          parameter hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset reset=
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled
            "Type of integrator reset" annotation (Evaluate=true);

          parameter Real y_reset = 0
            "Value to which integrator is reset, used if reset = Types.Reset.Parameter"
            annotation(Dialog(
                         enable=reset == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter,
                         group="Integrator reset"));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput y_reset_in if reset
             == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Input
            "Input signal for state to which integrator is reset, enabled if reset = Types.Reset.Input"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}}),
                visible=reset == Buildings.Controls.OBC.CDL.Types.Reset.Input));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput trigger if reset
             <> hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled
            "Resets the integrator output when trigger becomes true"
            annotation (Placement(
              transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}),
              visible=reset <> Buildings.Controls.OBC.CDL.Types.Reset.Disabled,

              iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120})));
        protected
          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput y_reset_internal
            "Internal connector for integrator reset";

          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput trigger_internal
            "Needed to use conditional connector trigger";

        initial equation
          y = y_start;

        equation
          der(y) = k*u;

          // Equations for integrator reset
          connect(trigger, trigger_internal);
          connect(y_reset_in, y_reset_internal);

          if reset <> hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Input
               then
            y_reset_internal = y_reset;
          end if;

          if reset == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled
               then
            trigger_internal = false;
          else
            when trigger_internal then
              reinit(y, y_reset_internal);
            end when;
          end if;

          annotation (
        defaultComponentName="intWitRes",
        Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-88,-94},{212,-54}},
                  lineColor={0,0,0},
                  textString="y_reset_in",
                  visible= (reset == Types.Reset.Input),
                  horizontalAlignment=TextAlignment.Left),
                Bitmap(extent={{-54,-50},{60,50}}, fileName=
                      "modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/int.png"),
                  Text(
                    extent={{-88,56},{206,92}},
                  lineColor={0,0,0},
                  textString="k=%k",
                  horizontalAlignment=TextAlignment.Left),
                  Text(
                    extent={{-92,-12},{208,28}},
                  lineColor={0,0,0},
                  horizontalAlignment=TextAlignment.Left,
                  textString="u"),
                  Text(
                    extent={{70,-14},{370,26}},
                  lineColor={0,0,0},
                  horizontalAlignment=TextAlignment.Left,
                  textString="y"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
This model is similar to
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
except that it optionally allows to reset the output <code>y</code>
of the integrator.
</p>
<p>
The output of the integrator can be reset as follows:
</p>
<ul>
<li>
If <code>reset = Types.Reset.Disabled</code>, which is the default,
then the integrator is never reset.
</li>
<li>
If <code>reset = Types.Reset.Parameter</code>, then a boolean
input signal <code>trigger</code> is enabled. Whenever the value of
this input changes from <code>false</code> to <code>true</code>,
the integrator is reset by setting <code>y</code>
to the value of the parameter <code>y_reset</code>.
</li>
<li>
If <code>reset = Types.Reset.Input</code>, then a boolean
input signal <code>trigger</code> is enabled. Whenever the value of
this input changes from <code>false</code> to <code>true</code>,
the integrator is reset by setting <code>y</code>
to the value of the input signal <code>y_reset_in</code>.
</li>
</ul>
<h4>Implementation</h4>
<p>
To adjust the icon layer, the code of
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
has been copied into this model rather than extended.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 21, 2020, by Michael Wetter:<br/>
Removed parameter <code>initType</code>.
<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1887\">issue 1887</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
November 6, 2017, by Michael Wetter:<br/>
Explicitly declared types from CDL.
</li>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of
<a href=\"modelica://Buildings.Utilities.Math.IntegratorWithReset\">
Buildings.Utilities.Math.IntegratorWithReset</a>.
</li>
</ul>
</html>"));
        end IntegratorWithReset;

        block Less "Output y is true, if input u1 is less than input u2"

          Interfaces.RealInput u1 "Connector of first Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealInput u2 "Connector of second Real input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 < u2;
          annotation (
                defaultComponentName="les",
                Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{32,10},{52,-10}}, lineColor={0,0,127}),
                Line(points={{-100,-80},{42,-80},{42,0}}, color={0,0,127}),
                Line(
                  points={{-6,18},{-50,-2},{-6,-20}},
                  thickness=0.5),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
                                    Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Real input <code>u1</code>
is less than the Real input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Less;

        block LessEqual
          "Output y is true, if input u1 is less or equal than input u2"

          Interfaces.RealInput u1 "Connector of first Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealInput u2 "Connector of second Real input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 <= u2;
          annotation (
                defaultComponentName="lesEqu",
                Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{32,10},{52,-10}}, lineColor={0,0,127}),
                Line(points={{-100,-80},{42,-80},{42,0}}, color={0,0,127}),
                Line(
                  points={{-10,20},{-54,0},{-10,-18}},
                  thickness=0.5),
                Line(
                  points={{-54,-18},{-14,-34}},
                  thickness=0.5),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
                                    Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Real input <code>u1</code>
is less than or equal to the Real input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end LessEqual;

        block LessEqualThreshold
          "Output y is true, if input u is less or equal than threshold"

          parameter Real threshold=0 "Comparison with respect to threshold";

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u <= threshold;

          annotation (
                defaultComponentName="lesEquThr",
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,-140},{150,-110}},
                  lineColor={0,0,0},
                  textString="%threshold"),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Line(
                  points={{-54,-18},{-14,-34}},
                  thickness=0.5),
                Line(
                  points={{-10,20},{-54,0},{-10,-18}},
                  thickness=0.5)}),
         Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Real input is less than or equal to
the parameter <code>threshold</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end LessEqualThreshold;

        block LessThreshold "Output y is true, if input u is less than threshold"

          parameter Real threshold=0 "Comparison with respect to threshold";

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u < threshold;
          annotation (
                defaultComponentName="lesThr",
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,-140},{150,-110}},
                  lineColor={0,0,0},
                  textString="%threshold"),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Line(
                  points={{-10,20},{-54,0},{-10,-18}},
                  thickness=0.5)}),
        Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Real input is less than
the parameter <code>threshold</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end LessThreshold;

        block LimPID
          "P, PI, PD, and PID controller with limited output, anti-windup compensation and setpoint weighting"
          parameter
            hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController controllerType=
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
            "Type of controller";
          parameter Real k(
            min=0) = 1 "Gain of controller";
          parameter Modelica.SIunits.Time Ti(min=Constants.small) = 0.5
            "Time constant of integrator block"
            annotation (Dialog(enable=
                  controllerType == CDL.Types.SimpleController.PI or
                  controllerType == CDL.Types.SimpleController.PID));
          parameter Modelica.SIunits.Time Td(
            min=0) = 0.1
            "Time constant of derivative block"
            annotation (Dialog(enable=
                  controllerType == CDL.Types.SimpleController.PD or
                  controllerType == CDL.Types.SimpleController.PID));
          parameter Real yMax = 1 "Upper limit of output";
          parameter Real yMin = 0 "Lower limit of output";
          parameter Real wp(min=0) = 1 "Set-point weight for Proportional block (0..1)";
          parameter Real wd(min=0) = 0 "Set-point weight for Derivative block (0..1)"
               annotation(Dialog(enable=controllerType==CDL.Types.SimpleController.PD or
                                        controllerType==CDL.Types.SimpleController.PID));
          parameter Real Ni(min=100*Modelica.Constants.eps) = 0.9
            "Ni*Ti is time constant of anti-windup compensation"
             annotation(Dialog(enable=controllerType==CDL.Types.SimpleController.PI or
                                      controllerType==CDL.Types.SimpleController.PID));
          parameter Real Nd(min=100*Modelica.Constants.eps) = 10
            "The higher Nd, the more ideal the derivative block"
               annotation(Dialog(enable=controllerType==CDL.Types.SimpleController.PD or
                                        controllerType==CDL.Types.SimpleController.PID));

          parameter Real xi_start=0
            "Initial value of integrator state"
            annotation (Dialog(
              group="Initialization",
              enable=
               controllerType==CDL.Types.SimpleController.PI or
               controllerType==CDL.Types.SimpleController.PID));
          parameter Real yd_start=0 "Initial value of derivative output"
          annotation(Dialog(
              group="Initialization",
              enable=
                controllerType==CDL.Types.SimpleController.PD or
                controllerType==CDL.Types.SimpleController.PID));
            parameter Boolean reverseAction = false
            "Set to true for throttling the water flow rate through a cooling coil controller";
          parameter hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset reset=
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled
            "Type of controller output reset" annotation (Evaluate=true, Dialog(
                group="Integrator reset", enable=controllerType == CDL.Types.SimpleController.PI
                   or controllerType == CDL.Types.SimpleController.PID));
          parameter Real y_reset=xi_start
            "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == CDL.Types.Reset.Parameter"
            annotation(Dialog(enable=
              reset == CDL.Types.Reset.Parameter and
              (controllerType==CDL.Types.SimpleController.PI or
              controllerType==CDL.Types.SimpleController.PID), group="Integrator reset"));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u_s
            "Connector of setpoint input signal" annotation (Placement(
                transformation(extent={{-260,-20},{-220,20}}),
                iconTransformation(extent={{-140,-20},{-100,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u_m
            "Connector of measurement input signal" annotation (Placement(
                transformation(
                origin={0,-220},
                extent={{20,-20},{-20,20}},
                rotation=270), iconTransformation(
                extent={{20,-20},{-20,20}},
                rotation=270,
                origin={0,-120})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y
            "Connector of actuator output signal" annotation (Placement(
                transformation(extent={{220,-20},{260,20}}), iconTransformation(
                  extent={{100,-20},{140,20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput y_reset_in if reset
             == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Input
            "Input signal for state to which integrator is reset, enabled if reset = CDL.Types.Reset.Input"
            annotation (Placement(
              transformation(extent={{-260,-120},{-220,-80}}),
              visible=reset == Buildings.Controls.OBC.CDL.Types.Reset.Input,
              iconTransformation(extent={{-140,-100},{-100,-60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput trigger if reset
             <> hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled
            "Resets the controller output when trigger becomes true"
            annotation (Placement(
              transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-160,-200}),
              visible=reset <> Buildings.Controls.OBC.CDL.Types.Reset.Disabled,

              iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-120})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Feedback controlError
            "Control error (set point - measurement)" annotation (Placement(
                transformation(extent={{-200,-10},{-180,10}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.IntegratorWithReset
            I(
            final k=1/Ti,
            final y_start=xi_start,
            final reset=if reset == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled
                 then hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled
                 else hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Input,

            final y_reset=y_reset) if with_I "Integral term"
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Derivative D(
            final k=Td,
            final T=Td/Nd,
            final y_start=yd_start) if with_D "Derivative term"
            annotation (Placement(transformation(extent={{-40,60},{-20,80}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Feedback errP "P error"
            annotation (Placement(transformation(extent={{-100,110},{-80,130}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Feedback errD if with_D
            "D error"
            annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Feedback errI1 if with_I
            "I error (before anti-windup componensation)" annotation (Placement(
                transformation(extent={{-120,-10},{-100,10}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Feedback errI2 if with_I
            "I error (after anti-windup componensation)"
            annotation (Placement(transformation(extent={{-82,-10},{-62,10}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Limiter lim(final
              uMax=yMax, final uMin=yMin) "Limiter"
            annotation (Placement(transformation(extent={{120,80},{140,100}})));
        protected
          final parameter Real revAct = if reverseAction then -1 else 1
            "Switch for sign for reverse action";
          final parameter Boolean with_I = controllerType==hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI
                                                                                                                or
                                     controllerType==hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID
            "Boolean flag to enable integral action"
            annotation(Evaluate=true, HideResult=true);
          final parameter Boolean with_D = controllerType==hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD
                                                                                                                or
                                     controllerType==hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID
            "Boolean flag to enable derivative action"
            annotation(Evaluate=true, HideResult=true);

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant Dzero(final k=0)
            if not with_D "Zero input signal" annotation (
            Evaluate=true,
            HideResult=true,
            Placement(transformation(extent={{-40,90},{-20,110}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant Izero(final k=0)
            if not with_I "Zero input signal" annotation (
            Evaluate=true,
            HideResult=true,
            Placement(transformation(extent={{-40,20},{-20,41}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain uS_revAct(final k=
                revAct) "Set point multiplied by reverse action sign"
            annotation (Placement(transformation(extent={{-200,30},{-180,50}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain uSetWp(final k=
                wp) "Set point multiplied by weight for proportional gain"
            annotation (Placement(transformation(extent={{-160,110},{-140,130}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain uMea_revAct(final k=
                revAct) "Set point multiplied by reverse action sign"
            annotation (Placement(transformation(extent={{-180,-50},{-160,-30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain uSetWd(final k=
                wd) if with_D
            "Set point multiplied by weight for derivative gain" annotation (
              Placement(transformation(extent={{-160,60},{-140,80}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add addPD(final k1=
                1, final k2=1) "Outputs P and D gains added"
            annotation (Placement(transformation(extent={{0,104},{20,124}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gainPID(final k=k)
            "Multiplier for control gain"
            annotation (Placement(transformation(extent={{80,80},{100,100}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add addPID(final k1=
                1, final k2=1) "Outputs P, I and D gains added"
            annotation (Placement(transformation(extent={{40,80},{60,100}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Feedback antWinErr if with_I
            "Error for anti-windup compensation"
            annotation (Placement(transformation(extent={{162,50},{182,70}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain antWinGai(k=1/(k*Ni))
            if with_I "Gain for anti-windup compensation" annotation (Placement(
                transformation(extent={{180,-30},{160,-10}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant yResSig(final k=
                y_reset) if reset == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter
            "Signal for y_reset" annotation (Placement(transformation(extent={{
                    -180,-80},{-160,-60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain divK(final k=1
                /k) if reset <> hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled
            "Division by k for integrator reset" annotation (Placement(
                transformation(extent={{-120,-80},{-100,-60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Feedback addRes if reset
             <> hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled
            "Adder for integrator reset" annotation (Placement(transformation(
                  extent={{-80,-80},{-60,-60}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant cheYMinMax(final k=
                yMin < yMax) "Check for values of yMin and yMax" annotation (
              Placement(transformation(extent={{120,-160},{140,-140}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.Assert assMesYMinMax(message=
                "LimPID: Limits must be yMin < yMax")
            "Assertion on yMin and yMax" annotation (Placement(transformation(
                  extent={{160,-160},{180,-140}})));

        equation
          connect(trigger, I.trigger)
            annotation (Line(points={{-160,-200},{-160,-140},{-30,-140},{-30,-12}},
              color={255,0,255}));
          connect(u_s, uS_revAct.u) annotation (Line(points={{-240,0},{-212,0},{-212,40},
                  {-202,40}},                    color={0,0,127}));
          connect(uS_revAct.y, uSetWp.u) annotation (Line(points={{-178,40},{-170,40},{-170,
                  120},{-162,120}},
                                  color={0,0,127}));
          connect(u_m, uMea_revAct.u) annotation (Line(points={{0,-220},{0,-160},{-190,
                  -160},{-190,-40},{-182,-40}},
                                          color={0,0,127}));
          connect(uS_revAct.y, uSetWd.u) annotation (Line(points={{-178,40},{-170,40},{-170,
                  70},{-162,70}}, color={0,0,127}));
          connect(uSetWp.y, errP.u1)
            annotation (Line(points={{-138,120},{-102,120}}, color={0,0,127}));
          connect(errP.u2, uMea_revAct.y) annotation (Line(points={{-90,108},{-90,100},
                  {-128,100},{-128,-40},{-158,-40}},color={0,0,127}));
          connect(errD.u1, uSetWd.y) annotation (Line(points={{-102,70},{-138,70}},
                                  color={0,0,127}));
          connect(errD.u2, uMea_revAct.y) annotation (Line(points={{-90,58},{-90,48},{
                  -128,48},{-128,-40},{-158,-40}},
                              color={0,0,127}));
          connect(D.u,errD. y) annotation (Line(points={{-42,70},{-78,70}},
                color={0,0,127}));
          connect(errI1.u1, uS_revAct.y) annotation (Line(points={{-122,0},{-170,0},{-170,
                  40},{-178,40}}, color={0,0,127}));
          connect(errI1.u2, uMea_revAct.y) annotation (Line(points={{-110,-12},{-110,
                  -40},{-158,-40}},
                               color={0,0,127}));
          connect(addPD.u1, errP.y)
            annotation (Line(points={{-2,120},{-78,120}}, color={0,0,127}));
          connect(addPID.u1,addPD. y) annotation (Line(points={{38,96},{28,96},{28,114},
                  {22,114}}, color={0,0,127}));
          connect(addPID.y, gainPID.u)
            annotation (Line(points={{62,90},{78,90}}, color={0,0,127}));
          connect(lim.u, gainPID.y)
            annotation (Line(points={{118,90},{102,90}}, color={0,0,127}));
          connect(lim.y, y) annotation (Line(points={{142,90},{200,90},{200,0},{240,0}},
                color={0,0,127}));
          connect(antWinErr.y, antWinGai.u) annotation (Line(points={{184,60},{190,60},{
                  190,-20},{182,-20}}, color={0,0,127}));
          connect(addPD.u2, Dzero.y) annotation (Line(points={{-2,108},{-10,108},{-10,100},
                  {-18,100}}, color={0,0,127}));
          connect(D.y, addPD.u2) annotation (Line(points={{-18,70},{-10,70},{-10,108},{-2,
                  108}}, color={0,0,127}));
          connect(addPID.u2, Izero.y) annotation (Line(points={{38,84},{34,84},{34,30.5},
                  {-18,30.5}}, color={0,0,127}));
          connect(addPID.u2, I.y) annotation (Line(points={{38,84},{34,84},{34,0},{-18,0}},
                color={0,0,127}));
          connect(divK.y, addRes.u1)
            annotation (Line(points={{-98,-70},{-82,-70}}, color={0,0,127}));
          connect(addRes.u2, addPD.y) annotation (Line(points={{-70,-82},{-70,-108},{28,
                  -108},{28,114},{22,114}}, color={0,0,127}));
          connect(addRes.y, I.y_reset_in) annotation (Line(points={{-58,-70},{-52,-70},
                  {-52,-8},{-42,-8}},
                       color={0,0,127}));
          connect(divK.u, yResSig.y) annotation (Line(points={{-122,-70},{-158,-70}},
                                    color={0,0,127}));
          connect(divK.u, y_reset_in) annotation (Line(points={{-122,-70},{-140,-70},{
                  -140,-100},{-240,-100}},
                                      color={0,0,127}));
          connect(antWinErr.u1, gainPID.y) annotation (Line(points={{160,60},{110,60},{110,
                  90},{102,90}}, color={0,0,127}));
          connect(antWinErr.u2, lim.y) annotation (Line(points={{172,48},{172,40},{150,40},
                  {150,90},{142,90}}, color={0,0,127}));
          connect(I.u, errI2.y)
            annotation (Line(points={{-42,0},{-60,0}}, color={0,0,127}));
          connect(errI1.y, errI2.u1)
            annotation (Line(points={{-98,0},{-84,0}}, color={0,0,127}));
          connect(errI2.u2,antWinGai. y)
            annotation (Line(points={{-72,-12},{-72,-20},{158,-20}}, color={0,0,127}));
          connect(controlError.u1, u_s)
            annotation (Line(points={{-202,0},{-240,0}}, color={0,0,127}));
          connect(controlError.u2, u_m) annotation (Line(points={{-190,-12},{-190,-160},
                  {0,-160},{0,-220}},                       color={0,0,127}));
          connect(cheYMinMax.y, assMesYMinMax.u)
            annotation (Line(points={{142,-150},{158,-150}}, color={255,0,255}));
        annotation (defaultComponentName="conPID",
          Icon(
            coordinateSystem(extent={{-100,-100},{100,100}}),
              graphics={
                Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-6,-20},{66,-66}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.P),
                  extent={{-32,-22},{68,-62}},
                  lineColor={0,0,0},
                  textString="P",
                  fillPattern=FillPattern.Solid,
                  fillColor={175,175,175}),
                Text(
                  visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PI),
                  extent={{-26,-22},{74,-62}},
                  lineColor={0,0,0},
                  textString="PI",
                  fillPattern=FillPattern.Solid,
                  fillColor={175,175,175}),
                Text(
                  visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PD),
                  extent={{-16,-22},{88,-62}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  fillColor={175,175,175},
                  textString="P D"),
                Text(
                  visible=(controllerType == Buildings.Controls.OBC.CDL.Types.SimpleController.PID),
                  extent={{-14,-22},{86,-62}},
                  lineColor={0,0,0},
                  textString="PID",
                  fillPattern=FillPattern.Solid,
                  fillColor={175,175,175}),
                Polygon(
                  points={{-80,82},{-88,60},{-72,60},{-80,82}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,68},{-80,-100}},color={192,192,192}),
                Line(points={{-90,-80},{70,-80}}, color={192,192,192}),
                Polygon(
                  points={{74,-80},{52,-72},{52,-88},{74,-80}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(
                  points={{-80,-80},{-80,-22}},
                  color={0,0,0}),
                Line(
                  points={{-80,-22},{6,56}},
                  color={0,0,0}),
                Line(
                  points={{6,56},{68,56}},
                  color={0,0,0}),
                Rectangle(
                  extent=DynamicSelect({{100,-100},{84,-100}}, {{100,-100},{84,-100+(y-yMin)/(yMax-yMin)*200}}),
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0})}),
            Diagram(coordinateSystem(extent={{-220,-200},{220,200}})),
        Documentation(info="<html>
<p>
PID controller in the standard form
</p>
<p align=\"center\" style=\"font-style:italic;\">
y = k &nbsp; ( e(t) + 1 &frasl; T<sub>i</sub> &nbsp; &int; e(s) ds + T<sub>d</sub> de(t)&frasl;dt ),
</p>
<p>
where
<i>y</i> is the control signal,
<i>e(t) = u<sub>s</sub> - u<sub>m</sub></i> is the control error,
with <i>u<sub>s</sub></i> being the set point and <i>u<sub>m</sub></i> being
the measured quantity,
<i>k</i> is the gain,
<i>T<sub>i</sub></i> is the time constant of the integral term and
<i>T<sub>d</sub></i> is the time constant of the derivative term.
</p>
<p>
Note that the units of <i>k</i> are the inverse of the units of the control error,
while the units of <i>T<sub>i</sub></i> and <i>T<sub>d</sub></i> are seconds.
</p>
<p>
For detailed treatment of integrator anti-windup, set-point weights and output limitation, see
<a href=\"modelica://Modelica.Blocks.Continuous.LimPID\">Modelica.Blocks.Continuous.LimPID</a>.
The model is similar to
<a href=\"modelica://Modelica.Blocks.Continuous.LimPID\">Modelica.Blocks.Continuous.LimPID</a>,
except for the following changes:
</p>
<ol>
<li>
<p>
It can be configured to have a reverse action.
</p>
<p>If the parameter <code>reverseAction=false</code> (the default), then
<code>u_m &lt; u_s</code> increases the controller output,
otherwise the controller output is decreased. Thus,
</p>
<ul>
  <li>for a heating coil with a two-way valve, set <code>reverseAction = false</code>, </li>
  <li>for a cooling coils with a two-way valve, set <code>reverseAction = true</code>. </li>
</ul>
</li>
<li>
<p>
It can be configured to enable an input port that allows resetting the controller
output. The controller output can be reset as follows:
</p>
<ul>
  <li>
  If <code>reset = CDL.Types.Reset.Disabled</code>, which is the default,
  then the controller output is never reset.
  </li>
  <li>
  If <code>reset = CDL.Types.Reset.Parameter</code>, then a boolean
  input signal <code>trigger</code> is enabled. Whenever the value of
  this input changes from <code>false</code> to <code>true</code>,
  the controller output is reset by setting <code>y</code>
  to the value of the parameter <code>y_reset</code>.
  </li>
  <li>
  If <code>reset = CDL.Types.Reset.Input</code>, then a boolean
  input signal <code>trigger</code> is enabled. Whenever the value of
  this input changes from <code>false</code> to <code>true</code>,
  the controller output is reset by setting <code>y</code>
  to the value of the input signal <code>y_reset_in</code>.
  </li>
</ul>
<p>
Note that this controller implements an integrator anti-windup. Therefore,
for most applications, keeping the default setting of
<code>reset = CDL.Types.Reset.Disabled</code> suffices.
However, better control performance is typically achieved if the output of the
controller is reset when a control loop is activated.
Examples where it may be beneficial to reset the controller output are situations
where the equipment control input should continuously increase as the equipment is
switched on, such as as a light dimmer that may slowly increase the luminance, or
a variable speed drive of a motor that should continuously increase the speed,
or a mixing valve that should slowly open.
</p>
</li>
<li>
There is no optional input for a feedforward compensation.
</li>
<li>
The parameter <code>limitsAtInit</code> has been removed.
</li>
<li>
Homotopy initialization is not implemented.
</li>
</ol>
<p>
During initialization, the state, and hence the output, of the integrator is set to the
parameter <code>xi_start</code>,
and the output of the derivative action is set to the parameter
<code>yd_start</code>.
Note that both will be multiplied by the gain <code>k</code> before the values
are sent to the output limiter and then the controller output.
</p>
<p>
For recommendations regarding tuning of closed loop control, see
<a href=\"modelica://Modelica.Blocks.Continuous.LimPID\">Modelica.Blocks.Continuous.LimPID</a>
or the control literature.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 23, 2020, by Michael Wetter:<br/>
Changed default parameters for limits <code>yMax</code> from unspecified to <code>1</code>
and <code>yMin</code> from <code>-yMax</code> to <code>0</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1888\">issue 1888</a>.
</li>
<li>
April 7, 2020, by Michael Wetter:<br/>
Reimplemented block using only CDL constructs.
This refactoring removes the no longer use parameters <code>xd_start</code> that was
used to initialize the state of the derivative term. This state is now initialized
based on the requested initial output <code>yd_start</code> which is a new parameter
with a default of <code>0</code>.
Also, removed the parameters <code>y_start</code> and <code>initType</code> because
the initial output of the controller can be set by using <code>xi_start</code>
and <code>yd_start</code>.
This is a non-backward compatible change, made to simplify the controller through
the removal of options that can be realized differently and are hardly ever used.
This refactoring also removes the parameter <code>strict</code> that
was used in the output limiter. The new implementation enforces a strict check by default.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1878\">issue 1878</a>.
</li>
<li>
March 9, 2020, by Michael Wetter:<br/>
Corrected unit declaration for gain <code>k</code>.<br/>
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1821\">issue 1821</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
February 25, 2020, by Michael Wetter:<br/>
Changed icon to display the output value.
</li>
<li>
October 19, 2019, by Michael Wetter:<br/>
Disabled homotopy to ensure bounded outputs
by copying the implementation from MSL 3.2.3 and by
hardcoding the implementation for <code>homotopyType=NoHomotopy</code>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1221\">issue 1221</a>.
</li>
<li>
November 13, 2017, by Michael Wetter:<br/>
Changed default controller type from PID to PI.
</li>
<li>
November 6, 2017, by Michael Wetter:<br/>
Explicitly declared types and used integrator with reset from CDL.
</li>
<li>
October 22, 2017, by Michael Wetter:<br/>
Added to CDL to have a PI controller with integrator reset.
</li>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model.
</li>
<li>
August 25, 2016, by Michael Wetter:<br/>
Removed parameter <code>limitsAtInit</code> because it was only propagated to
the instance <code>limiter</code>, but this block no longer makes use of this parameter.
This is a non-backward compatible change.<br/>
Revised implemenentation, added comments, made some parameter in the instances final.
</li>
<li>July 18, 2016, by Philipp Mehrfeld:<br/>
Added integrator reset.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/494\">issue 494</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Changed the default value to <code>strict=true</code> in order to avoid events
when the controller saturates.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/433\">issue 433</a>.
</li>
<li>
February 24, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LimPID;

        block Limiter "Limit the range of a signal"

          parameter Real uMax "Upper limit of input signal";
          parameter Real uMin "Lower limit of input signal";

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        initial equation
          assert(uMin < uMax, "uMin must be smaller than uMax. Check parameters.");

        equation
          y = homotopy(
            actual = smooth(0, noEvent(
              if u > uMax then uMax else if u < uMin then uMin else u)),
            simplified=u);
           annotation (
        defaultComponentName="lim",
        Documentation(info="<html>
<p>
Block that outputs <code>y = min(uMax, max(uMin, u))</code>,
where
<code>u</code> is an input
and
<code>uMax</code> and <code>uMin</code> are parameters.
</p>
<p>
If <code>uMax &lt; uMin</code>, an error occurs and no output is produced.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
July 17, 2017, by Michael Wetter:<br/>
Removed cyclical definition.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),
        Icon(graphics={
           Text(  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
            Line(points={{0,-90},{0,68}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-90,0},{68,0}}, color={192,192,192}),
            Polygon(
              points={{90,0},{68,-8},{68,8},{90,0}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-70},{-50,-70},{50,70},{80,70}}),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              points={{50,70},{80,70}}),
            Line(
              points={{-80,-70},{-50,-70}}),
            Text(
              extent={{12,72},{94,98}},
              lineColor={0,0,0},
                  textString="%uMax"),
            Text(
              extent={{-100,-98},{-18,-72}},
              lineColor={0,0,0},
                  textString="%uMin"),
            Text(
              extent={{226,60},{106,10}},
              lineColor={0,0,0},
              textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Limiter;

        block Line
          "Output the value of the input x along a line specified by two points"

          parameter Boolean limitBelow = true "If true, limit input u to be no smaller than x1"
            annotation(Evaluate=true);

          parameter Boolean limitAbove = true "If true, limit input u to be no larger than x2"
            annotation(Evaluate=true);

          Interfaces.RealInput x1 "Support point x1, with x1 < x2"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Interfaces.RealInput f1 "Support point f(x1)"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

          Interfaces.RealInput x2 "Support point x2, with x2 > x1"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

          Interfaces.RealInput f2 "Support point f(x2)"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.RealInput u "Independent variable"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "f(x) along the line specified by (x1, f1) and (x2, f2)"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));
        protected
          Real a "Intercept";
          Real b "Slope";
          Real xLim "Input value after applying the limits";

        equation
          if limitBelow or limitAbove then
            assert(x2 > x1, "x2 must be bigger than x1 in " + getInstanceName(),
              AssertionLevel.warning);
          end if;

          b = (f2-f1)/(x2-x1);
          a = f2 - b*x2;

          if limitBelow and limitAbove then
            xLim = min(x2, max(x1, u));
          elseif limitBelow then
            xLim = max(x1, u);
          elseif limitAbove then
            xLim = min(x2, u);
          else
            xLim = u;
          end if;
           y = a + b * xLim;
          annotation (
            defaultComponentName="lin",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Polygon(
                  points={{92,-78},{70,-70},{70,-86},{92,-78}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-46,40},{50,-44}},
                  color={0,0,0},
                  thickness=0.5),
                Line(points={{-80,-80},{-80,72}},
                     color={192,192,192}),
                Polygon(
                  points={{-80,92},{-88,70},{-72,70},{-80,92}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-88,-78},{76,-78}},
                     color={192,192,192}),
                Line(
                  points={{-100,80},{-64,80}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{-64,80},{-62,-78}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{-100,40},{-88,40}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{-88,40},{-48,40}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{-100,-40},{48,-36}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{48,-36},{50,-78}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{-100,-80},{-38,-56}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{-38,-56},{48,-44}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{-100,0},{-62,0}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{-62,0},{8,-8}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{10,-8},{52,-8}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Line(
                  points={{52,-8},{100,0}},
                  color={28,108,200},
                  smooth=Smooth.Bezier,
                  pattern=LinePattern.Dot),
                Ellipse(
                  extent={{44,-38},{56,-50}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{2,-2},{14,-14}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Line(points={{50,-44},{80,-70}},
                  color={0,0,0},
                  thickness=0.5,
                  visible=not limitAbove),
                Line(points={{52,-44},{86,-44}},
                  color={238,46,47},
                  thickness=0.5,
                  visible=limitAbove),
                Line(points={{-80,68},{-46,40}},
                  color={0,0,0},
                  thickness=0.5,
                  visible=not limitBelow),
                Line(points={{-80,40},{-46,40}},
                  color={238,46,47},
                  thickness=0.5,
                  visible=limitBelow),
                Ellipse(
                  extent={{-52,46},{-40,34}},
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
            Text(
              extent={{226,60},{106,10}},
              lineColor={0,0,0},
              textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = a + b u</code>,
where
<code>u</code> is an input
and the coefficients <code>a</code> and <code>b</code>
are determined so that the line intercepts the two input points
specified by the two points <code>x1</code> and <code>f1</code>,
and <code>x2</code> and <code>f2</code>.
</p>
<p>
The parameters <code>limitBelow</code> and <code>limitAbove</code>
determine whether <code>x1</code> and <code>x2</code> are also used
to limit the input <code>u</code>.
</p>
<p>
If the limits are used, then this block requires <code>x1 &lt; x2</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 25, 2018, by Michael Wetter:<br/>
Improved documentation, icon and added warning if the limits are used and
<code>x1 &gt; x2</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1155\">issue 1155</a>.
</li>
<li>
January 11, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Line;

        block Log
          "Output the natural (base e) logarithm of the input (input > 0 required)"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = Modelica.Math.log(u);

        annotation (
          defaultComponentName="log",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{-90,0},{68,0}}, color={192,192,192}),
                Line(points={{-80,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                      {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                      {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
                Text(
                  extent={{-6,-24},{66,-72}},
                  lineColor={192,192,192},
                  textString="log"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = log(u)</code>,
where
<code>u</code> is an input and <code>log()</code> is the
natural logarithm (base-e) function.
</p>

<p>
An error occurs if the input <code>u</code> is
zero or negative.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Log.png\"
     alt=\"log.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Log;

        block Log10 "Output the base 10 logarithm of the input (input > 0 required)"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = Modelica.Math.log10(u);

        annotation (
          defaultComponentName="log10",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{-90,0},{68,0}}, color={192,192,192}),
                Line(points={{-80,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                      {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                      {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
                Text(
                  extent={{-6,-24},{66,-72}},
                  lineColor={192,192,192},
                  textString="log10"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = log10(u)</code>,
where
<code>u</code> is an input and <code>log10()</code> is the
logarithm (base-10) function.
</p>

<p>
An error occurs if the input <code>u</code> is
zero or negative.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Log10.png\"
     alt=\"log10.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Log10;

        block MatrixGain
          "Output the product of a gain matrix with the input signal vector"

          parameter Real K[:, :]=[1, 0; 0, 1]
            "Gain matrix which is multiplied with the input";

          Interfaces.RealInput u[nin] "Connector of Real input signals"
            annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.RealOutput y[nout] "Connector of Real output signals"
            annotation (Placement(
              transformation(extent={{100,-20},{140,20}})));

        protected
          parameter Integer nin=size(K, 2) "Number of inputs";
          parameter Integer nout=size(K, 1) "Number of outputs";

        equation
          y = K*u;
          annotation (
            defaultComponentName="matGai",
            Documentation(info="<html>
<p>
This blocks computes output vector <i>y</i> as the product of the
gain matrix <i>K</i> with the input signal vector <i>u</i> as
<i>y = K u</i>.
For example,
</p>
<pre>
   parameter Real K[:,:] = [0.12 2; 3 1.5];
</pre>
<p>
results in
</p>
<pre>
     | y[1] |     | 0.12  2.00 |   | u[1] |
     |      |  =  |            | * |      |
     | y[2] |     | 3.00  1.50 |   | u[2] |
</pre>

</html>",         revisions="<html>
<ul>
<li>
February 11, 2019, by Milica Grahovac:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                                    Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                                      Text(
                  extent={{-50,-30},{20,38}},
                  lineColor={0,0,0},
                  textString="[  ]"), Text(
                  extent={{8,-30},{80,10}},
                  lineColor={0,0,0},
                  textString="*")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                                      Text(
                  extent={{-50,-30},{20,38}},
                  lineColor={0,0,0},
                  textString="[  ]"), Text(
                  extent={{8,-30},{80,10}},
                  lineColor={0,0,0},
                  textString="*")}));
        end MatrixGain;

        block MatrixMax "Output vector of row- or column-wise maximum of the input matrix"

          parameter Boolean rowMax = true "If true, outputs row-wise maximum, otherwise column-wise";

          parameter Integer nRow(final min=1) "Number of rows in input matrix";

          parameter Integer nCol(final min=1) "Number of columns in input matrix";

          Interfaces.RealInput u[nRow, nCol] "Connector of Real input signals"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y[if rowMax then size(u, 1) else size(u, 2)] "Connector of Real output signals"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          if rowMax then
            y = {max(u[i,:]) for i in 1:size(u, 1)};
          else
            y = {max(u[:,i]) for i in 1:size(u, 2)};
          end if;

        annotation (
            defaultComponentName="matMax",
            Documentation(info="<html>
<p>
If <code>rowMax = true</code>, this block outputs the row-wise maximum
of the input matrix <code>u</code>,
otherwise it outputs the column-wise maximum of the input matrix <code>u</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 17, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                                    Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),Text(
                  extent={{-78,-62},{86,68}},
                  lineColor={0,0,0},
                  textString="[  ] max()")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}})));
        end MatrixMax;

        block MatrixMin "Output vector of row- or column-wise minimum values"

          parameter Boolean rowMin = true "If true, outputs row-wise minimum, otherwise column-wise";

          parameter Integer nRow(final min=1) "Number of rows in input matrix";

          parameter Integer nCol(final min=1) "Number of columns in input matrix";

          Interfaces.RealInput u[nRow, nCol] "Connector of Real input signals"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y[if rowMin then size(u, 1) else size(u, 2)] "Connector of Real output signals"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          if rowMin then
            y = {min(u[i,:]) for i in 1:size(u, 1)};
          else
            y = {min(u[:,i]) for i in 1:size(u, 2)};
          end if;

        annotation (
            defaultComponentName="matMin",
            Documentation(info="<html>
<p>
If <code>rowMin = true</code>, this block outputs the row-wise minimum
of the input matrix <code>u</code>,
otherwise it outputs the column-wise minimum of the input matrix <code>u</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 17, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                                    Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                                      Text(
                  extent={{-78,-62},{86,68}},
                  lineColor={0,0,0},
                  textString="[  ] min()")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}})));
        end MatrixMin;

        block Max "Pass through the largest signal"

          Interfaces.RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = max(u1, u2);

        annotation (
        defaultComponentName="max",
        Documentation(info="<html>
<p>
Block that outputs <code>y = max(u1, u2)</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="max()"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Max;

        block Min "Pass through the smallest signal"

          Interfaces.RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = min(u1, u2);

        annotation (
        defaultComponentName="min",
        Documentation(info="<html>
<p>
Block that outputs <code>y = min(u1, u2)</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="min()"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Min;

        block Modulo
          "Output the remainder of first input divided by second input (~=0)"

          Interfaces.RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = mod(u1,u2);

          annotation (
            defaultComponentName="mod",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Ellipse(lineColor={0,0,127}, extent={{-50,-48},{50,52}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Text(
                  extent={{-32,-52},{40,-100}},
                  lineColor={192,192,192},
                  textString="mod"),
                Line(points={{-8,16}}, color={0,0,0}),
                Line(
                  points={{-100,60}},
                  color={0,0,0},
                  thickness=1),
                Line(points={{-100,60},{-28,60},{-12,50}}, color={0,0,127}),
                Line(points={{-100,-60},{-26,-60},{-2,-48}}, color={0,0,127}),
                Line(points={{50,2},{102,2},{100,2}}, color={0,0,127}),
                Ellipse(fillPattern=FillPattern.Solid, extent={{11,-18},{21,-8}}),
                Line(points={{-24,-20},{26,24}}),
                Ellipse(fillPattern=FillPattern.Solid, extent={{-21,12},{-11,22}}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = mod(u1/u2)</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 15, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Modulo;

        block MovingMean
          "Block to output moving average"

          parameter Modelica.SIunits.Time delta(min=1E-5)
            "Time horizon over which the input is averaged";

          Interfaces.RealInput u "Connector of Real input signal"
           annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.RealOutput y "Connector of Real output signal"
           annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          parameter Modelica.SIunits.Time tStart(fixed=false) "Start time";
          Real mu "Internal integrator variable";
          Real muDel "Internal integrator variable with delay";
          Boolean mode(start=false, fixed=true) "Calculation mode";

        initial equation
          tStart = time;
          mu = 0;
        equation
          u =der(mu);
          muDel = delay(mu, delta);

          // Compute the mode so that Dymola generates
          // time and not state events as it would with
          // an if-then construct
          when time >= tStart+delta then
            mode = true;
          end when;

          if mode then
            y = (mu-muDel)/delta;
          else
            y = (mu-muDel)/(time-tStart+1E-3);
          end if;
          annotation (
          defaultComponentName="movMea",
          Icon(graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-78,90},{-86,68},{-70,68},{-78,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-78,68},{-78,-80}}, color={192,192,192}),
                Line(points={{-88,0},{70,0}}, color={192,192,192}),
                Polygon(
                  points={{92,0},{70,8},{70,-8},{92,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(
                   points={{-78,-31},{-64,-31},{-64,-15},{-56,-15},{-56,-63},{-48,-63},{
                      -48,-41},{-40,-41},{-40,43},{-32,43},{-32,11},{-32,11},{-32,-49},{
                      -22,-49},{-22,-31},{-12,-31},{-12,-59},{-2,-59},{-2,23},{4,23},{4,
                      37},{10,37},{10,-19},{20,-19},{20,-7},{26,-7},{26,-37},{36,-37},{36,
                      35},{46,35},{46,1},{54,1},{54,-65},{64,-65}},
                    color={215,215,215}),
                Line(
                  points={{-78,-24},{68,-24}}),
                Text(
                  extent={{-140,152},{160,112}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-42,-63},{41,-106}},
                  lineColor={192,192,192},
                  textString="%delta s"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
           Documentation(info="<html>
<p>
This block outputs the mean value of its input signal as
</p>
<pre>
      1  t
y =   -  &int;   u(s) ds
      &delta;  t-&delta;
</pre>
<p>
where <i>&delta;</i> is a parameter that determines the time window over
which the input is averaged.
For
<i> t &lt; &delta;</i> seconds, it outputs
</P>
<pre>
           1      t
y =   --------    &int;   u(s) ds
      t-t<sub>0</sub>+10<sup>-10</sup>   t<sub>0</sub>
</pre>
<p>
where <i>t<sub>0</sub></i> is the initial time.
</p>
<p>
This block can for example be used to output the moving
average of a noisy measurement signal.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Validation.MovingMean\">
Buildings.Controls.OBC.CDL.Continuous.Validation.MovingMean</a>
and
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Validation.MovingMean_nonZeroStart\">
Buildings.Controls.OBC.CDL.Continuous.Validation.MovingMean_nonZeroStart</a>
for example.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
October 24, 2017, by Michael Wetter:<br/>
Set initial condition for <code>mu</code>.
</li>
<li>
October 17, 2017, by Michael Wetter:<br/>
Reformulated implementation to avoid direct feedthrough.
</li>
<li>
October 16, 2017, by Michael Wetter:<br/>
Reformulated implementation to handle division by zero as the previous
implementation caused division by zero in the VAV reheat model with the Radau solver.
</li>
<li>
September 27, 2017, by Thierry S. Nouidui:<br/>
Reformulated implementation to handle division by zero.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/978\">issue 978</a>.
</li>
<li>
September 15, 2017, by Thierry S. Nouidui:<br/>
Reformulated implementation to avoid state events.
</li>
<li>
July 5, 2017, by Michael Wetter:<br/>
Revised implementation to allow non-zero start time.
</li>
<li>
June 29, 2017, by Jianjun Hu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/825\">issue 825</a>.
</li>
</ul>
</html>"));
        end MovingMean;

        block MultiMax "Output the maximum element of the input vector"

          parameter Integer nin(min=0) = 0 "Number of input connections"
            annotation (Dialog(connectorSizing=true), HideResult=true);
          Interfaces.RealInput u[nin] "Connector of Real input signals"
            annotation (Placement(transformation(extent={{-140,20},{-100,-20}})));
          Interfaces.RealOutput y "Connector of Real output signals"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = max(u);

        annotation (
          defaultComponentName = "mulMax",
          Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}}),
              graphics={
                Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="max()"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
        Documentation(info="<html>
<p>
Outputs the maximum element of the input vector.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end MultiMax;

        block MultiMin "Output the minimum element of the input vector"

          parameter Integer nin(min=0) = 0 "Number of input connections"
            annotation (Dialog(connectorSizing=true), HideResult=true);
          Interfaces.RealInput u[nin] "Connector of Real input signals"
            annotation (Placement(transformation(extent={{-140,20},{-100,-20}})));
          Interfaces.RealOutput y "Connector of Real output signals"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = min(u);

        annotation (
          defaultComponentName = "mulMin",
          Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}}),
                graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="min()"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
        Documentation(info="<html>
<p>
Outputs the minimum element of the input vector.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end MultiMin;

        block MultiSum
          "Sum of Reals, y = k[1]*u[1] + k[2]*u[2] + ... + k[n]*u[n]"

          parameter Integer nin(min=0) = 0 "Number of input connections"
            annotation (Dialog(connectorSizing=true), HideResult=true);
          parameter Real k[nin]=fill(1, nin) "Input gains";
          Interfaces.RealInput u[nin] "Connector of Real input signals"
            annotation (Placement(transformation(extent={{-140,20},{-100,-20}})));
          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          if size(u, 1) > 0 then
            y = k*u;
          else
            y = 0;
          end if;

          annotation (
          defaultComponentName="mulSum",
          Icon(graphics={
               Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
               Text(
                  extent={{-200,-110},{200,-140}},
                  lineColor={0,0,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid,
                  textString="%k"), Text(
                  extent={{-82,90},{82,-46}},
                  lineColor={0,0,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid,
                  textString="+"),
                Text(
                  extent={{-144,150},{156,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs
</p>
<p align=\"center\" style=\"font-style:italic;\">
y = &sum;<sub>i=1</sub><sup>n</sup> k<sub>i</sub> &nbsp; u<sub>i</sub>,
</p>
<p>
where <i>k</i> is a parameter with <i>n</i> elements and <i>u</i> is
an input of the same length.
The dimension of <i>u</i> can be enlarged by
drawing an additional connection line. The connection is automatically connected
to this new free index.
</p>

<p>
If no connection to the input connector <i>u</i> is present,
the output is <i>y=0</i>.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Validation.MultiSum\">
Buildings.Controls.OBC.CDL.Continuous.Validation.MultiSum</a>
for an example.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
June 28, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the Modelica Standard
Library. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/825\">issue 825</a>.
</li>
</ul>
</html>"));
        end MultiSum;

        block NumberOfRequests
          "Outputs the number of signals that are above/below a certain threshold"

          parameter Integer nin "Number of inputs";
          parameter Real threShold = 0 "Threshold";
          parameter Integer kind
            "Set to 0 for u>threShold, to 1 for >=, to 2 for <= or to 3 for <";
          Interfaces.IntegerOutput y
            "Number of input signals that violate the threshold"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));
          Interfaces.RealInput u[nin] "Input signals"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        algorithm
          y := 0;
          for i in 1:nin loop
            if kind == 0 then
              if u[i] > threShold then
                y := y+1;
              end if;
            end if;
            if kind == 1 then
              if u[i] >= threShold then
                y := y+1;
              end if;
            end if;
            if kind == 2 then
              if u[i] <= threShold then
                y := y+1;
              end if;
            end if;
            if kind == 3 then
              if u[i] < threShold then
                y := y+1;
              end if;
            end if;
          end for;
          annotation (
        defaultComponentName="numReq",
        Documentation(info="<html>
<p>
Block that outputs the number of inputs that exceed a threshold.
The parameter <code>kind</code> is used to determine the kind of the
inequality. The table below shows the allowed settings.
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\" summary=\"Allowed parameter settings.\">
<tr>
<th>Value of parameter <code>kind</code></th>
<th>Output signal incremented by 1 for each <i>i &isin; {1, ..., nin}</i> if</th>
</tr>
<tr>
<td>0</td>
<td><code>u[i] &gt; threShold</code></td>
</tr>
<tr>
<td>1</td>
<td><code>u[i] &ge; threShold</code></td>
</tr>
<tr>
<td>2</td>
<td><code>u[i] &le; threShold</code></td>
</tr>
<tr>
<td>3</td>
<td><code>u[i] &lt; threShold</code></td>
</tr>
</table>
<p>
This model may be used to check how many rooms
exceed a temperature threshold.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 10, 2017, by Milica Grahovac:<br/>
Initial CDL implementation.
</li>
<li>
November 21, 2011, by Michael Wetter:<br/>
Improved documentation.
</li>
<li>
November 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Text(
                  extent={{-128,88},{-6,28}},
                  lineColor={0,0,255},
                  textString="%threShold"),
                Line(points={{-62,-6},{-4,24}}, color={0,0,255}),
                Line(points={{-4,24},{64,60}}, color={255,0,0}),
                Line(
                  points={{-78,24},{78,24}},
                  pattern=LinePattern.Dot),
                Line(points={{-86,4},{-18,24}}, color={0,0,255}),
                Line(points={{-18,24},{66,54}}, color={255,0,0}),
                Line(points={{-78,-50},{78,-50}}),
                Line(points={{70,-46},{78,-50}}),
                Line(points={{70,-54},{78,-50}}),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end NumberOfRequests;

        block Product "Output product of the two inputs"

          Interfaces.RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 * u2;

        annotation (
        defaultComponentName="pro",
        Documentation(info="<html>
<p>
Block that outputs <code>y = u1 * u2</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
              graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,127}),
                Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,127}),
                Line(points={{50,0},{100,0}}, color={0,0,127}),
                Line(points={{-30,0},{30,0}}),
                Line(points={{-15,25.99},{15,-25.99}}),
                Line(points={{-15,-25.99},{15,25.99}}),
                Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end Product;

        block Round "Round real number to given digits"

          parameter Integer n "Number of digits being round to";

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y
            "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));
        protected
          parameter Real fac = 10^n "Factor used for rounding";

        equation
          y = if (u>0) then floor(u*fac + 0.5)/fac else ceil(u*fac - 0.5)/fac;

        annotation (
        defaultComponentName="rou",
        Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,127},
                  extent={{-56,4},{72,106}},
                  textString="round( )"),
                Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                Text(
                  lineColor={0,0,127},
                  extent={{-60,-88},{54,-34}},
                  textString="%n"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
        Documentation(info="<html>
<p>
Block that outputs the input after rounding it to <code>n</code> digits.
</p>
<p>
For example,
</p>
<ul>
<li>
set <code>n = 0</code> to round to the nearest integer,
</li>
<li>
set <code>n = 1</code> to round to the next decimal point, and
</li>
<li>
set <code>n = -1</code> to round to the next multiple of ten.
</li>
</ul>
<p>
Hence, the block outputs
</p>
<pre>
    y = floor(u*(10^n) + 0.5)/(10^n)  for  u &gt; 0,
    y = ceil(u*(10^n) - 0.5)/(10^n)   for  u &lt; 0.
</pre>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Round;

        block Sin "Output the sine of the input"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = Modelica.Math.sin(u);

        annotation (
          defaultComponentName="sin",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
                Line(points={{-90,0},{68,0}}, color={192,192,192}),
                Line(
                  points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
                      {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},
                      {-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},
                      {29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{
                      57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}},
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{90,0},{68,8},{68,-8},{90,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{12,84},{84,36}},
                  lineColor={192,192,192},
                  textString="sin"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = sin(u)</code>,
where
<code>u</code> is an input.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Sin.png\"
     alt=\"sin.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Sin;

        block SlewRateLimiter "Limit the increase or decrease rate of input"

          parameter Real raisingSlewRate(
            min = Constants.small,
            unit = "1/s") "Speed with which to increase the output";

          parameter Real fallingSlewRate(
            max = -Constants.small,
            unit = "1/s") = -raisingSlewRate "Speed with which to decrease the output";

          parameter Modelica.SIunits.Time Td(min=Constants.eps) = raisingSlewRate*10
            "Derivative time constant";

          parameter Boolean enable = true
            "Set to false to disable rate limiter";

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          Real thr = (u-y)/Td "Approximation to derivative between input and output";

        initial equation
            y = u;

        equation
          if enable then
            der(y) = smooth(1, noEvent(
              if thr < fallingSlewRate then fallingSlewRate
              else if thr > raisingSlewRate then raisingSlewRate
              else thr));
          else
            y = u;
          end if;

           annotation (
        defaultComponentName="ramLim",
        Documentation(info="<html>
<p>
The block limits the rate of change of the input by a ramp.
This block computes a threshold for the rate of change between
input <code>u</code> and output <code>y</code> as
<code>thr = (u-y)/Td</code>, where <code>Td &gt; 0</code> is  parameter.
The output <code>y</code> is computed as follows:
<br/>
If <code>thr &lt; fallingSlewRate</code>, then <code>dy/dt = fallingSlewRate</code>,
<br/>
if <code>thr &gt; raisingSlewRate</code>, then <code>dy/dt = raisingSlewRate</code>,
<br/>
otherwise, <code>dy/dt = thr</code>.
</p>
<h4>Implementation</h4>
<p>
For the block to work with arbitrary inputs and in order to produce a differential output,
the input is numerically differentiated with derivative time constant <code>Td</code>.
Smaller time constant <code>Td</code> means nearer ideal derivative.
</p>

</html>",         revisions="<html>
<ul>
<li>
April 21, 2020, by Michael Wetter:<br/>
Removed final attribute on unit because if the input quantity is power,
then the rate limit is units of power per units of time.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 29, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),         Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
            Line(points={{0,-90},{0,68}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-90,0},{68,0}}, color={192,192,192}),
            Polygon(
              points={{90,0},{68,-8},{68,8},{90,0}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              lineColor={0,0,255}),
            Line(
              points={{-50,-70},{50,70}}),
            Text(
              extent={{226,60},{106,10}},
              lineColor={0,0,0},
              textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end SlewRateLimiter;

        block Sort "Sort elements of input vector in ascending or descending order"

          parameter Integer nin(min=0) = 0 "Number of input connections"
            annotation (Dialog(connectorSizing=true), HideResult=true);

          parameter Boolean ascending=true
            "= true if ascending order, otherwise descending order";
          Interfaces.RealInput u[nin] "Connector of Real input signals"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.RealOutput y[nin] "Connector of Real output signals"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));
        equation
          y = Modelica.Math.Vectors.sort(u, ascending=ascending);
          annotation (
        defaultComponentName="sort",
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
                       Text(
                  extent={{-58,70},{54,-60}},
                  lineColor={0,0,89},
                  textString="sort")}),
        Documentation(info="<html>
<p>
Block that sorts the elements of the input signal <i>u</i>.
If the parameter <code>ascending = true</code>, then the output signal satisfies
<i>y<sub>i</sub> &lt;= y<sub>i+1</sub></i> for all <i>i &isin; {1, ..., n-1}</i>.
Otherwise, it satisfies
<i>y<sub>i</sub> &gt;= y<sub>i+1</sub></i> for all <i>i &isin; {1, ..., n-1}</i>.
</p>
<p>
This block may for example be used in a variable air volume flow
controller to access the position of the dampers that are most open.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 22, 2017, by Michael Wetter:<br/>
Reimplemented function to make it work with OpenModelica.
</li>
<li>
September 14, 2017, by Jianjun Hu:<br/>
Changed model name.
</li>
<li>
January 10, 2017, by Milica Grahovac:<br/>
Initial CDL implementation.
</li>
<li>
November 21, 2011, by Michael Wetter:<br/>
Removed <code>assert</code> statement.
</li>
<li>
November 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Sort;

        block Sqrt
          "Output the square root of the input (input >= 0 required)"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = sqrt(u);
          annotation (
            defaultComponentName="sqr",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={  Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Line(points={{-90,-80},{68,-80}}, color={192,192,192}),
                Polygon(
                  points={{90,-80},{68,-72},{68,-88},{90,-80}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-80,-80},{-79.2,-68.7},{-78.4,-64},{-76.8,-57.3},{-73.6,-47.9},
                      {-67.9,-36.1},{-59.1,-22.2},{-46.2,-6.49},{-28.5,10.7},{-4.42,
                      30},{27.7,51.3},{69.5,74.7},{80,80}},
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-80,-88},{-80,68}}, color={192,192,192}),
                Text(
                  extent={{-8,-4},{64,-52}},
                  lineColor={192,192,192},
                  textString="sqrt"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs square root of the input <code>y = sqrt(u)</code>,
where <code>u</code> is an input. All elements of the input vector shall be non-negative.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 15, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Sqrt;

        block Tan "Output the tangent of the input"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = Modelica.Math.tan(u);

        annotation (
          defaultComponentName="tan",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name"),
                Text(
                  extent={{-90,72},{-18,24}},
                  lineColor={192,192,192},
                  textString="tan"),
                Line(points={{0,-80},{0,68}}, color={192,192,192}),
                Polygon(
                  points={{0,90},{-8,68},{8,68},{0,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{90,0},{68,8},{68,-8},{90,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-90,0},{68,0}}, color={192,192,192}),
                Line(
                  points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
                      {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
                      {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{
                      73.6,47.4},{76,56.1},{77.6,63.8},{80,80}},
                  smooth=Smooth.Bezier),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = tan(u)</code>,
where
<code>u</code> is an input.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Tan.png\"
     alt=\"tan.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Tan;

        package Sources "Package with blocks that generate source signals"

          model CalendarTime
            "Computes the unix time stamp and calendar time from the simulation time"

            parameter hil_flexlab_model.Controls_HIL.OBC.CDL.Types.ZeroTime zerTim
              "Enumeration for choosing how reference time (time = 0) should be defined";
            parameter Integer yearRef(min=firstYear, max=lastYear) = 2016
              "Year when time = 0, used if zerTim=Custom"
              annotation(Dialog(enable=zerTim == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.ZeroTime.Custom));
            parameter Modelica.SIunits.Time offset = 0
              "Offset that is added to 'time', may be used for computing time in different time zone"
              annotation(Dialog(tab="Advanced"));

            discrete Interfaces.IntegerOutput  year "Year"
              annotation (Placement(transformation(extent={{100,-40},{120,-20}}),
                  iconTransformation(extent={{100,-40},{120,-20}})));
            discrete Interfaces.IntegerOutput  month "Month of the year"
              annotation (Placement(transformation(extent={{100,-10},{120,10}}),
                  iconTransformation(extent={{100,-10},{120,10}})));
            Interfaces.IntegerOutput day(fixed=false) "Day of the month"
              annotation (Placement(transformation(extent={{100,20},{120,40}}),
                  iconTransformation(extent={{100,20},{120,40}})));
            Interfaces.IntegerOutput hour(fixed=false) "Hour of the day"
              annotation (Placement(transformation(extent={{100,50},{120,70}}),
                  iconTransformation(extent={{100,50},{120,70}})));
            Interfaces.RealOutput minute "Minute of the hour"
              annotation (Placement(transformation(extent={{100,80},{120,100}}),
                  iconTransformation(extent={{100,80},{120,100}})));
            Interfaces.IntegerOutput weekDay(fixed=false)
              "Integer output representing week day (monday = 1, sunday = 7)"
              annotation (Placement(transformation(extent={{100,-70},{120,-50}}),
                  iconTransformation(extent={{100,-70},{120,-50}})));

          protected
            final constant Integer firstYear = 2010
              "First year that is supported, i.e. the first year in timeStampsNewYear[:]";
            final constant Integer lastYear = firstYear + 11
              "Last year that is supported (actual building automation system need to support a larger range)";

            Buildings.Utilities.Time.CalendarTime calTim(
              final zerTim=zerTim,
              final yearRef=yearRef,
              final offset=offset) "Calendar time"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

          equation
            connect(calTim.minute, minute) annotation (Line(points={{11,9},{55.5,9},{55.5,
                    90},{110,90}}, color={0,0,127}));
            connect(calTim.hour, hour) annotation (Line(points={{11,6.4},{60,6.4},{60,60},
                    {110,60}}, color={255,127,0}));
            connect(calTim.day, day) annotation (Line(points={{11,3.8},{64,3.8},{64,30},{110,
                    30}}, color={255,127,0}));
            connect(calTim.month, month) annotation (Line(points={{11,1.2},{80,1.2},{80,0},
                    {110,0}}, color={255,127,0}));
            connect(calTim.year, year) annotation (Line(points={{11,-1.4},{64,-1.4},{64,-30},
                    {110,-30}}, color={255,127,0}));
            connect(calTim.weekDay, weekDay) annotation (Line(points={{11,-4},{60,-4},{60,
                    -60},{110,-60}}, color={255,127,0}));
            annotation (
              defaultComponentName="calTim",
            Documentation(
          info="<html>
<p>
Block that outputs minute, hour, day of the month, month, year and weekday.
</p>
<h4>Assumption and limitations</h4>
<p>
The implementation only supports date computations from year 2010 up to and including 2020.
Daylight saving and time zones are not supported.
</p>
<h4>Typical use and important parameters</h4>
<p>
The user must define which time and date correspond to <code>time = 0</code>
using the model parameters <code>zerTim</code>, and, if
<code>zerTim == CDL.Types.ZeroTime.Custom</code>,
the parameter <code>yearRef</code>.
The user can choose from new year, midnight for a number of years:
2010 to 2020 and also 1970.
The latter corresponds to a unix stamp of <i>0</i>.
Note that when choosing the reference time equal to 0 at 1970,
the actual simulation time must be within the 2010-2020 range.
For example, <code>startTime = 1262304000</code> corresponds
to the simulation starting on the 1st of January 2010 local time
when setting <code>zerTim = CDL.Types.ZeroTime.UnixTimeStamp</code>.
This is within the 2010-2020 range and is therefore allowed.
</p>
</html>", revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
August 20, 2019, by Filip Jorissen:<br/>
Revised implementation such that the meaning of <code>time</code> is better explained
and unix time stamps are correctly defined with respect to GMT.
(see <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1192\">#1192</a>).
</li>
<li>
March 14, 2017, by Michael Wetter:<br/>
Refactored implementation.
</li>
<li>
February 23, 2017, by Milica Grahovac:<br/>
First CDL implementation.
</li>
<li>
August 3, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={                    Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={223,211,169},
                  lineThickness=5.0,
                  borderPattern=BorderPattern.Raised,
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                  Ellipse(
                    extent={{-94,94},{16,-16}},
                    lineColor={160,160,164},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-34,92},{96,82}},
                    lineColor={28,108,200},
                    horizontalAlignment=TextAlignment.Right,
                    textString="Minute"),
                  Text(
                    extent={{-28,64},{96,54}},
                    lineColor={28,108,200},
                    horizontalAlignment=TextAlignment.Right,
                    textString="Hour"),
                  Text(
                    extent={{-38,36},{96,24}},
                    lineColor={28,108,200},
                    horizontalAlignment=TextAlignment.Right,
                    textString="Day"),
                  Text(
                    extent={{-50,4},{96,-6}},
                    lineColor={28,108,200},
                    horizontalAlignment=TextAlignment.Right,
                    textString="Month"),
                  Text(
                    extent={{-70,-24},{96,-34}},
                    lineColor={28,108,200},
                    horizontalAlignment=TextAlignment.Right,
                    textString="Year"),
                  Text(
                    extent={{-68,-54},{96,-66}},
                    lineColor={28,108,200},
                    horizontalAlignment=TextAlignment.Right,
                    textString="Weekday"),
                  Line(
                    points={{-40,38},{-64,62}},
                    thickness=0.5),
                  Line(
                    points={{-40,38},{-14,38}},
                    thickness=0.5)}));
          end CalendarTime;

          block Constant "Output constant signal of type Real"
            parameter Real k "Constant output value";

            Interfaces.RealOutput y
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y = k;
            annotation (
              defaultComponentName="con",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
                  Polygon(
                    points={{-80,90},{-88,68},{-72,68},{-80,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
                  Polygon(
                    points={{90,-70},{68,-62},{68,-78},{90,-70}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,0},{80,0}}),
                  Text(
                    extent={{-150,-150},{150,-110}},
                    lineColor={0,0,0},
                    textString="k=%k"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
              Documentation(info="<html>
<p>
Block that outputs a constant signal <code>y = k</code>,
where <code>k</code> is a real-valued parameter.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Constant.png\"
     alt=\"Constant.png\" />
</p>
</html>",           revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 16, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Constant;

          block ModelTime "Standard time"

            Interfaces.RealOutput y(final unit="s")
              "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y = time;

            annotation (
              defaultComponentName="modTim",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={         Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),   Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid),
                  Line(points={{0,80},{0,60}}, color={160,160,164}),
                  Line(points={{80,0},{60,0}}, color={160,160,164}),
                  Line(points={{0,-80},{0,-60}}, color={160,160,164}),
                  Line(points={{-80,0},{-60,0}}, color={160,160,164}),
                  Line(points={{37,70},{26,50}}, color={160,160,164}),
                  Line(points={{70,38},{49,26}}, color={160,160,164}),
                  Line(points={{71,-37},{52,-27}}, color={160,160,164}),
                  Line(points={{39,-70},{29,-51}}, color={160,160,164}),
                  Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
                  Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
                  Line(points={{-71,37},{-54,28}}, color={160,160,164}),
                  Line(points={{-38,70},{-28,51}}, color={160,160,164}),
                  Line(
                    points={{0,0},{-50,50}},
                    thickness=0.5),
                  Line(
                    points={{0,0},{40,0}},
                    thickness=0.5),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
          Documentation(info="<html>
<p>Block that outputs the standard time.
</p>
<h4>Implementation</h4>
<p>
This block outputs the time of the model.
In the case of a building automation system, the
building automation system synchronizes time, and hence
need to assign a value for the output of this block.
Daylight saving time shall not be taken into account,
e.g, the block always outputs standard time rather than
daylight savings time.
</p>
<p>
If a simulation starts
at <i>t=-1</i>, then this block outputs first <i>t=-1</i>,
and its output is advanced at the same rate as the simulation time.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 14, 2017, by Michael Wetter:<br/>
Revised implemenation.
</li>
<li>
February 23, 2017, by Milica Grahovac:<br/>
First CDL implementation.
</li>
<li>
January 16, 2015, by Michael Wetter:<br/>
Moved block from
<code>Buildings.Utilities.SimulationTime</code>
to
<code>Buildings.Utilities.Time.ModelTime</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
          end ModelTime;

          block Pulse "Generate pulse signal of type Real"
            parameter Real amplitude=1 "Amplitude of pulse";
            parameter Real width(
              final min=Constants.small,
              final max=1,
              final unit = "1") = 0.5 "Width of pulse in fraction of period";
            parameter Modelica.SIunits.Time period(final min=Constants.small)
             "Time for one period";
            parameter Integer nperiod=-1
              "Number of periods (< 0 means infinite number of periods)";
            parameter Real offset=0 "Offset of output signals";
            parameter Modelica.SIunits.Time startTime=0
              "Output = offset for time < startTime";
            Interfaces.RealOutput y "Connector of Pulse output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          protected
            Modelica.SIunits.Time T_width=period*width "Pulse duration time";
            Modelica.SIunits.Time T_start "Start time of current period";
            Integer count "Period count";
          initial equation
            count = integer((time - startTime)/period);
            T_start = startTime + count*period;
          equation
            when integer((time - startTime)/period) > pre(count) then
              count = pre(count) + 1;
              T_start = time;
            end when;
            y = offset + (if (time < startTime or nperiod == 0 or (nperiod > 0 and
              count >= nperiod)) then 0 else if time < T_start + T_width then amplitude
               else 0);
            annotation (
              defaultComponentName="pul",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={
                                          Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
                  Polygon(
                    points={{-80,90},{-88,68},{-72,68},{-80,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
                  Polygon(
                    points={{90,-70},{68,-62},{68,-78},{90,-70}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,-70},{-40,-70},{-40,44},{0,44},{0,-70},{40,-70},{40,
                        44},{79,44}}),
                  Text(
                    extent={{-147,-152},{153,-112}},
                    lineColor={0,0,0},
                    textString="period=%period"),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
              Documentation(info="<html>
<p>
The Real output y is a pulse signal:
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Sources/Pulse.png\"
     alt=\"Pulse.png\" />
</p>
</html>",           revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 16, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Pulse;

          block Ramp "Generate ramp signal"
            parameter Real height=1 "Height of ramps";
            parameter Modelica.SIunits.Time duration(min=Constants.small)
              "Duration of ramp (= 0.0 gives a Step)";
            parameter Real offset=0 "Offset of output signal";
            parameter Modelica.SIunits.Time startTime=0
              "Output = offset for time < startTime";

            Interfaces.RealOutput y "Connector of Real output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y = offset + (if time < startTime then 0 else if time < (startTime +
              duration) then (time - startTime)*height/duration else height);
            annotation (
              defaultComponentName="ram",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name"),  Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
                  Polygon(
                    points={{-80,90},{-88,68},{-72,68},{-80,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
                  Polygon(
                    points={{90,-70},{68,-62},{68,-78},{90,-70}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,-70},{-40,-70},{31,38}}),
                  Text(
                    extent={{-150,-150},{150,-110}},
                    lineColor={0,0,0},
                    textString="duration=%duration"),
                  Line(points={{31,38},{86,38}}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
              Documentation(info="<html>
<p>
The Real output y is a ramp signal:
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Sources/Ramp.png\"
     alt=\"Ramp.png\" />
</p>

</html>",           revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 16, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Ramp;

          block Sine "Generate sine signal"
            parameter Real amplitude=1 "Amplitude of sine wave";
            parameter Modelica.SIunits.Frequency freqHz(start=1) "Frequency of sine wave";
            parameter Modelica.SIunits.Angle phase=0 "Phase of sine wave";
            parameter Real offset=0 "Offset of output signal";
            parameter Modelica.SIunits.Time startTime=0 "Output = offset for time < startTime";

            hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y
              "Connector of Real output signal" annotation (Placement(
                  transformation(extent={{100,-20},{140,20}})));

          equation
            y = offset + (if time < startTime then 0 else amplitude*
              Modelica.Math.sin(2*hil_flexlab_model.Controls_HIL.OBC.CDL.Constants.pi
              *freqHz*(time - startTime) + phase));
            annotation (
              defaultComponentName="sin",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}),graphics={
                  Text(
                    lineColor={0,0,255},
                    extent={{-148,104},{152,144}},
                    textString="%name"),
                  Rectangle(extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
                  Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-90,0},{68,0}}, color={192,192,192}),
                  Polygon(points={{90,0},{68,8}, {68,-8},{90,0}},
                    lineColor={192,192,192}, fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,
                        74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,
                        59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,
                        -64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},
                        {57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, smooth = Smooth.Bezier),
                  Text(extent={{-147,-152},{153,-112}},lineColor={0,0,0},
                    textString="freqHz=%freqHz"),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
              Documentation(info="<html>
<p>
Block that outputs a <code>sine</code>.
</p>
<p>
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Continuous/Sources/Sine.png\"
     alt=\"Sine.png\"/>
</p>
</html>",           revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
November 06, 2017, by Milica Grahovac:<br/>
First CDL implementation.
</li>
</ul>
</html>"));
          end Sine;

          block TimeTable
            "Table look-up with respect to time and linear or periodic extrapolation"

            parameter Real table[:,:]
            "Table matrix (time = first column is time in seconds, unless timeScale <> 1)";
            parameter CDL.Types.Smoothness smoothness=CDL.Types.Smoothness.LinearSegments
              "Smoothness of table interpolation";
            parameter CDL.Types.Extrapolation extrapolation=CDL.Types.Extrapolation.Periodic
              "Extrapolation of data outside the definition range";
            parameter Real offset[:]={0} "Offsets of output signals";
            parameter Modelica.SIunits.Time timeScale=1
              "Time scale of first table column. Set to 3600 if time in table is in hours";

            Interfaces.RealOutput y[nout] "Output of the table"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          protected
            final parameter Integer nout=size(table, 2)-1
              "Dimension of output vector";

            parameter Modelica.SIunits.Time t0(fixed=false)
              "First sample time instant";

            // CDL uses different enumerations for smoothness and for extrapolation
            // than the Modelica Standard Library. Hence, we cast the CDL
            // enumeration to the MSL enumaration.
            Modelica.Blocks.Sources.CombiTimeTable tab(
              final tableOnFile=false,
              final table=table,
              final columns=2:size(tab.table, 2),
              final smoothness=if smoothness == CDL.Types.Smoothness.LinearSegments then
                                  Modelica.Blocks.Types.Smoothness.LinearSegments
                               else
                                  Modelica.Blocks.Types.Smoothness.ConstantSegments,
              final extrapolation=if extrapolation == CDL.Types.Extrapolation.HoldLastPoint then
                                    Modelica.Blocks.Types.Extrapolation.HoldLastPoint
                                  elseif extrapolation == CDL.Types.Extrapolation.LastTwoPoints then
                                    Modelica.Blocks.Types.Extrapolation.LastTwoPoints
                                  else
                                    Modelica.Blocks.Types.Extrapolation.Periodic,
              final offset=offset,
              final startTime=if (extrapolation == Types.Extrapolation.Periodic) then integer(t0/86400)*86400 else 0,
              final timeScale=timeScale) "Time table"
              annotation (Placement(transformation(extent={{-12,-10},{8,10}})));

          initial equation
            t0=time;

          equation
            connect(tab.y, y) annotation (Line(points={{9,0},{120,0}}, color={0,0,127}));

          annotation (
          defaultComponentName = "timTab",
          Documentation(info="<html>
<p>
Block that outputs values of a time table.
</p>
<p>
The block takes as a parameter a time table of the format
</p>
<pre>
table = [ 0*3600, 0;
          6*3600, 0;
          6*3600, 1;
         18*3600, 1;
         18*3600, 0;
         24*3600, 0];
</pre>
<p>
where the first column is time in seconds, and the remaining
column(s) are the table values.
Any number of columns can be specified.
The parameter <code>smoothness</code> determines how the table values
are interpolated. The following settings are allowed:
</p>

<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr><th><code>smoothness</code></th><th>Description</th></tr>
<tr>
  <td><code>CDL.Types.LinearSegments</code></td>
  <td>Table points are linearly interpolated.</td>
</tr>
<tr>
  <td><code>CDL.Types.ConstantSegments</code></td>
  <td>Table points are not interpolated,
      but the previous tabulated value is returned.</td>
</tr>
</table>

<p>
The parameter <code>extrapolation</code> determines how the table
values are extrapolated. The following settings are allowed:
</p>

<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr><th><code>extrapolation</code></th><th>Description</th></tr>
<tr>
  <td><code>CDL.Types.HoldLastPoint</code></td>
  <td>Hold the first or last table point outside of the table scope.</td>
</tr>
<tr>
  <td><code>CDL.Types.LastTwoPoints</code></td>
  <td>Extrapolate by using the derivative at the first or last table points
      outside of the table scope.</td>
</tr>
<tr>
  <td><code>CDL.Types.Periodic</code></td>
  <td>Repeat the table scope periodically with periodicity
      <code>(max(table[:, 1]-min(table[:, 1]))*timeScale)</code>.</td>
</tr>
</table>

<p>
If <code>extrapolation === CDL.Types.Periodic</code>, then the above example
would give a schedule with periodicity of one day. The simulation can start at any time,
whether it is a multiple of a day or not, and positive or negative.
</p>

<p>
The value of the parameter <code>offset</code> is added to the tabulated
values.
The parameters <code>timeScale</code> is used to scale the first column
of the table. For example, set <code>timeScale = 3600</code> if the first
column is in hour (because in CDL, the time unit is seconds).
</p>
<p>
If the table has only one row, no interpolation is performed and
the table values of this row are just returned.
</p>
<p>
An interval boundary is defined by two identical time values
following each other. For example
</p>
<pre>
   table = [0, 0;
            1, 0;
            1, 1;
            2, 3;
            3, 5;
            3, 2;
            4, 4;
            5, 5];
</pre>
<p>
defines three intervalls: 0..1, 1..3, 3..5. Within an interval the defined
interpolation method is applied (so the table outputs within an interval are
continuous if <code>smoothness = CDL.Types.LinearSegments</code>).
</p>
<p>
Example:
</p>
<pre>
  table = [0, 0;
           1, 0;
           1, 1;
           2, 4;
           3, 9;
           4, 16];
  smoothness = CDL.Types.LinearSegments;

If, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)
    e.g., time = 1.5, the output y =  2.5,
    e.g., time = 2.0, the output y =  4.0,
    e.g., time = 5.0, the output y = 23.0 (i.e., extrapolation via last 2 points).
</pre>
<h4>Implementation</h4>
<p>
For simulation,
no time events are generated within an interval
in order that also intervals with many points do not reduce the simulation efficiency.
If the table points are largely changing, it is adviseable to force
time events by duplicating every time point (especially, if the model in which
the table is present allows the variable step integrator to make large
integrator steps). For example, if a sawtooth signal is defined with the table,
it is more reliable to define the table as:
</p>
<pre>
   table = [0, 0;
            1, 2;
            1, 2;
            2, 0;
            2, 0;
            3, 2;
            3, 2];
</pre>
<p>
instead of
</p>
<pre>
   table = [0, 0;
            1, 2;
            2, 0;
            3, 2];
</pre>
<p>
because time events are then generated at every time point.
</p>
<p>
Building automation systems typically have discrete time semantics
with fixed sampling times, and no notion of superdense time (in which
a tabulated value can change without advancing time).
Therefore, to implement a table with two equal time stamps,
a CDL translator may parameterize
a table in the building automation in such a way that the step change happens
at the time indicated in the first column, whereas previous sampling times
output the tabulated value at the last transition. For example,
</p>
<pre>
table = [0, 0;
         1, 0;
         1, 1];
smoothness = CDL.Types.ConstantSegments;
</pre>
<p>
may be converted such that a building automation system with a sampling time
of <i>0.5</i> seconds outputs
</p>
<pre>
  t = 0, 0.5, 1, ...
  y = 0, 0  , 1, ...
</pre>
</html>", revisions="<html>
<ul>
<li>
March 13, 2020, by Michael Wetter:<br/>
Corrected implementation so that the table also works if the simulation
starts at a negative time.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1834\">issue 1834</a>.
</li>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
March 14, 2017, by Michael Wetter:<br/>
Refactored and simplified implementation.
</li>
<li>
February 23, 2017, by Milica Grahovac:<br/>
Initial CDL implementation.
</li>
</ul>
</html>"),    Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={                Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
              Line(points={{-80.0,68.0},{-80.0,-80.0}},
                color={192,192,192}),
              Line(points={{-90.0,-70.0},{82.0,-70.0}},
                color={192,192,192}),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{90.0,-70.0},{68.0,-62.0},{68.0,-78.0},{90.0,-70.0}}),
              Rectangle(lineColor={255,255,255},
                fillColor={255,215,136},
                fillPattern=FillPattern.Solid,
                extent={{-48.0,-50.0},{2.0,70.0}}),
              Line(points={{-48.0,-50.0},{-48.0,70.0},{52.0,70.0},{52.0,-50.0},
                  {-48.0,-50.0},{-48.0,-20.0},{52.0,-20.0},{52.0,10.0},{-48.0,10.0},
                  {-48.0,40.0},{52.0,40.0},{52.0,70.0},{2.0,70.0},{2.0,-51.0}}),
                  Text(
                    extent={{226,60},{106,10}},
                    lineColor={0,0,0},
                    textString=DynamicSelect("", if (nout==1) then String(y[1], leftjustified=false, significantDigits=3) else ""))}));
          end TimeTable;

          package Validation "Collection of models that validate the continuous sources blocks of the CDL"

            model CalendarTimeMonths
              "Validation model for the calendar time model"
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.CalendarTime
                calTim(zerTim=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.ZeroTime.NY2017)
                "Computes date and time assuming time=0 corresponds to new year 2017"
                annotation (Placement(transformation(extent={{-20,-10},{0,10}})));

              annotation (experiment(StartTime=172800, Tolerance=1e-6, StopTime=345600),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/CalendarTimeMonths.mos"
                    "Simulate and plot"),
              Documentation(info="<html>
<p>
This model validates the use of the
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.CalendarTime\">
Buildings.Controls.OBC.CDL.Continuous.Sources.CalendarTime</a>
block for a period of a couple of months.
This shorter simulation time has been selected to
store the reference results that are used in the regression tests
at a resulation that makes sense for the minute and hour outputs.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 18, 2017, by Jianjun Hu:<br/>
First implementation in CDL.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end CalendarTimeMonths;

            model CalendarTimeMonthsMinus
              "Validation model for the calendar time model with start time slightly below the full hour"
              extends
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Validation.CalendarTimeMonths;

              annotation (experiment(StartTime=172799, Tolerance=1e-6, StopTime=345599),
                __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/CalendarTimeMonthsMinus.mos"
                    "Simulate and plot"),
              Documentation(info="<html>
<p>
This model validates the use of the
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.CalendarTime\">
Buildings.Controls.OBC.CDL.Continuous.Sources.CalendarTime</a>.
It is identical to
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.Validation.CalendarTimeMonths\">
Buildings.Controls.OBC.CDL.Continuous.Sources.Validation.CalendarTimeMonths</a>
except that the start and end time are different.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 18, 2017, by Jianjun Hu:<br/>
First implementation in CDL.
</li>
</ul>
</html>"));
            end CalendarTimeMonthsMinus;

            model CalendarTimeMonthsPlus
              "Validation model for the calendar time model with start time slightly higher than the full hour"
              extends
                hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Validation.CalendarTimeMonths;

              annotation (experiment(StartTime=172801, Tolerance=1e-6, StopTime=345601),
                __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/CalendarTimeMonthsPlus.mos"
                    "Simulate and plot"),
              Documentation(info="<html>
<p>
This model validates the use of the
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.CalendarTime\">
Buildings.Controls.OBC.CDL.Continuous.Sources.CalendarTime</a>.
It is identical to
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.Validation.CalendarTimeMonths\">
Buildings.Controls.OBC.CDL.Continuous.Sources.Validation.CalendarTimeMonths</a>
except that the start and end time are different.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 18, 2017, by Jianjun Hu:<br/>
First implementation in CDL.
</li>
</ul>
</html>"));
            end CalendarTimeMonthsPlus;

            model Constant "Validate the Constant block"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant
                con(k=2.5) "Block output real constant value" annotation (
                  Placement(transformation(extent={{-10,-10},{10,10}})));
              annotation (
              experiment(StopTime=1.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/Constant.mos"
                    "Simulate and plot"),
                Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.Constant\">
Buildings.Controls.OBC.CDL.Continuous.Sources.Constant</a>.
</p>

</html>",             revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end Constant;

            model Pulse "Validation model for the Pulse block"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pulse(
                amplitude=2.0,
                width=0.5,
                offset=0.2,
                period=1) "Block that generates pulse signal of type Real"
                annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

              annotation (
              experiment(StopTime=5.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/Pulse.mos"
                    "Simulate and plot"),
                Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.Pulse\">
Buildings.Controls.OBC.CDL.Continuous.Sources.Pulse</a>.
</p>

</html>",             revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end Pulse;

            model Ramp "Validation model for the Ramp"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram(
                height=2,
                duration=3,
                offset=0.5,
                startTime=1.0) "Block that generates ramp signal" annotation (
                  Placement(transformation(extent={{-10,-10},{10,10}})));

              annotation (
              experiment(StopTime=5.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/Ramp.mos"
                    "Simulate and plot"),
                Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.Ramp\">
Buildings.Controls.OBC.CDL.Continuous.Sources.Ramp</a>.
</p>
</html>",             revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end Ramp;

            model Sine "Validation model for Sine"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine sin(
                amplitude=5,
                freqHz=1/60,
                phase=0,
                offset=10,
                startTime=10) "Sine source block" annotation (Placement(
                    transformation(extent={{-12,-10},{8,10}})));
              annotation (
              experiment(StopTime=130.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/Sine.mos"
                    "Simulate and plot"),
                Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.Ramp\">
Buildings.Controls.OBC.CDL.Continuous.Sources.Ramp</a>.
</p>
</html>",             revisions="<html>
<ul>
<li>
November 06, 2017, by Milica Grahovac:<br/>
First CDL implementation.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end Sine;

            model StandardTime "Test model for the StandardTime block"
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.ModelTime
                staTim "Standard time" annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}})));

              annotation (experiment(StartTime=-1,Tolerance=1e-6, StopTime=1),
                __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/StandardTime.mos"
                    "Simulate and plot"),
              Documentation(info="<html>
<p>
This model tests the implementation of the block that outputs the
model time.
</p>
</html>",             revisions="<html>
<ul>
<li>
July 18, 2017, by Jianjun Hu:<br/>
First implementation in CDL.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end StandardTime;

            model TimeTable "Validation model for TimeTable block"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabLin(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.LinearSegments,
                  table=[0,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of linear segments"
                annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabLinHol(
                smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.LinearSegments,

                extrapolation=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Extrapolation.HoldLastPoint,

                table=[0,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of linear segments, hold first and last value"
                annotation (Placement(transformation(extent={{-10,10},{10,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabLinDer(
                smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.LinearSegments,

                extrapolation=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Extrapolation.LastTwoPoints,

                table=[0,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of linear segments, extrapolate with der"
                annotation (Placement(transformation(extent={{50,10},{70,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabCon(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                  table=[0,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of constant segments"
                annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabLinCon(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.LinearSegments,
                  table=[0,0; 6*3600,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of linear segments"
                annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));

              annotation (experiment(Tolerance=1e-6, StopTime=172800),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/TimeTable.mos"
                   "Simulate and plot"),
              Documentation(info="<html>
<p>
This model validates the TimeTable block. It takes as a parameter a time table of
the format
</p>
<pre>
table = [ 0*3600, 0;
          6*3600, 1;
         18*3600, 0.5;
         24*3600, 0];
</pre>
<p>
The block <code>timTabLin</code> applies smoothness method of linear segments
between table points, periodically repeat the table scope.
</p>
<p>
The block <code>timTabLinHol</code> applies smoothness method of linear segments
between table points, hold the last table points when it becomes outside of
table scope.
</p>
<p>
The block <code>timTabLinDer</code> applies smoothness method of linear segments
between table points, extrapolate by using the derivative at the last table
points to find points outside the table scope.
</p>
<p>
The block <code>timTabCon</code> applies smoothness method of constant segments
between table points, periodically repeat the table scope.
</p>
<p>
The block <code>timTabLinCon</code> applies smoothness method of linear segments
between table points, periodically repeat the table scope. Table points is
different so to ensure constant zero during time range of
<code>(0*3600, 6*36000)</code>.
</p>
<pre>
table = [ 0*3600, 0;
          6*3600, 0;
          6*3600, 1;
         18*3600, 0.5;
         24*3600, 0];
</pre>
</html>",   revisions="<html>
<ul>
<li>
July 18, 2017, by Jianjun Hu:<br/>
First implementation in CDL.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end TimeTable;

            model TimeTableNegativeStartTime
              "Validation model for TimeTable block with negative start time"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabLin(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.LinearSegments,
                  table=[0,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of linear segments"
                annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabLinHol(
                smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.LinearSegments,

                extrapolation=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Extrapolation.HoldLastPoint,

                table=[0,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of linear segments, hold first and last value"
                annotation (Placement(transformation(extent={{-10,10},{10,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabLinDer(
                smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.LinearSegments,

                extrapolation=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Extrapolation.LastTwoPoints,

                table=[0,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of linear segments, extrapolate with der"
                annotation (Placement(transformation(extent={{50,10},{70,30}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabCon(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                  table=[0,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of constant segments"
                annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
                timTabLinCon(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.LinearSegments,
                  table=[0,0; 6*3600,0; 6*3600,1; 18*3600,0.5; 24*3600,0])
                "Time table with smoothness method of linear segments"
                annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));

              annotation (experiment(Tolerance=1e-6, StartTime=-129600.0, StopTime=172800),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Sources/Validation/TimeTableNegativeStartTime.mos"
                   "Simulate and plot"),
              Documentation(info="<html>
<p>
This model validates the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.TimeTable\">
Buildings.Controls.OBC.CDL.Continuous.Sources.TimeTable</a>.
The model is identical to
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.Validation.TimeTable\">
Buildings.Controls.OBC.CDL.Continuous.Sources.Validation.TimeTable</a>
except that the start time is negative, and not a multiple of a full day.
</html>",   revisions="<html>
<ul>
<li>
March 13, 2020, by Michael Wetter:<br/>
First implementation in CDL.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end TimeTableNegativeStartTime;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources\">
Buildings.Controls.OBC.CDL.Continuous.Sources</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Polygon(
                    origin={8.0,14.0},
                    lineColor={78,138,73},
                    fillColor={78,138,73},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}}),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0)}));
          end Validation;
        annotation (
        Documentation(
        info="<html>
<p>
Package with blocks that generate signals.
</p>
</html>"),         Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  fillColor = {128,128,128},
                  pattern = LinePattern.None,
                  fillPattern = FillPattern.Solid,
                  extent = {{-70,-4.5},{0,4.5}}),
                Polygon(origin={23.3333,0.0},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0)}));
        end Sources;

        package Validation "Collection of models that validate the continuous blocks of the CDL"

          model Abs "Validation model for the absolute block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Abs abs1
              "Block that outputs the absolute value of the input" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp(
              height=2,
              duration=1,
              offset=-1) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp.y, abs1.u)
              annotation (Line(points={{-38,0},{-38,0},{-12,0}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Abs.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Abs\">
Buildings.Controls.OBC.CDL.Continuous.Abs</a>.
The input varies from <i>-1</i> to <i>+1</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 17, 2017, by Jianjun Hu:<br/>
Update the Ramp block: <a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Ramp\">
Buildings.Controls.OBC.CDL.Continuous.Ramp</a>.
</li>
</ul>
<ul>
<li>
February 22, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Abs;

          model Add "Validation model for the add block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1
              "Block that outputs the sum of the two inputs" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,10},{-40,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              height=2,
              duration=1,
              offset=-1) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-30},{-40,-10}})));
          equation
            connect(ramp1.y, add1.u1) annotation (Line(points={{-38,20},{-26,20},{-26,6},
                    {-12,6}},color={0,0,127}));
            connect(ramp2.y, add1.u2) annotation (Line(points={{-38,-20},{-26,-20},{-26,
                    -6},{-12,-6}},
                               color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Add.mos"
                  "Simulate and plot"),
              Documentation(
          info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Add\">
Buildings.Controls.OBC.CDL.Continuous.Add</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2</i> to <i>+2</i>, input <code>u2</code> varies from <i>-1</i> to <i>+1</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Add;

          model AddParameter "Validation model for the AddParameter block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar(p=0.5, k=
                  1.0)
              "Block that outputs the sum of an input plus a parameter"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, addPar.u)
              annotation (Line(points={{-38,0},{-38,0},{-12,0}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/AddParameter.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.AddParameter\">
Buildings.Controls.OBC.CDL.Continuous.AddParameter</a>.
</p>
<p>
The input <code>u</code> varies from <i>-2</i> to <i>+2</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end AddParameter;

          model Atan "Validation model for the Atan block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Atan atan1
              "Block that outputs the arc tangent of the input" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, atan1.u)
              annotation (Line(points={{-38,0},{-12,0},{-12,0}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Atan.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Atan\">
Buildings.Controls.OBC.CDL.Continuous.Atan</a>.
</p>
<p>
The input <code>u</code> varies from <i>-2</i> to <i>+2</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Atan;

          model Atan2 "Validation model for the Atan2 block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Atan2 atan2_1
              "Block that outputs atan(u1/u2) of the inputs u1 and u2"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,10},{-40,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=1,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-30},{-40,-10}})));

          equation
            connect(ramp1.y, atan2_1.u1) annotation (Line(points={{-38,20},{-26,20},{-26,
                    6},{-12,6}},
                              color={0,0,127}));
            connect(ramp2.y, atan2_1.u2) annotation (Line(points={{-38,-20},{-26,-20},{
                    -26,-6},{-12,-6}},
                                   color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Atan2.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Atan2\">
Buildings.Controls.OBC.CDL.Continuous.Atan2</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2</i> to <i>+2</i>,
The input <code>u2</code> varies from <i>+1</i> to <i>+3</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Atan2;

          model Average "Validation model for the Average block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Average avg1
              "Block that outputs the average of its two inputs" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=6) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,10},{-40,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=1.5,
              height=3.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-30},{-40,-10}})));
          equation
            connect(ramp1.y, avg1.u1) annotation (Line(points={{-39,20},{-26,20},{-26,6},
                    {-12,6}},color={0,0,127}));
            connect(ramp2.y, avg1.u2) annotation (Line(points={{-39,-20},{-26,-20},{-26,
                    -6},{-12,-6}},
                               color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Average.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Average\">
Buildings.Controls.OBC.CDL.Continuous.Average</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2.0</i> to <i>+6.0</i>, input <code>u2</code> varies from <i>+1.5</i> to <i>+4.5</i>
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Average;

          model ChangeSign "Validation model for the ChangeSign block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.ChangeSign changSign
              "Block that change sign of the input" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-1.5,
              height=3.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, changSign.u)
              annotation (Line(points={{-39,0},{-12,0}},         color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/ChangeSign.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.ChangeSign\">
Buildings.Controls.OBC.CDL.Continuous.ChangeSign</a>.
</p>
<p>
The input <code>u</code> varies from <i>-1.5</i> to <i>+1.5</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end ChangeSign;

          model Cos "Validation model for the Cos block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Cos cos1
              "Block that outputs the cosine of the input" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=6.283) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, cos1.u)
              annotation (Line(points={{-39,0},{-12,0}},         color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Cos.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Cos\">
Buildings.Controls.OBC.CDL.Continuous.Cos</a>.
</p>
<p>
The input <code>u</code> varies from <i>0.0</i> to <i>+6.283</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Cos;

          model Derivative "Validation model for the Derivative block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Cos cos1
              "Block that outputs the cosine of the input" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=5,
              offset=0,
              height=6.283*5) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Derivative der1(y_start=-10)
              "Approximate the derivative of the input"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));

          equation
            connect(ramp1.y, cos1.u)
              annotation (Line(points={{-38,0},{-12,0}},         color={0,0,127}));
            connect(cos1.y, der1.u)
              annotation (Line(points={{12,0},{38,0}},        color={0,0,127}));
            annotation (
            experiment(StopTime=2.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Derivative.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Derivative\">
Buildings.Controls.OBC.CDL.Continuous.Derivative</a>.
</p>
<p>
The input <code>u</code> varies from <i>0.0</i> to <i>+5*6.283</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Derivative;

          model Division "Validation model for the Division block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division div1
              "Block that outputs first input divided by second input: u1/u2"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,10},{-40,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              height=2,
              duration=1,
              offset=1) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-30},{-40,-10}})));
          equation
            connect(ramp1.y, div1.u1) annotation (Line(points={{-39,20},{-26,20},{-26,6},
                    {-12,6}},color={0,0,127}));
            connect(ramp2.y, div1.u2) annotation (Line(points={{-39,-20},{-26,-20},{-26,-6},
                    {-12,-6}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Division.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Division\">
Buildings.Controls.OBC.CDL.Continuous.Division</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2</i> to <i>+2</i>, input <code>u2</code> varies from <i>+1</i> to <i>+3</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Division;

          model Exp "Validation model for the Exp block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Exp Exp1
              "Block that outputs the exponential (base e) of the input"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, Exp1.u)
              annotation (Line(points={{-39,0},{-12,0}},         color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Exp.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Exp\">
Buildings.Controls.OBC.CDL.Continuous.Exp</a>.
</p>
<p>
The input <code>u</code> varies from <i>0.0</i> to <i>+2</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Exp;

          model Feedback "Validation model for the Feedback block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Feedback feedback1
              "Block that outputs difference between commanded and feedback input"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-1,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              height=2,
              duration=1,
              offset=-1) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-40},{-40,-20}})));
          equation
            connect(ramp1.y, feedback1.u1) annotation (Line(points={{-38,0},{-12,0}},
                             color={0,0,127}));
            connect(ramp2.y, feedback1.u2) annotation (Line(points={{-38,-30},{0,-30},{0,
                    -12}},     color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Feedback.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Feedback\">
Buildings.Controls.OBC.CDL.Continuous.Feedback</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2</i> to <i>+2</i>, input <code>u2</code> varies from <i>-1</i> to <i>+1</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 20, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Feedback;

          model Gain "Validation model for the Gain block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gain1(k=2.5)
              "Block that outputs the product of a gain value with the input signal"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, gain1.u)
              annotation (Line(points={{-39,0},{-12,0}},         color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Gain.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Gain\">
Buildings.Controls.OBC.CDL.Continuous.Gain</a>.
</p>
<p>
The input <code>u</code> varies from <i>0.0</i> to <i>+2</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 20, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Gain;

          model Greater "Validation model for the Greater block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-26,10},{-6,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-26,-32},{-6,-12}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Greater greater1
              "Check if the first input is greater than the second input"
              annotation (Placement(transformation(extent={{26,-10},{46,10}})));

          equation
            connect(ramp1.y, greater1.u1)
              annotation (Line(points={{-4,20},{8,20},{8,0},{24,0}}, color={0,0,127}));
            connect(ramp2.y, greater1.u2) annotation (Line(points={{-4,-22},{10,-22},{10,-8},
                    {24,-8}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Greater.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Greater\">
Buildings.Controls.OBC.CDL.Continuous.Greater</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Greater;

          model GreaterEqual "Validation model for the GreaterEqual block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-26,12},{-6,32}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-26,-30},{-6,-10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqual greEqu
              "Check if the first input is greater than or equal to the second input"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(ramp1.y, greEqu.u1)
              annotation (Line(points={{-4,22},{8,22},{8,2},{24,2}}, color={0,0,127}));
            connect(ramp2.y, greEqu.u2) annotation (Line(points={{-4,-20},{10,-20},{10,-6},
                    {24,-6}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/GreaterEqual.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.GreaterEqual\">
Buildings.Controls.OBC.CDL.Continuous.GreaterEqual</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end GreaterEqual;

          model GreaterEqualThreshold  "Validation model for the GreaterEqualThreshold block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=2) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-26,-8},{-6,12}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqualThreshold
              greEquThr
              "Check if the input is greater than or equal to the threshold"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(ramp2.y, greEquThr.u)
              annotation (Line(points={{-4,2},{-4,2},{24,2}},color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/GreaterEqualThreshold.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.GreaterEqualThreshold\">
Buildings.Controls.OBC.CDL.Continuous.GreaterEqualThreshold</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end GreaterEqualThreshold;

          model GreaterThreshold  "Validation model for the GreaterThreshold block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=2) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-26,-8},{-6,12}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterThreshold greThr
              "Check if the input is greater than the threshold"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(ramp2.y, greThr.u)
              annotation (Line(points={{-4,2},{-4,2},{24,2}},color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/GreaterThreshold.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.GreaterThreshold\">
Buildings.Controls.OBC.CDL.Continuous.GreaterThreshold</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end GreaterThreshold;

          model Hysteresis "Validation model for the Hysteresis block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hysteresis(final
                uLow=0, final uHigh=1)
              "Transform Real to Boolean signal with Hysteresis"
              annotation (Placement(transformation(extent={{50,30},{70,50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hysteresis1(
              final uLow=0,
              final uHigh=1,
              final pre_y_start=true)
              "Transform Real to Boolean signal with Hysteresis"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hysteresis2(final
                uLow=0 + 0.01, final uHigh=1 - 0.01)
              "Transform Real to Boolean signal with Hysteresis" annotation (
                Placement(transformation(extent={{20,-50},{40,-30}})));

          protected
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              final duration=1,
              final offset=0,
              final height=6.2831852) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-74,30},{-54,50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
              "Block that outputs the sine of the input" annotation (Placement(
                  transformation(extent={{-30,30},{-10,50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gain1(final k=
                  2.5)
              "Block that outputs the product of a gain value with the input signal"
              annotation (Placement(transformation(extent={{10,30},{30,50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pul(final
                amplitude=1, final period=0.1) "Pulse signal" annotation (
                Placement(transformation(extent={{-40,-10},{-20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pul1(final
                amplitude=1, final period=0.1) "Pulse signal" annotation (
                Placement(transformation(extent={{-40,-50},{-20,-30}})));

          equation
            connect(ramp1.y, sin1.u)
              annotation (Line(points={{-52,40},{-32,40}}, color={0,0,127}));
            connect(sin1.y, gain1.u)
              annotation (Line(points={{-8,40},{8,40}}, color={0,0,127}));
            connect(gain1.y, hysteresis.u)
              annotation (Line(points={{32,40},{48,40}}, color={0,0,127}));
            connect(hysteresis2.u, pul1.y)
              annotation (Line(points={{18,-40},{-18,-40}}, color={0,0,127}));
            connect(pul.y, hysteresis1.u)
              annotation (Line(points={{-18,0},{18,0}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Hysteresis.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Hysteresis\">
Buildings.Controls.OBC.CDL.Continuous.Hysteresis</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Hysteresis;

          model HysteresisWithHold "Validation model for the HysteresisWithHold block"
            Modelica.Blocks.Sources.Sine pulse1(
              amplitude = 0.2,
              freqHz =    1/360) "Generate sine wave signal"
              annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.HysteresisWithHold
              noHold(
              trueHoldDuration=0,
              falseHoldDuration=0,
              uLow=0.05,
              uHigh=0.15) "No true/false hold"
              annotation (Placement(transformation(extent={{20,50},{40,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.HysteresisWithHold
              onHold_30s(
              trueHoldDuration=30,
              falseHoldDuration=30,
              uLow=0.05,
              uHigh=0.15) "On/off signal are hold for short period"
              annotation (Placement(transformation(extent={{20,10},{40,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.HysteresisWithHold
              offHold_300s(
              trueHoldDuration=30,
              falseHoldDuration=300,
              uLow=0.05,
              uHigh=0.15) "Off signal being hold even when it should be on"
              annotation (Placement(transformation(extent={{20,-30},{40,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.HysteresisWithHold
              onHold_150s(
              trueHoldDuration=150,
              falseHoldDuration=30,
              uLow=0.05,
              uHigh=0.15) "On signal being hold even when it should be off."
              annotation (Placement(transformation(extent={{20,-70},{40,-50}})));

          equation
            connect(pulse1.y, onHold_150s.u)
              annotation (Line(points={{-19,0},{0,0},{0,-60},{18,-60}}, color={0,0,127}));
            connect(pulse1.y, noHold.u)
              annotation (Line(points={{-19,0},{0,0},{0,60},{18,60}}, color={0,0,127}));
            connect(pulse1.y, offHold_300s.u)
              annotation (Line(points={{-19,0},{-10,0},{0,0},{0,-20},{18,-20}}, color={0,0,127}));
            connect(pulse1.y, onHold_30s.u)
              annotation (Line(points={{-19,0},{0,0},{0,20},{18,20}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1800,  Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/HysteresisWithHold.mos"
                  "Simulate and plot"),
            Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.HysteresisWithHold\">
Buildings.Controls.OBC.CDL.Continuous.HysteresisWithHold</a>.
</p>
<p>
The hold durations are configured as follows:
</p>
<ul>
<li>
<code>true</code> hold duration time <code>trueHoldDuration=0</code>,
<code>false</code> hold duration time <code>falseHoldDuration=0</code>.
</li>
<li>
<code>true</code> hold duration time <code>trueHoldDuration=30</code>,
<code>false</code> hold duration time <code>falseHoldDuration=30</code>.
</li>
<li>
<code>true</code> hold duration time <code>trueHoldDuration=30</code>,
<code>false</code> hold duration time <code>falseHoldDuration=300</code>.
The <code>false</code> hold period covers
the instance when it should be on.
</li>
<li>
<code>true</code> hold duration time <code>trueHoldDuration</code>=150,
<code>false</code> hold duration time <code>falseHoldDuration=30</code>.
The <code>true</code> hold period covers
the instance when it should be off.
</li>
</ul>
</html>",           revisions="<html>
<ul>
<li>
June 26, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end HysteresisWithHold;

          model IntegratorWithReset "Test model for integrator with reset"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant cons(k=10)
              "Constant as source term" annotation (Placement(transformation(
                    extent={{-60,60},{-40,80}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.IntegratorWithReset
              intWitRes1(
              y_start=5,
              reset=Types.Reset.Parameter,
              k=0.5,
              y_reset=2) "Integrator with reset"
              annotation (Placement(transformation(extent={{-10,20},{10,40}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.IntegratorWithReset
              intWitRes2(
              y_reset=10,
              y_start=-5,
              reset=Types.Reset.Input,
              k=0.5) "Integrator with reset and y_reset = 2" annotation (
                Placement(transformation(extent={{-10,-30},{10,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booleanPulse(width=0.5,
                period=0.2) "Boolean pulse" annotation (Placement(
                  transformation(extent={{-60,-70},{-40,-50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.IntegratorWithReset
              intNoReset(
              reset=Types.Reset.Disabled,
              k=0.5,
              y_start=1) "Integrator without reset"
              annotation (Placement(transformation(extent={{-10,60},{10,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.SampleTrigger
              sampleTrigger(period=0.2) "Sample trigger"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp(
              height=-1,
              duration=1,
              offset=-2) "Ramp as a source term" annotation (Placement(
                  transformation(extent={{-60,-38},{-40,-18}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.IntegratorWithReset
              intDef "Integrator with default values" annotation (Placement(
                  transformation(extent={{-12,-90},{8,-70}})));
          equation
            connect(cons.y, intWitRes1.u) annotation (Line(points={{-39,70},{-26,70},{-26,
                    30},{-12,30}}, color={0,0,127}));
            connect(intNoReset.u, cons.y) annotation (Line(points={{-12,70},{-12,70},{-28,
                    70},{-39,70}}, color={0,0,127}));
            connect(cons.y, intWitRes2.u) annotation (Line(points={{-39,70},{-39,70},{-26,
                    70},{-26,-20},{-12,-20}}, color={0,0,127}));
            connect(sampleTrigger.y, intWitRes1.trigger) annotation (Line(points={{-39,10},
                    {0,10},{0,18}},             color={255,0,255}));
            connect(booleanPulse.y, intWitRes2.trigger)
              annotation (Line(points={{-39,-60},{0,-60},{0,-32}},   color={255,0,255}));
            connect(ramp.y, intWitRes2.y_reset_in) annotation (Line(points={{-39,-28},{
                    -39,-28},{-34,-28},{-12,-28}},
                                               color={0,0,127}));
            connect(cons.y, intDef.u) annotation (Line(points={{-39,70},{-26,70},{-26,-80},
                    {-14,-80}}, color={0,0,127}));
                    annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/IntegratorWithReset.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This model tests the implementation of
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.IntegratorWithReset\">
Buildings.Controls.OBC.CDL.Continuous.IntegratorWithReset</a>
with and without reset, and with different start values
and reset values.
</p>
<p>
The integrator <code>intWitRes1</code> is triggered by a sample trigger
which becomes true at <i>t=0</i>, while <code>intWitRes2</code> is triggered
by a boolean pulse with is true at <i>t=0</i>.
Hence, <code>intWitRes1</code> starts with <code>y(0)=y_reset</code> while
<code>intWitRes2</code> starts with <code>y(0)=y_start</code>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end IntegratorWithReset;

          model Less "Validation model for the Less block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-26,12},{-6,32}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-26,-30},{-6,-10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Less less1
              "Check if the first input is less than the second input"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(ramp1.y, less1.u1)
              annotation (Line(points={{-4,22},{8,22},{8,2},{24,2}}, color={0,0,127}));
            connect(ramp2.y, less1.u2) annotation (Line(points={{-4,-20},{10,-20},{10,-6},
                    {24,-6}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Less.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Less\">
Buildings.Controls.OBC.CDL.Continuous.Less</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Less;

          model LessEqual "Validation model for the LessEqual block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-26,12},{-6,32}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-26,-30},{-6,-10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessEqual lesEqu
              "Check if the first input is less than or equal to the second input"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(ramp1.y, lesEqu.u1)
              annotation (Line(points={{-4,22},{8,22},{8,2},{24,2}}, color={0,0,127}));
            connect(ramp2.y, lesEqu.u2) annotation (Line(points={{-4,-20},{10,-20},{10,-6},
                    {24,-6}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/LessEqual.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.LessEqual\">
Buildings.Controls.OBC.CDL.Continuous.LessEqual</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end LessEqual;

          model LessEqualThreshold  "Validation model for the LessEqualThreshold block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-36,-10},{-16,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessEqualThreshold
              lesEquThr
              "Check if the input is less than or equal to the threshold"
              annotation (Placement(transformation(extent={{16,-10},{36,10}})));

          equation
            connect(ramp1.y, lesEquThr.u)
              annotation (Line(points={{-14,0},{-14,0},{14,0}}, color={0,0,127}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/LessEqualThreshold.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.LessEqualThreshold\">
Buildings.Controls.OBC.CDL.Continuous.LessEqualThreshold</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end LessEqualThreshold;

          model LessThreshold "Validation model for the LessThreshold block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-36,-10},{-16,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessThreshold lesThr
              "Check if the input is less than the threshold"
              annotation (Placement(transformation(extent={{16,-10},{36,10}})));

          equation
            connect(ramp1.y, lesThr.u)
              annotation (Line(points={{-14,0},{-14,0},{14,0}}, color={0,0,127}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/LessThreshold.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.LessThreshold\">
Buildings.Controls.OBC.CDL.Continuous.LessThreshold</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end LessThreshold;

          model LimPID "Test model for LimPID controller"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pulse(period=
                  0.25) "Setpoint" annotation (Placement(transformation(extent=
                      {{-90,14},{-70,34}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPID(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID,

              Ti=1,
              Td=1,
              yMin=-1) "PID controller" annotation (Placement(transformation(
                    extent={{-30,40},{-10,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPIDOri(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID,

              Ti=1,
              Td=1,
              yMin=-1) "PID controller" annotation (Placement(transformation(
                    extent={{-30,74},{-10,94}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant const(k=0.5)
              "Measurement data" annotation (Placement(transformation(extent={{
                      -90,-22},{-70,-2}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPI(
              Ti=1,
              Td=1,
              yMin=-1,
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI)
              "PI controller"
              annotation (Placement(transformation(extent={{-30,2},{-10,22}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPD(
              Ti=1,
              Td=1,
              yMin=-1,
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD)
              "PD controller" annotation (Placement(transformation(extent={{-30,
                      -30},{-10,-10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limP(
              Ti=1,
              Td=1,
              yMin=-1,
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.P)
              "P controller" annotation (Placement(transformation(extent={{-30,
                      -60},{-10,-40}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID noLimPID(
              Ti=1,
              Td=1,
              yMax=1e15,
              yMin=-1e15,
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID)
              "PID controller with no output limit" annotation (Placement(
                  transformation(extent={{-30,-90},{-10,-70}})));

          equation
            connect(pulse.y, limPID.u_s) annotation (Line(
                points={{-68,24},{-54,24},{-54,50},{-32,50}},
                color={0,0,127}));
            connect(const.y, limPID.u_m) annotation (Line(
                points={{-68,-12},{-62,-12},{-62,30},{-20,30},{-20,38}},
                color={0,0,127}));
            connect(pulse.y, limPIDOri.u_s) annotation (Line(
                points={{-68,24},{-54,24},{-54,84},{-32,84}},
                color={0,0,127}));
            connect(const.y, limPIDOri.u_m) annotation (Line(
                points={{-68,-12},{-62,-12},{-62,66},{-20,66},{-20,72}},
                color={0,0,127}));
            connect(const.y, limPI.u_m)
              annotation (Line(points={{-68,-12},{-62,-12},{-62,-2},{-20,-2},{-20,0}},
                                                                   color={0,0,127}));
            connect(const.y, limPD.u_m) annotation (Line(points={{-68,-12},{-62,-12},{-62,
                    -34},{-20,-34},{-20,-32}},
                                     color={0,0,127}));
            connect(pulse.y, limPI.u_s) annotation (Line(points={{-68,24},{-54,24},{-54,
                    12},{-32,12}},
                               color={0,0,127}));
            connect(pulse.y, limPD.u_s) annotation (Line(points={{-68,24},{-54,24},{-54,
                    -20},{-32,-20}},
                                color={0,0,127}));
            connect(pulse.y, limP.u_s) annotation (Line(points={{-68,24},{-54,24},{-54,
                    -50},{-32,-50}},
                                color={0,0,127}));
            connect(pulse.y, noLimPID.u_s) annotation (Line(points={{-68,24},{-54,24},{
                    -54,-80},{-32,-80}},
                                     color={0,0,127}));
            connect(const.y, limP.u_m) annotation (Line(points={{-68,-12},{-62,-12},{-62,
                    -64},{-20,-64},{-20,-62}},
                                color={0,0,127}));
            connect(const.y, noLimPID.u_m) annotation (Line(points={{-68,-12},{-62,-12},{
                    -62,-96},{-20,-96},{-20,-92}},
                                     color={0,0,127}));
           annotation (
           experiment(StopTime=1.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/LimPID.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.LimPID\">
Buildings.Controls.OBC.CDL.Continuous.LimPID</a>.
</p>
<p>
The model <code>limPIDOri</code> is the original
implementation of the controller from the Modelica
Standard Library. The models <code>limPID</code>
is the implementations from the Buildings library.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 24, 2017, by Jianjun Hu:<br/>
Added into CDL, simplified the validation model.
</li>
<li>
April 26, 2016, by Michael Wetter:<br/>
Relaxed tolerance of assertions from <i>1E-10</i>
to <i>1E-3</i> as the default relative tolerance in JModelica
is <i>1E-4</i>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/510\">
Buildings, issue 510</a>.
</li>
<li>
November 21, 2011, by Michael Wetter:<br/>
Added documentation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end LimPID;

          model LimPIDInitialDerivativeOutput
            "Test model for LimPID controller with initial output specified"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant ySet(k=0.75)
              "Set point" annotation (Placement(transformation(extent={{-40,30},
                      {-20,50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant yMea(k=0.75)
              "Measured value"
              annotation (Placement(transformation(extent={{-40,0},{-20,20}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPID(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID,

              k=3,
              yd_start=0.2) "PID controller"
              annotation (Placement(transformation(extent={{20,20},{40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPD(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PD,

              k=3,
              yd_start=0.2) "PD controller" annotation (Placement(
                  transformation(extent={{20,-40},{40,-20}})));

          equation
            connect(ySet.y, limPID.u_s) annotation (Line(points={{-18,40},{0,40},{0,30},{18,
                    30}}, color={0,0,127}));
            connect(ySet.y,limPD. u_s) annotation (Line(points={{-18,40},{0,40},{0,-30},{18,
                    -30}}, color={0,0,127}));
            connect(yMea.y, limPID.u_m)
              annotation (Line(points={{-18,10},{30,10},{30,18}}, color={0,0,127}));
            connect(yMea.y,limPD. u_m) annotation (Line(points={{-18,10},{-4,10},{-4,-50},
                    {30,-50},{30,-42}}, color={0,0,127}));
           annotation (
           experiment(
                StopTime=0.2,
                Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/LimPIDInitialDerivativeOutput.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.LimPID\">
Buildings.Controls.OBC.CDL.Continuous.LimPID</a>.
</p>
<p>
This model validates setting the initial output of the controller to a specified value.
Note that the control error must be zero for the initial output to be at the specified value.
See the description of
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.LimPID\">
Buildings.Controls.OBC.CDL.Continuous.LimPID</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 8, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                   graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
              Diagram(coordinateSystem(extent={{-100,-100},{100,100}})));
          end LimPIDInitialDerivativeOutput;

          model LimPIDInitialState
            "Test model for LimPID controller with initial state specified"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant ySet(k=0.75)
              "Set point" annotation (Placement(transformation(extent={{-40,30},
                      {-20,50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant yMea(k=0.5)
              "Measured value"
              annotation (Placement(transformation(extent={{-40,0},{-20,20}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPID(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID,

              k=3,
              xi_start=0.25) "PID controller"
              annotation (Placement(transformation(extent={{20,20},{40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPI(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

              k=3,
              xi_start=0.25) "PI controller" annotation (Placement(
                  transformation(extent={{20,-40},{40,-20}})));

          equation
            connect(ySet.y, limPID.u_s) annotation (Line(points={{-18,40},{0,40},{0,30},{18,
                    30}}, color={0,0,127}));
            connect(ySet.y, limPI.u_s) annotation (Line(points={{-18,40},{0,40},{0,-30},{18,
                    -30}}, color={0,0,127}));
            connect(yMea.y, limPID.u_m)
              annotation (Line(points={{-18,10},{30,10},{30,18}}, color={0,0,127}));
            connect(yMea.y, limPI.u_m) annotation (Line(points={{-18,10},{-4,10},{-4,-50},
                    {30,-50},{30,-42}}, color={0,0,127}));
           annotation (
           experiment(
                StopTime=1,
                Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/LimPIDInitialState.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.LimPID\">
Buildings.Controls.OBC.CDL.Continuous.LimPID</a>.
</p>
<p>
This model validates setting the initial state of the controller to a specified value.
</p>
<p>
The model sets the initial values <code>xi_start=0.25</code>
of the integrator for both instances of the controller.
For the instance <code>limPID</code>, it also sets the initial value of the state of the
derivative block <code>xd_start=-0.5</code>.
The derivative block obtains as an input signal the value
<i>u=-0.5</i> because the set point weight for the derivative action is <code>wd=0</code>.
Therefore, an initial state of <i>x(t<sub>0</sub>)=-0.5</i> causes the state of the derivative
block to be at steady-state, because
<i>dx(t)/dt = (u - x)/T</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 8, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                   graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
              Diagram(coordinateSystem(extent={{-100,-100},{100,100}})));
          end LimPIDInitialState;

          model LimPIDWithReset
            "Test model for LimPID controller with reset trigger"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal setPoi
              "Set point" annotation (Placement(transformation(extent={{-20,-40},
                      {0,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.ModelTime
              modTim "Model time" annotation (Placement(transformation(extent={
                      {-90,-70},{-70,-50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqualThreshold
              greEquThr(threshold=1) "Outputs true after t=1" annotation (
                Placement(transformation(extent={{-52,-70},{-32,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPIDPar(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID,

              k=1,
              Ti=1,
              Td=1,
              yMin=-1,
              reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter,

              y_reset=0.5) "Controller, reset to parameter value"
              annotation (Placement(transformation(extent={{20,60},{40,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.IntegratorWithReset
              intWitRes1(reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled)
              "Integrator whose output should be brought to the set point"
              annotation (Placement(transformation(extent={{60,60},{80,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPIDInp(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PID,

              k=1,
              Ti=1,
              Td=1,
              yMin=-1,
              reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Input,
              y_reset=0.5) "Controller, reset to input value"
              annotation (Placement(transformation(extent={{20,20},{40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.IntegratorWithReset
              intWitRes2(reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled)
              "Integrator whose output should be brought to the set point"
              annotation (Placement(transformation(extent={{60,20},{80,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant resVal(k=0.75)
              "Reset value" annotation (Placement(transformation(extent={{-40,
                      12},{-20,32}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPIPar(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

              k=1,
              Ti=1,
              Td=1,
              yMin=-1,
              reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Parameter,

              y_reset=0.5) "Controller, reset to parameter value" annotation (
                Placement(transformation(extent={{20,-40},{40,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.IntegratorWithReset
              intWitRes3(reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled)
              "Integrator whose output should be brought to the set point"
              annotation (Placement(transformation(extent={{60,-40},{80,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID limPIInp(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

              k=1,
              Ti=1,
              Td=1,
              yMin=-1,
              reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Input,
              y_reset=0.5) "Controller, reset to input value" annotation (
                Placement(transformation(extent={{20,-80},{40,-60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.IntegratorWithReset
              intWitRes4(reset=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Reset.Disabled)
              "Integrator whose output should be brought to the set point"
              annotation (Placement(transformation(extent={{60,-80},{80,-60}})));
          equation
            connect(limPIDPar.u_s, setPoi.y) annotation (Line(points={{18,70},{6,70},{6,
                    -30},{2,-30}}, color={0,0,127}));
            connect(intWitRes1.u, limPIDPar.y)
              annotation (Line(points={{58,70},{42,70}}, color={0,0,127}));
            connect(intWitRes1.y, limPIDPar.u_m) annotation (Line(points={{82,70},{90,70},
                    {90,50},{30,50},{30,58}}, color={0,0,127}));
            connect(modTim.y, greEquThr.u)
              annotation (Line(points={{-68,-60},{-54,-60}},   color={0,0,127}));
            connect(greEquThr.y, setPoi.u) annotation (Line(points={{-30,-60},{-28,-60},{
                    -28,-30},{-22,-30}},    color={255,0,255}));
            connect(greEquThr.y, limPIDPar.trigger) annotation (Line(points={{-30,-60},{8,
                    -60},{8,50},{24,50},{24,58}},  color={255,0,255}));
            connect(intWitRes2.u, limPIDInp.y)
              annotation (Line(points={{58,30},{42,30}}, color={0,0,127}));
            connect(intWitRes2.y, limPIDInp.u_m) annotation (Line(points={{82,30},{90,30},
                    {90,10},{30,10},{30,18}}, color={0,0,127}));
            connect(limPIDInp.u_s, setPoi.y) annotation (Line(points={{18,30},{6,30},{6,
                    -30},{2,-30}},
                               color={0,0,127}));
            connect(limPIDInp.y_reset_in, resVal.y)
              annotation (Line(points={{18,22},{-18,22}},
                                                        color={0,0,127}));
            connect(limPIPar.u_s, setPoi.y) annotation (Line(points={{18,-30},{2,-30}},
                               color={0,0,127}));
            connect(intWitRes3.u, limPIPar.y)
              annotation (Line(points={{58,-30},{42,-30}}, color={0,0,127}));
            connect(intWitRes3.y, limPIPar.u_m) annotation (Line(points={{82,-30},{90,-30},
                    {90,-50},{30,-50},{30,-42}}, color={0,0,127}));
            connect(greEquThr.y, limPIPar.trigger) annotation (Line(points={{-30,-60},{8,
                    -60},{8,-50},{24,-50},{24,-42}},  color={255,0,255}));
            connect(intWitRes4.u, limPIInp.y)
              annotation (Line(points={{58,-70},{42,-70}}, color={0,0,127}));
            connect(intWitRes4.y, limPIInp.u_m) annotation (Line(points={{82,-70},{90,-70},
                    {90,-90},{30,-90},{30,-82}}, color={0,0,127}));
            connect(limPIInp.u_s, setPoi.y) annotation (Line(points={{18,-70},{6,-70},{6,
                    -30},{2,-30}},
                               color={0,0,127}));
            connect(limPIInp.y_reset_in, resVal.y) annotation (Line(points={{18,-78},{14,
                    -78},{14,22},{-18,22}},
                                          color={0,0,127}));
            connect(greEquThr.y, limPIInp.trigger) annotation (Line(points={{-30,-60},{8,
                    -60},{8,-90},{24,-90},{24,-82}},  color={255,0,255}));
            connect(limPIDInp.trigger, greEquThr.y) annotation (Line(points={{24,18},{24,
                    10},{8,10},{8,-60},{-30,-60}},
                                                 color={255,0,255}));
           annotation (
           experiment(
                StopTime=10,
                Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/LimPIDWithReset.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.LimPID\">
Buildings.Controls.OBC.CDL.Continuous.LimPID</a>.
</p>
<p>
This model validates the controller for different settings of the control output reset.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 7, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                   graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
              Diagram(coordinateSystem(extent={{-100,-100},{100,100}})));
          end LimPIDWithReset;

          model Limiter "Validation model for the Limiter block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Limiter limiter1(uMax=2.5,
                uMin=1.2) "Block that limit the range of a signal" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, limiter1.u)
              annotation (Line(points={{-39,0},{-12,0}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Limiter.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Limiter\">
Buildings.Controls.OBC.CDL.Continuous.Limiter</a>.
</p>
<p>
The input <code>u</code> varies from <i>0.0</i> to <i>+2</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 20, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Limiter;

          model Line "Validation model for the Line block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line line1
              "Block that out the value of the input x along a line specified by two points"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant x1(k=1.0)
              "Block that generate x1" annotation (Placement(transformation(
                    extent={{-60,52},{-40,72}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant f1(k=0.5)
              "Block that generate f(x1)" annotation (Placement(transformation(
                    extent={{-60,20},{-40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant x2(k=2.0)
              "Block that generate x2" annotation (Placement(transformation(
                    extent={{-60,-40},{-40,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant f2(k=1.5)
              "Block that generate f(x2)" annotation (Placement(transformation(
                    extent={{-60,-70},{-40,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              offset=0,
              duration=0.5,
              startTime=0.25,
              height=3) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line line2(
                limitAbove=true, limitBelow=false)
              "Block that out the value of the input x along a line specified by two points"
              annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Line line3(
                limitBelow=true, limitAbove=false)
              "Block that out the value of the input x along a line specified by two points"
              annotation (Placement(transformation(extent={{-10,-70},{10,-50}})));
          equation
            connect(ramp1.y, line1.u)
              annotation (Line(points={{-39,0},{-12,0}}, color={0,0,127}));
            connect(f1.y, line1.f1) annotation (Line(points={{-39,30},{-24,30},{-24,4},{-12,
                    4}}, color={0,0,127}));
            connect(x1.y, line1.x1) annotation (Line(points={{-39,62},{-26,62},{-26,8},{-12,
                    8}}, color={0,0,127}));
            connect(x2.y, line1.x2) annotation (Line(points={{-39,-30},{-24,-30},{-24,-4},
                    {-12,-4}}, color={0,0,127}));
            connect(f2.y, line1.f2) annotation (Line(points={{-39,-60},{-26,-60},{-26,-8},
                    {-12,-8}}, color={0,0,127}));
            connect(ramp1.y,line2. u)
              annotation (Line(points={{-39,0},{-36,0},{-36,-30},{-12,-30}},
                                                         color={0,0,127}));
            connect(f1.y,line2. f1) annotation (Line(points={{-39,30},{-24,30},{-24,-26},
                    {-12,-26}},
                         color={0,0,127}));
            connect(x1.y,line2. x1) annotation (Line(points={{-39,62},{-26,62},{-26,-22},
                    {-12,-22}},
                         color={0,0,127}));
            connect(x2.y,line2. x2) annotation (Line(points={{-39,-30},{-24,-30},{-24,-34},
                    {-12,-34}},color={0,0,127}));
            connect(f2.y,line2. f2) annotation (Line(points={{-39,-60},{-26,-60},{-26,-38},
                    {-12,-38}},color={0,0,127}));
            connect(ramp1.y,line3. u)
              annotation (Line(points={{-39,0},{-36,0},{-36,-60},{-12,-60}},
                                                         color={0,0,127}));
            connect(f1.y,line3. f1) annotation (Line(points={{-39,30},{-24,30},{-24,-56},
                    {-12,-56}},
                         color={0,0,127}));
            connect(x1.y,line3. x1) annotation (Line(points={{-39,62},{-26,62},{-26,-52},
                    {-12,-52}},
                         color={0,0,127}));
            connect(x2.y,line3. x2) annotation (Line(points={{-39,-30},{-24,-30},{-24,-64},
                    {-12,-64}},color={0,0,127}));
            connect(f2.y,line3. f2) annotation (Line(points={{-39,-60},{-26,-60},{-26,-68},
                    {-12,-68}},color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Line.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Line\">
Buildings.Controls.OBC.CDL.Continuous.Line</a>.
</p>
<p>
The input <code>u</code> varies from <i>0.0</i> to <i>+2</i>.
</p>
<p>
The block outputs <code>y = a + b u</code>,
where
<code>u</code> is an input
and the coefficients <code>a</code> and <code>b</code>
are determined so that the line intercepts the two input points
specified by the two points <code>x1</code> and <code>f1</code>,
and <code>x2</code> and <code>f2</code>.
</p>
<p>
The parameters <code>limitBelow</code> and <code>limitAbove</code>
determine whether <code>x1</code> and <code>x2</code> are also used
to limit the input <code>u</code>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 25, 2018, by Michael Wetter:<br/>
Improved test to validate that the limits are properly used.
</li>
<li>
March 20, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Line;

          model Log "Validation model for the Log block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Log log1
              "Block that outputs the natural (base e) logarithm of the input (input > 0 required)"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=1,
              height=5) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, log1.u)
              annotation (Line(points={{-39,0},{-12,0}},         color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Log.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Log\">
Buildings.Controls.OBC.CDL.Continuous.Log</a>.
</p>
<p>
The input <code>u</code> varies from <i>+1</i> to <i>+6</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Log;

          model Log10 "Validation model for the Log10 block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Log10 log10_1
              "Block that outputs the base 10 logarithm of the input (input > 0 required)"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=1,
              height=9) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, log10_1.u)
              annotation (Line(points={{-39,0},{-12,0}},         color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Log10.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Log10\">
Buildings.Controls.OBC.CDL.Continuous.Log10</a>.
</p>
<p>
The input <code>u</code> varies from <i>+1</i> to <i>+10</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Log10;

          model MatrixGain "Validation model for the MatrixGain block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MatrixGain matGai(K=[1,0; 1,
                  1; 1,2])
              "Block that outputs the product of a matrix gain value with the input signal"
              annotation (Placement(transformation(extent={{20,30},{40,50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MatrixGain matGai1(K=[1,2; 3,
                  4])
              "Block that outputs the product of a matrix gain value with the input signal"
              annotation (Placement(transformation(extent={{20,-50},{40,-30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp(
              duration=1,
              offset=0,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-40,30},{-20,50}})));

            Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=1) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-40,-30},{-20,-10}})));

            Sources.Ramp ramp2(
              duration=1,
              offset=0,
              height=2) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));

          equation
            connect(ramp2.y, matGai1.u[2]) annotation (Line(points={{-19,-60},{0,-60},{0,-40},
                    {18,-40}}, color={0,0,127}));
            connect(ramp1.y, matGai1.u[1]) annotation (Line(points={{-19,-20},{0,-20},{0,-40},
                    {18,-40}},          color={0,0,127}));
            connect(ramp.y, matGai.u[1])
              annotation (Line(points={{-19,40},{18,40}}, color={0,0,127}));
            connect(ramp.y, matGai.u[2])
              annotation (Line(points={{-19,40},{18,40}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/MatrixGain.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.MatrixGain\">
Buildings.Controls.OBC.CDL.Continuous.MatrixGain</a>.
</p>
<p>
The input vector output two identical values <code>u[1]</code> and 
<code>u[2]</code> that vary from <i>0.0</i> to <i>+2</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
February 11, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MatrixGain;

          model MatrixMax "Validation model for the MatrixMax block"

            Sources.Constant con[3,3](k={{1,2,3},{6,4,2},{3,9,6}})
              "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-40,50},{-20,70}})));

            Sources.Constant con1[2,3](k={{1,4,3},{2,2,6}})
              "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));

            Sources.Constant con2[2,3](k={{1,2,3},{6,4,2}})
              "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MatrixMax matMax(
              rowMax=false,
              nRow=3,
              nCol=3) "Matrix maximum"
              annotation (Placement(transformation(extent={{0,50},{20,70}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MatrixMax matMax1(nCol=3,
                nRow=2) "Matrix maximum"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MatrixMax matMax2(nCol=3,
                nRow=2) "Matrix maximum"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));

          equation
            connect(con.y,matMax. u)
              annotation (Line(points={{-19,60},{-2,60}}, color={0,0,127}));
            connect(con1.y,matMax1. u)
              annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
            connect(con2.y,matMax2. u)
              annotation (Line(points={{-19,-60},{-2,-60}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/MatrixMax.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.MatrixMax\">
Buildings.Controls.OBC.CDL.Continuous.MatrixMax</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 17, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MatrixMax;

          model MatrixMin "Validation model for the MatrixMin block"

            Sources.Constant con[3,3](k={{-1,-2,-3},{-6,-4,-2},{-3,-9,-6}})
              "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-40,50},{-20,70}})));

            Sources.Constant con1[2,3](k={{-1,-4,-3},{-2,-2,-6}})
              "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));

            Sources.Constant con2[2,3](k={{-1,-2,-3},{-6,-4,-2}})
              "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MatrixMin matMin(
              nRow=3,
              nCol=3,
              rowMin=false) "Matrix minimum"
              annotation (Placement(transformation(extent={{0,50},{20,70}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MatrixMin matMin1(
              nCol=3,
              rowMin=false,
              nRow=2) "Matrix minimum"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MatrixMin matMin2(
              nCol=3,
              rowMin=true,
              nRow=2) "Matrix minimum"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));

          equation
            connect(con.y, matMin.u)
              annotation (Line(points={{-19,60},{-2,60}}, color={0,0,127}));
            connect(con1.y, matMin1.u)
              annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
            connect(con2.y, matMin2.u)
              annotation (Line(points={{-19,-60},{-2,-60}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/MatrixMin.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.MatrixMin\">
Buildings.Controls.OBC.CDL.Continuous.MatrixMin</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 17, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MatrixMin;

          model Max "Validation model for the Max block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Max max1
              "Block that pass through the largest signal" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,10},{-40,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-30},{-40,-10}})));
          equation
            connect(ramp1.y, max1.u1) annotation (Line(points={{-39,20},{-26,20},{-26,6},
                    {-12,6}},color={0,0,127}));
            connect(ramp2.y, max1.u2) annotation (Line(points={{-39,-20},{-26,-20},{-26,-6},
                    {-12,-6}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Max.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Max\">
Buildings.Controls.OBC.CDL.Continuous.Max</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2</i> to <i>+2</i>, input <code>u2</code> varies from <i>-1</i> to <i>+1</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Max;

          model Min "Validation model for the Min block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min min1
              "Block that pass through the smallest signal" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,10},{-40,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-30},{-40,-10}})));
          equation
            connect(ramp1.y, min1.u1) annotation (Line(points={{-39,20},{-26,20},{-26,6},
                    {-12,6}},color={0,0,127}));
            connect(ramp2.y, min1.u2) annotation (Line(points={{-39,-20},{-26,-20},{-26,-6},
                    {-12,-6}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Min.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Min\">
Buildings.Controls.OBC.CDL.Continuous.Min</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2</i> to <i>+2</i>, input <code>u2</code> varies from <i>-1</i> to <i>+1</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Min;

          model Modulo "Validation model for the Modulo block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Modulo mod1
              "Block that outputs the remainder of first input divided by second input (~=0)"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=6) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,10},{-40,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=1.5,
              height=3.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-30},{-40,-10}})));
          equation
            connect(ramp1.y, mod1.u1) annotation (Line(points={{-39,20},{-26,20},{-26,6},
                    {-12,6}},color={0,0,127}));
            connect(ramp2.y, mod1.u2) annotation (Line(points={{-39,-20},{-26,-20},{-26,
                    -6},{-12,-6}},
                               color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Modulo.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Modulo\">
Buildings.Controls.OBC.CDL.Continuous.Modulo</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2.0</i> to <i>+6.0</i>, input <code>u2</code> varies from <i>+1.5</i> to <i>+4.5</i>
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Modulo;

          model MovingMean "Validation model for the MovingMean block"
            Modelica.Blocks.Sources.Sine sinInpNoDel(freqHz=1/80)
              "Start from zero second"
              annotation (Placement(transformation(extent={{-90,50},{-70,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_1(delta=100)
              "Moving average with 100 s sliding window" annotation (Placement(
                  transformation(extent={{-40,50},{-20,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_2(delta=200)
              "Moving average with 200 s sliding window" annotation (Placement(
                  transformation(extent={{-40,20},{-20,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_3(delta=300)
              "Moving average with 300 s sliding window" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_4(delta=400)
              "Moving average with 400 s sliding window" annotation (Placement(
                  transformation(extent={{-40,-40},{-20,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_5(delta=500)
              "Moving average with 500 s sliding window" annotation (Placement(
                  transformation(extent={{-40,-70},{-20,-50}})));
            Modelica.Blocks.Sources.Sine sinInp50sDel(freqHz=1/80, startTime=50)
              "Start from 50 seconds"
              annotation (Placement(transformation(extent={{0,50},{20,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_6(delta=100)
              "Moving average with 100 s sliding window"
              annotation (Placement(transformation(extent={{60,50},{80,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_7(delta=200)
              "Moving average with 200 s sliding window"
              annotation (Placement(transformation(extent={{60,20},{80,40}})));
            Modelica.Blocks.Sources.Sine sinInp100sDel(freqHz=1/80, startTime=100)
              "Start from 100 seconds"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_8(delta=100)
              "Moving average with 100 s sliding window" annotation (Placement(
                  transformation(extent={{60,-30},{80,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_9(delta=200)
              "Moving average with 200 s sliding window" annotation (Placement(
                  transformation(extent={{60,-60},{80,-40}})));

          equation
            connect(sinInpNoDel.y, movingMean_3.u) annotation (Line(points={{-69,60},{-60,
                    60},{-60,0},{-42,0}}, color={0,0,127}));
            connect(sinInpNoDel.y, movingMean_1.u)
              annotation (Line(points={{-69,60},{-42,60}},          color={0,0,127}));
            connect(sinInpNoDel.y, movingMean_2.u) annotation (Line(points={{-69,60},{-60,
                    60},{-60,30},{-42,30}},          color={0,0,127}));
            connect(sinInpNoDel.y, movingMean_5.u) annotation (Line(points={{-69,60},{-60,
                    60},{-60,-60},{-42,-60}}, color={0,0,127}));
            connect(sinInpNoDel.y, movingMean_4.u) annotation (Line(points={{-69,60},{-60,
                    60},{-60,-30},{-42,-30}}, color={0,0,127}));
            connect(sinInp50sDel.y, movingMean_6.u)
              annotation (Line(points={{21,60},{21,60},{58,60}}, color={0,0,127}));
            connect(sinInp50sDel.y, movingMean_7.u) annotation (Line(points={{21,60},{21,60},
                    {40,60},{40,30},{58,30}}, color={0,0,127}));
            connect(sinInp100sDel.y, movingMean_9.u) annotation (Line(points={{21,-20},{21,
                    -20},{40,-20},{40,-50},{58,-50}}, color={0,0,127}));
            connect(sinInp100sDel.y, movingMean_8.u)
              annotation (Line(points={{21,-20},{58,-20}}, color={0,0,127}));
            annotation (experiment(StopTime=900.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/MovingMean.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.MovingMean\">
Buildings.Controls.OBC.CDL.Continuous.MovingMean</a>.
</p>
<p>
The input <code>sinInpNoDel</code>,  <code>sinInp50sDel</code>,
<code>sinInp100sDel</code>,  generate sine outputs with same frequency of
<code>1/80 Hz</code>, but different start times of <code>0 second</code>,
<code>50 second</code>, <code>100 second</code>.
</p>
</html>",           revisions="<html>
<ul>
<li>
June 29, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MovingMean;

          model MovingMean_nonZeroStart  "Validation model for the MovingMean block"
            Modelica.Blocks.Sources.Sine sinInpNoDel(freqHz=1/80)
              "Start from zero second"
              annotation (Placement(transformation(extent={{-90,50},{-70,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_1(delta=100)
              "Moving average with 100 s sliding window" annotation (Placement(
                  transformation(extent={{-40,50},{-20,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_2(delta=200)
              "Moving average with 200 s sliding window" annotation (Placement(
                  transformation(extent={{-40,20},{-20,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_3(delta=300)
              "Moving average with 300 s sliding window" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_4(delta=400)
              "Moving average with 400 s sliding window" annotation (Placement(
                  transformation(extent={{-40,-40},{-20,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_5(delta=500)
              "Moving average with 500 s sliding window" annotation (Placement(
                  transformation(extent={{-40,-70},{-20,-50}})));
            Modelica.Blocks.Sources.Sine sinInp50sDel(freqHz=1/80, startTime=50)
              "Start from 50 seconds"
              annotation (Placement(transformation(extent={{0,50},{20,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_6(delta=100)
              "Moving average with 100 s sliding window"
              annotation (Placement(transformation(extent={{60,50},{80,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_7(delta=200)
              "Moving average with 200 s sliding window"
              annotation (Placement(transformation(extent={{60,20},{80,40}})));
            Modelica.Blocks.Sources.Sine sinInp100sDel(freqHz=1/80, startTime=100)
              "Start from 100 seconds"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_8(delta=100)
              "Moving average with 100 s sliding window" annotation (Placement(
                  transformation(extent={{60,-30},{80,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MovingMean movingMean_9(delta=200)
              "Moving average with 200 s sliding window" annotation (Placement(
                  transformation(extent={{60,-60},{80,-40}})));

          equation
            connect(sinInpNoDel.y, movingMean_3.u) annotation (Line(points={{-69,60},{-60,
                    60},{-60,0},{-42,0}}, color={0,0,127}));
            connect(sinInpNoDel.y, movingMean_1.u)
              annotation (Line(points={{-69,60},{-42,60}},          color={0,0,127}));
            connect(sinInpNoDel.y, movingMean_2.u) annotation (Line(points={{-69,60},{-60,
                    60},{-60,30},{-42,30}},          color={0,0,127}));
            connect(sinInpNoDel.y, movingMean_5.u) annotation (Line(points={{-69,60},{-60,
                    60},{-60,-60},{-42,-60}}, color={0,0,127}));
            connect(sinInpNoDel.y, movingMean_4.u) annotation (Line(points={{-69,60},{-60,
                    60},{-60,-30},{-42,-30}}, color={0,0,127}));
            connect(sinInp50sDel.y, movingMean_6.u)
              annotation (Line(points={{21,60},{21,60},{58,60}}, color={0,0,127}));
            connect(sinInp50sDel.y, movingMean_7.u) annotation (Line(points={{21,60},{21,60},
                    {40,60},{40,30},{58,30}}, color={0,0,127}));
            connect(sinInp100sDel.y, movingMean_9.u) annotation (Line(points={{21,-20},{21,
                    -20},{40,-20},{40,-50},{58,-50}}, color={0,0,127}));
            connect(sinInp100sDel.y, movingMean_8.u)
              annotation (Line(points={{21,-20},{58,-20}}, color={0,0,127}));
            annotation (experiment(StartTime=100, StopTime=900.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/MovingMean_nonZeroStart.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.MovingMean\">
Buildings.Controls.OBC.CDL.Continuous.MovingMean</a>.
</p>
<p>
The inputs <code>sinInpNoDel</code>, <code>sinInp50sDel</code> and
<code>sinInp100sDel</code> generate sine outputs with the same frequency of
<code>1/80</code> Hertz, but different start times of <code>0</code> seconds,
<code>50</code> seconds and <code>100</code> seconds.
</p>
</html>",           revisions="<html>
<ul>
<li>
June 29, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MovingMean_nonZeroStart;

          model MultiMax "Validation model for the MultiMax block"
            parameter Integer sizOfVec = 5 "Size of the input vector";
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiMax maxVal(nin=
                  sizOfVec)
              "Block that outputs the maximum element of the input vector"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant con[sizOfVec]
              (k={1,2,3,4,5}) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-58,-10},{-38,10}})));
          equation
            connect(con.y,maxVal. u)
               annotation (Line(points={{-37,0},{-24.5,0},{-12,0}}, color={0,0,127}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/MultiMax.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.MultiMax\">
Buildings.Controls.OBC.CDL.Continuous.MultiMax</a>.
</p>
<p>
The input vector<code>con</code> has size <i>5</i> and its element values are <code>{1,2,3,4,5}</code>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MultiMax;

          model MultiMin "Validation model for the MultiMin block"
            parameter Integer sizOfVec = 5 "Size of the input vector";
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiMin minVal(nin=
                  sizOfVec)
              "Block that outputs the minimum element of the input vector"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant con[sizOfVec]
              (k={1,2,3,4,5}) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-58,-10},{-38,10}})));
          equation
            for i in 1:sizOfVec loop
              connect(con[i].y,minVal. u[i])
              annotation (Line(points={{-37,0},{-24.5,0},{-12,0}}, color={0,0,127}));
            end for;
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/MultiMin.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.MultiMin\">
Buildings.Controls.OBC.CDL.Continuous.MultiMin</a>.
</p>
<p>
The input vector<code>con</code> has size <i>5</i> and its element values are <code>{1,2,3,4,5}</code>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MultiMin;

          model MultiSum "Model to validate the application of MultiSum block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,50},{-40,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              height=2,
              duration=1,
              offset=-1) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,20},{-40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp3(
              height=3,
              duration=1,
              offset=-1) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp4(
              height=3,
              duration=1,
              offset=-2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-40},{-40,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp5(
              height=3,
              duration=1,
              offset=-3) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-70},{-40,-50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum mulSum_5(nin=5, k=
                  {1,0.5,0.1,1,2})
              "Sum of Reals, y = k[1]*u[1] + k[2]*u[2] + ... + k[5]*u[5]"
              annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum mulSum_2(nin=2, k=
                  {1,0.5}) "Sum of Reals, y = k[1]*u[1] + k[2]*u[2]"
              annotation (Placement(transformation(extent={{40,0},{60,20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum mulSum_1(nin=1, k=
                  {1}) "Sum of Reals, y = k[1]*u[1]"
              annotation (Placement(transformation(extent={{40,40},{60,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum mulSum_3(nin=3)
              "Sum of Reals, y = k[1]*u[1] + k[2]*u[2]" annotation (Placement(
                  transformation(extent={{40,-92},{60,-72}})));
          equation
            connect(ramp1.y, mulSum_5.u[1]) annotation (Line(points={{-39,60},{-39,60},{
                    20,60},{20,-28.4},{38,-28.4}}, color={0,0,127}));
            connect(ramp2.y, mulSum_5.u[2]) annotation (Line(points={{-39,30},{-39,30},{
                    10,30},{10,-29.2},{38,-29.2}}, color={0,0,127}));
            connect(ramp3.y, mulSum_5.u[3]) annotation (Line(points={{-39,0},{0,0},{0,-30},
                    {38,-30}}, color={0,0,127}));
            connect(ramp4.y, mulSum_5.u[4]) annotation (Line(points={{-39,-30},{-20,-30},
                    {-20,-32},{10,-32},{10,-30.8},{38,-30.8}},
                                           color={0,0,127}));
            connect(ramp5.y, mulSum_5.u[5]) annotation (Line(points={{-39,-60},{20,-60},{
                    20,-31.6},{38,-31.6}}, color={0,0,127}));
            connect(ramp1.y, mulSum_1.u[1]) annotation (Line(points={{-39,60},{20,60},{20,
                    50},{38,50}}, color={0,0,127}));
            connect(ramp1.y, mulSum_2.u[1]) annotation (Line(points={{-39,60},{20,60},{20,
                    11},{38,11}},     color={0,0,127}));
            connect(ramp2.y, mulSum_2.u[2]) annotation (Line(points={{-39,30},{10,30},{10,
                    9},{38,9}},     color={0,0,127}));
            connect(ramp4.y, mulSum_3.u[1]) annotation (Line(points={{-39,-30},{-0.5,-30},
                    {-0.5,-80.6667},{38,-80.6667}}, color={0,0,127}));
            connect(ramp5.y, mulSum_3.u[2]) annotation (Line(points={{-39,-60},{0,-60},{0,
                    -82},{38,-82}}, color={0,0,127}));
            connect(ramp5.y, mulSum_3.u[3]) annotation (Line(points={{-39,-60},{0,-60},{0,
                    -83.3333},{38,-83.3333}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/MultiSum.mos"
                  "Simulate and plot"),
            Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.MultiSum\">
Buildings.Controls.OBC.CDL.Continuous.MultiSum</a>.
</p>
<p>
The inputs and gains are configured as follows:
</p>
<ul>
<li>
<i>u<sub>1</sub></i> varies from <i>-2</i> to <i>+2</i>,
with gain <i>k = 1</i>.
</li>
<li>
<i>u<sub>2</sub></i> varies from <i>-1</i> to <i>+1</i>,
with gain <i>k = 0.5</i>.
</li>
<li>
<i>u<sub>3</sub></i> varies from <i>-1</i> to <i>+2</i>,
with gain <i>k = 0.1</i>.
</li>
<li>
<i>u<sub>4</sub></i> varies from <i>-2</i> to <i>+1</i>,
with gain <i>k = 1</i>.
</li>
<li>
<i>u<sub>5</sub></i> varies from <i>-3</i> to <i>0</i>,
with gain <i>k = 2</i>.
</li>
</ul>
</html>",           revisions="<html>
<ul>
<li>
June 28, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MultiSum;

          model NumberOfRequests  "Validation model for the NumberOfRequests block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.NumberOfRequests numReq1(
              nin=5,
              threShold=1.0,
              kind=0)
              "Block that outputs the number of signals that are above/below a certain threshold"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,56},{-40,76}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=3) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,22},{-40,42}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp3(
              duration=1,
              height=3.5,
              offset=0.5) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp4(
              duration=1,
              offset=3,
              height=-1) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-42},{-40,-22}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp5(
              duration=1,
              offset=0,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-74},{-40,-54}})));

          equation
            connect(ramp1.y, numReq1.u[1]) annotation (Line(points={{-39,66},{-26,66},{-26,
                    -1.6},{-12,-1.6}}, color={0,0,127}));
            connect(ramp2.y, numReq1.u[2]) annotation (Line(points={{-39,32},{-26,32},{-26,
                    -0.8},{-12,-0.8}}, color={0,0,127}));
            connect(ramp3.y, numReq1.u[3])
              annotation (Line(points={{-39,0},{-25.5,0},{-12,0}}, color={0,0,127}));
            connect(ramp4.y, numReq1.u[4]) annotation (Line(points={{-39,-32},{-26,-32},{-26,
                    0.8},{-12,0.8}}, color={0,0,127}));
            connect(ramp5.y, numReq1.u[5]) annotation (Line(points={{-39,-64},{-26,-64},{-26,
                    1.6},{-12,1.6}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/NumberOfRequests.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.NumberOfRequests\">
Buildings.Controls.OBC.CDL.Continuous.NumberOfRequests</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2</i> to <i>+2</i>, input <code>u2</code> varies from <i>-1</i> to <i>+2</i>,
input <code>u3</code> varies from <i>+2</i> to <i>-2</i>, input <code>u4</code> varies from <i>+3</i> to <i>+2</i>,
input <code>u5</code> varies from <i>0</i> to <i>+4</i>,
</p>
</html>",           revisions="<html>
<ul>
<li>
September 26, 2017, by Thierry S. Nouidui:<br/>
Revised implementation for JModelica verification.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/939\">issue 939</a>.
</li>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end NumberOfRequests;

          model Product "Validation model for the Product block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Product product1
              "Block that outputs product of the two inputs" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,10},{-40,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=3) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-30},{-40,-10}})));

          equation
            connect(ramp1.y, product1.u1) annotation (Line(points={{-39,20},{-26,20},{-26,
                    6},{-12,6}}, color={0,0,127}));
            connect(ramp2.y, product1.u2) annotation (Line(points={{-39,-20},{-26,-20},{
                    -26,-6},{-12,-6}},
                                   color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Product.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Product\">
Buildings.Controls.OBC.CDL.Continuous.Product</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2</i> to <i>+2</i>, input <code>u2</code> varies from <i>-1</i> to <i>+2</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Product;

          model Round "Validation model for the Round block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits"
              annotation (Placement(transformation(extent={{40,40},{60,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=7.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=1)
              "Round real number to given digits"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round3(n=-1)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{40,-60},{60,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai(k=0.1)
              "Gain"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain gai1(k=10)
              "Gain"
              annotation (Placement(transformation(extent={{0,-60},{20,-40}})));
          equation
            connect(ramp1.y,round1. u)
              annotation (Line(points={{-39,0},{-20,0},{-20,50},{38,50}},
                                                         color={0,0,127}));

            connect(ramp1.y, gai.u)
              annotation (Line(points={{-39,0},{-20,0},{-2,0}}, color={0,0,127}));
            connect(round2.u, gai.y)
              annotation (Line(points={{38,0},{21,0}}, color={0,0,127}));
            connect(ramp1.y, gai1.u) annotation (Line(points={{-39,0},{-20,0},{-20,-50},{
                    -2,-50}}, color={0,0,127}));
            connect(round3.u, gai1.y)
              annotation (Line(points={{38,-50},{30,-50},{21,-50}}, color={0,0,127}));
          annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Round.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Round\">
Buildings.Controls.OBC.CDL.Continuous.Round</a>.
</p>
<p>
The input <code>u</code> varies from <i>-3.5</i> to <i>+3.5</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Round;

          model Sin "Validation model for the Sin block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
              "Block that outputs the sine of the input" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=6.2831852) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, sin1.u)
              annotation (Line(points={{-39,0},{-12,0}},         color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Sin.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sin\">
Buildings.Controls.OBC.CDL.Continuous.Sin</a>.
</p>
<p>
The input <code>u</code> varies from <i>0.0</i> to <i>+2&pi;</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Sin;

          model SlewRateLimiter "Validation model for the SlewRateLimiter block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.SlewRateLimiter sleRatLim(
                raisingSlewRate=1/30)
              "Block that limit the increase or decrease rate of input"
              annotation (Placement(transformation(extent={{70,-10},{90,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              offset=0,
              height=1.5,
              duration=20,
              startTime=10) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,100},{-60,120}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              offset=0,
              height=-1.5,
              startTime=60,
              duration=20) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,70},{-60,90}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add
              "Signal adder" annotation (Placement(transformation(extent={{-40,
                      80},{-20,100}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp3(
              offset=0,
              height=-1.5,
              duration=30,
              startTime=120 + 60) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp4(
              offset=0,
              height=1.5,
              duration=30,
              startTime=120) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,40},{-60,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp5(
              offset=0,
              height=-1.5,
              startTime=240 + 60,
              duration=40) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-60},{-60,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp6(
              offset=0,
              height=1.5,
              startTime=240,
              duration=40) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-30},{-60,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1
              "Signal adder" annotation (Placement(transformation(extent={{-40,
                      20},{-20,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2
              "Signal adder" annotation (Placement(transformation(extent={{-40,
                      -48},{-20,-28}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp7(
              offset=0,
              height=-1.5,
              duration=50,
              startTime=360 + 60) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-80,-130},{-60,-110}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp8(
              offset=0,
              height=1.5,
              duration=50,
              startTime=360) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-100},{-60,-80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add3
              "Signal adder" annotation (Placement(transformation(extent={{-40,
                      -120},{-20,-100}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add4
              "Signal adder"
              annotation (Placement(transformation(extent={{0,50},{20,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add5
              "Signal adder"
              annotation (Placement(transformation(extent={{0,-80},{20,-60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add6
              "Signal adder"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          equation
            connect(ramp1.y, add.u1) annotation (Line(points={{-59,110},{-46,110},{-46,96},
                    {-42,96}},
                         color={0,0,127}));
            connect(ramp2.y, add.u2) annotation (Line(points={{-59,80},{-52,80},{-52,84},{
                    -42,84}},  color={0,0,127}));
            connect(ramp4.y, add1.u1) annotation (Line(points={{-59,50},{-50,50},{-50,36},
                    {-42,36}},
                             color={0,0,127}));
            connect(ramp3.y, add1.u2) annotation (Line(points={{-59,20},{-50,20},{-50,24},
                    {-42,24}}, color={0,0,127}));
            connect(ramp6.y, add2.u1) annotation (Line(points={{-59,-20},{-50,-20},{-50,-32},
                    {-42,-32}}, color={0,0,127}));
            connect(ramp5.y, add2.u2) annotation (Line(points={{-59,-50},{-50,-50},{-50,-44},
                    {-42,-44}}, color={0,0,127}));
            connect(ramp8.y,add3. u1) annotation (Line(points={{-59,-90},{-50,-90},{-50,-104},
                    {-42,-104}},color={0,0,127}));
            connect(ramp7.y,add3. u2) annotation (Line(points={{-59,-120},{-50,-120},{-50,
                    -116},{-42,-116}},
                                color={0,0,127}));
            connect(add.y, add4.u1) annotation (Line(points={{-19,90},{-12,90},{-12,66},{-2,
                    66}}, color={0,0,127}));
            connect(add1.y, add4.u2) annotation (Line(points={{-19,30},{-10,30},{-10,54},{
                    -2,54}}, color={0,0,127}));
            connect(add2.y, add5.u1) annotation (Line(points={{-19,-38},{-10,-38},{-10,-64},
                    {-2,-64}}, color={0,0,127}));
            connect(add3.y, add5.u2) annotation (Line(points={{-19,-110},{-12,-110},{-12,-76},
                    {-2,-76}}, color={0,0,127}));
            connect(add4.y, add6.u1)
              annotation (Line(points={{21,60},{24,60},{24,6},{38,6}}, color={0,0,127}));
            connect(add5.y, add6.u2) annotation (Line(points={{21,-70},{24,-70},{24,-6},{38,
                    -6}}, color={0,0,127}));
            connect(sleRatLim.u, add6.y)
              annotation (Line(points={{68,0},{68,0},{61,0}}, color={0,0,127}));
            annotation (
           experiment(StopTime=480, Tolerance=1e-06),
             __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/SlewRateLimiter.mos"
                   "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.SlewRateLimiter\">
Buildings.Controls.OBC.CDL.Continuous.SlewRateLimiter</a>.
</p>
<p>
The input <code>ramp1.u</code> varies from <i>0</i> to <i>+1.5</i>,
in <code> 1 s</code>.
</p>
<p>
The increase and decrease rate limits are <code>[increase/incDt, -decrease/decDt] </code>, which is <code>[1, -1]</code> here.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 29, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Diagram(coordinateSystem(extent={{-100,-140},{100,140}})),
              Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end SlewRateLimiter;

          model Sort "Validation model for the Sort block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sort sorAsc(nin=5)
              "Block that sorts signals in ascending order"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-2,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,56},{-40,76}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1,
              height=3) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,22},{-40,42}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp3(
              duration=1,
              offset=2,
              height=-4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp4(
              duration=1,
              offset=3,
              height=-1) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-42},{-40,-22}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp5(
              duration=1,
              offset=0,
              height=4) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-74},{-40,-54}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sort sorDes(nin=5,
                ascending=false) "Block that sorts signals in ascending order"
              annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
          equation
            connect(ramp1.y, sorAsc.u[1]) annotation (Line(points={{-39,66},{-22,66},{-22,
                    28.4},{-2,28.4}}, color={0,0,127}));
            connect(ramp2.y, sorAsc.u[2]) annotation (Line(points={{-39,32},{-20,32},{-20,
                    29.2},{-2,29.2}}, color={0,0,127}));
            connect(ramp3.y, sorAsc.u[3]) annotation (Line(points={{-39,0},{-22,0},{-22,
                    30},{-2,30}}, color={0,0,127}));
            connect(ramp4.y, sorAsc.u[4]) annotation (Line(points={{-39,-32},{-22,-32},{
                    -22,30.8},{-2,30.8}}, color={0,0,127}));
            connect(ramp5.y, sorAsc.u[5]) annotation (Line(points={{-39,-64},{-20,-64},{
                    -20,31.6},{-2,31.6}}, color={0,0,127}));
            connect(ramp1.y, sorDes.u[1]) annotation (Line(points={{-39,66},{-22,66},{-22,
                    -31.6},{-2,-31.6}}, color={0,0,127}));
            connect(ramp2.y, sorDes.u[2]) annotation (Line(points={{-39,32},{-20,32},{-20,
                    -30.8},{-2,-30.8}}, color={0,0,127}));
            connect(ramp3.y, sorDes.u[3]) annotation (Line(points={{-39,0},{-22,0},{-22,
                    -30},{-2,-30}}, color={0,0,127}));
            connect(ramp4.y, sorDes.u[4]) annotation (Line(points={{-39,-32},{-22,-32},{
                    -22,-29.2},{-2,-29.2}}, color={0,0,127}));
            connect(ramp5.y, sorDes.u[5]) annotation (Line(points={{-39,-64},{-20,-64},{
                    -20,-28.4},{-2,-28.4}}, color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Sort.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sort\">
Buildings.Controls.OBC.CDL.Continuous.Sort</a>.
</p>
<p>
The input <code>u1</code> varies from <i>-2</i> to <i>+2</i>, input <code>u2</code> varies from <i>-1</i> to <i>+2</i>,
input <code>u3</code> varies from <i>+2</i> to <i>-2</i>, input <code>u4</code> varies from <i>+3</i> to <i>+2</i>,
input <code>u5</code> varies from <i>0</i> to <i>+4</i>,
</p>
</html>",           revisions="<html>
<ul>
<li>
September 14, 2017, by Jianjun Hu:<br/>
Changed model name.
</li>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Sort;

          model Sqrt "Validation model for the Sqrt block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sqrt sqrt1
              "Block that outputs the square root of the input (input >= 0 required)"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=9) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, sqrt1.u)
              annotation (Line(points={{-39,0},{-12,0}},         color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Sqrt.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sqrt\">
Buildings.Controls.OBC.CDL.Continuous.Sqrt</a>.
</p>
<p>
The input <code>u</code> varies from <i>0.0</i> to <i>+9.0</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Sqrt;

          model Tan "Validation model for the Tan block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Tan tan1
              "Block that outputs the sine of the input" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-1.5,
              height=3.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ramp1.y, tan1.u)
              annotation (Line(points={{-39,0},{-12,0}},         color={0,0,127}));
            annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Continuous/Validation/Tan.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Tan\">
Buildings.Controls.OBC.CDL.Continuous.Tan</a>.
</p>
<p>
The input <code>u</code> varies from <i>-1.5</i> to <i>+1.5</i>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 22, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Tan;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous\">
Buildings.Controls.OBC.CDL.Continuous</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={8.0,14.0},
                  lineColor={78,138,73},
                  fillColor={78,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}}),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0)}));
        end Validation;
      annotation (
      Documentation(
      info="<html>
<p>
Package with blocks for elementary mathematical functions
for continuous variables.
</p>
</html>",
      revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),
      Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
                     Text(
              extent={{-52,86},{52,-92}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              textString="R"),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0)}));
      end Continuous;

      package Conversions "Package with blocks for type conversion"

        block BooleanToInteger "Convert Boolean to Integer signal"

          parameter Integer integerTrue=1 "Output signal for true Boolean input";

          parameter Integer integerFalse=0 "Output signal for false Boolean input";

          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.IntegerOutput y
            "Connector of Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = if u then integerTrue else integerFalse;

        annotation (
        defaultComponentName="booToInt",
        Documentation(info="<html>
<p>
Block that outputs the <code>Boolean</code>
equivalent of the <code>Integer</code> input.
</p>
<pre>
  y = if u then integerTrue else integerFalse;
</pre>
<p>
where <code>u</code> is of <code>Boolean</code> and <code>y</code>
of <code>Integer</code> type,
and <code>integerTrue</code> and <code>integerFalse</code> are parameters.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),       Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Text(
                  extent={{-86,92},{-6,10}},
                  lineColor={255,0,255},
                  textString="B"),
                Polygon(
                  points={{-12,-46},{-32,-26},{-32,-36},{-64,-36},{-64,-56},{-32,-56},
                      {-32,-66},{-12,-46}},
                  lineColor={255,170,85},
                  fillColor={255,170,85},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{8,-4},{92,-94}},
                  lineColor={255,170,85},
                  textString="I"),               Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                           Ellipse(
                  extent={{-71,7},{-85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),      Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end BooleanToInteger;

        block BooleanToReal "Convert Boolean to Real signal"

          parameter Real realTrue=1 "Output signal for true Boolean input";

          parameter Real realFalse=0 "Output signal for false Boolean input";

          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y
            "Connector of Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = if u then realTrue else realFalse;

        annotation (
        defaultComponentName="booToRea",
        Documentation(info="<html>
<p>
Block that outputs the <code>Boolean</code>
equivalent of the <code>Integer</code> input.
</p>
<pre>
  y = if u then integerTrue else integerFalse;
</pre>
<p>
where <code>u</code> is of <code>Boolean</code> and <code>y</code>
of <code>Integer</code> type,
and <code>integerTrue</code> and <code>integerFalse</code> are parameters.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 10, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),       Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Text(
                  extent={{-86,92},{-6,10}},
                  lineColor={255,0,255},
                  textString="B"),
                Polygon(
                  points={{-12,-46},{-32,-26},{-32,-36},{-64,-36},{-64,-56},{-32,-56},
                      {-32,-66},{-12,-46}},
                  lineColor={255,170,85},
                  fillColor={255,170,85},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{8,-4},{92,-94}},
                  lineColor={255,170,85},
                  textString="I"),               Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                           Ellipse(
                  extent={{-71,7},{-85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),      Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end BooleanToReal;

        block IntegerToReal "Convert Integer to Real signals"

          Interfaces.IntegerInput u "Connector of Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u;

        annotation (
            defaultComponentName="intToRea",
            Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
              Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),   Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                  lineColor={255,127,0},
                  extent={{-120.0,-40.0},{-20.0,40.0}},
                  textString="I"),
              Text(
                  lineColor={0,0,127},
                  fillPattern=FillPattern.Solid,
                  extent={{0.0,-40.0},{100.0,40.0}},
                  textString="R"),
              Polygon(
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid,
                  points={{10.0,0.0},{-10.0,20.0},{-10.0,10.0},{-40.0,10.0},{-40.0,-10.0},
                      {-10.0,-10.0},{-10.0,-20.0},{10.0,0.0}})}),
        Documentation(info="<html>
<p>
Block that outputs the <code>Real</code>
equivalent of the <code>Integer</code> input.
</p>
<pre>
  y = u;
</pre>
<p>
where <code>u</code> is of <code>Integer</code> and
<code>y</code> of <code>Real</code> type.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end IntegerToReal;

        block IsHoliday
          "Block that outputs true if the input is a holiday"

          Interfaces.DayTypeInput u "Connector of DayType input signal"
            annotation ( Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.Holiday;

        annotation (
        defaultComponentName="isHol",
        Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the input signal is
of type holiday.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-82,46},{82,-44}},
                  lineColor={0,127,0},
                  textString="isHoliday"),
                Text(
                  extent={{-140,148},{160,108}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end IsHoliday;

        block IsNonWorkingDay
          "Block that outputs true if the input is a non-working day"

          Interfaces.DayTypeInput u "Connector of DayType input signal"
            annotation ( Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.NonWorkingDay;

        annotation (
        defaultComponentName="isNonWorDay",
        Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the input signal is
of type non-working day.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-82,46},{82,-44}},
                  lineColor={0,127,0},
                  textString="isNonWorkingDay"),
                Text(
                  extent={{-140,148},{160,108}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end IsNonWorkingDay;

        block IsWorkingDay
          "Block that outputs true if the input is a working day"

          Interfaces.DayTypeInput u "Connector of DayType input signal"
            annotation ( Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u == hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.WorkingDay;

        annotation (
        defaultComponentName="isWorDay",
        Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the input signal is
of type working day.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-82,46},{82,-44}},
                  lineColor={0,127,0},
                  textString="isWorkingDay"),
                Text(
                  extent={{-140,148},{160,108}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end IsWorkingDay;

        block RealToInteger "Convert Real to Integer signal"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.IntegerOutput y
            "Connector of Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = if (u > 0) then integer(floor(u + 0.5)) else integer(ceil(u - 0.5));

        annotation (
        defaultComponentName="reaToInt",
        Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
                Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,127},
                  extent={{-100.0,-40.0},{0.0,40.0}},
                  textString="R"),
                Text(
                  lineColor={255,127,0},
                  extent={{20.0,-40.0},{120.0,40.0}},
                  textString="I"),
                Polygon(
                  lineColor={255,127,0},
                  fillColor={255,127,0},
                  fillPattern=FillPattern.Solid,
                  points={{50.0,0.0},{30.0,20.0},{30.0,10.0},{0.0,10.0},{0.0,-10.0},{
                      30.0,-10.0},{30.0,-20.0},{50.0,0.0}}),
                                                    Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255})}),
        Documentation(info="<html>
<p>
Block that outputs <code>y</code>
as the nearest integer value of the input <code>u</code>.
</p>
<p>
The block outputs
</p>
<pre>
    y = integer( floor( u + 0.5 ) )  for  u &gt; 0,
    y = integer( ceil ( u - 0.5 ) )  for  u &lt; 0.
</pre>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end RealToInteger;

        package Validation "Collection of models that validate the conversion blocks of the CDL"

          model BooleanToInteger  "Validation model for the BooleanToInteger block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
              booToInt "Block that convert Boolean to Integer signal"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(period=1)
              "Generate output cyclic on and off"
              annotation (Placement(transformation(extent={{-20,-10},{0,10}})));

          equation
            connect(booPul.y, booToInt.u)
              annotation (Line(points={{1,0},{28,0},{28,0}}, color={255,0,255}));
            annotation (
            experiment(StopTime=4.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Conversions/Validation/BooleanToInteger.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Conversions.BooleanToInteger\">
Buildings.Controls.OBC.CDL.Conversions.BooleanToInteger</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 31, 2017, by Jianjun Hu:<br/>
First implementation..
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end BooleanToInteger;

          model BooleanToReal "Validation model for the BooleanToReal block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea
              "Block that convert Boolean to Real signal"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(period=1)
              "Generate output cyclic on and off"
              annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
          equation
            connect(booPul.y, booToRea.u)
              annotation (Line(points={{1,0},{28,0},{28,0}}, color={255,0,255}));
            annotation (
            experiment(StopTime=4.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Conversions/Validation/BooleanToReal.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Conversions.BooleanToReal\">
Buildings.Controls.OBC.CDL.Conversions.BooleanToReal</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 10, 2017, by Jianjun Hu:<br/>
First implementation..
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end BooleanToReal;

          model DayTypeCheck  "Model to validate blocks IsWorkingDay, IsNonWorkingDay, IsHoliday"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.IsWorkingDay isWorDay
              "Block to check if it is working day"
              annotation (Placement(transformation(extent={{20,30},{40,50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.IsNonWorkingDay isNonWorDay
              "Block to check if it is non-working day"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.IsHoliday isHoliday
              "Block to check if it is holiday day" annotation (Placement(
                  transformation(extent={{20,-50},{40,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.DayType dayTypSat(iStart=6)
              "Model that outputs the type of the day, starting with Saturday"
              annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
          equation
            connect(dayTypSat.y[1], isNonWorDay.u)
              annotation (Line(points={{-59,0},{-40,0},{-20,0},{18,0}}, color={0,127,0}));
            connect(dayTypSat.y[1], isHoliday.u)
              annotation (Line(points={{-59,0},{-40,0},{-20,0},{-20,-40},{18,-40}},
                color={0,127,0}));
            connect(dayTypSat.y[1], isWorDay.u)
              annotation (Line(points={{-59,0},{-20,0},{-20,40},{18,40}},
                color={0,127,0}));
            annotation (
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Conversions/Validation/DayTypeCheck.mos"
                  "Simulate and plot"),
               experiment(StartTime=0, StopTime=1814400, Tolerance=1E-6),
              Documentation(info="<html>
<p>
This example validates the bocks <code>IsWorkingDay</code>,
<code>IsNonWorkingDay</code>, <code>IsHoliday</code>. The instance
<code>dayTypSat</code> generates DayType signals for three consecutive weeks,
with five working and two non-working days. The first day is Saturady, which
is a non-working day.
</p>
</html>", revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First CDL implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end DayTypeCheck;

          model IntegerToReal "Validation model for the IntegerToReal block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.IntegerToReal intToRea
              "Block that convert Integer to Real signal"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=7.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-10},{-60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

          equation
            connect(ramp1.y, round2.u)
              annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
            connect(round2.y, reaToInt1.u)
              annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
            connect(reaToInt1.y, intToRea.u)
              annotation (Line(points={{21,0},{28,0},{28,0},{38,0}}, color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Conversions/Validation/IntegerToReal.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Conversions.IntegerToReal\">
Buildings.Controls.OBC.CDL.Conversions.IntegerToReal</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 31, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end IntegerToReal;

          model RealToInteger "Validation model for the RealToInteger block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Block that converts Real to Integer signal"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=7.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

          equation
            connect(ramp1.y, reaToInt.u)
              annotation (Line(points={{-39,0},{28,0}},        color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Conversions/Validation/RealToInteger.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Conversions.RealToInteger\">
Buildings.Controls.OBC.CDL.Conversions.RealToInteger</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
March 31, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end RealToInteger;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Conversions\">
Buildings.Controls.OBC.CDL.Conversions</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100,-100},{100,100}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100,-100},{100,100}},
                  radius=25.0),
                Polygon(
                  origin={8,14},
                  lineColor={78,138,73},
                  fillColor={78,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
        end Validation;
      annotation (
      Documentation(
      info="<html>
<p>
Package with blocks for type conversions.
</p>
</html>",
      revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0)}));
      end Conversions;

      package Discrete "Package with discrete blocks"

        model DayType "Block that outputs a signal that indicates week-day or week-end"
          parameter Integer nout = 2
            "Number of days to output. Set to two for one day predictions";
          parameter hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day[:] days={
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.WorkingDay,
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.WorkingDay,
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.WorkingDay,
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.WorkingDay,
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.WorkingDay,
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.NonWorkingDay,
              hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Day.NonWorkingDay}
            "Array where each element is a day indicator";
           parameter Integer iStart(min=1, max=size(days, 1)) = 1
            "Index of element in days at simulation start";

          Interfaces.DayTypeOutput y[nout]
            "Type of the day for the current and the next (nout-1) days" annotation (
              Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          parameter Modelica.SIunits.Time samplePeriod=86400
            "Sample period of component";
          output Integer iDay(min=1, max=size(days, 1))
            "Pointer to days that determines what day type is sent to the output";
          parameter Modelica.SIunits.Time firstSample(fixed=false)
            "Time when the sampling starts";
          output Boolean sampleTrigger "True, if sample time instant";
          output Boolean skipIDayIncrement
            "If true, don't increment iDay in first sample";

        initial equation
          iDay = iStart;
          firstSample = ceil(time/86400)*86400;
          // skipIDayIncrement is true if the simulation starts at midnight.
          skipIDayIncrement = abs(firstSample-time) < 1E-8;
        equation
          for i in 1:nout loop
            y[i] = days[ mod(iDay+i-2, size(days, 1))+1];
          end for;
          sampleTrigger = sample(firstSample, samplePeriod);
          when sampleTrigger then
            skipIDayIncrement = false;
            if pre(skipIDayIncrement) then
              iDay = pre(iDay);
            else
              iDay = mod(pre(iDay), size(days, 1))+1;
            end if;
          end when;
          annotation (
          defaultComponentName="dayTyp",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={    Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                lineThickness=5.0,
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid),
                Text(
                  extent={{-68,54},{68,-38}},
                  lineColor={0,0,255},
                  textString="day"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
This block outputs a signal that indicates the type of the day.
It can for example be used to generate a signal that indicates whether
the current time is a work day or a non-working day.
The output signal is of type
<a href=\"modelica://Buildings.Controls.OBC.CDL.Types.Day\">
Buildings.Controls.OBC.CDL.Types.Day</a>.
</p>
<p>
The parameter <code>nout</code> determines how many days should be
sent to the output. For applications in which only the current day
is of interest, set <code>nout=1</code>.
For applications in which the load is predicted for the next <i>24</i> hours,
set <code>nout=2</code> in order to output the type of day for today and for
tomorrow.
</p>
<p>
The transition from one day type to another always happens when the simulation time
is a multiple of <i>1</i> day. Hence, if the simulation starts for example
at <i>t=-3600</i> seconds, then the first transition to another day will be
at <i>t=0</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
January 11, 2016, by Milica Grahovac:<br/>
First CDL implementation.
</li>
<li>
March 20, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end DayType;

        block FirstOrderHold "First order hold of a sampled-data system"

          parameter Modelica.SIunits.Time samplePeriod(min=1E-3)
            "Sample period of component";

          Interfaces.RealInput u "Continuous input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Continuous output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          parameter Modelica.SIunits.Time t0(fixed=false)
            "First sample time instant";

          output Boolean sampleTrigger "True, if sample time instant";

          output Boolean firstTrigger(start=false, fixed=true)
            "Rising edge signals first sample instant";

          Modelica.SIunits.Time tSample "Time of sample";
          Real uSample "Value of sample";
          Real pre_uSample "Value of previous sample";
          Real c "Slope";

        initial equation
          t0 = time;
          pre(tSample) = time;
          pre(uSample) = u;
          pre(pre_uSample) = u;
          pre(c) = 0.0;

        equation
          // Declarations that are used for all discrete blocks
          sampleTrigger = sample(t0, samplePeriod);
          when sampleTrigger then
            firstTrigger = time <= t0 + samplePeriod/2;
          end when;

          // Declarations specific to this type of discrete block
          when sampleTrigger then
            tSample = time;
            uSample = u;
            pre_uSample = pre(uSample);
            c = if firstTrigger then 0 else (uSample - pre_uSample)/samplePeriod;
          end when;
          /* Use pre_uSample and pre(c) to break potential algebraic loops by an
       infinitesimal delay if both the continuous and the discrete part
       have direct feedthrough.
    */
          y = pre_uSample + pre(c)*(time - tSample);
          annotation (
          defaultComponentName="firOrdHol",
            Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={                     Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                lineThickness=5.0,
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
              Line(points={{-79.0,-41.0},{-59.0,-33.0},{-40.0,1.0},{-20.0,9.0},
                          {0.0,63.0},{21.0,20.0},{41.0,10.0},{60.0,20.0}},
                color={0,0,127}),
              Line(points={{60.0,20.0},{81.0,10.0}},
                color={0,0,127}),
              Text(
                extent={{226,60},{106,10}},
                lineColor={0,0,0},
                textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs the extrapolation through the
values of the last two sampled input signals.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Michael Wetter:<br/>
Removed parameter <code>startTime</code> to allow model to work
also for negative start time without having to change the value of this
parameters.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/938\">issue 938</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end FirstOrderHold;

        block Sampler "Ideal sampler of a continuous signal"

          parameter Modelica.SIunits.Time samplePeriod(min=1E-3)
            "Sample period of component";

          Interfaces.RealInput u "Continuous input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Continuous output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          parameter Modelica.SIunits.Time t0(fixed=false)
            "First sample time instant";

          output Boolean sampleTrigger "True, if sample time instant";

          output Boolean firstTrigger(start=false, fixed=true)
            "Rising edge signals first sample instant";
        initial equation
          t0 = time;

        equation
          // Declarations that are used for all discrete blocks
          sampleTrigger = sample(t0, samplePeriod);
          when sampleTrigger then
            firstTrigger = time <= t0 + samplePeriod/2;
          end when;

          // Declarations specific to this type of discrete block
          when {sampleTrigger, initial()} then
            y = u;
          end when;
          annotation (
            defaultComponentName="sam",
            Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={                     Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                lineThickness=5.0,
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
              Ellipse(lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{25.0,-10.0},{45.0,10.0}}),
              Line(points={{-100.0,0.0},{-45.0,0.0}},
                color={0,0,127}),
              Line(points={{45.0,0.0},{100.0,0.0}},
                color={0,0,127}),
              Line(points={{-35.0,0.0},{30.0,35.0}},
                color={0,0,127}),
              Ellipse(lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-45.0,-10.0},{-25.0,10.0}})}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-25,-10},{-45,10}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{45,-10},{25,10}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-100,0},{-45,0}}, color={0,0,255}),
                Line(points={{45,0},{100,0}}, color={0,0,255}),
                Line(points={{-35,0},{30,35}}, color={0,0,255}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs the input signal, sampled at a sampling rate defined
via parameter <code>samplePeriod</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Michael Wetter:<br/>
Removed parameter <code>startTime</code> to allow model to work
also for negative start time without having to change the value of this
parameters.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/938\">issue 938</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Sampler;

        block TriggeredMax
          "Output the maximum, absolute value of a continuous signal at trigger instants"

          Interfaces.RealInput u "Connector with a Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector with a Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          Interfaces.BooleanInput trigger "Connector for trigger"
            annotation (Placement(
                transformation(
                origin={0,-118},
                extent={{-20,-20},{20,20}},
                rotation=90)));

        initial equation
          y = u;

        equation
          when trigger then
             y = max(pre(y), abs(u));
          end when;

          annotation (
            defaultComponentName="triMax",
            Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={                     Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                lineThickness=5.0,
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
              Ellipse(lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{25.0,-10.0},{45.0,10.0}}),
              Line(points={{-100.0,0.0},{-45.0,0.0}},
                color={0,0,127}),
              Line(points={{45.0,0.0},{100.0,0.0}},
                color={0,0,127}),
              Line(points={{0.0,-100.0},{0.0,-26.0}},
                color={255,0,255}),
              Line(points={{-35.0,0.0},{28.0,-48.0}},
                color={0,0,127}),
              Text(extent={{-86.0,24.0},{82.0,82.0}},
                textString="max"),
              Ellipse(lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-45.0,-10.0},{-25.0,10.0}})}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-25,-10},{-45,10}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{45,-10},{25,10}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-100,0},{-45,0}}, color={0,0,255}),
                Line(points={{45,0},{100,0}}, color={0,0,255}),
                Line(points={{-35,0},{28,-48}}, color={0,0,255}),
                Line(points={{0,-100},{0,-26}}, color={255,0,255}),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs the input signal whenever the trigger input
signal is rising (i.e., trigger changes to
<code>true</code>). The maximum, absolute value of the input signal
at the sampling point is provided as the output signal.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Michael Wetter:<br/>
Removed parameter <code>startTime</code> and <code>sampleTime</code>
as these are not needed for this block, and introduced parameter
<code>y_start=0</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/938\">issue 938</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end TriggeredMax;

        block TriggeredMovingMean
          "Triggered discrete moving mean of an input signal"

          parameter Integer n(min=1)
            "Number of samples over which the input is averaged";

          Interfaces.RealInput u "Continuous input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanInput trigger "Boolean signal that triggers the block"
            annotation (Placement(
                transformation(
                origin={0,-120},
                extent={{-20,-20},{20,20}},
                rotation=90), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120})));
          Interfaces.RealOutput y "Discrete averaged signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          parameter Modelica.SIunits.Time t0(fixed=false) "First sample time instant";
          Integer iSample(start=0, fixed=true) "Sample numbering in the calculation";
          Integer counter(start=0, fixed=true)
              "Number of samples used for averaging calculation";
          Integer index(start=0, fixed=true) "Index of the vector ySample";
          Real ySample[n](
            start=zeros(n),
            each fixed=true) "Vector of samples to be averaged";

        initial equation
          t0 = time;

        equation
          when {initial(), trigger} then
            index = mod(pre(iSample), n) + 1;
            ySample = {if (i == index) then u else pre(ySample[i]) for i in 1:n};
            counter = if pre(counter) == n then n else pre(counter) + 1;
            y = sum(ySample)/counter;
            iSample = pre(iSample) + 1;
          end when;

          annotation (
          defaultComponentName="triMovMea",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
               graphics={
               Rectangle(
               extent={{-100,-100},{100,100}},
               lineColor={0,0,127},
               fillColor={223,211,169},
               lineThickness=5.0,
               borderPattern=BorderPattern.Raised,
               fillPattern=FillPattern.Solid),
               Text(
               extent={{-150,150},{150,110}},
               textString="%name",
               lineColor={0,0,255}),
               Line(points={{-88,0},{70,0}}, color={192,192,192}),
               Polygon(
                  points={{92,0},{70,8},{70,-8},{92,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
               Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
               Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
               Line(points={{-80,0},{-52,0}}, color={217,67,180}),
               Line(
                  points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
                      {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},
                      {-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},
                      {29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{
                      57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}},
                  smooth=Smooth.Bezier,
                  color={28,108,200}),
               Line(points={{-52,36},{-24,36}}, color={217,67,180}),
               Line(points={{-52,0},{-52,36}}, color={217,67,180}, smooth=Smooth.Bezier),
               Line(points={{-24,36},{-24,46}}, color={217,67,180}, smooth=Smooth.Bezier),
               Line(points={{-24,46},{4,46}}, color={217,67,180}),
               Line(points={{4,4},{32,4}}, color={217,67,180}),
               Line(points={{4,46},{4,4}}, color={217,67,180}, smooth=Smooth.Bezier),
               Line(points={{32,-32},{60,-32}}, color={217,67,180}),
               Line(points={{32,4},{32,-32}}, color={217,67,180}, smooth=Smooth.Bezier),
               Line(points={{60,-58},{82,-58}}, color={217,67,180}),
               Line(points={{60,-32},{60,-58}}, color={217,67,180},smooth=Smooth.Bezier),
                Ellipse(
                  extent={{-25,-10},{-45,10}},
                  lineColor={176,181,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{45,-10},{25,10}},
                  lineColor={176,181,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-100,0},{-45,0}}, color={176,181,255}),
                Line(points={{45,0},{100,0}}, color={176,181,255}),
                Line(points={{-35,0},{28,-48}}, color={176,181,255}),
                Line(points={{0,-100},{0,-26}}, color={255,0,255}),
                Text(
                  extent={{56,92},{92,60}},
                  lineColor={28,108,200},
                  textString="%n"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
        Documentation(info="<html>
<p>
Block that outputs the triggered moving mean value of an input signal.
</p>
<p>
At the start of the simulation, and whenever the trigger signal is rising
(i.e., the trigger changes to <code>true</code>), the block samples
the input, computes the moving mean value over the past <code>n</code> samples,
and produces this value at its output <code>y</code>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
November 7, 2019, by Michael Wetter:<br/>
Reformulated model to use an <code>equation</code> rather than an <code>algorithm</code> section.
</li>
<li>
October 16, 2019, by Kun Zhang:<br/>
First implementation. This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1588\">issue 1588</a>.
</li>
</ul>
</html>"));
        end TriggeredMovingMean;

        block TriggeredSampler "Triggered sampling of continuous signals"

          parameter Real y_start=0 "Initial value of output signal";

          Interfaces.RealInput u "Connector with a Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector with a Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          Interfaces.BooleanInput trigger "Signal that triggers the sampler"
            annotation (Placement(
                transformation(
                origin={0,-118},
                extent={{-20,-20},{20,20}},
                rotation=90)));

        initial equation
          y = y_start;

        equation
          when trigger then
            y = u;
          end when;

          annotation (
            defaultComponentName="triSam",
            Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                lineThickness=5.0,
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid),
              Ellipse(lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{25.0,-10.0},{45.0,10.0}}),
              Line(points={{-100.0,0.0},{-45.0,0.0}},
                color={0,0,127}),
              Line(points={{45.0,0.0},{100.0,0.0}},
                color={0,0,127}),
              Line(points={{0.0,-100.0},{0.0,-26.0}},
                color={255,0,255}),
              Line(points={{-35.0,0.0},{28.0,-48.0}},
                color={0,0,127}),
              Ellipse(lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-45.0,-10.0},{-25.0,10.0}}),
              Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{226,60},{106,10}},
                lineColor={0,0,0},
                textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Samples the continuous input signal whenever the trigger input
signal is rising (i.e., trigger changes from <code>false</code> to
<code>true</code>) and provides the sampled input signal as output.
Before the first sampling, the output signal is equal to
the initial value defined via parameter <code>y_start</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
May 18, 2017, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
May 17, 2017, by Milica Grahovac:<br/>
First revision, based on the implementation of the
Modelica Standard Library.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end TriggeredSampler;

        block UnitDelay "Output the input signal with a unit delay"

          parameter Modelica.SIunits.Time samplePeriod(min=1E-3)
            "Sample period of component";

          parameter Real y_start=0 "Initial value of output signal";

          Interfaces.RealInput u "Continuous input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Continuous output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          parameter Modelica.SIunits.Time t0(fixed=false)
            "First sample time instant";

          output Boolean sampleTrigger "True, if sample time instant";

          output Boolean firstTrigger(start=false, fixed=true)
            "Rising edge signals first sample instant";

        initial equation
          t0 = time;
          y = y_start;

        equation
          // Declarations that are used for all discrete blocks
          sampleTrigger = sample(t0, samplePeriod);
          when sampleTrigger then
            firstTrigger = time <= t0 + samplePeriod/2;
          end when;

          // Declarations specific to this type of discrete block
          when sampleTrigger then
            y = pre(u);
          end when;

          annotation (
        defaultComponentName="uniDel",
        Documentation(info="<html>
<p>
Block that outputs the input signal with a unit delay:
</p>
<pre>
          1
     y = --- * u
          z
</pre>
<p>
that is, the output signal <code>y</code> is the
input signal <code>u</code> of the
previous sample instant. Before the second sample instant,
the output <code>y</code> is identical to parameter <code>y_start</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Michael Wetter:<br/>
Removed parameter <code>startTime</code> to allow model to work
also for negative start time without having to change the value of this
parameters.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/938\">issue 938</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),         Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={                       Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                lineThickness=5.0,
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
            Line(points={{-30.0,0.0},{30.0,0.0}},
              color={0,0,127}),
            Text(lineColor={0,0,127},
              extent={{-90.0,10.0},{90.0,90.0}},
              textString="1"),
            Text(lineColor={0,0,127},
              extent={{-90.0,-90.0},{90.0,-10.0}},
              textString="z"),
                Text(
                  extent={{226,60},{106,10}},
                  lineColor={0,0,0},
                  textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}));
        end UnitDelay;

        block ZeroOrderHold "Output the input signal with a zero order hold"

          parameter Modelica.SIunits.Time samplePeriod(min=1E-3)
            "Sample period of component";

          Interfaces.RealInput u "Continuous input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Continuous output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          parameter Modelica.SIunits.Time t0(fixed=false)
            "First sample time instant";

          output Real ySample(fixed=true, start=0)
            "Sampled value of input";

          output Boolean sampleTrigger "True, if sample time instant";

          output Boolean firstTrigger(start=false, fixed=true)
            "Rising edge signals first sample instant";

        initial equation
          t0 = time;

        equation
          // Declarations that are used for all discrete blocks
          sampleTrigger = sample(t0, samplePeriod);
          when sampleTrigger then
            firstTrigger = time <= t0 + samplePeriod/2;
          end when;

          // Declarations specific to this type of discrete block
          when {sampleTrigger, initial()} then
            ySample = u;
          end when;

          /* Define y=ySample with an infinitesimal delay to break potential
       algebraic loops if both the continuous and the discrete part have
       direct feedthrough
    */
          y = pre(ySample);
          annotation (
            defaultComponentName="zerOrdHol",
            Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={                     Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                lineThickness=5.0,
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
              Line(points={{-78.0,-42.0},{-52.0,-42.0},{-52.0,0.0},{-26.0,0.0},{-26.0,24.0},{-6.0,24.0},{-6.0,64.0},{18.0,64.0},{18.0,20.0},{38.0,20.0},{38.0,0.0},{44.0,0.0},{44.0,0.0},{62.0,0.0}},
                color={0,0,127}),
              Text(
                extent={{226,60},{106,10}},
                lineColor={0,0,0},
                textString=DynamicSelect("", String(y, leftjustified=false, significantDigits=3)))}),
            Documentation(info="<html>
<p>
Block that outputs the sampled input signal at sample
time instants. The output signal is held at the value of the last
sample instant during the sample points.
At initial time, the block feeds the input directly to the output.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 2, 2020, by Michael Wetter:<br/>
Changed icon to display dynamically the output value.
</li>
<li>
September 14, 2017, by Michael Wetter:<br/>
Removed parameter <code>startTime</code> to allow model to work
also for negative start time without having to change the value of this
parameters.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/938\">issue 938</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end ZeroOrderHold;

        package Examples "Collection of models that illustrate model use and test models"

          model DayType "Example model for the source that outputs the type of the day"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.DayType dayTypMon
              "Model that outputs the type of the day, starting with Monday"
              annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.DayType dayTypSat(iStart=6)
              "Model that outputs the type of the day, starting with Saturday"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.DayType dayTypTwoWeeks(days={
                  Types.Day.WorkingDay,Types.Day.WorkingDay,Types.Day.WorkingDay,
                  Types.Day.WorkingDay,Types.Day.WorkingDay,Types.Day.WorkingDay,
                  Types.Day.NonWorkingDay,Types.Day.NonWorkingDay,Types.Day.NonWorkingDay,
                  Types.Day.NonWorkingDay,Types.Day.NonWorkingDay,Types.Day.NonWorkingDay,
                  Types.Day.NonWorkingDay,Types.Day.NonWorkingDay}, nout=14)
              "Model that outputs the type of the day, starting with 6 workdays, then 8 non-working days"
              annotation (Placement(transformation(extent={{-60,-40},{-40,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.DayType dayTypMonThr(nout=3)
              "Model that outputs the type of the day for 3 days, starting with Monday"
              annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
            annotation (
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Discrete/Examples/DayType.mos"
                  "Simulate and plot"),
                  experiment(StartTime=-1814400, StopTime=1.8144e+06, Tolerance=1E-6),
              Documentation(
              info="<html>
<p>
This example generates signals for three different work weeks.
The instance <code>dayTypMon</code> outputs a signal with five working
days, followed by two non-working days.
The instance <code>dayTypSat</code> does the same, except that the first
days is a non-working day.
The instance <code>dayTypTwoWeeks</code> outputs six working days, followed
by 8 non-working days.
The instance <code>dayTypMonThr</code> is configured the same as
<code>dayTypMon</code>, except that it outputs the type of the day
for three days, starting with the current day, then the next day and
the day after.
</p>
</html>", revisions="<html>
<ul>
<li>
January 11, 2017, by Milica Grahovac:<br/>
First CDL implementation.
</li>
<li>
March 20, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end DayType;

          model FirstOrderHold "Example model for the FirstOrderHold block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.FirstOrderHold firOrdHol(
                samplePeriod=0.2)
              "Block that first order hold of a sampled-data system"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=6.2831852) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Cos cos1
              "Block that outputs the cosine of the input" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));

          equation
            connect(ramp1.y, cos1.u)
              annotation (Line(points={{-39,0},{-12,0},{-12,0}}, color={0,0,127}));
            connect(cos1.y, firOrdHol.u)
              annotation (Line(points={{11,0},{20,0},{28,0}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Discrete/Examples/FirstOrderHold.mos"
                  "Simulate and plot"),
              Documentation(
              info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Discrete.FirstOrderHold\">
Buildings.Controls.OBC.CDL.Discrete.FirstOrderHold</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
September 14, 2017, by Michael Wetter:<br/>
Changed example to have non-zero initial conditions.
</li>
<li>
March 31, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end FirstOrderHold;

          model Sampler "Example model for the Sampler block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.Sampler sampler1(
                samplePeriod=0.2) "Ideal sampler of a continuous signal"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=6.2831852) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
              "Block that outputs the sine of the input" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}})));

          equation
            connect(ramp1.y, sin1.u)
              annotation (Line(points={{-39,0},{-12,0},{-12,0}}, color={0,0,127}));
            connect(sin1.y, sampler1.u)
              annotation (Line(points={{11,0},{20,0},{28,0}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Discrete/Examples/Sampler.mos"
                  "Simulate and plot"),
              Documentation(
              info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Discrete.Sampler\">
Buildings.Controls.OBC.CDL.Discrete.Sampler</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
March 31, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Sampler;

          model TriggeredMax "Example model for the TriggeredMax block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredMax triggeredMax
              "Output the maximum, absolute value of a continuous signal at trigger instants"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=6.2831852) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
              "Block that outputs the sine of the input" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                period=0.2) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-10,-50},{10,-30}})));
          equation
            connect(ramp1.y, sin1.u)
              annotation (Line(points={{-39,0},{-12,0},{-12,0}}, color={0,0,127}));
            connect(sin1.y, triggeredMax.u)
              annotation (Line(points={{11,0},{19.5,0},{28,0}}, color={0,0,127}));
            connect(booPul.y, triggeredMax.trigger) annotation (Line(points={{11,-40},{26,
                    -40},{40,-40},{40,-11.8}}, color={255,0,255}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Discrete/Examples/TriggeredMax.mos"
                  "Simulate and plot"),
              Documentation(
              info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Discrete.TriggeredMax\">
Buildings.Controls.OBC.CDL.Discrete.TriggeredMax</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
March 31, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end TriggeredMax;

          model TriggeredMovingMean "Validation model for the TriggeredMovingMean block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine sin(
              freqHz=1/8,
              phase=0.5235987755983,
              startTime=-0.5) "Example input signal" annotation (Placement(
                  transformation(extent={{-60,40},{-40,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(
              width=0.5,
              period=1,
              startTime=-0.5) "Block that outputs trigger signals" annotation (
                Placement(transformation(extent={{-60,-20},{-40,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredMovingMean
              triMovMea(n=3) "Triggered moving mean with 3 samples to average"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredMovingMean
              triMovMea1(n=1) "Triggered moving mean with 1 sample to average"
              annotation (Placement(transformation(extent={{0,60},{20,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredMovingMean
              triMovMea2(n=3)
              "Triggered moving mean with 3 samples to average with a different trigger period"
              annotation (Placement(transformation(extent={{0,-60},{20,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(
              width=0.5,
              period=1,
              startTime=0) "Block that outputs trigger signals" annotation (
                Placement(transformation(extent={{-60,-80},{-40,-60}})));
          equation

            connect(sin.y, triMovMea.u) annotation (Line(points={{-38,50},{-20,50},{-20,
                    10},{-2,10}}, color={0,0,127}));
            connect(booPul.y, triMovMea.trigger) annotation (Line(points={{-38,-10},{10,
                    -10},{10,-2}},   color={255,0,255}));
            connect(booPul.y, triMovMea1.trigger) annotation (Line(points={{-38,-10},{-10,
                    -10},{-10,30},{10,30},{10,58}},   color={255,0,255}));
            connect(sin.y, triMovMea1.u) annotation (Line(points={{-38,50},{-20,50},{-20,
                    70},{-2,70}}, color={0,0,127}));
            connect(booPul1.y, triMovMea2.trigger) annotation (Line(points={{-38,-70},{10,
                    -70},{10,-62}},   color={255,0,255}));
            connect(sin.y, triMovMea2.u) annotation (Line(points={{-38,50},{-20,50},{-20,
                    -50},{-2,-50}}, color={0,0,127}));
            annotation (
            experiment(StartTime=-0.5, StopTime=15.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Discrete/Examples/TriggeredMovingMean.mos"
                  "Simulate and plot"),
              Documentation(
              info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Discrete.TriggeredMovingMean\">
Buildings.Controls.OBC.CDL.Discrete.TriggeredMovingMean</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
October 16, 2019 by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end TriggeredMovingMean;

          model TriggeredSampler "Example model for the TriggeredSampler block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=6.2831852) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
              "Block that outputs the sine of the input"
              annotation (Placement(transformation(extent={{-20,-10},{0,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                period=0.2) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-10,-50},{10,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triSam
              "Triggered sampler wity y_start = 0"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triSam1(y_start=1)
              "Triggered sampler with y_start = 1"
              annotation (Placement(transformation(extent={{60,40},{80,60}})));
          equation
            connect(ramp1.y, sin1.u)
              annotation (Line(points={{-39,0},{-22,0}},         color={0,0,127}));
            connect(sin1.y, triSam.u)
              annotation (Line(points={{1,0},{38,0}}, color={0,0,127}));
            connect(booPul.y, triSam.trigger) annotation (Line(points={{11,-40},{50,-40},
                    {50,-12},{50,-11.8}}, color={255,0,255}));
            connect(sin1.y, triSam1.u)
              annotation (Line(points={{1,0},{30,0},{30,50},{58,50}}, color={0,0,127}));
            connect(booPul.y, triSam1.trigger)
              annotation (Line(points={{11,-40},{70,-40},{70,38.2}}, color={255,0,255}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Discrete/Examples/TriggeredSampler.mos"
                  "Simulate and plot"),
              Documentation(
              info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Discrete.TriggeredSampler\">
Buildings.Controls.OBC.CDL.Discrete.TriggeredSampler</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
March 31, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end TriggeredSampler;

          model UnitDelay "Example model for the UnitDelay block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.UnitDelay unitDelay1(
                samplePeriod=0.2) "Sample period of component"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=6.2831852) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
              "Block that outputs the sine of the input" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}})));

          equation
            connect(ramp1.y, sin1.u)
              annotation (Line(points={{-39,0},{-12,0},{-12,0}}, color={0,0,127}));
            connect(sin1.y, unitDelay1.u)
              annotation (Line(points={{11,0},{20,0},{28,0}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Discrete/Examples/UnitDelay.mos"
                  "Simulate and plot"),
              Documentation(
              info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Discrete.UnitDelay\">
Buildings.Controls.OBC.CDL.Discrete.UnitDelay</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
March 31, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end UnitDelay;

          model ZeroOrderHold "Example model for the ZeroOrderHold block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.ZeroOrderHold zerOrdHol(
                samplePeriod=0.2)
              "Output the input signal with a zero order hold"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=0,
              height=6.2831852) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Cos cos1
              "Block that outputs the cosine of the input" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}})));

          equation
            connect(ramp1.y,cos1. u)
              annotation (Line(points={{-39,0},{-12,0},{-12,0}}, color={0,0,127}));
            connect(cos1.y, zerOrdHol.u)
              annotation (Line(points={{11,0},{20,0},{28,0}}, color={0,0,127}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Discrete/Examples/ZeroOrderHold.mos"
                  "Simulate and plot"),
              Documentation(
              info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Discrete.ZeroOrderHold\">
Buildings.Controls.OBC.CDL.Discrete.ZeroOrderHold</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
September 14, 2017, by Michael Wetter:<br/>
Changed example to have non-zero initial conditions.
</li>
<li>
March 31, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end ZeroOrderHold;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Discrete\">
Buildings.Controls.OBC.CDL.Discrete</a>.
</p>
</html>"),  Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={8.0,14.0},
                  lineColor={78,138,73},
                  fillColor={78,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
        end Examples;
        annotation (Documentation(info="<html>
<p>
This package contains discrete control blocks
with fixed sample period.
Every component of this package is structured in the following way:
</p>
<ol>
<li> A component has continuous Real input and output signals.</li>
<li> The input signals are sampled by the given sample period
     defined via parameter <code>samplePeriod</code>.
     The first sample instant is defined by the parameter <code>startTime</code>.
</li>
<li> The output signals are computed from the sampled input signals.
</li>
</ol>

</html>",
      revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Line(points={{-88,0},{-45,0}}, color={95,95,95}),
              Ellipse(
                lineColor={95,95,95},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-45,-10},{-25,10}}),
              Line(points={{-35,0},{24,52}}, color={95,95,95}),
              Ellipse(
                lineColor={95,95,95},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{25,-10},{45,10}}),
              Line(points={{45,0},{82,0}}, color={95,95,95})}));
      end Discrete;

      package Integers "Package with blocks for integer variables"

        block Abs "Output the absolute value of the input"

          Interfaces.IntegerInput u "Connector of Integer input signals"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.IntegerOutput y "Connector of Integer output signals"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = if u >= 0 then u else -u;
          annotation (
            defaultComponentName="absInt",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={             Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                                                Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
                Polygon(
                  points={{92,0},{70,8},{70,-8},{92,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{0,-14},{0,68}}, color={192,192,192}),
                Polygon(
                  points={{0,90},{-8,68},{8,68},{0,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-34,-28},{38,-76}},
                  lineColor={192,192,192},
                  textString="abs"),
                Line(points={{-88,0},{76,0}}, color={192,192,192}),
                Ellipse(
                  extent={{-68,68},{-60,60}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-38,38},{-30,30}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-4,4},{4,-4}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{28,38},{36,30}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{58,68},{66,60}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{-64,-6},{-64,6}},
                                              color={192,192,192}),
                Line(points={{-34,-6},{-34,6}},
                                              color={192,192,192}),
                Line(points={{32,-6},{32,6}}, color={192,192,192}),
                Line(points={{62,-6},{62,6}}, color={192,192,192}),
                Line(points={{-8,64},{8,64}}, color={192,192,192}),
                Line(points={{-8,34},{8,34}}, color={192,192,192})}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = abs(u)</code>,
where
<code>u</code> is an Integer input.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Abs;

        block Add "Output the sum of the two inputs"

          parameter Integer k1=+1 "Gain of upper input";

          parameter Integer k2=+1 "Gain of lower input";

          Interfaces.IntegerInput u1 "Connector of Integer input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.IntegerInput u2 "Connector of Integer input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.IntegerOutput y "Connector of Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = k1*u1 + k2*u2;

        annotation (
        defaultComponentName="addInt",
        Documentation(info="<html>
<p>
Block that outputs <code>y</code> as the weighted <i>sum</i> of the
two Integer input signals <code>u1</code> and <code>u2</code>,
</p>
<pre>
    y = k1*u1 + k2*u2;
</pre>
<p>
where <code>k1</code> and <code>k2</code> are Integer parameters.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                                                    Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),          Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Line(points={{-100,60},{-74,24},{-44,24}}, color={255,127,0}),
                Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={255,127,0}),
                Ellipse(lineColor={255,127,0}, extent={{-50,-50},{50,50}}),
                Line(points={{50,0},{100,0}}, color={255,127, 0}),
                Text(extent={{-40,-20},{36,48}}, textString="+"),
                Text(extent={{-100,52},{5,92}}, textString="%k1"),
                Text(extent={{-100,-92},{5,-52}}, textString="%k2")}));
        end Add;

        block Change
          "Output whether the Integer input changes values, increases or decreases"
          parameter Boolean y_start = false
            "Initial value of y";

          Interfaces.IntegerInput u "Connector of Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));
          Interfaces.BooleanOutput up
            "Connector of Boolean output signal indicating input increase"
            annotation (Placement(transformation(extent={{100,40},{140,80}})));
          Interfaces.BooleanOutput down
            "Connector of Boolean output signal indicating input decrease"
            annotation (Placement(transformation(extent={{100,-80},{140,-40}})));

        protected
          Integer u_start = 0 "Initial value of input";

        initial equation
           pre(y) = y_start;
           pre(u) = u_start;

        equation
          y = change(u);
          up = u > pre(u);
          down = u < pre(u);

        annotation (defaultComponentName="cha",
        Icon(coordinateSystem(preserveAspectRatio=true), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-50,62},{50,-56}},
                  lineColor={255,127,0},
                  textString="change"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
        Documentation(info="<html>
<p>
Block that evaluates the integer input <code>u</code> to check if its value
changes.
</p>
<ul>
<li>
When the input <code>u</code> changes, the output <code>y</code> will be
<code>true</code>, otherwise it will be <code>false</code>.
</li>
<li>
When the input <code>u</code> increases, the output <code>up</code> will be
<code>true</code>, otherwise it will be <code>false</code>.
</li>
<li>
When the input <code>u</code> decreases, the output <code>down</code> will be
<code>true</code>, otherwise it will be <code>false</code>.
</li>
</ul>
</html>",
        revisions="<html>
<ul>
<li>
July 18, 2018, by Michael Wetter:<br/>
Revised model and icon.
</li>
<li>
July 13, 2018, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Change;

        block Equal "Output y is true, if input u1 is equal to input u2"

          Interfaces.IntegerInput u1 "Connector of first Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.IntegerInput u2 "Connector of second Integer input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 == u2;

        annotation (
          defaultComponentName="intEqu",
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{32,10},{52,-10}}, lineColor={255,127,0}),
                Line(points={{-100,-80},{42,-80},{42,0}}, color={255,127,0}),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),    Text(
                  extent={{-76,-36},{20,54}},
                  lineColor={255,127,0},
                  textString="=")}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Integer input <code>u1</code>
is equal to the Integer input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Equal;

        block Greater
          "Output y is true, if input u1 is greater than input u2"

          Interfaces.IntegerInput u1 "Connector of first Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.IntegerInput u2 "Connector of second Integer input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 > u2;

        annotation (
          defaultComponentName="intGre",
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{32,10},{52,-10}}, lineColor={255,127,0}),
                Line(points={{-100,-80},{42,-80},{42,0}}, color={255,127,0}),
                Line(
                  points={{-54,22},{-8,2},{-54,-18}},
                  thickness=0.5,
                  color={255,127,0}),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Integer input <code>u1</code>
is greater than the Integer input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Greater;

        block GreaterEqual
          "Output y is true, if input u1 is greater or equal than input u2"

          Interfaces.IntegerInput u1 "Connector of first Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.IntegerInput u2 "Connector of second Integer input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 >= u2;

        annotation (
          defaultComponentName="intGreEqu",
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{32,10},{52,-10}}, lineColor={255,127,0}),
                Line(points={{-100,-80},{42,-80},{42,0}}, color={255,127,0}),
                Line(
                  points={{-54,22},{-8,2},{-54,-18}},
                  thickness=0.5,
                  color={255,127,0}),
                Line(
                  points={{-52,-36},{-6,-14}},
                  thickness=0.5,
                  color={255,127,0}),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if Integer the input <code>u1</code>
is greater than or equal to the Integer input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end GreaterEqual;

        block GreaterEqualThreshold
          "Output y is true, if input u is greater or equal than threshold"

          parameter Integer threshold=0 "Comparison with respect to threshold";

          Interfaces.IntegerInput u "Connector of Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u >= threshold;

        annotation (
          defaultComponentName="intGreEquThr",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Text(
                  extent={{-150,-140},{150,-110}},
                  lineColor={0,0,0},
                  textString="%threshold"),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(
                  points={{-54,22},{-8,2},{-54,-18}},
                  thickness=0.5,
                  color={255,127,0}),
                Line(
                  points={{-52,-36},{-6,-14}},
                  thickness=0.5,
                  color={255,127,0})}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Integer input is greater than or equal to
the parameter <code>threshold</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end GreaterEqualThreshold;

        block GreaterThreshold
          "Output y is true, if input u is greater than threshold"

          parameter Integer threshold=0 "Comparison with respect to threshold";

          Interfaces.IntegerInput u "Connector of Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u > threshold;

        annotation (
          defaultComponentName="intGreThr",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,-140},{150,-110}},
                  lineColor={0,0,0},
                  textString="%threshold"),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Line(
                  points={{-54,22},{-8,2},{-54,-18}},
                  thickness=0.5,
                  color={255,127,0})}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Integer input is greater than
the parameter <code>threshold</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end GreaterThreshold;

        block Less "Output y is true, if input u1 is less than input u2"

          Interfaces.IntegerInput u1 "Connector of first Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.IntegerInput u2 "Connector of second Integer input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 < u2;
          annotation (
                defaultComponentName="intLes",
                Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{32,10},{52,-10}}, lineColor={255,127,0}),
                Line(points={{-100,-80},{42,-80},{42,0}}, color={255,127,0}),
                Line(
                  points={{-6,18},{-50,-2},{-6,-20}},
                  thickness=0.5,
                  color={255,127,0}),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Integer input <code>u1</code>
is less than the Integer input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Less;

        block LessEqual
          "Output y is true, if input u1 is less or equal than input u2"

          Interfaces.IntegerInput u1 "Connector of first Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.IntegerInput u2 "Connector of second Integer input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 <= u2;

        annotation (
          defaultComponentName="intLesEqu",
                Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(extent={{32,10},{52,-10}}, lineColor={255,127,0}),
                Line(points={{-100,-80},{42,-80},{42,0}}, color={255,127,0}),
                Line(
                  points={{-10,20},{-54,0},{-10,-18}},
                  thickness=0.5,
                  color={255,127,0}),
                Line(
                  points={{-54,-18},{-14,-34}},
                  thickness=0.5,
                  color={255,127,0}),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Integer input <code>u1</code>
is less than or equal to the Integer input <code>u2</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end LessEqual;

        block LessEqualThreshold
          "Output y is true, if input u is less or equal than threshold"

          parameter Integer threshold=0 "Comparison with respect to threshold";

          Interfaces.IntegerInput u "Connector of Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u <= threshold;

        annotation (
          defaultComponentName="intLesEquThr",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,-140},{150,-110}},
                  lineColor={0,0,0},
                  textString="%threshold"),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Line(
                  points={{-54,-18},{-14,-34}},
                  thickness=0.5,
                  color={255,127,0}),
                Line(
                  points={{-10,20},{-54,0},{-10,-18}},
                  thickness=0.5,
                  color={255,127,0})}),
         Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Integer input is less than or equal to
the parameter <code>threshold</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end LessEqualThreshold;

        block LessThreshold
          "Output y is true, if input u is less than threshold"

          parameter Integer threshold=0 "Comparison with respect to threshold";

          Interfaces.IntegerInput u "Connector of Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u < threshold;
          annotation (
                defaultComponentName="intLesThr",
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,-140},{150,-110}},
                  lineColor={0,0,0},
                  textString="%threshold"),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Line(
                  points={{-10,20},{-54,0},{-10,-18}},
                  thickness=0.5,
                  color={255,127,0})}),
        Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Integer input is less than
the parameter <code>threshold</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end LessThreshold;

        block Max "Pass through the largest signal"

          Interfaces.IntegerInput u1 "Connector of Integer input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.IntegerInput u2 "Connector of Integer input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.IntegerOutput y "Connector of Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = max(u1, u2);

        annotation (
        defaultComponentName="maxInt",
        Documentation(info="<html>
<p>
Block that outputs <code>y = max(u1, u2)</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 9, 2017, by Milica Grahovac:<br/>
First integer implementation, based on the implementation of the
Modelica Standard Library.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                graphics={                         Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="max()")}));
        end Max;

        block Min "Pass through the smallest signal"

          Interfaces.IntegerInput u1 "Connector of Integer input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.IntegerInput u2 "Connector of Integer input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.IntegerOutput y "Connector of Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = min(u1, u2);

        annotation (
        defaultComponentName="minInt",
        Documentation(info="<html>
<p>
Block that outputs <code>y = min(u1, u2)</code>,
where
<code>u1</code> and <code>u2</code> are inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 9, 2017, by Milica Grahovac:<br/>
First integer implementation, based on the implementation of the
Modelica Standard Library.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                graphics={                         Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Text(
                    extent={{-90,36},{90,-36}},
                    lineColor={160,160,164},
                    textString="min()")}));
        end Min;

        block MultiSum
          "Sum of Reals, y = k[1]*u[1] + k[2]*u[2] + ... + k[n]*u[n]"

          parameter Integer nin(min=0) = 0 "Number of input connections"
            annotation (Dialog(connectorSizing=true), HideResult=true);
          parameter Integer k[nin]=fill(1, nin) "Input gains";
          Interfaces.IntegerInput u[nin] "Connector of Integer input signals"
            annotation (Placement(transformation(extent={{-140,70},{-100,-70}})));
          Interfaces.IntegerOutput y "Connector of Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          if size(u, 1) > 0 then
            y = k*u;
          else
            y = 0;
          end if;

          annotation (
          defaultComponentName="mulSumInt",
          Icon(graphics={   Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={255,127,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                                     Text(
                  extent={{-200,-110},{200,-140}},
                  lineColor={0,0,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid,
                  textString="%k"), Text(
                  extent={{-82,84},{82,-52}},
                  lineColor={255,127,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid,
                  textString="+"),
                Text(
                  extent={{-144,150},{156,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
Block that outputs
</p>
<p align=\"center\" style=\"font-style:italic;\">
y = &sum;<sub>i=1</sub><sup>n</sup> k<sub>i</sub> &nbsp; u<sub>i</sub>,
</p>
<p>
where <i>k</i> is a parameter with <i>n</i> elements and <i>u</i> is
an input of the same length.
The dimension of <i>u</i> can be enlarged by
drawing an additional connection line. The connection is automatically connected
to this new free index.
</p>

<p>
If no connection to the input connector <i>u</i> is present,
the output is <i>y=0</i>.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Validation.MultiSum\">
Buildings.Controls.OBC.CDL.Integers.Validation.MultiSum</a>
for an example.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the Modelica Standard
Library. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/933\">issue 933</a>.
</li>
</ul>
</html>"));
        end MultiSum;

        block OnCounter "Increment the output if the input switches to true"

          parameter Integer y_start = 0
            "Initial and reset value of y if input reset switches to true";

          Interfaces.BooleanInput trigger "Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanInput reset "Reset the counter" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120})));

          Interfaces.IntegerOutput y "Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        initial equation
          pre(y) = y_start;

        equation
          when {trigger, reset} then
             y = if reset then y_start else pre(y) + 1;
          end when;

          annotation (
            defaultComponentName="onCouInt",
            Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}},
                initialScale=0.06), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                  Text(
                    visible=use_reset,
                    extent={{-64,-62},{58,-86}},
                    lineColor={0,0,0},
                    textString="reset"),        Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
Block that outputs how often the <code>trigger</code> input changed to <code>true</code>
since the last invocation of <code>reset</code>.
</p>
<p>
This block may be used as a counter. Its output <code>y</code> starts
at the parameter value <code>y_start</code>.
Whenever the input signal <code>trigger</code> changes to <code>true</code>,
the output is incremented by <i>1</i>.
When the input <code>reset</code> changes to <code>true</code>,
then the output is reset to <code>y = y_start</code>.
If both inputs <code>trigger</code> and <code>reset</code> change
simultaneously, then the ouput is <code>y = y_start</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end OnCounter;

        block Product "Output product of the two inputs"

          Interfaces.IntegerInput u1 "Connector of Integer input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Interfaces.IntegerInput u2 "Connector of Integer input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Interfaces.IntegerOutput y "Connector of Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 * u2;

        annotation (
        defaultComponentName="proInt",
        Documentation(info="<html>
<p>
Block that outputs <code>y = u1 * u2</code>,
where
<code>u1</code> and <code>u2</code> are Integer inputs.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                                                   Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Line(points={{-100,60},{-40,60},{-30,40}}, color={255,127,0}),
                Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={255,127,0}),
                Line(points={{50,0},{100,0}}, color={255,127,0}),
                Line(points={{-30,0},{30,0}}),
                Line(points={{-15,25.99},{15,-25.99}}),
                Line(points={{-15,-25.99},{15,25.99}}),
                Ellipse(lineColor={255,127,0}, extent={{-50,-50},{50,50}}),
                                                Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}));
        end Product;

        package Sources "Package with blocks that generate source signals"

          block Constant "Output constant signal of type Integer"
            parameter Integer k "Constant output value";

            Interfaces.IntegerOutput y "Connector of Integer output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y = k;
            annotation (
              defaultComponentName="conInt",
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics={          Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),              Rectangle(
                      extent={{-100,-100},{100,100}},
                      lineColor={255,127,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                  Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
                  Polygon(
                    points={{-80,90},{-88,68},{-72,68},{-80,90}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
                  Polygon(
                    points={{90,-70},{68,-62},{68,-78},{90,-70}},
                    lineColor={192,192,192},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,0},{80,0}}),
                  Text(
                    extent={{-150,-150},{150,-110}},
                    lineColor={0,0,0},
                    textString="k=%k")}),
              Documentation(info="<html>
<p>
Block that outputs a constant signal <code>y = k</code>,
where <code>k</code> is an Integer-valued parameter.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Integers/Sources/Constant.png\"
     alt=\"IntegerConstant.png\" />
</p>
</html>"));
          end Constant;

          package Validation "Collection of models that validate the logical sources blocks of the CDL"

            model Constant "Validate the Constant block"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant con(k=5)
                "Block output integer constant value" annotation (Placement(
                    transformation(extent={{-10,-10},{10,10}})));
              annotation (
              experiment(StopTime=1.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Sources/Validation/Constant.mos"
                    "Simulate and plot"),
                Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Sources.Constant\">
Buildings.Controls.OBC.CDL.Integers.Sources.Constant</a>.
</p>

</html>",             revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent={{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points={{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end Constant;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Sources\">
Buildings.Controls.OBC.CDL.Integers.Sources</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),  Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100,-100},{100,100}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100,-100},{100,100}},
                    radius=25.0),
                  Polygon(
                    origin={8,14},
                    lineColor={78,138,73},
                    fillColor={78,138,73},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
          end Validation;
        annotation (
        Documentation(
        info="<html>
<p>
Package with blocks that generate signals.
</p>
</html>"),         Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100,-100},{100,100}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100,-100},{100,100}},
                  radius=25.0),
                Polygon(origin={23.3333,0},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
                Rectangle(
                  fillColor = {128,128,128},
                  pattern = LinePattern.None,
                  fillPattern = FillPattern.Solid,
                  extent={{-70,-4.5},{0,4.5}})}));
        end Sources;

        package Validation "Collection of models that validate the integer blocks of the CDL"

          model Abs "Validation model for the absolute block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Abs abs1
              "Block that outputs the absolute value of the input"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=7.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-10},{-60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
            connect(reaToInt.y, abs1.u)
              annotation (Line(points={{21,0},{38,0}}, color={255,127,0}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/Abs.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Abs\">
Buildings.Controls.OBC.CDL.Integers.Abs</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Abs;

          model Add "Validation model for the Add block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Add add1
              "Block that outputs the sum of the two inputs"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=7.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,10},{-60,30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-0.5,
              height=7.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-30},{-60,-10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,10},{-20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,10},{20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-30},{-20,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,20},{-42,20}}, color={0,0,127}));
            connect(ramp2.y, round2.u)
              annotation (Line(points={{-59,-20},{-42,-20}}, color={0,0,127}));
            connect(round2.y, reaToInt1.u)
              annotation (Line(points={{-19,-20},{-2,-20}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,20},{-2,20}}, color={0,0,127}));
            connect(reaToInt.y, add1.u1)
              annotation (Line(points={{21,20},{40,20},{40,6},{58,6}},
                color={255,127,0}));
            connect(reaToInt1.y, add1.u2)
              annotation (Line(points={{21,-20},{40,-20},{40,-6},{58,-6}},
                color={255,127,0}));
            annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/Add.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Add\">
Buildings.Controls.OBC.CDL.Integers.Add</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Add;

          model Change "Validation model for the Change block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Change cha
              "Check if the integer input changes value"
              annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              offset=0,
              height=20,
              duration=1) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-40,20},{-20,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler changeSampler
              "Triggered sampler"
              annotation (Placement(transformation(extent={{60,20},{80,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer" annotation (Placement(transformation(
                    extent={{-40,-50},{-20,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
              timTabLin(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                table=[0,-1; 0.3,0.5; 0.5,0; 0.7,1; 1,0])
              "Time table with smoothness method of constant segments"
              annotation (Placement(transformation(extent={{-80,-50},{-60,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler increaseSampler
              "Increase sampler"
              annotation (Placement(transformation(extent={{60,60},{80,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler decreaseSampler
              "Decrease sampler"
              annotation (Placement(transformation(extent={{60,-20},{80,0}})));

          equation
            connect(ramp2.y, changeSampler.u)
              annotation (Line(points={{-18,30},{58,30}}, color={0,0,127}));
            connect(timTabLin.y[1], reaToInt.u)
              annotation (Line(points={{-58,-40},{-42,-40}}, color={0,0,127}));
            connect(reaToInt.y, cha.u)
              annotation (Line(points={{-18,-40},{-2,-40}}, color={255,127,0}));
            connect(ramp2.y, increaseSampler.u)
              annotation (Line(points={{-18,30},{40,30},{40,70},{58,70}},
                color={0,0,127}));
            connect(ramp2.y, decreaseSampler.u)
              annotation (Line(points={{-18,30},{40,30},{40,-10},{58,-10}},
                color={0,0,127}));
            connect(cha.up, increaseSampler.trigger)
              annotation (Line(points={{22,-34},{30,-34},{30,52},{70,52},{70,58.2}},
                color={255,0,255}));
            connect(cha.y, changeSampler.trigger)
              annotation (Line(points={{22,-40},{46,-40},{46,12},{70,12},{70,18.2}},
                color={255,0,255}));
            connect(cha.down, decreaseSampler.trigger)
              annotation (Line(points={{22,-46},{70,-46},{70,-21.8}}, color={255,0,255}));

          annotation (
          experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/Change.mos"
                  "Simulate and plot"),
          Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Change\">
Buildings.Controls.OBC.CDL.Integers.Change</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 13, 2018, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
          Diagram(coordinateSystem(preserveAspectRatio=false)));
          end Change;

          model Equal "Validation model for the Equal block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Equal intEqu
              "Block output true if input 1 is equal to input 2"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{-20,10},{0,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer" annotation (Placement(transformation(
                    extent={{-20,-30},{0,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
              timTabLin(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                table=[0,0; 0.3,1; 0.5,0; 0.7,1; 1,0])
              "Time table with smoothness method of constant segments"
              annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
              timTabLin1(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                table=[0,0; 0.35,1; 0.55,0; 0.7,1; 1,0])
              "Time table with smoothness method of constant segments"
              annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
          equation
            connect(reaToInt.y, intEqu.u1)
              annotation (Line(points={{1,20},{40,20},{40,0},{58,0}},
                color={255,127,0}));
            connect(reaToInt1.y, intEqu.u2)
              annotation (Line(points={{1,-20},{40,-20},{40,-8},{58,-8}},
                color={255,127,0}));
            connect(timTabLin.y[1], reaToInt.u)
              annotation (Line(points={{-59,20},{-22,20}}, color={0,0,127}));
            connect(timTabLin1.y[1], reaToInt1.u)
              annotation (Line(points={{-59,-20},{-22,-20}}, color={0,0,127}));
          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/Equal.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Equal\">
Buildings.Controls.OBC.CDL.Integers.Equal</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 26, 2017, by Thierry S. Nouidui:<br/>
Revised implementation for JModelica verification.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/939\">issue 939</a>.
</li>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Equal;

          model Greater "Validation model for the Greater block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=10.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,10},{-60,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1.5,
              height=5.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-30},{-60,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Greater intGre
              "Block output true if input 1 is greater than input 2"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,10},{-20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,10},{20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-30},{-20,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,20},{-42,20}}, color={0,0,127}));
            connect(ramp2.y, round2.u)
              annotation (Line(points={{-59,-20},{-42,-20}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,20},{-2,20}}, color={0,0,127}));
            connect(round2.y, reaToInt1.u)
              annotation (Line(points={{-19,-20},{-2,-20}}, color={0,0,127}));
            connect(reaToInt.y, intGre.u1)
              annotation (Line(points={{21,20},{40,20},{40,0},{58,0}},
                color={255,127,0}));
            connect(reaToInt1.y, intGre.u2)
              annotation (Line(points={{21,-20},{40,-20},{40,-8},{58,-8}},
                color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/Greater.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Greater\">
Buildings.Controls.OBC.CDL.Integers.Greater</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Greater;

          model GreaterEqual "Validation model for the GreaterEqual block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterEqual intGreEqu
              "Block output true if input 1 is greater or equal to input 2"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{-20,10},{0,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer" annotation (Placement(transformation(
                    extent={{-20,-30},{0,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
              timTabLin(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                table=[0,-1; 0.3,0.5; 0.5,0; 0.7,1; 1,0])
              "Time table with smoothness method of constant segments"
              annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
              timTabLin1(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                table=[0,0; 0.35,1; 0.55,0; 0.7,1; 1,0])
              "Time table with smoothness method of constant segments"
              annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
          equation
            connect(reaToInt.y, intGreEqu.u1)
              annotation (Line(points={{1,20},{40,20},{40,0},{58,0}},  color={255,127,0}));
            connect(reaToInt1.y, intGreEqu.u2)
              annotation (Line(points={{1,-20},{40,-20},{40,-8},{58,-8}},
                color={255,127,0}));
            connect(timTabLin.y[1], reaToInt.u)
              annotation (Line(points={{-59,20},{-22,20}}, color={0,0,127}));
            connect(timTabLin1.y[1], reaToInt1.u)
              annotation (Line(points={{-59,-20},{-22,-20}}, color={0,0,127}));
          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/GreaterEqual.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.GreaterEqual\">
Buildings.Controls.OBC.CDL.Integers.GreaterEqual</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 26, 2017, by Thierry S. Nouidui:<br/>
Revised implementation for JModelica verification.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/939\">issue 939</a>.
</li>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end GreaterEqual;

          model GreaterEqualThreshold  "Validation model for the GreaterEqualThreshold block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=10.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-10},{-60,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterEqualThreshold
              intGreEquThr(threshold=2)
              "Block output true if input is greater or equal to threshold value"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
            connect(reaToInt.y, intGreEquThr.u)
              annotation (Line(points={{21,0},{38,0}}, color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/GreaterEqualThreshold.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.GreaterEqualThreshold\">
Buildings.Controls.OBC.CDL.Integers.GreaterEqualThreshold</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end GreaterEqualThreshold;

          model GreaterThreshold "Validation model for the GreaterThreshold block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=10.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-10},{-60,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.GreaterThreshold intGreThr(threshold
                =2)
              "Block output true if input is greater than threshold value"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,0},{-50,0},{-50,0},{-42,0}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,0},{-12,0},{-12,0},{-2,0}}, color={0,0,127}));
            connect(reaToInt.y, intGreThr.u)
              annotation (Line(points={{21,0},{38,0}}, color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/GreaterThreshold.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.GreaterThreshold\">
Buildings.Controls.OBC.CDL.Integers.GreaterThreshold</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end GreaterThreshold;

          model Less "Validation model for the Less block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Less intLes
              "Block output true if input 1 is less than input 2"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{-20,10},{0,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer" annotation (Placement(transformation(
                    extent={{-20,-30},{0,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
              timTabLin(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                table=[0,-1; 0.3,0.5; 0.5,0; 0.7,1; 1,0])
              "Time table with smoothness method of constant segments"
              annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
              timTabLin1(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                table=[0,0; 0.35,1; 0.55,0; 0.7,1; 1,0])
              "Time table with smoothness method of constant segments"
              annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
          equation
            connect(reaToInt1.y, intLes.u2)
              annotation (Line(points={{1,-20},{40,-20},{40,-8},{58,-8}},
                color={255,127,0}));
            connect(reaToInt.y, intLes.u1)
              annotation (Line(points={{1,20},{40,20},{40,0},{58,0}},
                color={255,127,0}));
            connect(timTabLin.y[1], reaToInt.u)
              annotation (Line(points={{-59,20},{-22,20}}, color={0,0,127}));
            connect(timTabLin1.y[1], reaToInt1.u)
              annotation (Line(points={{-59,-20},{-22,-20}}, color={0,0,127}));
          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/Less.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Less\">
Buildings.Controls.OBC.CDL.Integers.Less</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 26, 2017, by Thierry S. Nouidui:<br/>
Revised implementation for JModelica verification.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/939\">issue 939</a>.
</li>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Less;

          model LessEqual "Validation model for the LessEqual block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=10.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,10},{-60,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1.5,
              height=5.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-30},{-60,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.LessEqual intLesEqu
              "Block output true if input 1 is less or equal to input 2"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,10},{-20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,10},{20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-30},{-20,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,20},{-42,20}}, color={0,0,127}));
            connect(ramp2.y, round2.u)
              annotation (Line(points={{-59,-20},{-42,-20}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,20},{-2,20}}, color={0,0,127}));
            connect(round2.y, reaToInt1.u)
              annotation (Line(points={{-19,-20},{-2,-20}}, color={0,0,127}));
            connect(reaToInt1.y, intLesEqu.u2)
              annotation (Line(points={{21,-20},{40,-20},{40,-8},{58,-8}},
                color={255,127,0}));
            connect(reaToInt.y, intLesEqu.u1)
              annotation (Line(points={{21,20},{40,20},{40,0},{58,0}},
                color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/LessEqual.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.LessEqual\">
Buildings.Controls.OBC.CDL.Integers.LessEqual</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end LessEqual;

          model LessEqualThreshold  "Validation model for the LessEqualThreshold block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=10.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-10},{-60,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.LessEqualThreshold intLesEquThr(threshold
                =2)
              "Block output true if input is less or equal to threshold value"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
            connect(reaToInt.y, intLesEquThr.u)
              annotation (Line(points={{21,0},{38,0}}, color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/LessEqualThreshold.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.LessEqualThreshold\">
Buildings.Controls.OBC.CDL.Integers.LessEqualThreshold</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end LessEqualThreshold;

          model LessThreshold "Validation model for the LessThreshold block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=10.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-10},{-60,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.LessThreshold intLesThr(threshold
                =2) "Block output true if input is less than threshold value"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
            connect(reaToInt.y, intLesThr.u)
              annotation (Line(points={{21,0},{38,0}}, color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/LessThreshold.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.LessThreshold\">
Buildings.Controls.OBC.CDL.Integers.LessThreshold</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end LessThreshold;

          model Max "Validation model for the Max block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Max max1
              "Block that outputs the largest inputs"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=10.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,10},{-60,30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1.5,
              height=5.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-30},{-60,-10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,10},{-20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,10},{20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-30},{-20,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,20},{-42,20}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,20},{-2,20}}, color={0,0,127}));
            connect(ramp2.y, round2.u)
              annotation (Line(points={{-59,-20},{-42,-20}}, color={0,0,127}));
            connect(round2.y, reaToInt1.u)
              annotation (Line(points={{-19,-20},{-2,-20}}, color={0,0,127}));
            connect(reaToInt1.y, max1.u2)
              annotation (Line(points={{21,-20},{40,-20},{40,-6},{58,-6}},
                color={255,127,0}));
            connect(reaToInt.y, max1.u1)
              annotation (Line(points={{21,20},{40,20},{40,6},{58,6}},
                color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/Max.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Max\">
Buildings.Controls.OBC.CDL.Integers.Max</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Max;

          model Min "Validation model for the Min block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Min min1
              "Block that outputs the smallest inputs"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=10.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,10},{-60,30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-1.5,
              height=5.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-30},{-60,-10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,10},{-20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,10},{20,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-30},{-20,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,20},{-42,20}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,20},{-2,20}}, color={0,0,127}));
            connect(reaToInt.y, min1.u1)
              annotation (Line(points={{21,20},{40,20},{40,6},{58,6}},
                color={255,127,0}));
            connect(ramp2.y, round2.u)
              annotation (Line(points={{-59,-20},{-42,-20}}, color={0,0,127}));
            connect(round2.y, reaToInt1.u)
              annotation (Line(points={{-19,-20},{-2,-20}}, color={0,0,127}));
            connect(reaToInt1.y, min1.u2)
              annotation (Line(points={{21,-20},{40,-20},{40,-6},{58,-6}},
                color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/Min.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Min\">
Buildings.Controls.OBC.CDL.Integers.Min</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Min;

          model MultiSum  "Validation model for the block to find sum of multiple inputs"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.MultiSum add1(nin=3)
              "Block that outputs the sum of the inputs"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=1,
              offset=-3.5,
              height=7.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,30},{-60,50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=1,
              offset=-0.5,
              height=7.0) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-10},{-60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp3(
              duration=1,
              height=7.0,
              offset=-1.5) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-80,-50},{-60,-30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round1(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,30},{-20,50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,30},{20,50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round2(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Round round3(n=0)
              "Round real number to given digits" annotation (Placement(
                  transformation(extent={{-40,-50},{-20,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt2
              "Convert real to integer"
              annotation (Placement(transformation(extent={{0,-50},{20,-30}})));

          equation
            connect(ramp1.y, round1.u)
              annotation (Line(points={{-59,40},{-42,40}}, color={0,0,127}));
            connect(ramp2.y, round2.u)
              annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
            connect(ramp3.y, round3.u)
              annotation (Line(points={{-59,-40},{-42,-40}}, color={0,0,127}));
            connect(round3.y, reaToInt2.u)
              annotation (Line(points={{-19,-40},{-2,-40}}, color={0,0,127}));
            connect(round2.y, reaToInt1.u)
              annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
            connect(round1.y, reaToInt.u)
              annotation (Line(points={{-19,40},{-2,40}}, color={0,0,127}));
            connect(reaToInt.y, add1.u[1])
              annotation (Line(points={{21,40},{40,40},{40,4.66667},{58,4.66667}},
                color={255,127,0}));
            connect(reaToInt1.y, add1.u[2])
              annotation (Line(points={{21,0},{38,0},{38,0},{58,0}}, color={255,127,0}));
            connect(reaToInt2.y, add1.u[3])
              annotation (Line(points={{21,-40},{40,-40},{40,-4.66667},{58,-4.66667}},
                color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/MultiSum.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.MultiSum\">
Buildings.Controls.OBC.CDL.Integers.MultiSum</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 14, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MultiSum;

          model OnCounter "Validation model for the OnCounter block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.OnCounter onCounter
              "Block that outputs increment if the input switches to true"
              annotation (Placement(transformation(extent={{16,-10},{36,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                period=0.1) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-10},{-6,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse reset(width=0.5,
                period=1.0) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-50},{-6,-30}})));

          equation
            connect(reset.y, onCounter.reset) annotation (Line(points={{-5,-40},{26,-40},{
                    26,-14},{26,-14},{26,-12},{26,-12}},
                                        color={255,0,255}));
            connect(booPul.y, onCounter.trigger)
              annotation (Line(points={{-5,0},{12,0},{12,0}},color={255,0,255}));
            annotation (
            experiment(StopTime=2.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/OnCounter.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.OnCounter\">
Buildings.Controls.OBC.CDL.Integers.OnCounter</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end OnCounter;

          model Product "Validation model for the Product block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Product product
              "Block that outputs the sum of the two inputs"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt1
              "Convert real to integer"
              annotation (Placement(transformation(extent={{-20,10},{0,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt2
              "Convert real to integer" annotation (Placement(transformation(
                    extent={{-20,-30},{0,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
              timTabLin(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                table=[0,-1; 0.3,0.5; 0.5,0; 0.7,1; 1,0])
              "Time table with smoothness method of constant segments"
              annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.TimeTable
              timTabLin1(smoothness=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.Smoothness.ConstantSegments,
                table=[0,0; 0.35,1; 0.55,0; 0.7,1; 1,0])
              "Time table with smoothness method of constant segments"
              annotation (Placement(transformation(extent={{-80,-30},{-60,-10}})));
          equation
            connect(reaToInt1.y, product.u1)
              annotation (Line(points={{1,20},{40,20},{40,6},{58,6}},
                color={255,127,0}));
            connect(reaToInt2.y, product.u2)
              annotation (Line(points={{1,-20},{40,-20},{40,-6},{58,-6}},
                color={255,127,0}));
            connect(timTabLin.y[1], reaToInt1.u)
              annotation (Line(points={{-59,20},{-22,20}}, color={0,0,127}));
            connect(timTabLin1.y[1], reaToInt2.u)
              annotation (Line(points={{-59,-20},{-22,-20}}, color={0,0,127}));
          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Integers/Validation/Product.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers.Product\">
Buildings.Controls.OBC.CDL.Integers.Product</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 26, 2017, by Thierry S. Nouidui:<br/>
Revised implementation for JModelica verification.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/939\">issue 939</a>.
</li>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Product;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Integers\">
Buildings.Controls.OBC.CDL.Integers</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),  Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100,-100},{100,100}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100,-100},{100,100}},
                  radius=25.0),
                Polygon(
                  origin={8,14},
                  lineColor={78,138,73},
                  fillColor={78,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
        end Validation;
      annotation (
      Documentation(
      info="<html>
<p>
Package with blocks for elementary mathematical functions
for integer variables.
</p>
</html>",
      revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
                     Text(
              extent={{-56,90},{48,-88}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid,
              textString="Z")}));
      end Integers;

      package Logical "Package with logical blocks"

        block And "Logical 'and': y = u1 and u2"

          Interfaces.BooleanInput u1 "Connector of first Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanInput u2
            "Connector of second Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 and u2;

          annotation (
            defaultComponentName="and2",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={           Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                      Text(
                  extent={{-90,40},{90,-40}},
                  lineColor={0,0,0},
                  textString="and"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-6},{-89,8}},
                  lineColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-73},{-89,-87}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
Block that outputs <code>true</code> if all inputs are <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end And;

        block And3 "Logical 'and3': y = u1 and u2 and u3"

          Interfaces.BooleanInput u1 "Connector of first Boolean input signal"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Interfaces.BooleanInput u2
            "Connector of second Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanInput u3
            "Connector of second Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 and u2 and u3;

          annotation (
            defaultComponentName="and3",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={           Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                      Text(
                  extent={{-90,40},{90,-40}},
                  lineColor={0,0,0},
                  textString="and"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-6},{-89,8}},
                  lineColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-73},{-89,-87}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
Block that outputs <code>true</code> if all inputs are <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 10, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end And3;

        block Change
          "Output y is true, if the input u has a rising or falling edge (y = change(u))"

          parameter Boolean pre_u_start=false "Start value of pre(u) at initial time";

          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        initial equation
          pre(u) = pre_u_start;
        equation
          y = change(u);
          annotation (
            defaultComponentName="cha",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                      Text(
                  extent={{-50,62},{50,-56}},
                  lineColor={0,0,0},
                  textString="change"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Boolean input has either a rising edge
from <code>false</code> to <code>true</code> or a falling edge from
<code>true</code> to <code>false</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Change;

        block Edge "Output y is true, if the input u has a rising edge (y = edge(u))"

          parameter Boolean pre_u_start=false "Start value of pre(u) at initial time";

          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        initial equation
          pre(u) = pre_u_start;

        equation
          y = edge(u);
          annotation (
            defaultComponentName="edg",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                      Text(
                  extent={{-50,52},{50,-46}},
                  lineColor={0,0,0},
                  textString="edge"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Polygon(points={{-120,140},{-120,140}}, lineColor={28,108,200}),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the Boolean input has a rising edge
from <code>false</code> to <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Edge;

        block FallingEdge
          "Output y is true, if the input u has a falling edge (y = edge(not u))"

          parameter Boolean pre_u_start=false "Start value of pre(u) at initial time";

          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          Boolean not_u=not u "Boolean not of the input";

        initial equation
          pre(not_u) = not pre_u_start;

        equation
          y = edge(not_u);
          annotation (
                defaultComponentName="falEdg",
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                           Text(
                  extent={{-62,64},{56,-54}},
                  lineColor={0,0,0},
                  textString="falling"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}),   Documentation(info="<html>
<p>
Block that outputs  <code>true</code> if the Boolean input has a falling edge
from <code>true</code> to <code>false</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end FallingEdge;

        block IntegerSwitch "Switch between two integer signals"

          Interfaces.IntegerInput u1
            "Integer input signal"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Interfaces.BooleanInput u2
            "Boolean switch input signal, if true, y=u1, else y=u3"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.IntegerInput u3
            "Integer input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.IntegerOutput y
          "Integer output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = if u2 then u1 else u3;

          annotation (
        defaultComponentName="intSwi",
        Documentation(info="<html>
<p>
Block that outputs one of two integer input signals based on a boolean input signal.
</p>
<p>
If the input signal <code>u2</code> is <code>true</code>,
the block outputs <code>y = u1</code>.
Otherwise, it outputs <code>y = u3</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 10, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                  graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Line(
                  points={{12,0},{100,0}},
                  color={244,125,35}),
                Line(
                  points={{-100,0},{-40,0}},
                  color={255,0,255}),
                Line(
                  points={{-100,-80},{-40,-80},{-40,-80}},
                  color={244,125,35}),
                Line(points={{-40,12},{-40,-10}}, color={255,0,255}),
                Line(points={{-100,80},{-40,80}}, color={244,125,35}),
                Line(
                  points={{-40,80},{8,2}},
                  color={244,125,35},
                  thickness=1),
                Ellipse(lineColor={0,0,127},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{2.0,-6.0},{18.0,8.0}}),
                Ellipse(
                  extent={{-71,7},{-85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}));
        end IntegerSwitch;

        block Latch "Maintains a true signal until change condition"

          parameter Boolean pre_y_start=false "Start value of pre(y) if clr=false";

          Interfaces.BooleanInput u "Latch input"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanInput clr "Clear input"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Interfaces.BooleanOutput y "Output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        initial equation
          pre(y) = pre_y_start;
          pre(u) = false;
          pre(clr) = false;

        equation
          when initial() then
            //scenario = 1;
            y = if clr then false else pre_y_start;
          elsewhen (not clr) and change(u) and (pre(u) == false) then
            //scenario = 2;
            y = not clr;
          elsewhen (not clr) and change(u) and (pre(u) == true) then
             //scenario = 3;
            y = if clr then false else pre(y);
          elsewhen change(clr) and (pre(clr) == true) and (not u) then
            //scenario = 4;
            y = false;
          elsewhen clr then
            //scenario = 5;
            y = false;
          end when;

        annotation (defaultComponentName="lat",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{-73,9},{-87,-5}},
                  lineColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{81,7},{95,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-73,-53},{-87,-67}},
                  lineColor=DynamicSelect({235,235,235}, if u0 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u0 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Line(points={{-68,-62},{4,-62},{4,-22},{74,-22}}, color={255,0,255}),
                Line(points={{-68,24},{-48,24},{-48,56},{-16,56},{-16,24},{24,24},{24,56},
                      {54,56},{54,24},{74,24}}, color={255,0,255}),
                Text(
                  extent={{-14,-8},{14,-18}},
                  lineColor={0,0,0},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  textString="Clear"),
                Text(
                  extent={{-16,72},{24,58}},
                  lineColor={0,0,0},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  textString="Latch input"),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),Documentation(info="<html>
<p>
Block that generates a <code>true</code> output when the latch input <code>u</code> 
rises from <code>false</code> to <code>true</code>, provided that the clear input 
<code>clr</code> is <code>false</code> or also became at the same time <code>false</code>.
The output remains <code>true</code> until the clear input <code>clr</code> rises 
from <code>false</code> to <code>true</code>.
</p>
<p>
If the clear input <code>clr</code> is <code>true</code>, the output <code>y</code>
switches to <code>false</code> (if it was <code>true</code>) and it remains <code>false</code>,
regardless of the value of the latch input <code>u</code>.
</p>
<p>
At initial time, if <code>clr = false</code>, then the output will be 
<code>y = pre_y_start</code>. Otherwise it will be <code>y=false</code> 
(because the clear input <code>clr</code> is <code>true</code>).
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/Latch.png\"
     alt=\"Latch.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 9, 2020, by Michael Wetter:<br/>
Simplified implementation, and made model work with OpenModelica.
</li>
<li>
April 4, 2019, by Jianjun Hu:<br/>
Corrected implementation that causes wrong output at initial stage. 
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1402\">issue 1402</a>.
</li>
<li>
December 1, 2017, by Michael Wetter:<br/>
Revised documentation.
</li>
<li>
March 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Latch;

        block LogicalSwitch "Switch between two boolean signals"

          Interfaces.BooleanInput u1
            "Boolean input signal"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Interfaces.BooleanInput u2
            "Boolean switch input signal, if true, y=u1, else y=u3"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanInput u3
            "Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y
            "Booelan output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = if u2 then u1 else u3;

          annotation (
        defaultComponentName="logSwi",
        Documentation(info="<html>
<p>
Block that outputs one of two boolean input signals based on a boolean input signal.
</p>
<p>
If the input signal <code>u2</code> is <code>true</code>,
the block outputs <code>y = u1</code>.
Otherwise, it outputs <code>y = u3</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),       Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                  graphics={                     Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Line(
                  points={{12,0},{100,0}},
                  color={255,0,255}),
                Line(
                  points={{-100,0},{-40,0}},
                  color={255,0,255}),
                Line(
                  points={{-100,-80},{-40,-80},{-40,-80}},
                  color={255,0,255}),
                Line(points={{-40,12},{-40,-10}}, color={255,0,255}),
                Line(points={{-100,80},{-40,80}}, color={255,0,255}),
                Line(
                  points={{-40,80},{8,2}},
                  color={255,0,255},
                  thickness=1),
                Ellipse(lineColor={0,0,127},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{2.0,-6.0},{18.0,8.0}}),
                Ellipse(
                  extent={{-71,7},{-85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-71,74},{-85,88}},
                  lineColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-71,-74},{-85,-88}},
                  lineColor=DynamicSelect({235,235,235}, if u3 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u3 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}));
        end LogicalSwitch;

        block MultiAnd
          "Logical MultiAnd, y = u[1] and u[2] and u[3] and ..."

          parameter Integer nu(min=0) = 0 "Number of input connections"
            annotation (Dialog(connectorSizing=true), HideResult=true);

          Interfaces.BooleanInput u[nu] "Connector of Boolean input signals"
            annotation (Placement(transformation(extent={{-140,70},{-100,-70}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          Boolean uTemp[nu] "Temporary variable";

        equation
          if size(u, 1) > 1 then
            uTemp[1] = u[1];
            for i in 2:size(u, 1) loop
              uTemp[i] = u[i] and uTemp[i-1];
            end for;
            y = uTemp[nu];
          elseif (size(u, 1) == 1) then
            uTemp[1] = u[1];
            y = uTemp[1];
          else
            y = false;
          end if;

          annotation (
          defaultComponentName="mulAnd",
          Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-144,150},{156,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-80,52},{56,-52}},
                  lineColor={0,0,0},
                  textString="AND"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = true</code> if and only if
all elements of the input vector <code>u</code> are <code>true</code>.
If no connection to the input connector <code>u</code> is present,
the output is <code>y=false</code>.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Validation.MultiAnd\">
Buildings.Controls.OBC.CDL.Logical.Validation.MultiAnd</a>
for an example.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 28, 2017, by Jianjun Hu:<br/>
First implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/825\">issue 825</a>.
</li>
</ul>
</html>"));
        end MultiAnd;

        block MultiOr "Logical MultiOr, y = u[1] or u[2] or u[3] or ..."

          parameter Integer nu(min=0) = 0 "Number of input connections"
            annotation (Dialog(connectorSizing=true), HideResult=true);

          Interfaces.BooleanInput u[nu] "Connector of Boolean input signals"
            annotation (Placement(transformation(extent={{-140,70},{-100,-70}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          Boolean uTemp[nu] "Temporary variable";

        equation
          if size(u, 1) > 1 then
            uTemp[1] = u[1];
            for i in 2:size(u, 1) loop
              uTemp[i] = u[i] or uTemp[i-1];
            end for;
            y = uTemp[nu];
          elseif (size(u, 1) == 1) then
            uTemp[1] = u[1];
            y = uTemp[1];
          else
            y = false;
          end if;

          annotation (
          defaultComponentName="mulOr",
          Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-144,150},{156,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-80,52},{56,-52}},
                  lineColor={0,0,0},
                  textString="OR"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Block that outputs <code>y = true</code> if any element in the input 
vector <code>u</code> is <code>true</code>.
If no connection to the input connector <code>u</code> is present,
the output is <code>y=false</code>.
</p>
<p>
See
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Validation.MultiOr\">
Buildings.Controls.OBC.CDL.Logical.Validation.MultiOr</a>
for an example.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 6, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
        end MultiOr;

        block Nand "Logical 'nand': y = not (u1 and u2)"

          Interfaces.BooleanInput u1 "Connector of first Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanInput u2
            "Connector of second Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = not (u1 and u2);
          annotation (
                  defaultComponentName="nand",
                  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={      Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                           Text(
                  extent={{-50,52},{50,-48}},
                  lineColor={0,0,0},
                  textString="nand"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-6},{-89,8}},
                  lineColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-73},{-89,-87}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),Documentation(info="<html>
<p>
Block that outputs <code>true</code> if at least
one input is <code>false</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Nand;

        block Nor "Logical 'nor': y = not (u1 or u2)"

          Interfaces.BooleanInput u1 "Connector of first Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanInput u2
            "Connector of second Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = not (u1 or u2);
          annotation (
                  defaultComponentName="nor",
                  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={      Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                           Text(
                  extent={{-90,40},{90,-40}},
                  lineColor={0,0,0},
                  textString="nor"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-6},{-89,8}},
                  lineColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-73},{-89,-87}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
          Documentation(info="<html>
<p>
Block that outputs <code>true</code> if none of the inputs is <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Nor;

        block Not "Logical not"

          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = not u;
          annotation (
            defaultComponentName="not1",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  lineThickness=5.0,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                      Text(
                  extent={{-56,28},{72,-24}},
                  lineColor={0,0,0},
                  textString="not"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Block that outputs <code>true</code> if the input is <code>false</code>,
and <code>false</code> if the input is <code>true</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Not;

        block OnOffController "On-off controller"

          parameter Real bandwidth(min=0) "Bandwidth around reference signal";

          parameter Boolean pre_y_start=false "Value of pre(y) at initial time";

          Interfaces.RealInput reference
            "Connector of Real input signal used as reference signal"
            annotation (Placement(transformation(extent={{-140,80},{-100,40}})));

          Interfaces.RealInput u
            "Connector of Real input signal used as measurement signal"
            annotation (Placement(transformation(extent={{-140,-40},{-100,-80}})));

          Interfaces.BooleanOutput y
            "Connector of Real output signal used as actuator signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        initial equation
          pre(y) = pre_y_start;
        equation
          y = pre(y) and (u < reference + bandwidth/2) or (u < reference - bandwidth/2);

          annotation (
                defaultComponentName="onOffCon",
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Text(
                  extent={{-92,74},{44,44}},
                  lineThickness=0.5,
                  textString="reference"),
                Text(
                  extent={{-94,-52},{-34,-74}},
                  textString="u"),
                Line(points={{-86,-32},{-78,-6},{-60,26},{-34,40},{-12,42},{6,36},{22,
                      28},{38,12},{48,-6},{58,-28}},
                  color={0,0,127}),
                Line(points={{-88,-2},{-16,18},{72,-12}},
                  color={255,0,0}),
                Line(points={{-88,12},{-16,30},{72,0}}),
                Line(points={{-88,-16},{-16,4},{72,-26}}),
                Line(points={{-92,-18},{-66,-18},{-66,-40},{54,-40},{54,-20},{80,-20}},
                  color={255,0,255}),
                Ellipse(
                  extent={{73,7},{87,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),Documentation(info="<html>
<p>
Block that represents and on/off controller.
</p>
<p>
The block outputs <code>true</code> when
the input signal <code>u</code> falls below
the <code>reference</code> signal minus half of the bandwidth.
It sets the output signal to <code>false</code> when the input
signal <code>u</code> exceeds the <code>reference</code> signal
plus half of the bandwidth.
The parameter <code>pre_y_start</code> is used to initialize the
previous value of the output <code>pre(y)</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end OnOffController;

        block Or "Logical 'or': y = u1 or u2"

          Interfaces.BooleanInput u1 "Connector of first Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanInput u2
            "Connector of second Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 or u2;

          annotation (
            defaultComponentName="or2",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={           Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                      Text(
                  extent={{-90,40},{90,-40}},
                  lineColor={0,0,0},
                  textString="or"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-6},{-89,8}},
                  lineColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-73},{-89,-87}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Block that outputs <code>true</code> if at least one input
is <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Or;

        block Or3 "Logical 'or': y = u1 or u2 or u3"

          Interfaces.BooleanInput u1 "Connector of first Boolean input signal"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Interfaces.BooleanInput u2
            "Connector of second Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanInput u3
            "Connector of second Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = u1 or u2 or u3;

          annotation (
            defaultComponentName="or3",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={           Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                      Text(
                  extent={{-90,40},{90,-40}},
                  lineColor={0,0,0},
                  textString="or"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-73,-6},{-87,8}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0} else {235,
                      235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0} else {235,
                      235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-73,-73},{-87,-87}},
                  lineColor=DynamicSelect({235,235,235}, if u3 then {0,255,0} else {235,
                      235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u3 then {0,255,0} else {235,
                      235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Ellipse(
                  extent={{-75,72},{-89,86}},
                  lineColor=DynamicSelect({235,235,235}, if u1 then {0,255,0} else {235,
                      235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u1 then {0,255,0} else {235,
                      235,235}),
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Block that outputs <code>true</code> if at least one input
is <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 10, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Or3;

        block Pre
          "Breaks algebraic loops by an infinitesimal small time delay (y = pre(u): event iteration continues until u = pre(u))"

          parameter Boolean pre_u_start=false "Start value of pre(u) at initial time";

          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        initial equation
          pre(u) = pre_u_start;
        equation
          y = pre(u);
          annotation (
            defaultComponentName="pre",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={           Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                      Text(
                  extent={{-90,40},{90,-40}},
                  lineColor={0,0,0},
                  textString="pre"),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-6},{-89,8}},
                  lineColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This block delays the Boolean input by an infinitesimal small time delay and
therefore breaks algebraic loops. In a network of logical blocks, in every
<i>closed connection loop</i>, at least one logical block must have a delay,
since algebraic systems of Boolean equations are not solvable.
</p>

<p>
This block returns the value of the input signal <code>u</code> from the
last event iteration. The event iteration stops once both
values are identical, i.e., if <code>u = pre(u)</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 24, 2017, by Milica Grahovac:<br/>
First CDL implementation.
</li>
</ul>

</html>"));
        end Pre;

        block Switch "Switch between two Real signals"

          Interfaces.RealInput u1
            "Real input signal"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Interfaces.BooleanInput u2
            "Boolean switch input signal, if true, y=u1, else y=u3"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealInput u3
            "Real input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.RealOutput y
          "Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = if u2 then u1 else u3;

          annotation (
            defaultComponentName="swi",
            Documentation(info="<html>
<p>
Block that outputs one of two real input signals based on a boolean input signal.
</p>
<p>
If the input signal <code>u2</code> is <code>true</code>,
the block outputs <code>y = u1</code>.
Otherwise, it outputs <code>y = u3</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
                                                 Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Line(points={{12.0,0.0},{100.0,0.0}},
                  color={0,0,127}),
                Line(points={{-100.0,0.0},{-40.0,0.0}},
                  color={255,0,255}),
                Line(points={{-100.0,-80.0},{-40.0,-80.0},{-40.0,-80.0}},
                  color={0,0,127}),
                Line(points={{-40.0,12.0},{-40.0,-12.0}},
                  color={255,0,255}),
                Line(points={{-100.0,80.0},{-38.0,80.0}},
                  color={0,0,127}),
                Line(points={{-38.0,80.0},{6.0,2.0}},
                  color={0,0,127},
                  thickness=1.0),
                Ellipse(lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  extent={{2.0,-8.0},{18.0,8.0}}),
                Ellipse(
                  extent={{-71,7},{-85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}));
        end Switch;

        block Timer
          "Timer measuring the time from the time instant where the Boolean input became true"

          parameter Boolean accumulate = false
            "If true, accumulate time until Boolean input 'reset' becomes true, otherwise reset timer whenever u becomes true";

          Interfaces.BooleanInput u "Connector for signal that switches timer on if true, and off if false"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanInput reset if accumulate
            "Connector for signal that sets timer to zero if it switches to true"
            annotation (Placement(transformation(extent={{-140,-90},{-100,-50}}),
              iconTransformation(extent={{-140,-100},{-100,-60}})));
          Interfaces.RealOutput y(
            final quantity="Time",
            final unit="s") "Timer output"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          discrete Modelica.SIunits.Time entryTime "Time instant when u became true";
          discrete Modelica.SIunits.Time yAcc "Accumulated time up to last change to true";
          Interfaces.BooleanInput reset_internal(
            final start=false,
            final fixed=true) "Internal connector";

        initial equation
          pre(entryTime) = 0;
          yAcc = 0;

        equation
          connect(reset, reset_internal);
          if not accumulate then
            reset_internal = false;
          end if;

          when u and (not edge(reset_internal)) then
            entryTime = time;
          elsewhen reset_internal then
            entryTime = time;
          end when;

          when reset_internal then
            yAcc = 0;
          elsewhen (not u) then
            yAcc = pre(y);
          end when;

          if not accumulate then
            y = if u then time - entryTime else 0.0;
          else
            y = if u then yAcc + (time - entryTime) else yAcc;
          end if;

        annotation (
            defaultComponentName="tim",
            Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
              Line(points={{-66,-60},{82,-60}},
                color={192,192,192}),
              Line(points={{-58,68},{-58,-80}},
                color={192,192,192}),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{90,-60},{68,-52},{68,-68},{90,-60}}),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{-58,90},{-66,68},{-50,68},{-58,90}}),
              Line(points={{-56,-60},{-38,-60},{-38,-16},{40,-16},{40,-60},{68,-60}},
                color={255,0,255}),
              Line(points={{-58,0},{-40,0},{40,90},{40,0},{68,0}},
                color={0,0,127}),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Ellipse(
                  extent={{-83,7},{-69,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u then {0,255,0} else {235,
                      235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u then {0,255,0} else {235,
                      235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-88,-58},{88,-98}},
                  lineColor={217,67,180},
                  textString="accumulate: %accumulate")}),
            Documentation(info="<html>
<p>
Timer with option to accumulate time until it is reset by an input signal.
</p>
<p>
Each time the Boolean input <code>u</code> becomes true, the timer runs, otherwise
it is dormant.
If the parameter <code>accumulate</code> is <code>false</code>, the timer is set to zero each time the
input <code>u</code> becomes <code>false</code>.
If <code>accumulate = true</code>, an input <code>reset</code> is enabled, the timer accumulates time,
and the timer is set to zero only when the value of the input <code>reset</code> becomes <code>true</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 8, 2019, by Michael Wetter:<br/>
Revised implementation. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1221\">issue 1221</a>.
</li>
<li>
July 23, 2018, by Jianjun Hu:<br/>
Added conditional boolean input for cumulative time measuring. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1221\">issue 1221</a>.
</li>
<li>
July 18, 2018, by Jianjun Hu:<br/>
Updated implementation to output accumulated true input time.  This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1212\">issue 1212</a>.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Timer;

        block Toggle "Toggles output value whenever its input turns true"

          parameter Boolean pre_y_start=false "Start value of pre(y) if clr=false";

          Interfaces.BooleanInput u "Toggle input"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanInput clr "Clear input"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Interfaces.BooleanOutput y "Output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        initial equation
          pre(y) = pre_y_start;
          pre(u) = false;
          pre(clr) = false;

        equation
          when initial() then
            //scenario = 1
            y = if clr then false else pre(y);
          elsewhen (not clr) and change(u) and (pre(u) == false) and (pre(y) == false) then
            //scenario = 2
            y = true;
          elsewhen (not clr) and change(u) and (pre(u) == false) and (pre(y) == true) then
            //scenario = 3
            y = false;
          elsewhen (not clr) and change(u) and (pre(u) == true) then
            //scenario = 4
            y = pre(y);
          elsewhen clr then
            //scenario = 5
            y = false;
          end when;

        annotation (defaultComponentName="tog",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Ellipse(
                  extent={{-73,9},{-87,-5}},
                  lineColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-73,-53},{-87,-67}},
                  lineColor=DynamicSelect({235,235,235}, if u0 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u0 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Line(points={{-68,-62},{4,-62},{4,-22},{74,-22}}, color={255,0,255}),
                Line(points={{-68,24},{-48,24},{-48,56},{-16,56},{-16,24},{24,24},{24,56},
                      {54,56},{54,24},{74,24}}, color={255,0,255}),
                Text(
                  extent={{-22,72},{28,58}},
                  lineColor={0,0,0},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  textString="Toggle input"),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-14,-10},{14,-20}},
                  lineColor={0,0,0},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  textString="Clear")}),
          Documentation(info="<html>
<p>
Block that generates a <code>true</code> output when toggle input <code>u</code> 
rises from <code>false</code> to <code>true</code>, provided that the clear input
<code>clr</code> is <code>false</code> or also became at the same time 
<code>false</code>. The output remains <code>true</code> until
</p>
<ul>
<li>
the toggle input <code>u</code> rises from <code>false</code> to <code>true</code> again, or
</li>
<li>
the clear input <code>clr</code> rises from <code>false</code> to <code>true</code>.
</li>
</ul>
<p>
If the clear input <code>clr</code> is <code>true</code>, the output <code>y</code>
switches to <code>false</code> (if it was <code>true</code>) and it remains <code>false</code>,
regardless of the value of the toggle input <code>u</code>.
</p>

<p>
At initial time, if <code>clr = false</code>, then the output will be 
<code>y = pre_y_start</code>. Otherwise it will be <code>y=false</code> 
(because the clear input <code>clr</code> is <code>true</code>).
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/Toggle.png\"
     alt=\"Toggle.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
March 9, 2020, by Michael Wetter:<br/>
Simplified implementation, and made model work with OpenModelica.
</li>
<li>
April 4, 2019, by Jianjun Hu:<br/>
Corrected implementation that causes wrong output at initial stage. 
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1402\">issue 1402</a>.
</li>
<li>
March 31, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Toggle;

        block TriggeredTrapezoid "Triggered trapezoid generator"

          parameter Real amplitude "Amplitude of trapezoid";

          parameter Modelica.SIunits.Time rising(final min=0) = 0
            "Rising duration of trapezoid";

          parameter Modelica.SIunits.Time falling(final min=0) = rising
            "Falling duration of trapezoid";

          parameter Real offset=0 "Offset of output signal";

          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          discrete Real endValue "Value of y at time of recent edge";
          discrete Real rate "Current rising/falling rate";
          discrete Modelica.SIunits.Time T
            "Predicted time of output reaching endValue";
        equation
          y = if time < T then endValue - (T - time)*rate else endValue;

          when {initial(), u, not u} then
            endValue = if u then offset + amplitude else offset;
            rate = if u and (rising > 0) then amplitude/rising else if not u and (
              falling > 0) then -amplitude/falling else 0;
            T = if u and not (rising > 0) or not u and not (falling > 0) or not abs(
              amplitude) > 0 or initial() then time else time + (endValue - pre(y))/
              rate;
          end when;

          annotation (
            defaultComponentName="triTra",
            Icon(
              coordinateSystem(preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
                graphics={                       Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
              Line(points={{-46,-70},{-46,-70},{-16,40},{22,40},{54,-70},{54,-70}},
                color={0,0,127}),
              Line(points={{-90.0,-70.0},{82.0,-70.0}},
                color={192,192,192}),
              Line(points={{-66,68},{-66,-80}},
                color={192,192,192}),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{-66,90},{-74,68},{-58,68},{-66,90}}),
              Line(points={{-66,-70},{-46,-70},{-46,24},{22,24},{22,-70},{74,-70}},
                color={255,0,255}),
                Ellipse(
                  extent={{-71,7},{-85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
              Polygon(lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid,
                points={{90.0,-70.0},{68.0,-62.0},{68.0,-78.0},{90.0,-70.0}}),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Line(points={{-80,-20},{-60,-20},{-30,40},{
                  8,40},{40,-20},{60,-20}}, color={0,0,255}),Line(points={{-90,-70},{
                  82,-70}}),Line(points={{-80,68},{-80,-80}}, color={0,
                  0,0}),Polygon(
                    points={{90,-70},{68,-62},{68,-78},{90,-70}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Polygon(
                    points={{-80,90},{-88,68},{-72,68},{-80,90}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Line(points={{-80,-68},{-60,-68},{
                  -60,-42},{8,-42},{8,-68},{60,-68}}, color={255,0,255}),Line(
                    points={{-60,40},{-60,-42}},
                    pattern=LinePattern.Dot),Line(
                    points={{8,-42},{8,40}},
                    pattern=LinePattern.Dot),Line(points={{-60,40},{-30,40}}, color={
                  0,0,0}),Line(points={{8,-20},{40,-20}}),Line(points=
                  {{-20,40},{-20,-20}}),Line(points={{-20,-20},{-20,-70}}),Text(
                    extent={{-44,50},{-44,40}},
                    lineColor={0,0,0},
                    textString="rising"),Text(
                    extent={{24,-10},{24,-20}},
                    lineColor={0,0,0},
                    textString="falling"),Polygon(
                    points={{-60,40},{-56,42},{-56,38},{-60,40}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Polygon(
                    points={{-30,40},{-34,42},{-34,38},{-30,40}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Polygon(
                    points={{8,-20},{12,-18},{12,-22},{8,-20}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Polygon(
                    points={{40,-20},{36,-18},{36,-22},{40,-20}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Polygon(
                    points={{-22,-24},{-20,-20},{-18,-24},{-22,-24}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Polygon(
                    points={{-18,-66},{-22,-66},{-20,-70},{-18,-66}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Polygon(
                    points={{-22,36},{-20,40},{-18,36},{-22,36}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Polygon(
                    points={{-18,-16},{-22,-16},{-20,-20},{-18,-16}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Rectangle(
                    extent={{-40,6},{0,-4}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Text(
                    extent={{-20,6},{-20,-4}},
                    lineColor={0,0,0},
                    textString="amplitude"),Rectangle(
                    extent={{-40,-48},{0,-58}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Text(
                    extent={{-20,-48},{-20,-58}},
                    lineColor={0,0,0},
                    textString="offset"),Text(
                    extent={{60,-82},{94,-92}},
                    lineColor={0,0,0},
                    textString="time"),Text(
                    extent={{-88,-4},{-54,-14}},
                    lineColor={0,0,0},
                    textString="y"),Text(
                    extent={{-88,-46},{-54,-56}},
                    lineColor={0,0,0},
                    textString="u")}),
            Documentation(info="<html>
<p>
Block that represents a triggered trapezoid.
</p>
<p>
The block has a Boolean input and a Real
output signal and requires the parameters <i>amplitude</i>,
<i>rising</i>, <i>falling</i> and <i>offset</i>. The
output signal <code>y</code> represents a trapezoidal signal dependent on the
input signal <code>u</code>.
</p>
<p>The behaviour is as follows: Assume the initial input to be
<code>false</code>. In this
case, the output will be <i>offset</i>. After a rising edge (i.e., the input
changes from <code>false</code> to <code>true</code>),
the output is rising during <i>rising</i> to the
sum of <i>offset</i> and <i>amplitude</i>. In contrast, after a falling
edge (i.e., the input changes from true to false), the output is falling
during <i>falling</i> to a value of <i>offset</i>.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TriggeredTrapezoid.png\"
     alt=\"TriggeredTrapezoid.png\" />
</p>
<p>
Note, the case of edges before expiration of rising or falling is
handled properly.</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end TriggeredTrapezoid;

        block TrueDelay
          "Delay a rising edge of the input, but do not delay a falling edge."

          parameter Modelica.SIunits.Time delayTime "Delay time";

          parameter Boolean delayOnInit = false
            "Set to true to delay initial true input";

          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          parameter Modelica.SIunits.Time t_past(fixed=false)
             "Time before simulation started";
           Modelica.SIunits.Time t_next;

        initial equation
          t_past = time - 1000;
          pre(u) = false;
          pre(t_next) = time - 1000;

        equation
          when initial() then
            t_next = if not delayOnInit then t_past else time + delayTime;
            y = if not (delayOnInit and delayTime > 0) then u else false;
          elsewhen u then
            t_next = time + delayTime;
            y = if delayTime > 0 then false else true;
          elsewhen not u then
            t_next = t_past;
            y = false;
          elsewhen time >= pre(t_next) then
            t_next = t_past;
            y = u;
          end when;

              annotation (
                  defaultComponentName="truDel",
                  Icon(graphics={        Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                  Text(
                    extent={{-250,-120},{250,-150}},
                    lineColor={0,0,0},
                  textString="%delayTime"),
                  Line(points={{-80,-66},{-60,-66},{-60,-22},{38,-22},{38,-66},{66,-66}}),
                  Line(points={{-80,32},{-4,32},{-4,76},{38,76},{38,32},{66,32}},
                      color={255,0,255}),
                Ellipse(
                  extent={{-71,7},{-85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}), Documentation(info="<html>
<p>
Block that delays a signal when it becomes <code>true</code>.
</p>
<p>
A rising edge of the Boolean input <code>u</code> gives a delayed output.
A falling edge of the input is immediately given to the output. If 
<code>delayOnInit = true</code>, then a <code>true</code> input signal
at the start time is also delayed, otherwise the input signal is
produced immediately at the output.
</p>
<p>
Simulation results of a typical example with a delay time of <i>0.1</i> second
is shown below.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueDelay1.png\"
     alt=\"OnDelay1.png\" />
<br/>
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueDelay2.png\"
     alt=\"OnDelay2.png\" />
</p>

</html>",         revisions="<html>
<ul>
<li>
February 11, 2019, by Milica Grahovac:<br/>
Added boolean input to enable delay of an initial true input.
</li>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end TrueDelay;

        block TrueFalseHold "Block that holds an output signal for at least a specified duration"

          parameter Modelica.SIunits.Time trueHoldDuration
            "true hold duration";

          parameter Modelica.SIunits.Time falseHoldDuration = trueHoldDuration
            "false hold duration";

          Interfaces.BooleanInput u "Boolean input signal"
            annotation (Placement(transformation(extent={{-220,-20},{-180,20}}),
                iconTransformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Boolean output signal"
            annotation (Placement(transformation(extent={{160,-20},{200,20}}),
                iconTransformation(extent={{100,-20},{140,20}})));

        protected
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDel1(delayTime
              =falseHoldDuration)
            "Output true when timer elapsed the required time" annotation (
              Placement(transformation(extent={{-100,-40},{-80,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDel2(delayTime
              =trueHoldDuration)
            "Output true when timer elapsed the required time"
            annotation (Placement(transformation(extent={{20,-70},{40,-50}})));

          inner Modelica.StateGraph.StateGraphRoot stateGraphRoot
            "Root of state graph"
            annotation (Placement(transformation(extent={{-160,100},{-140,120}})));
          Modelica.StateGraph.StepWithSignal        outputFalse(nIn=2)
            "State for which the block outputs false"
            annotation (Placement(transformation(extent={{-60,10},{-40,30}})));
          Modelica.StateGraph.TransitionWithSignal toTrue "Transition to true"
            annotation (Placement(transformation(extent={{-30,10},{-10,30}})));
          CDL.Logical.Not notU "Negation of input"
            annotation (Placement(transformation(extent={{-140,60},{-120,80}})));
          Modelica.StateGraph.StepWithSignal outputTrue(nIn=2)
            "State with true output signal"
            annotation (Placement(transformation(extent={{0,10},{20,30}})));
          Modelica.StateGraph.TransitionWithSignal toFalse "Transition to false"
            annotation (Placement(transformation(extent={{30,10},{50,30}})));
          CDL.Logical.And and2 "Check for input and elapsed timer"
            annotation (Placement(transformation(extent={{60,-70},{80,-50}})));
          CDL.Logical.And and1 "Check for input and elapsed timer"
            annotation (Placement(transformation(extent={{-50,-40},{-30,-20}})));

          Modelica.StateGraph.InitialStep initialStep(nIn=0, nOut=2) "Initial state"
            annotation (Placement(transformation(extent={{-120,100},{-100,120}})));
          Modelica.StateGraph.TransitionWithSignal toTrue1 "Transition to true"
            annotation (Placement(transformation(extent={{-70,102},{-50,122}})));
          Modelica.StateGraph.TransitionWithSignal toFalse1 "Transition to false"
            annotation (Placement(transformation(extent={{-90,80},{-70,100}})));
        equation
          connect(outputTrue.outPort[1], toFalse.inPort)
            annotation (Line(points={{20.5,20},{28,20},{36,20}}, color={0,0,0}));
          connect(outputTrue.active, y)
            annotation (Line(points={{10,9},{10,0},{180,0}},  color={255,0,255}));
          connect(outputFalse.outPort[1], toTrue.inPort)
            annotation (Line(points={{-39.5,20},{-32,20},{-24,20}}, color={0,0,0}));
          connect(toFalse.outPort, outputFalse.inPort[1]) annotation (Line(points={{41.5,20},
                  {60,20},{60,40},{-70,40},{-70,20.5},{-61,20.5}},     color={0,0,0}));
          connect(outputTrue.active,onDel2. u)
            annotation (Line(points={{10,9},{10,0},{10,-60},{18,-60}},
                                                                 color={255,0,255}));
          connect(notU.y, and2.u2)
            annotation (Line(points={{-118,70},{140,70},{140,-80},{48,-80},{48,-68},{58,
                  -68}},                                   color={255,0,255}));
          connect(and2.y, toFalse.condition) annotation (Line(points={{82,-60},{100,-60},
                  {100,-20},{40,-20},{40,8}},color={255,0,255}));
          connect(outputFalse.active,onDel1. u) annotation (Line(points={{-50,9},{-50,0},
                  {-140,0},{-140,-30},{-102,-30}},
                                                 color={255,0,255}));
          connect(u, and1.u2) annotation (Line(points={{-200,0},{-160,0},{-160,-50},{
                  -60,-50},{-60,-38},{-52,-38},{-52,-38}},
                color={255,0,255}));
          connect(and1.y, toTrue.condition) annotation (Line(points={{-28,-30},{-20,-30},
                  {-20,8}},                   color={255,0,255}));
          connect(u, toTrue1.condition) annotation (Line(points={{-200,0},{-160,0},{-160,
                  52},{-60,52},{-60,100}},
                                      color={255,0,255}));
          connect(toTrue1.outPort, outputTrue.inPort[1]) annotation (Line(points={{-58.5,
                  112},{-10,112},{-10,20.5},{-1,20.5}},
                                                      color={0,0,0}));
          connect(toTrue.outPort, outputTrue.inPort[2])
            annotation (Line(points={{-18.5,20},{-1,20},{-1,19.5}}, color={0,0,0}));
          connect(toFalse1.outPort, outputFalse.inPort[2]) annotation (Line(points={{-78.5,
                  90},{-72,90},{-72,44},{-72,20},{-61,20},{-61,19.5}},          color={0,
                  0,0}));
          connect(initialStep.outPort[1], toTrue1.inPort) annotation (Line(points={{-99.5,
                  110.25},{-90,110.25},{-90,110},{-90,112},{-64,112}},
                                                   color={0,0,0}));
          connect(initialStep.outPort[2], toFalse1.inPort) annotation (Line(points={{-99.5,
                  109.75},{-94,109.75},{-94,110},{-90,110},{-90,90},{-84,90}},
                                                           color={0,0,0}));
          connect(notU.u, u) annotation (Line(points={{-142,70},{-160,70},{-160,0},{-200,
                  0}},
                color={255,0,255}));
          connect(notU.y, toFalse1.condition)
            annotation (Line(points={{-118,70},{-80,70},{-80,78}},color={255,0,255}));
          connect(onDel1.y, and1.u1)
            annotation (Line(points={{-78,-30},{-52,-30}}, color={255,0,255}));
          connect(onDel2.y, and2.u1)
            annotation (Line(points={{42,-60},{42,-60},{58,-60}}, color={255,0,255}));
          annotation (defaultComponentName="truFalHol",
                  Icon(graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised,
                  lineColor={0,0,0}),
                  Line(points={{-84,10},{-50,10},{-50,54},{-18,54},{-18,10},{-18,10}},
                      color={255,0,255}),
                  Line(points={{-78,-46},{-48,-46},{-48,-2},{-24,-2},{-24,-46},{-24,-46}}),
                  Line(points={{-24,-46},{6,-46},{6,-2},{44,-2},{44,-46},{74,-46}}),
                  Line(points={{-18,10},{14,10},{14,54},{46,54},{46,10},{66,10}},
                      color={255,0,255}),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-88,-62},{92,-90}},
                  lineColor={0,0,255},
                  textString="%falseHoldDuration"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-83,7},{-69,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u then {0,255,0} else {235,
                      235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u then {0,255,0} else {235,
                      235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-90,96},{96,68}},
                  lineColor={0,0,255},
                  textString="%trueHoldDuration")}),
                Diagram(coordinateSystem(
                  preserveAspectRatio=false, extent={{-180,-120},{160,140}})),
        Documentation(info="<html>
<p>
Block that holds a <code>true</code> or <code>false</code> signal for at least a defined time period.
</p>
<p>
Whenever the input <code>u</code> switches, the output <code>y</code>
switches and remains at that value for at least <code>duration</code>
seconds, where <code>duration</code> is a parameter.
After <code>duration</code> elapsed, the output will be
<code>y = u</code>.
If this change required changing the value of <code>y</code>,
then <code>y</code> will remain at that value for at least <code>duration</code>.
Otherwise, <code>y</code> will change immediately whenever <code>u</code>
changes.
</p>
<p>
This block could for example be used to disable an economizer,
and not re-enable it for <i>10</i> minutes, and vice versa.
</p>
<p>
The image below shows the implementation with a state graph in which
each transition is only triggered when the input has the corresponding value,
and the current state has been active for at least <code>duration</code> seconds.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueFalseHoldImplementation.png\"
alt=\"Input and output of the block\"/>
</p>

<p>
Simulation results of a typical example with <code>duration = 1000</code> seconds.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueFalseHold.png\"
alt=\"Input and output of the block\"/>
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 18, 2017, by Michael Wetter:<br/>
Improved event handling.
</li>
<li>
July 14, 2017, by Michael Wetter:<br/>
Corrected model to set output equal to input during initialization.
</li>
<li>
June 13, 2017, by Michael Wetter:<br/>
Reimplemented model using a state graph to avoid having to test for equality within tolerance,
and to correct a bug.
This implementation is also easier to understand.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/789\">issue 789</a>.
</li>
<li>
May 24, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TrueFalseHold;

        block TrueHoldWithReset "Block that holds a true signal for at least a requested duration"

          parameter Modelica.SIunits.Time duration "Time duration of the true output signal hold";

          Interfaces.BooleanInput u "Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanOutput y "Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          inner Modelica.StateGraph.StateGraphRoot stateGraphRoot
            "Root of state graph"
            annotation (Placement(transformation(extent={{70,68},{90,88}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay(final
              delayTime=duration) "Delay for the on signal"
            annotation (Placement(transformation(extent={{10,10},{30,30}})));
          Modelica.StateGraph.InitialStep initialStep "Initial step"
            annotation (Placement(transformation(extent={{-80,50},{-60,70}})));
          Modelica.StateGraph.StepWithSignal outputTrue
            "Holds the output at true"
            annotation (Placement(transformation(extent={{-10,50},{10,70}})));
          Modelica.StateGraph.TransitionWithSignal toOutputTrue
            "Transition that activates sending a true output signal"
            annotation (Placement(transformation(extent={{-50,50},{-30,70}})));
          Modelica.StateGraph.TransitionWithSignal toInitial
            "Transition that activates the initial state"
            annotation (Placement(transformation(extent={{30,50},{50,70}})));

        equation
          connect(initialStep.outPort[1], toOutputTrue.inPort)
            annotation (Line(points={{-59.5,60},{-44,60}}, color={0,0,0}));
          connect(outputTrue.active, y) annotation (Line(points={{0,49},{0,0},{120,0}},
                                                           color={255,0,255}));
          connect(toOutputTrue.condition, u)
            annotation (Line(points={{-40,48},{-40,0},{-120,0}}, color={255,0,255}));
          connect(toInitial.outPort, initialStep.inPort[1]) annotation (Line(points={{41.5,60},
                  {52,60},{52,86},{-90,86},{-90,60},{-81,60}},   color={0,0,0}));
          connect(outputTrue.active, onDelay.u)
            annotation (Line(points={{0,49},{0,20},{8,20}}, color={255,0,255}));
          connect(toOutputTrue.outPort, outputTrue.inPort[1])
            annotation (Line(points={{-38.5,60},{-11,60}}, color={0,0,0}));
          connect(outputTrue.outPort[1], toInitial.inPort)
            annotation (Line(points={{10.5,60},{36,60}}, color={0,0,0}));

          connect(onDelay.y, toInitial.condition)
            annotation (Line(points={{32,20},{40,20},{40,48}}, color={255,0,255}));
          annotation (
          defaultComponentName = "truHol",
          Icon(graphics={    Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                  Line(points={{-72,18},{-48,18},{-48,62},{52,62},{52,18},{80,18}},
                      color={255,0,255}),
                  Line(points={{-68,-46},{-48,-46},{-48,-2},{22,-2},{22,-46},{78,-46}}),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-90,-62},{96,-90}},
                  lineColor={0,0,255},
                  textString="%duration"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-83,7},{-69,-7}},
                  lineColor=DynamicSelect({235,235,235}, if u then {0,255,0} else {235,
                      235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u then {0,255,0} else {235,
                      235,235}),
                  fillPattern=FillPattern.Solid)}),
                      Documentation(info="<html>
<p>
Block that holds a <code>true</code> input signal for at least a defined time period.
</p>
<p>
At initialization, the output <code>y</code> is equal to the input <code>u</code>.
If the input <code>u</code> becomes <code>true</code>, or is <code>true</code>
during intialization, a timer starts
and the Boolean output <code>y</code> stays <code>true</code> for the time
period provided by the parameter <code>duration</code>.
When this time is elapsed, the input is checked again. If
it is <code>true</code>, then the timer is restarted and the output remains
<code>true</code> for another <code>duration</code> seconds.
If the input <code>u</code> is <code>false</code> after
<code>holdTime</code> seconds, then the ouput is switched to <code>false</code>,
until the input becomes <code>true</code> again.
</p>
<p>
The figure below shows the state chart of the implementation. Note that the
transition are done in zero time.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithResetImplementation.png\"
alt=\"Input and output of the block\"/>
</p>
<p>
The figure below shows an example with a hold time of <i>3600</i> seconds
and a pulse width period <i>9000</i> seconds that starts at <i>t=200</i> seconds.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithReset.png\"
alt=\"Input and output of the block\"/>
</p>

<p>
The figure below shows an example with a hold time of <i>60</i> seconds
and a pulse width period <i>3600</i> seconds that starts at <i>t=0</i> seconds.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithReset1.png\"
alt=\"Input and output of the block\"/>
</p>
<p>
The next two figures show the same experiment, except that the input <code>u</code>
has been negated. The figure below has again a hold time of <i>3600</i> seconds
and a pulse width period <i>9000</i> seconds that starts at <i>t=200</i> seconds.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithReset2.png\"
alt=\"Input and output of the block\"/>
</p>
<p>
The figure below has again a hold time of <i>60</i> seconds
and a pulse width period <i>3600</i> seconds that starts at <i>t=0</i> seconds.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/TrueHoldWithReset3.png\"
alt=\"Input and output of the block\"/>
</p>
</html>",         revisions="<html>
<ul>
<li>
September 18, 2017, by Michael Wetter:<br/>
Improved event handling.
</li>
<li>
June 13, 2017, by Michael Wetter:<br/>
Reimplemented model using a state graph to avoid having to test for equality within tolerance.
This implementation is also easier to understand.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/789\">issue 789</a>.
</li>
<li>
May 24, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TrueHoldWithReset;

        block Xor "Logical 'xor': y = u1 xor u2"

          Interfaces.BooleanInput u1 "Connector of first Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanInput u2
            "Connector of second Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = not ((u1 and u2) or (not u1 and not u2));
          annotation (
                defaultComponentName="xor",
                Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={      Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                                           Text(
                  extent={{-90,40},{90,-40}},
                  lineColor={0,0,0},
                  textString="xor"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-6},{-89,8}},
                  lineColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u1 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-75,-73},{-89,-87}},
                  lineColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if u2 then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Block that outputs <code>true</code> if exactly one input is <code>true</code>.
Otherwise the output is <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end Xor;

        block ZeroCrossing "Trigger zero crossing of input u"

          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          Interfaces.BooleanInput enable
            "Zero input crossing is triggered if the enable input signal is true"
            annotation (Placement(transformation(
                origin={0,-120},
                extent={{-20,-20},{20,20}},
                rotation=90)));

        protected
          Boolean disable=not enable "Boolean not of enable input";
          Boolean u_pos "Positive real input";
        initial equation
          pre(u_pos) = false;
          pre(enable) = false;
          pre(disable) = not pre(enable);
        equation
          u_pos = enable and u >= 0;
          y = change(u_pos) and not edge(enable) and not edge(disable);
          annotation (
        defaultComponentName="zerCro",
        Documentation(info="<html>
<p>
Block that detects zero crossings.
</p>
<p>
The output <code>y</code> is <code>true</code> at the
time instant when the input <code>u</code> becomes
zero, provided the input <code>enable</code> is
<code>true</code>. At all other time instants,
the output <code>y</code> is <code>false</code>.
If the input <code>u</code> is zero at a time instant when
the <code>enable</code>
input changes its value, then the output <code>y</code> is <code>false</code>.
</p>
<p>
Note, that in the plot window of a Modelica simulator, the output of
this block is usually identically to <code>false</code>, because the output
may only be <code>true</code> at an event instant, but not during
continuous integration. In order to check that this component is
actually working as expected, one should connect its output to, e.g.,
component <i>Buildings.Controls.OBC.CDL.Discrete.TriggeredSampler</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"),       Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={      Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={210,210,210},
                  lineThickness=5.0,
                  fillPattern=FillPattern.Solid,
                  borderPattern=BorderPattern.Raised),
                Line(points={{-78,68},{-78,-80}}, color={192,192,192}),
                Polygon(
                  points={{-78,90},{-86,68},{-70,68},{-78,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-88,0},{62,0}}, color={192,192,192}),
                Line(points={{-78,0},{-73.2,32.3},{-70,50.3},{-66.7,64.5},{-63.5,74.2},
                      {-60.3,79.3},{-57.1,79.6},{-53.9,75.3},{-50.7,67.1},{-46.6,52.2},
                      {-41,25.8},{-33,-13.9},{-28.2,-33.7},{-24.1,-45.9},{-20.1,-53.2},
                      {-16.1,-55.3},{-12.1,-52.5},{-8.1,-45.3},{-3.23,-32.1},{10.44,
                      13.7},{15.3,26.4},{20.1,34.8},{24.1,38},{28.9,37.2},{33.8,31.8},{
                      40.2,19.4}},              color={192,192,192}, smooth = Smooth.Bezier),
                Line(points={{-36,-59},{-36,81}}, color={255,0,255}),
                Line(points={{6,-59},{6,81}}, color={255,0,255}),
                Line(points={{-78,0},{58,0}}, color={255,0,255}),
                Polygon(
                  points={{64,0},{42,8},{42,-8},{64,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  lineColor={0,0,255},
                  textString="%name"),
                Ellipse(
                  extent={{71,7},{85,-7}},
                  lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                       else {235,235,235}),
                  fillPattern=FillPattern.Solid)}));
        end ZeroCrossing;

        package Sources "Package with blocks that generate source signals"

          block Constant "Output constant signal of type Boolean"
            parameter Boolean k "Constant output value";

            Interfaces.BooleanOutput y "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y = k;
            annotation (
              defaultComponentName="con",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={
                                                         Text(
                    extent={{-150,150},{150,110}},
                    textString="%name",
                    lineColor={0,0,255}),          Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                         else {235,235,235}),
                    fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                         else {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Line(points={{-90,-70},{72,-70}}, color={255,0,255}),
                  Polygon(
                    points={{90,-70},{68,-62},{68,-78},{90,-70}},
                    lineColor={255,0,255},
                    fillColor={255,0,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-80,88},{-88,66},{-72,66},{-80,88}},
                    lineColor={255,0,255},
                    fillColor={255,0,255},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,66},{-80,-82}}, color={255,0,255}),
                                                             Line(points={{-80,0},{64,0}}),
                    Text(
                    extent={{-150,-140},{150,-110}},
                    lineColor={0,0,0},
                    textString="%k")}),
                Documentation(info="<html>
<p>
Block that outputs a constant signal <code>y = k</code>,
where <code>k</code> is a Boolean-valued parameter.
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/Constant.png\"
     alt=\"Constant.png\" />
</p>
</html>"));
          end Constant;

          block Pulse "Generate pulse signal of type Boolean"

            parameter Real width(
              final min=Constants.small,
              final max=1,
              final unit = "1") = 0.5 "Width of pulse in fraction of period";
            parameter Modelica.SIunits.Time period(
              final min=Constants.small) "Time for one period";
            parameter Modelica.SIunits.Time startTime=0 "Time instant of first pulse";
            Interfaces.BooleanOutput y "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          protected
            parameter Modelica.SIunits.Time Twidth=period*width
              "Width of one pulse";
            discrete Modelica.SIunits.Time pulseStart "Start time of pulse";

          initial equation
            pulseStart = startTime;
          equation
            when sample(startTime, period) then
              pulseStart = time;
            end when;
            y = time >= pulseStart and time < pulseStart + Twidth;
            annotation (
              defaultComponentName="booPul",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={
                                                   Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),     Text(
                    extent={{-150,-140},{150,-110}},
                    lineColor={0,0,0},
                    textString="%period"), Line(points={{-80,-70},{-40,-70},{-40,44},{0,
                        44},{0,-70},{40,-70},{40,44},{79,44}}),
                  Polygon(
                    points={{-80,88},{-88,66},{-72,66},{-80,88}},
                    lineColor={255,0,255},
                    fillColor={255,0,255},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,66},{-80,-82}}, color={255,0,255}),
                  Line(points={{-90,-70},{72,-70}}, color={255,0,255}),
                  Polygon(
                    points={{90,-70},{68,-62},{68,-78},{90,-70}},
                    lineColor={255,0,255},
                    fillColor={255,0,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                         else {235,235,235}),
                    fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                         else {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name")}),
                Documentation(info="<html>
<p>
The Boolean output y is a pulse signal:
</p>

<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/Sources/BooleanPulse.png\"
     alt=\"BooleanPulse.png\" />
</p>

</html>",           revisions="<html>
<ul>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end Pulse;

          block SampleTrigger "Generate sample trigger signal"
            parameter Modelica.SIunits.Time period(
              final min=Constants.small) "Sample period";
            parameter Modelica.SIunits.Time startTime=0
              "Time instant of first sample trigger";
            Interfaces.BooleanOutput y  "Connector of Boolean output signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));

          equation
            y = sample(startTime, period);
            annotation (
              defaultComponentName="samTri",
              Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}}), graphics={
                                                   Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={210,210,210},
                    lineThickness=5.0,
                    fillPattern=FillPattern.Solid,
                    borderPattern=BorderPattern.Raised),
                  Line(points={{-60,-70},{-60,70}}),
                  Line(points={{-20,-70},{-20,70}}),
                  Line(points={{20,-70},{20,70}}),
                  Line(points={{60,-70},{60,70}}),
                  Text(
                    extent={{-150,-140},{150,-110}},
                    lineColor={0,0,0},
                    textString="%period"),
                  Polygon(
                    points={{-80,88},{-88,66},{-72,66},{-80,88}},
                    lineColor={255,0,255},
                    fillColor={255,0,255},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-80,66},{-80,-82}}, color={255,0,255}),
                  Line(points={{-90,-70},{72,-70}}, color={255,0,255}),
                  Polygon(
                    points={{90,-70},{68,-62},{68,-78},{90,-70}},
                    lineColor={255,0,255},
                    fillColor={255,0,255},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{71,7},{85,-7}},
                    lineColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                         else {235,235,235}),
                    fillColor=DynamicSelect({235,235,235}, if y then {0,255,0}
                         else {235,235,235}),
                    fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name")}),
                Documentation(info="<html>
<p>
The Boolean output y is a trigger signal where the output y is only <code>true</code>
at sample times (defined by parameter <code>period</code>) and is otherwise
<code>false</code>.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/Logical/Sources/SampleTrigger.png\"
     alt=\"SampleTrigger.png\" />
</p>

</html>",           revisions="<html>
<ul>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
          end SampleTrigger;

          package Validation "Collection of models that validate the logical sources blocks of the CDL"

            model Constant "Validate the Constant block"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant con(k=true)
                "Block output boolean constant value" annotation (Placement(
                    transformation(extent={{-10,-10},{10,10}})));
              annotation (
              experiment(StopTime=1.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Sources/Validation/Constant.mos"
                    "Simulate and plot"),
                Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Sources.Constant\">
Buildings.Controls.OBC.CDL.Logical.Sources.Constant</a>.
</p>

</html>",             revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end Constant;

            model Pulse "Validation model for the Boolean Pulse block"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                  period=1) "Block that generates pulse signal of type Boolean"
                annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

              annotation (
              experiment(StopTime=5.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Sources/Validation/Pulse.mos"
                    "Simulate and plot"),
                Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Sources.Pulse\">
Buildings.Controls.OBC.CDL.Logical.Sources.Pulse</a>.
</p>
</html>",             revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end Pulse;

            model SampleTrigger "Validation model for the SampleTrigger block"

              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.SampleTrigger
                samTri(period=0.5) "Block that generates sample trigger signal"
                annotation (Placement(transformation(extent={{-30,-30},{-10,-10}})));

              hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
                duration=5,
                offset=0,
                height=20) "Block that generates ramp signal" annotation (
                  Placement(transformation(extent={{-30,10},{-10,30}})));

              hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triggeredSampler
                "Triggered sampler" annotation (Placement(transformation(extent
                      ={{20,10},{40,30}})));
            equation
              connect(ramp2.y, triggeredSampler.u)
                annotation (Line(points={{-9,20},{18,20}}, color={0,0,127}));
              connect(samTri.y, triggeredSampler.trigger) annotation (Line(points={{-9,-20},
                      {30,-20},{30,8},{30,8.2}}, color={255,0,255}));
              annotation (
              experiment(StopTime=5.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Sources/Validation/SampleTrigger.mos"
                    "Simulate and plot"),
                Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Sources.SampleTrigger\">
Buildings.Controls.OBC.CDL.Logical.Sources.SampleTrigger</a>.
</p>

</html>",             revisions="<html>
<ul>
<li>
July 17, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),      Icon(graphics={
                    Ellipse(lineColor = {75,138,73},
                            fillColor={255,255,255},
                            fillPattern = FillPattern.Solid,
                            extent = {{-100,-100},{100,100}}),
                    Polygon(lineColor = {0,0,255},
                            fillColor = {75,138,73},
                            pattern = LinePattern.None,
                            fillPattern = FillPattern.Solid,
                            points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
            end SampleTrigger;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Sources\">
Buildings.Controls.OBC.CDL.Logical.Sources</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),    Icon(graphics={
                  Rectangle(
                    lineColor={200,200,200},
                    fillColor={248,248,248},
                    fillPattern=FillPattern.HorizontalCylinder,
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Rectangle(
                    lineColor={128,128,128},
                    extent={{-100.0,-100.0},{100.0,100.0}},
                    radius=25.0),
                  Polygon(
                    origin={8.0,14.0},
                    lineColor={78,138,73},
                    fillColor={78,138,73},
                    pattern=LinePattern.None,
                    fillPattern=FillPattern.Solid,
                    points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
          end Validation;
        annotation (
        Documentation(
        info="<html>
<p>
Package with blocks that generate signals.
</p>
</html>"),         Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(origin={23.3333,0.0},
                  fillColor={128,128,128},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
                Rectangle(
                  fillColor = {128,128,128},
                  pattern = LinePattern.None,
                  fillPattern = FillPattern.Solid,
                  extent = {{-70,-4.5},{0,4.5}})}));
        end Sources;

        package Validation "Collection of models that validate the logical blocks of the CDL"

          model And "Validation model for the And block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.5,
                period=1.5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-26,8},{-6,28}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-26},{-6,-6}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and1
              "Logical and"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(booPul2.y, and1.u2) annotation (Line(points={{-4,-16},{8,-16},{8,-6},
                    {24,-6}}, color={255,0,255}));
            connect(booPul1.y, and1.u1) annotation (Line(points={{-4,18},{10,18},{10,2},{
                    24,2}}, color={255,0,255}));
            annotation (
            experiment(StopTime=10.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/And.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.And\">
Buildings.Controls.OBC.CDL.Logical.And</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end And;

          model And3 "Validation model for the And3 block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.5,
                period=1.5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-26,24},{-6,44}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-10},{-6,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And3 and1
              "Logical and of three inputs"
              annotation (Placement(transformation(extent={{26,-10},{46,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul3(width=0.5,
                period=3) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-44},{-6,-24}})));
          equation
            connect(booPul1.y, and1.u1) annotation (Line(points={{-4,34},{8,34},{8,8},{24,
                    8}},  color={255,0,255}));
            connect(booPul2.y, and1.u2)
              annotation (Line(points={{-4,0},{-4,0},{24,0}}, color={255,0,255}));
            connect(booPul3.y, and1.u3) annotation (Line(points={{-4,-34},{8,-34},{8,-8},
                    {24,-8}},color={255,0,255}));
            annotation (
            experiment(StopTime=10.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/And3.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.And3\">
Buildings.Controls.OBC.CDL.Logical.And3</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 10, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end And3;

          model Change "Validation model for the Change block."

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                period=1.0) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-40,-10},{-20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Change change
              "Outputs true if the input changes"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=5,
              offset=0,
              height=20) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triggeredSampler
              "Triggered sampler"
              annotation (Placement(transformation(extent={{40,40},{60,60}})));
          equation
            connect(booPul.y, change.u)
              annotation (Line(points={{-19,0},{-6,0},{-2,0}},color={255,0,255}));
            connect(ramp2.y, triggeredSampler.u)
              annotation (Line(points={{21,50},{29.5,50},{38,50}}, color={0,0,127}));
            connect(change.y, triggeredSampler.trigger) annotation (Line(points={{21,0},{
                    50,0},{50,38.2}}, color={255,0,255}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Change.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Change\">
Buildings.Controls.OBC.CDL.Logical.Change</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Change;

          model Edge "Validation model for the Edge block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                period=1.0) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-40,-10},{-20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Edge edge1
              "Outputs true if the input has a rising edge"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=5,
              offset=0,
              height=20) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triggeredSampler
              "Triggered sampler"
              annotation (Placement(transformation(extent={{40,40},{60,60}})));
          equation
            connect(booPul.y, edge1.u)
              annotation (Line(points={{-19,0},{-8,0},{-2,0}},color={255,0,255}));
            connect(edge1.y, triggeredSampler.trigger) annotation (Line(points={{21,0},{
                    50,0},{50,38},{50,38.2}},       color={255,0,255}));
            connect(ramp2.y, triggeredSampler.u)
              annotation (Line(points={{21,50},{29.5,50},{38,50}}, color={0,0,127}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Edge.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Edge\">
Buildings.Controls.OBC.CDL.Logical.Edge</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Edge;

          model FallingEdge "Validation model for the falling edge block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                period=1.0) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-40,-10},{-20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.FallingEdge falEdg
              "Output true when input changes from true to false"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=5,
              offset=0,
              height=20) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triggeredSampler
              "Trigger sampling of continuous signal"
              annotation (Placement(transformation(extent={{40,40},{60,60}})));
          equation
            connect(booPul.y, falEdg.u)
              annotation (Line(points={{-18,0},{-18,0},{-2,0}},
                                                              color={255,0,255}));
            connect(ramp2.y, triggeredSampler.u)
              annotation (Line(points={{22,50},{22,50},{38,50}},   color={0,0,127}));
            connect(falEdg.y, triggeredSampler.trigger) annotation (Line(points={{22,0},{
                    22,0},{50,0},{50,38.2}}, color={255,0,255}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/FallingEdge.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.FallingEdge\">
Buildings.Controls.OBC.CDL.Logical.FallingEdge</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 1, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end FallingEdge;

          model IntegerSwitch "Validation model for the IntegerSwitch block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.IntegerSwitch integerSwitch
              "Integer switch"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.7,
                period=1.5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-80,20},{-60,40}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=3)
              "Block that outputs cyclic on and off: switch between u1 and u3"
              annotation (Placement(transformation(extent={{-26,-10},{-6,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul3(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-80,-80},{-60,-60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt(k=5)
              "Integer constant" annotation (Placement(transformation(extent={{
                      -80,60},{-60,80}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt1(k=2)
              "Integer constant" annotation (Placement(transformation(extent={{
                      -80,-40},{-60,-20}})));

          protected
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
              booToInt "Type converter" annotation (Placement(transformation(
                    extent={{-40,20},{-20,40}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Product proInt "Product"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToInteger
              booToInt1 "Type converter" annotation (Placement(transformation(
                    extent={{-40,-80},{-20,-60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Product proInt1 "Product"
              annotation (Placement(transformation(extent={{0,-60},{20,-40}})));
          equation
            connect(booPul2.y,integerSwitch. u2)
              annotation (Line(points={{-5,0},{58,0}}, color={255,0,255}));
            connect(booPul1.y, booToInt.u)
              annotation (Line(points={{-59,30},{-42,30}}, color={255,0,255}));
            connect(booPul3.y, booToInt1.u)
              annotation (Line(points={{-59,-70},{-42,-70}}, color={255,0,255}));
            connect(conInt.y, proInt.u1) annotation (Line(points={{-59,70},{-20,70},{-20,56},
                    {-2,56}}, color={255,127,0}));
            connect(booToInt.y, proInt.u2) annotation (Line(points={{-19,30},{-10,30},{-10,
                    44},{-2,44}}, color={255,127,0}));
            connect(conInt1.y, proInt1.u1) annotation (Line(points={{-59,-30},{-10,-30},{-10,
                    -44},{-2,-44}}, color={255,127,0}));
            connect(booToInt1.y, proInt1.u2) annotation (Line(points={{-19,-70},{-10,-70},
                    {-10,-56},{-2,-56}}, color={255,127,0}));
            connect(proInt.y,integerSwitch. u1) annotation (Line(points={{21,50},{40,50},{
                    40,8},{58,8}}, color={255,127,0}));
            connect(proInt1.y,integerSwitch. u3) annotation (Line(points={{21,-50},{40,-50},
                    {40,-8},{58,-8}}, color={255,127,0}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
             __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/IntegerSwitch.mos"
                   "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.IntegerSwitch\">
Buildings.Controls.OBC.CDL.Logical.IntegerSwitch</a>.
</p>
<p>
The input <code>u2</code> is the switch input: If <code>u2 = true</code>,
then output <code>y = u1</code>;
else output <code>y = u3</code>.
</p>

</html>",           revisions="<html>
<ul>
<li>
July 10, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end IntegerSwitch;

          model Latch "Validation model for the Latch block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch falCle
              "Latch block with clear input being contantly false" annotation (
                Placement(transformation(extent={{-100,90},{-80,110}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch truCle(
                pre_y_start=true)
              "Latch block with clear input being contantly true" annotation (
                Placement(transformation(extent={{-100,10},{-80,30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch iniFalOut
              "False clear input, initial false output" annotation (Placement(
                  transformation(extent={{-100,-70},{-80,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch iniTruOut(
                pre_y_start=true) "False clear input, initial true output"
              annotation (Placement(transformation(extent={{-100,-150},{-80,-130}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch swiCleInp
              "Initial false output, with clear input switch between false and true"
              annotation (Placement(transformation(extent={{100,90},{120,110}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch swiCleInp1
              "Initial false output, with clear input switch between false and true"
              annotation (Placement(transformation(extent={{100,-70},{120,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse cleInp(final
                width=0.5, final period=6)
              "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{0,70},{20,90}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
              "Logcal not" annotation (Placement(transformation(extent={{40,-70},
                      {60,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant fal(final k=
                  false) "False clear input" annotation (Placement(
                  transformation(extent={{-160,70},{-140,90}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse latInp(final
                width=0.5, final period=2)
              "Block that outputs cyclic on and off" annotation (Placement(
                  transformation(extent={{-160,150},{-140,170}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant tru(final k=
                  true) "True clear input" annotation (Placement(transformation(
                    extent={{-160,-10},{-140,10}})));

          equation
            connect(cleInp.y, swiCleInp.clr)
              annotation (Line(points={{21,80},{70,80},{70,94},{99,94}}, color={255,0,255}));
            connect(not1.u, cleInp.y)
              annotation (Line(points={{38,-60},{30,-60},{30,80},{21,80}},
                color={255,0,255}));
            connect(not1.y, swiCleInp1.clr)
              annotation (Line(points={{61,-60},{72,-60},{72,-66},{99,-66}},
                color={255,0,255}));
            connect(fal.y, falCle.clr)
              annotation (Line(points={{-139,80},{-112,80},{-112,94},{-101,94}},
                color={255,0,255}));
            connect(latInp.y, falCle.u)
              annotation (Line(points={{-139,160},{-120,160},{-120,100},{-101,100}},
                color={255,0,255}));
            connect(tru.y, truCle.clr)
              annotation (Line(points={{-139,0},{-106,0},{-106,14},{-101,14}},
                color={255,0,255}));
            connect(latInp.y, truCle.u)
              annotation (Line(points={{-139,160},{-120,160},{-120,20},{-101,20}},
                color={255,0,255}));
            connect(fal.y, iniFalOut.clr)
              annotation (Line(points={{-139,80},{-112,80},{-112,-66},{-101,-66}},
                color={255,0,255}));
            connect(fal.y,iniTruOut. clr)
              annotation (Line(points={{-139,80},{-112,80},{-112,-146},{-101,-146}},
                color={255,0,255}));
            connect(latInp.y, iniFalOut.u)
              annotation (Line(points={{-139,160},{-120,160},{-120,-60},{-101,-60}},
                color={255,0,255}));
            connect(latInp.y,iniTruOut. u)
              annotation (Line(points={{-139,160},{-120,160},{-120,-140},{-101,-140}},
                color={255,0,255}));
            connect(latInp.y, swiCleInp.u)
              annotation (Line(points={{-139,160},{80,160},{80,100},{99,100}},
                color={255,0,255}));
            connect(latInp.y, swiCleInp1.u)
              annotation (Line(points={{-139,160},{80,160},{80,-60},{99,-60}},
                color={255,0,255}));

          annotation (
            experiment(StopTime=10.0, Tolerance=1e-06),
             __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Latch.mos"
                   "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Latch\">
Buildings.Controls.OBC.CDL.Logical.Latch</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 4, 2019, by Jianjun Hu:<br/>
Added test to validate initial output. 
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1402\">issue 1402</a>.
</li>
<li>
March 30, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                   graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
              Diagram(coordinateSystem(extent={{-180,-180},{180,180}}), graphics={
                  Text(
                    extent={{-110,130},{-42,118}},
                    lineColor={28,108,200},
                    textString="Clear input keeps false"),
                  Text(
                    extent={{-108,60},{-40,48}},
                    lineColor={28,108,200},
                    textString="Clear input keeps true"),
                  Text(
                    extent={{-108,-20},{-40,-32}},
                    lineColor={28,108,200},
                    textString="Clear input keeps false"),
                  Text(
                    extent={{-108,-26},{0,-48}},
                    lineColor={28,108,200},
                    textString="Start value of y is false (default)"),
                  Text(
                    extent={{-108,-100},{-40,-112}},
                    lineColor={28,108,200},
                    textString="Clear input keeps false"),
                  Text(
                    extent={{-110,-110},{-28,-124}},
                    lineColor={28,108,200},
                    textString="Start value of y is true"),
                  Text(
                    extent={{-108,50},{-28,38}},
                    lineColor={28,108,200},
                    textString="Start value of y is true"),
                  Text(
                    extent={{76,148},{136,140}},
                    lineColor={28,108,200},
                    textString="At 3rd second:"),
                  Text(
                    extent={{92,128},{172,118}},
                    lineColor={28,108,200},
                    textString="Clear input falls: true to false"),
                  Text(
                    extent={{92,138},{170,128}},
                    lineColor={28,108,200},
                    textString="Latch input falls: true to false"),
                  Text(
                    extent={{92,64},{170,56}},
                    lineColor={28,108,200},
                    textString="Clear input rises: false to true"),
                  Text(
                    extent={{92,76},{172,66}},
                    lineColor={28,108,200},
                    textString="Latch input rise: false to true"),
                  Text(
                    extent={{76,86},{136,78}},
                    lineColor={28,108,200},
                    textString="At 6th second:"),
                  Text(
                    extent={{92,-96},{172,-104}},
                    lineColor={28,108,200},
                    textString="Clear input falls: true to false"),
                  Text(
                    extent={{92,-84},{172,-94}},
                    lineColor={28,108,200},
                    textString="Latch input rise: false to true"),
                  Text(
                    extent={{76,-74},{136,-82}},
                    lineColor={28,108,200},
                    textString="At 6th second:"),
                  Text(
                    extent={{76,-12},{136,-20}},
                    lineColor={28,108,200},
                    textString="At 3rd second:"),
                  Text(
                    extent={{92,-32},{172,-42}},
                    lineColor={28,108,200},
                    textString="Clear input rises: false to true"),
                  Text(
                    extent={{92,-22},{170,-32}},
                    lineColor={28,108,200},
                    textString="Latch input falls: true to false")}));
          end Latch;

          model LogicalSwitch "Validation model for the LogicalSwitch block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.7,
                period=1.5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-26,24},{-6,44}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=3)
              "Block that outputs cyclic on and off: switch between u1 and u3"
              annotation (Placement(transformation(extent={{-26,-10},{-6,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul3(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-46},{-6,-26}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.LogicalSwitch logicalSwitch
              "Switch between two boolean inputs"
              annotation (Placement(transformation(extent={{26,-10},{46,10}})));

          equation
            connect(booPul2.y, logicalSwitch.u2)
              annotation (Line(points={{-4,0},{-4,0},{24,0}}, color={255,0,255}));
            connect(booPul1.y, logicalSwitch.u1) annotation (Line(points={{-4,34},{10,34},
                    {10,8},{24,8}},
                                color={255,0,255}));
            connect(booPul3.y, logicalSwitch.u3) annotation (Line(points={{-4,-36},{10,
                    -36},{10,-8},{24,-8}},
                                      color={255,0,255}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
             __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/LogicalSwitch.mos"
                   "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.LogicalSwitch\">
Buildings.Controls.OBC.CDL.Logical.LogicalSwitch</a>.
</p>
<p>
The input <code>u2</code> is the switch input: If <code>u2 = true</code>,
then output <code>y = u1</code>;
else output <code>y = u3</code>.
</p>

</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end LogicalSwitch;

          model MultiAnd "Model to validate the application of MultiAnd block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.MultiAnd mulAnd0
              "Logical and with multiple inputs: 0 input"
              annotation (Placement(transformation(extent={{40,60},{60,80}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.MultiAnd mulAnd1(nu=1)
              "Logical 'MultiAnd': 1 input connection y=u"
              annotation (Placement(transformation(extent={{40,20},{60,40}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.MultiAnd mulAnd2(nu=2)
              "Logical 'MultiAnd': 2 input connections y=and(u1, u2)"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.MultiAnd mulAnd5(nu=5)
              "Logical 'MultiAnd': 5 input connections y=and(u1, u2, ..., u5)"
              annotation (Placement(transformation(extent={{40,-40},{60,-20}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.5,
                period=1) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,50},{-40,70}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=2) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,20},{-40,40}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul3(width=0.5,
                period=3) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul4(width=0.5,
                period=4) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,-40},{-40,-20}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul5(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,-70},{-40,-50}})));

          equation
            connect(booPul1.y, mulAnd5.u[1]) annotation (Line(points={{-38,60},{-38,60},{
                    20,60},{20,-24.4},{38,-24.4}},
                                                color={255,0,255}));
            connect(booPul2.y, mulAnd5.u[2]) annotation (Line(points={{-38,30},{14,30},{
                    14,-27.2},{38,-27.2}},
                                        color={255,0,255}));
            connect(booPul3.y, mulAnd5.u[3]) annotation (Line(points={{-38,0},{0,0},{0,
                    -30},{38,-30}},
                               color={255,0,255}));
            connect(booPul4.y, mulAnd5.u[4]) annotation (Line(points={{-38,-30},{-38,-30},
                    {-4,-30},{-4,-32},{-4,-32},{-4,-32.8},{38,-32.8}}, color={255,0,255}));
            connect(booPul5.y, mulAnd5.u[5]) annotation (Line(points={{-38,-60},{-38,-60},
                    {20,-60},{20,-35.6},{38,-35.6}}, color={255,0,255}));
            connect(booPul1.y, mulAnd2.u[1]) annotation (Line(points={{-38,60},{-38,60},{
                    20,60},{20,3.5},{38,3.5}},
                                            color={255,0,255}));
            connect(booPul2.y, mulAnd2.u[2]) annotation (Line(points={{-38,30},{-38,30},{
                    14,30},{14,-3.5},{38,-3.5}},
                                              color={255,0,255}));
            connect(booPul1.y, mulAnd1.u[1]) annotation (Line(points={{-38,60},{20,60},{
                    20,30},{38,30}},
                                  color={255,0,255}));
            annotation (
            experiment(StopTime=10.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/MultiAnd.mos"
                  "Simulate and plot"),
            Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.MultiAnd\">
Buildings.Controls.OBC.CDL.Logical.MultiAnd</a>.
</p>
<p>
The input signals are configured as follows:</p>
<ul>
<li>input <i>u<sub>1</sub></i> has a period of <i>1</i> s and a width of
<i>0.5</i> s.</li>
<li>input <i>u<sub>2</sub></i> has a period of <i>2</i> s and a width of
<i>0.5</i> s.</li>
<li>input <i>u<sub>3</sub></i> has a period of <i>3</i> s and a width of
<i>0.5</i> s.</li>
<li>input <i>u<sub>4</sub></i> has a period of <i>4</i> s and a width of
<i>0.5</i> s.</li>
<li>input <i>u<sub>5</sub></i> has a period of <i>5</i> s and a width of
<i>0.5</i> s.</li>
</ul>

</html>",           revisions="<html>
<ul>
<li>
June 28, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MultiAnd;

          model MultiOr "Model to validate the application of MultiOr block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.MultiOr mulOr0
              "Logical 'MultiOr': 1 input connection y=u"
              annotation (Placement(transformation(extent={{40,60},{60,80}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.MultiOr mulOr1(nu=1)
              "Logical 'MultiOr': 1 input connection y=u"
              annotation (Placement(transformation(extent={{40,20},{60,40}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.MultiOr mulOr2(nu=2)
              "Logical 'MultiOr': 2 input connections y=and(u1, u2)"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.MultiOr mulOr5(nu=5)
              "Logical 'MultiOr': 5 input connections y=and(u1, u2, ..., u5)"
              annotation (Placement(transformation(extent={{40,-40},{60,-20}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.5,
                period=1) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,50},{-40,70}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=2) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,20},{-40,40}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul3(width=0.5,
                period=3) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul4(width=0.5,
                period=4) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,-40},{-40,-20}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul5(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-60,-70},{-40,-50}})));

          equation
            connect(booPul1.y, mulOr5.u[1]) annotation (Line(points={{-39,60},{-39,60},{20,
                    60},{20,-24.4},{38,-24.4}}, color={255,0,255}));
            connect(booPul2.y, mulOr5.u[2]) annotation (Line(points={{-39,30},{14,30},{14,
                    -27.2},{38,-27.2}}, color={255,0,255}));
            connect(booPul3.y, mulOr5.u[3]) annotation (Line(points={{-39,0},{0,0},{0,-30},
                    {38,-30}}, color={255,0,255}));
            connect(booPul4.y, mulOr5.u[4]) annotation (Line(points={{-39,-30},{-39,-30},{
                    -4,-30},{-4,-32},{-4,-32},{-4,-32.8},{38,-32.8}}, color={255,0,255}));
            connect(booPul5.y, mulOr5.u[5]) annotation (Line(points={{-39,-60},{-39,-60},{
                    20,-60},{20,-35.6},{38,-35.6}}, color={255,0,255}));
            connect(booPul1.y, mulOr2.u[1]) annotation (Line(points={{-39,60},{-39,60},{20,
                    60},{20,3.5},{38,3.5}}, color={255,0,255}));
            connect(booPul2.y, mulOr2.u[2]) annotation (Line(points={{-39,30},{-39,30},{14,
                    30},{14,-3.5},{38,-3.5}}, color={255,0,255}));
            connect(booPul1.y, mulOr1.u[1]) annotation (Line(points={{-39,60},{20,60},{20,
                    30},{38,30}}, color={255,0,255}));
            annotation (
            experiment(StopTime=10.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/MultiOr.mos"
                  "Simulate and plot"),
            Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.MultiOr\">
Buildings.Controls.OBC.CDL.Logical.MultiOr</a>.
</p>
<p>
The input signals are configured as follows:</p>
<ul>
<li>input <i>u<sub>1</sub></i> has a period of <i>1</i> s and a width of
<i>0.5</i> s.</li>
<li>input <i>u<sub>2</sub></i> has a period of <i>2</i> s and a width of
<i>0.5</i> s.</li>
<li>input <i>u<sub>3</sub></i> has a period of <i>3</i> s and a width of
<i>0.5</i> s.</li>
<li>input <i>u<sub>4</sub></i> has a period of <i>4</i> s and a width of
<i>0.5</i> s.</li>
<li>input <i>u<sub>5</sub></i> has a period of <i>5</i> s and a width of
<i>0.5</i> s.</li>
</ul>

</html>",           revisions="<html>
<ul>
<li>
June 6, 2019, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end MultiOr;

          model Nand "Validation model for the Nand block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.5,
                period=1.5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-26,8},{-6,28}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-26},{-6,-6}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Nand nand1
              "Outputs true if at least one input is false"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(booPul2.y, nand1.u2) annotation (Line(points={{-4,-16},{8,-16},{8,-6},
                    {24,-6}}, color={255,0,255}));
            connect(booPul1.y, nand1.u1) annotation (Line(points={{-4,18},{10,18},{10,2},
                    {24,2}},color={255,0,255}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Nand.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Nand\">
Buildings.Controls.OBC.CDL.Logical.Nand</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Nand;

          model Nor "Validation model for the Nor block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.5,
                period=1.5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-26,8},{-6,28}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-26},{-6,-6}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Nor nor1
              "Outputs true if none of the inputs is true, otherwise outputs false"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(booPul2.y, nor1.u2) annotation (Line(points={{-4,-16},{8,-16},{8,-6},
                    {24,-6}}, color={255,0,255}));
            connect(booPul1.y, nor1.u1) annotation (Line(points={{-4,18},{10,18},{10,2},{
                    24,2}}, color={255,0,255}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Nor.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Nor\">
Buildings.Controls.OBC.CDL.Logical.Nor</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Nor;

          model Not "Validation model for the Not block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                period=1.5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-10},{-6,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
              "Output true when input is false and output false when input is true"
              annotation (Placement(transformation(extent={{26,-10},{46,10}})));

          equation
            connect(booPul.y, not1.u)
              annotation (Line(points={{-4,0},{-4,0},{24,0}},color={255,0,255}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Not.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Not\">
Buildings.Controls.OBC.CDL.Logical.Not</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Not;

          model OnOffController  "Validation model for the OnOffController block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=5,
              offset=0,
              height=31.415926) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-76,-16},{-56,4}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
              "Block that outputs the sine of the input" annotation (Placement(
                  transformation(extent={{-32,-16},{-12,4}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant cons2(k=0.7)
              "Constant as source term" annotation (Placement(transformation(
                    extent={{-32,18},{-12,38}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.OnOffController onOffController(bandwidth
                =0.1)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{26,-10},{46,10}})));

          equation
            connect(ramp1.y, sin1.u)
              annotation (Line(points={{-55,-6},{-34,-6}}, color={0,0,127}));
            connect(sin1.y, onOffController.u)
              annotation (Line(points={{-11,-6},{6,-6},{24,-6}}, color={0,0,127}));
            connect(cons2.y, onOffController.reference)
              annotation (Line(points={{-11,28},{6,28},{6,6},{24,6}}, color={0,0,127}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/OnOffController.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.OnOffController\">
Buildings.Controls.OBC.CDL.Logical.OnOffController</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end OnOffController;

          model Or "Validation model for the Or block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.5,
                period=1.5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-26,8},{-6,28}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=3) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-26},{-6,-6}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or1
              "Output true if at least one input is true"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(booPul2.y, or1.u2) annotation (Line(points={{-4,-16},{8,-16},{8,-6},{
                    24,-6}},  color={255,0,255}));
            connect(booPul1.y, or1.u1) annotation (Line(points={{-4,18},{10,18},{10,2},{
                    24,2}}, color={255,0,255}));
            annotation (
            experiment(StopTime=10.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Or.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Or\">
Buildings.Controls.OBC.CDL.Logical.Or</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Or;

          model Or3 "Validation model for the Or3 block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.5,
                period=1.5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-26,26},{-6,46}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=3) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-26,-8},{-6,12}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or3 or1
              "Output true if at least one input is true"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul3(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-42},{-6,-22}})));
          equation
            connect(booPul3.y, or1.u3) annotation (Line(points={{-4,-32},{8,-32},{8,-6},{
                    24,-6}},
                          color={255,0,255}));
            connect(booPul2.y, or1.u2)
              annotation (Line(points={{-4,2},{-4,2},{24,2}},  color={255,0,255}));
            connect(booPul1.y, or1.u1) annotation (Line(points={{-4,36},{10,36},{10,10},{
                    24,10}},
                          color={255,0,255}));
            annotation (
            experiment(StopTime=10.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Or3.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Or3\">
Buildings.Controls.OBC.CDL.Logical.Or3</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 10, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Or3;

          model Switch "Validation model for the Switch block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=5,
              offset=-1,
              height=6) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{-26,22},{-6,42}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=5,
              offset=-1,
              height=2) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-26,-42},{-6,-22}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                period=2) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-10},{-6,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch switch1
              "Switch between two real inputs"
              annotation (Placement(transformation(extent={{26,-10},{46,10}})));

          equation
            connect(booPul.y, switch1.u2)
              annotation (Line(points={{-4,0},{-4,0},{24,0}}, color={255,0,255}));
            connect(ramp2.y, switch1.u3) annotation (Line(points={{-4,-32},{8,-32},{8,-8},
                    {24,-8}}, color={0,0,127}));
            connect(ramp1.y, switch1.u1)
              annotation (Line(points={{-4,32},{8,32},{8,8},{24,8}}, color={0,0,127}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Switch.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Switch\">
Buildings.Controls.OBC.CDL.Logical.Switch</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Switch;

          model Timer "Validation model for the Timer block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Timer resetTimer
              "Timer will reset"
              annotation (Placement(transformation(extent={{20,70},{40,90}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Timer accuTimer(final
                accumulate=true) "Reset timer based on boolean input"
              annotation (Placement(transformation(extent={{20,30},{40,50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Timer accuTimer1(final
                accumulate=true) "Reset timer based on boolean input"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Timer accuTimer2(final
                accumulate=true) "Reset timer based on boolean input"
              annotation (Placement(transformation(extent={{20,-50},{40,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Timer accuTimer3(final
                accumulate=true) "Reset timer based on boolean input"
              annotation (Placement(transformation(extent={{20,-80},{40,-60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(final
                width=0.1, final period=4)
              "Block that outputs cyclic on and off" annotation (Placement(
                  transformation(extent={{-40,30},{-20,50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterEqualThreshold
              greEquThr(final threshold=1.5)
              "Output true when input is greater than threshold" annotation (
                Placement(transformation(extent={{-80,-80},{-60,-60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Pre pre
              "Returns the value of the input signal from the last event iteration"
              annotation (Placement(transformation(extent={{-40,-80},{-20,-60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(final
                width=0.5, final period=2)
              "Block that outputs cyclic on and off" annotation (Placement(
                  transformation(extent={{-40,70},{-20,90}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(
              final width=0.5,
              final period=2,
              final startTime=0.5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-40,-50},{-20,-30}})));

          equation
            connect(booPul.y, resetTimer.u)
              annotation (Line(points={{-18,80},{18,80}}, color={255,0,255}));
            connect(booPul.y, accuTimer.u)
              annotation (Line(points={{-18,80},{0,80},{0,40},{18,40}},
                color={255,0,255}));
            connect(booPul1.y, accuTimer.reset)
              annotation (Line(points={{-18,40},{-10,40},{-10,32},{18,32}},color={255,0,255}));
            connect(booPul.y,accuTimer3. u)
              annotation (Line(points={{-18,80},{0,80},{0,-70},{18,-70}},
                color={255,0,255}));
            connect(accuTimer3.y, greEquThr.u)
              annotation (Line(points={{42,-70},{60,-70},{60,-90},{-92,-90},{-92,-70},
                {-82,-70}}, color={0,0,127}));
            connect(greEquThr.y, pre.u)
              annotation (Line(points={{-58,-70},{-42,-70}}, color={255,0,255}));
            connect(pre.y,accuTimer3. reset)
              annotation (Line(points={{-18,-70},{-10,-70},{-10,-78},{18,-78}},
                color={255,0,255}));
            connect(booPul.y, accuTimer1.u)
              annotation (Line(points={{-18,80},{0,80},{0,0},{18,0}}, color={255,0,255}));
            connect(booPul.y, accuTimer1.reset)
              annotation (Line(points={{-18,80},{0,80},{0,-8},{18,-8}}, color={255,0,255}));
            connect(booPul.y, accuTimer2.reset)
              annotation (Line(points={{-18,80},{0,80},{0,-48},{18,-48}}, color={255,0,255}));
            connect(booPul2.y, accuTimer2.u)
              annotation (Line(points={{-18,-40},{18,-40}}, color={255,0,255}));

          annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Timer.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Timer\">
Buildings.Controls.OBC.CDL.Logical.Timer</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 23, 2018, by Jianjun Hu:<br/>
Updated implementation to reset accumulate timer with boolean input.
</li>
<li>
July 18, 2018, by Jianjun Hu:<br/>
Updated implementation to include accumulate timer.
</li>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Timer;

          model Toggle "Validation model for the Toggle block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Toggle falCle
              "Latch block with clear input being contantly false" annotation (
                Placement(transformation(extent={{-100,90},{-80,110}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Toggle truCle(
                pre_y_start=true)
              "Latch block with clear input being contantly true" annotation (
                Placement(transformation(extent={{-100,10},{-80,30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Toggle iniFalOut
              "False clear input, initial false output" annotation (Placement(
                  transformation(extent={{-100,-70},{-80,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Toggle iniTruOut(
                pre_y_start=true) "False clear input, initial true output"
              annotation (Placement(transformation(extent={{-100,-150},{-80,-130}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Toggle swiCleInp
              "Initial false output, with clear input switch between false and true"
              annotation (Placement(transformation(extent={{100,90},{120,110}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Toggle swiCleInp1
              "Initial false output, with clear input switch between false and true"
              annotation (Placement(transformation(extent={{100,-70},{120,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse cleInp(final
                width=0.5, final period=6)
              "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{0,70},{20,90}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
              "Logical not" annotation (Placement(transformation(extent={{40,-70},
                      {60,-50}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant fal(final k=
                  false) "False clear input" annotation (Placement(
                  transformation(extent={{-160,70},{-140,90}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse togInp(final
                width=0.5, final period=2)
              "Block that outputs cyclic on and off" annotation (Placement(
                  transformation(extent={{-160,150},{-140,170}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant tru(final k=
                  true) "True clear input" annotation (Placement(transformation(
                    extent={{-160,-10},{-140,10}})));

          equation
            connect(cleInp.y,swiCleInp. clr)
              annotation (Line(points={{21,80},{70,80},{70,94},{99,94}}, color={255,0,255}));
            connect(not1.u,cleInp. y)
              annotation (Line(points={{38,-60},{30,-60},{30,80},{21,80}},
                color={255,0,255}));
            connect(not1.y,swiCleInp1. clr)
              annotation (Line(points={{61,-60},{72,-60},{72,-66},{99,-66}},
                color={255,0,255}));
            connect(fal.y,falCle. clr)
              annotation (Line(points={{-139,80},{-112,80},{-112,94},{-101,94}},
                color={255,0,255}));
            connect(togInp.y,falCle. u)
              annotation (Line(points={{-139,160},{-120,160},{-120,100},{-101,100}},
                color={255,0,255}));
            connect(tru.y,truCle. clr)
              annotation (Line(points={{-139,0},{-106,0},{-106,14},{-101,14}},
                color={255,0,255}));
            connect(togInp.y,truCle. u)
              annotation (Line(points={{-139,160},{-120,160},{-120,20},{-101,20}},
                color={255,0,255}));
            connect(fal.y,iniFalOut. clr)
              annotation (Line(points={{-139,80},{-112,80},{-112,-66},{-101,-66}},
                color={255,0,255}));
            connect(fal.y,iniTruOut. clr)
              annotation (Line(points={{-139,80},{-112,80},{-112,-146},{-101,-146}},
                color={255,0,255}));
            connect(togInp.y,iniFalOut. u)
              annotation (Line(points={{-139,160},{-120,160},{-120,-60},{-101,-60}},
                color={255,0,255}));
            connect(togInp.y,iniTruOut. u)
              annotation (Line(points={{-139,160},{-120,160},{-120,-140},{-101,-140}},
                color={255,0,255}));
            connect(togInp.y,swiCleInp. u)
              annotation (Line(points={{-139,160},{80,160},{80,100},{99,100}},
                color={255,0,255}));
            connect(togInp.y,swiCleInp1. u)
              annotation (Line(points={{-139,160},{80,160},{80,-60},{99,-60}},
                color={255,0,255}));

          annotation (
            experiment(StopTime=10.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Toggle.mos"
                    "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Toggle\">
Buildings.Controls.OBC.CDL.Logical.Toggle</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 4, 2019, by Jianjun Hu:<br/>
Added test to validate initial output. 
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1402\">issue 1402</a>.
</li>
<li>
March 31, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
                   graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
              Diagram(coordinateSystem(extent={{-180,-180},{180,180}}), graphics={
                  Text(
                    extent={{-110,130},{-42,118}},
                    lineColor={28,108,200},
                    textString="Clear input keeps false"),
                  Text(
                    extent={{-108,60},{-40,48}},
                    lineColor={28,108,200},
                    textString="Clear input keeps true"),
                  Text(
                    extent={{-108,-20},{-40,-32}},
                    lineColor={28,108,200},
                    textString="Clear input keeps false"),
                  Text(
                    extent={{-108,-26},{0,-48}},
                    lineColor={28,108,200},
                    textString="Start value of y is false (default)"),
                  Text(
                    extent={{-108,-100},{-40,-112}},
                    lineColor={28,108,200},
                    textString="Clear input keeps false"),
                  Text(
                    extent={{-110,-110},{-28,-124}},
                    lineColor={28,108,200},
                    textString="Start value of y is true"),
                  Text(
                    extent={{-108,50},{-28,38}},
                    lineColor={28,108,200},
                    textString="Start value of y is true"),
                  Text(
                    extent={{76,148},{136,140}},
                    lineColor={28,108,200},
                    textString="At 3rd second:"),
                  Text(
                    extent={{92,128},{172,118}},
                    lineColor={28,108,200},
                    textString="Clear input falls: true to false"),
                  Text(
                    extent={{92,138},{170,128}},
                    lineColor={28,108,200},
                    textString="Toggle input falls: true to false"),
                  Text(
                    extent={{92,64},{170,56}},
                    lineColor={28,108,200},
                    textString="Clear input rises: false to true"),
                  Text(
                    extent={{92,76},{172,66}},
                    lineColor={28,108,200},
                    textString="Toggle input rise: false to true"),
                  Text(
                    extent={{76,86},{136,78}},
                    lineColor={28,108,200},
                    textString="At 6th second:"),
                  Text(
                    extent={{92,-96},{172,-104}},
                    lineColor={28,108,200},
                    textString="Clear input falls: true to false"),
                  Text(
                    extent={{92,-84},{172,-94}},
                    lineColor={28,108,200},
                    textString="Toggle input rise: false to true"),
                  Text(
                    extent={{76,-74},{136,-82}},
                    lineColor={28,108,200},
                    textString="At 6th second:"),
                  Text(
                    extent={{76,-12},{136,-20}},
                    lineColor={28,108,200},
                    textString="At 3rd second:"),
                  Text(
                    extent={{92,-32},{172,-42}},
                    lineColor={28,108,200},
                    textString="Clear input rises: false to true"),
                  Text(
                    extent={{92,-22},{170,-32}},
                    lineColor={28,108,200},
                    textString="Toggle input falls: true to false")}));
          end Toggle;

          model TriggeredTrapezoid  "Validation model for the TriggeredTrapezoid block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(width=0.5,
                period=2) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-10},{-6,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TriggeredTrapezoid triggeredTrapezoid1(
              amplitude=5,
              rising=0.3,
              offset=1.5) "Triggered trapezoid generator"
              annotation (Placement(transformation(extent={{26,-10},{46,10}})));

          equation
            connect(booPul.y, triggeredTrapezoid1.u)
              annotation (Line(points={{-5,0},{9.5,0},{24,0}}, color={255,0,255}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/TriggeredTrapezoid.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.TriggeredTrapezoid\">
Buildings.Controls.OBC.CDL.Logical.TriggeredTrapezoid</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end TriggeredTrapezoid;

          model TrueDelay "Validation model for the TrueDelay block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay0(final
                delayTime=0)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{0,130},{20,150}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay1(final
                delayTime=0.5)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{60,130},{80,150}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay2(final
                delayTime=0.8)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{0,100},{20,120}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay4(final
                delayTime=0)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{0,40},{20,60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay5(final
                delayTime=0.5)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{60,40},{80,60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay6(final
                delayTime=0.8)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{0,10},{20,30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
              "Negation of input signal" annotation (Placement(transformation(
                    extent={{-60,60},{-40,80}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay3(final
                delayTime=1.8)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{60,100},{80,120}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay7(final
                delayTime=1.8)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{60,10},{80,30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay00(final
                delayTime=0, final delayOnInit=true)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{0,-50},{20,-30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay11(final
                delayTime=0.5, final delayOnInit=true)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{60,-50},{80,-30}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay22(final
                delayTime=0.8, final delayOnInit=true)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{0,-80},{20,-60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay44(final
                delayTime=0, final delayOnInit=true)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{0,-140},{20,-120}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay55(final
                delayTime=0.5, final delayOnInit=true)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{60,-140},{80,-120}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay66(final
                delayTime=0.8, final delayOnInit=true)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{0,-170},{20,-150}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not2
              "Negation of input signal" annotation (Placement(transformation(
                    extent={{-60,-120},{-40,-100}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay33(final
                delayTime=1.8, final delayOnInit=true)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{60,-80},{80,-60}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueDelay onDelay77(final
                delayTime=1.8, final delayOnInit=true)
              "Delay a rising edge of the input, but do not delay a falling edge."
              annotation (Placement(transformation(extent={{60,-170},{80,-150}})));

          protected
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(final
                width=0.5, final period=1.5)
              "Block that outputs cyclic on and off" annotation (Placement(
                  transformation(extent={{-100,80},{-80,100}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(final
                width=0.5, final period=1.5)
              "Block that outputs cyclic on and off" annotation (Placement(
                  transformation(extent={{-100,-100},{-80,-80}})));

          equation
            connect(booPul.y, not1.u)
              annotation (Line(points={{-79,90},{-70,90},{-70,70},{-62,70}},
                color={255,0,255}));
            connect(booPul.y, onDelay0.u)
              annotation (Line(points={{-79,90},{-20,90},{-20,
                    140},{-2,140}}, color={255,0,255}));
            connect(booPul.y, onDelay2.u)
              annotation (Line(points={{-79,90},{-20,90},{-20,110},{-2,110}},
                color={255,0,255}));
            connect(booPul.y, onDelay1.u)
              annotation (Line(points={{-79,90},{40,90},{40,140},{58,140}},
                color={255,0,255}));
            connect(booPul.y, onDelay3.u)
              annotation (Line(points={{-79,90},{40,90},{40,110},{58,110}},
                color={255,0,255}));
            connect(not1.y, onDelay4.u)
              annotation (Line(points={{-39,70},{-20,70},{-20,50},{-2,50}},
                color={255,0,255}));
            connect(not1.y, onDelay6.u)
              annotation (Line(points={{-39,70},{-20,70},{-20,20},{-2,20}},
                color={255,0,255}));
            connect(not1.y, onDelay5.u)
              annotation (Line(points={{-39,70},{40,70},{40,50},{58,50}},
                color={255,0,255}));
            connect(not1.y, onDelay7.u)
              annotation (Line(points={{-39,70},{40,70},{40,20},{58,20}},
                color={255,0,255}));

            connect(booPul1.y, not2.u)
              annotation (Line(points={{-79,-90},{-70,-90},{-70,
                    -110},{-62,-110}}, color={255,0,255}));
            connect(booPul1.y, onDelay00.u)
              annotation (Line(points={{-79,-90},{-20,-90},
                    {-20,-40},{-2,-40}}, color={255,0,255}));
            connect(booPul1.y, onDelay22.u)
              annotation (Line(points={{-79,-90},{-20,-90},
                    {-20,-70},{-2,-70}}, color={255,0,255}));
            connect(booPul1.y, onDelay11.u)
              annotation (Line(points={{-79,-90},{40,-90},{
                    40,-40},{58,-40}}, color={255,0,255}));
            connect(booPul1.y, onDelay33.u)
              annotation (Line(points={{-79,-90},{40,-90},{
                    40,-70},{58,-70}}, color={255,0,255}));
            connect(not2.y, onDelay44.u)
              annotation (Line(points={{-39,-110},{-20,-110},{
                    -20,-130},{-2,-130}}, color={255,0,255}));
            connect(not2.y, onDelay66.u)
              annotation (Line(points={{-39,-110},{-20,-110},{
                    -20,-160},{-2,-160}}, color={255,0,255}));
            connect(not2.y, onDelay55.u)
              annotation (Line(points={{-39,-110},{40,-110},{
                    40,-130},{58,-130}}, color={255,0,255}));
            connect(not2.y, onDelay77.u)
              annotation (Line(points={{-39,-110},{40,-110},{
                    40,-160},{58,-160}}, color={255,0,255}));

          annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/TrueDelay.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.TrueDelay\">
Buildings.Controls.OBC.CDL.Logical.TrueDelay</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
February 11, 2019, by Milica Grahovac:<br/>
Added tests for initial true input delay.
</li>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
              Diagram(coordinateSystem(extent={{-100,-180},{100,180}})));
          end TrueDelay;

          model TrueFalseHold "Validation model for the TrueFalseHold block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(startTime
                =0, period=1500) "Boolean pulse input signal" annotation (
                Placement(transformation(extent={{-140,60},{-120,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold truFalHol(
                trueHoldDuration=1000)
              "The block introduces a minimal offset between the input signal rising and falling edge"
              annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(
              startTime=0,
              period=1000,
              width=0.25) "Boolean pulse input signal" annotation (Placement(
                  transformation(extent={{-140,20},{-120,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold truFalHol1(
                trueHoldDuration=1000)
              "The block introduces a minimal offset between the input signal rising and falling edge"
              annotation (Placement(transformation(extent={{-40,20},{-20,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(startTime
                =0, period=1500) "Boolean pulse input signal" annotation (
                Placement(transformation(extent={{-140,-20},{-120,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold truFalHol2(
                trueHoldDuration=1000)
              "The block introduces a minimal offset between the input signal rising and falling edge"
              annotation (Placement(transformation(extent={{-40,-20},{-20,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul3(
              startTime=0,
              period=1000,
              width=0.25) "Boolean pulse input signal" annotation (Placement(
                  transformation(extent={{-140,-60},{-120,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold truFalHol3(
                trueHoldDuration=1000)
              "The block introduces a minimal offset between the input signal rising and falling edge"
              annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
              "Negation of input signal" annotation (Placement(transformation(
                    extent={{-90,-20},{-70,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not3
              "Negation of input signal" annotation (Placement(transformation(
                    extent={{-90,-60},{-70,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul4(startTime
                =100, period=1500) "Boolean pulse input signal"
              annotation (Placement(transformation(extent={{20,60},{40,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold truFalHol4(
                trueHoldDuration=1000)
              "The block introduces a minimal offset between the input signal rising and falling edge"
              annotation (Placement(transformation(extent={{120,60},{140,80}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul5(
              startTime=100,
              period=1000,
              width=0.25) "Boolean pulse input signal"
              annotation (Placement(transformation(extent={{20,20},{40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold truFalHol5(
                trueHoldDuration=1000)
              "The block introduces a minimal offset between the input signal rising and falling edge"
              annotation (Placement(transformation(extent={{120,20},{140,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul6(startTime
                =100, period=1500) "Boolean pulse input signal"
              annotation (Placement(transformation(extent={{20,-20},{40,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold truFalHol6(
                trueHoldDuration=1000)
              "The block introduces a minimal offset between the input signal rising and falling edge"
              annotation (Placement(transformation(extent={{120,-20},{140,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul7(
              startTime=100,
              period=1000,
              width=0.25) "Boolean pulse input signal" annotation (Placement(
                  transformation(extent={{20,-60},{40,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueFalseHold truFalHol7(
                trueHoldDuration=1000)
              "The block introduces a minimal offset between the input signal rising and falling edge"
              annotation (Placement(transformation(extent={{120,-60},{140,-40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not2
              "Negation of input signal"
              annotation (Placement(transformation(extent={{70,-20},{90,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not4
              "Negation of input signal" annotation (Placement(transformation(
                    extent={{70,-60},{90,-40}})));
          equation
            connect(booPul.y, truFalHol.u)
              annotation (Line(points={{-119,70},{-80,70},{-41,70}},
                                                                color={255,0,255}));
            connect(booPul1.y, truFalHol1.u)
              annotation (Line(points={{-119,30},{-41,30}},   color={255,0,255}));
            connect(booPul2.y, not1.u)
              annotation (Line(points={{-119,-10},{-92,-10}}, color={255,0,255}));
            connect(not1.y, truFalHol2.u)
              annotation (Line(points={{-69,-10},{-41,-10}},   color={255,0,255}));
            connect(booPul3.y, not3.u)
              annotation (Line(points={{-119,-50},{-92,-50}}, color={255,0,255}));
            connect(not3.y, truFalHol3.u)
              annotation (Line(points={{-69,-50},{-41,-50}},   color={255,0,255}));
            connect(booPul4.y, truFalHol4.u)
              annotation (Line(points={{41,70},{119,70}},   color={255,0,255}));
            connect(booPul5.y, truFalHol5.u)
              annotation (Line(points={{41,30},{119,30}},   color={255,0,255}));
            connect(booPul6.y, not2.u)
              annotation (Line(points={{41,-10},{68,-10}}, color={255,0,255}));
            connect(not2.y, truFalHol6.u)
              annotation (Line(points={{91,-10},{119,-10}},   color={255,0,255}));
            connect(booPul7.y, not4.u)
              annotation (Line(points={{41,-50},{68,-50}}, color={255,0,255}));
            connect(not4.y, truFalHol7.u)
              annotation (Line(points={{91,-50},{119,-50}},   color={255,0,255}));
            annotation (
            experiment(StopTime=7200.0, Tolerance=1e-06),
            __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/TrueFalseHold.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.TrueFalseHold\">
Buildings.Controls.OBC.CDL.Logical.TrueFalseHold</a>.
</p>
<p>
The validation uses different instances to validate different hold trueHoldDurations, different lengths
of the input pulse, and different initial values for the input signal.
</p>
</html>",           revisions="<html>
<ul>
<li>
June 14, 2017, by Michael Wetter:<br/>
Added more tests for different initial signals and different hold values.
</li>
<li>
May 24, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"),    Diagram(coordinateSystem(extent={{-160,-100},{160,100}})),
              Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end TrueFalseHold;

          model TrueHoldWithReset "Validation model for the TrueHoldWithReset block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(period=
                  9000, startTime=300) "Boolean pulse input signal" annotation
              (Placement(transformation(extent={{-40,70},{-20,90}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueHoldWithReset truHol(duration=
                  3600)
              "Block that holds a signal on for a requested time period"
              annotation (Placement(transformation(extent={{20,70},{40,90}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(period=
                  3600) "Boolean pulse input signal" annotation (Placement(
                  transformation(extent={{-40,20},{-20,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueHoldWithReset truHol1(duration=
                  600)
              "Block that holds a signal on for a requested time period"
              annotation (Placement(transformation(extent={{20,20},{40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(period=
                  9000, startTime=300) "Boolean pulse input signal" annotation
              (Placement(transformation(extent={{-40,-20},{-20,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueHoldWithReset truHol2(duration=
                  3600)
              "Block that holds a signal on for a requested time period"
              annotation (Placement(transformation(extent={{20,-20},{40,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul3(period=
                  3600) "Boolean pulse input signal" annotation (Placement(
                  transformation(extent={{-40,-70},{-20,-50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueHoldWithReset truHol3(duration=
                  600)
              "Block that holds a signal on for a requested time period"
              annotation (Placement(transformation(extent={{20,-70},{40,-50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not2
              "Negation of input signal"
              annotation (Placement(transformation(extent={{-10,-20},{10,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not3
              "Negation of input signal" annotation (Placement(transformation(
                    extent={{-10,-70},{10,-50}})));
          equation
            connect(booPul.y, truHol.u)
              annotation (Line(points={{-19,80},{2,80},{19,80}},
                                                              color={255,0,255}));
            connect(booPul1.y, truHol1.u)
              annotation (Line(points={{-19,30},{19,30}},
                                                        color={255,0,255}));
            connect(booPul2.y, not2.u)
              annotation (Line(points={{-19,-10},{-12,-10}}, color={255,0,255}));
            connect(not2.y, truHol2.u)
              annotation (Line(points={{11,-10},{19,-10}}, color={255,0,255}));
            connect(booPul3.y, not3.u)
              annotation (Line(points={{-19,-60},{-12,-60}}, color={255,0,255}));
            connect(not3.y, truHol3.u)
              annotation (Line(points={{11,-60},{19,-60}}, color={255,0,255}));
            annotation (
            experiment(StopTime=15000.0, Tolerance=1e-06),
            __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/TrueHoldWithReset.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.TrueHoldWithReset\">
Buildings.Controls.OBC.CDL.Logical.TrueHoldWithReset</a>.
</p>
<p>
The validation uses different instances to validate different hold durations, different lengths
of the input pulse, and different initial values for the input signal.
</p>
</html>",           revisions="<html>
<ul>
<li>
June 14, 2017, by Michael Wetter:<br/>
Added more tests for different initial signals and different hold values.
</li>
<li>
May 24, 2017, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end TrueHoldWithReset;

          model Xor "Validation model for the Xor block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=0.5,
                period=1.5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-26,8},{-6,28}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul2(width=0.5,
                period=5) "Block that outputs cyclic on and off" annotation (
                Placement(transformation(extent={{-26,-26},{-6,-6}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Xor xor1
              "Outputs true if exactly one input is true"
              annotation (Placement(transformation(extent={{26,-8},{46,12}})));

          equation
            connect(booPul2.y, xor1.u2) annotation (Line(points={{-4,-16},{8,-16},{8,-6},
                    {24,-6}}, color={255,0,255}));
            connect(booPul1.y, xor1.u1) annotation (Line(points={{-4,18},{10,18},{10,2},{
                    24,2}}, color={255,0,255}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/Xor.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.Xor\">
Buildings.Controls.OBC.CDL.Logical.Xor</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Xor;

          model ZeroCrossing "Validation model for the zero crossing block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp1(
              duration=5,
              offset=0,
              height=31.415926) "Block that generates ramp signal" annotation (
                Placement(transformation(extent={{-82,-10},{-62,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sin sin1
              "Block that outputs the sine of the input" annotation (Placement(
                  transformation(extent={{-38,-10},{-18,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul1(width=
                  0.15, period=5) "Block that outputs cyclic on and off"
              annotation (Placement(transformation(extent={{-38,-44},{-18,-24}})));
              hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.ZeroCrossing zeroCrossing
              "Zero crossing block"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ramp2(
              duration=5,
              offset=0,
              height=31.415926) "Block that generates ramp signal"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));

            Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triggeredSampler
              "Triggered sampler"
              annotation (Placement(transformation(extent={{60,40},{80,60}})));
          equation
            connect(booPul1.y, zeroCrossing.enable)
              annotation (Line(points={{-17,-34},{10,-34},{10,-12}},color={255,0,255}));
            connect(ramp1.y, sin1.u)
              annotation (Line(points={{-61,0},{-50.5,0},{-40,0}},    color={0,0,127}));
            connect(sin1.y, zeroCrossing.u)
              annotation (Line(points={{-17,0},{-2,0}},         color={0,0,127}));
            connect(ramp2.y, triggeredSampler.u)
              annotation (Line(points={{21,50},{58,50},{58,50}}, color={0,0,127}));
            connect(zeroCrossing.y, triggeredSampler.trigger) annotation (Line(points={{21,0},{70,0},
                    {70,36},{70,38},{70,38},{70,38.2}}, color={255,0,255}));
            annotation (
            experiment(StopTime=5.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Logical/Validation/ZeroCrossing.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical.ZeroCrossing\">
Buildings.Controls.OBC.CDL.Logical.ZeroCrossing</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 2, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>

</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end ZeroCrossing;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Logical\">
Buildings.Controls.OBC.CDL.Logical</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),  Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={8.0,14.0},
                  lineColor={78,138,73},
                  fillColor={78,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
        end Validation;
      annotation (
      Documentation(
      info="<html>
<p>
Package with blocks for elementary mathematical functions
for boolean variables.
</p>
</html>",
      revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
                     Line(
                points={{-86,-22},{-50,-22},{-50,22},{48,22},{48,-22},{88,-24}},
                color={255,0,255})}));
      end Logical;

      package Psychrometrics "Package with psychrometric blocks"

        block TDewPoi_TDryBulPhi
          "Block to compute the dew point temperature based on relative humidity"

          Interfaces.RealInput TDryBul(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            final min=100) "Dry bulb temperature"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Interfaces.RealInput phi(final min=0, final max=1, unit="1")
            "Relative air humidity"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealInput p(final quantity="Pressure",
                                 final unit="Pa",
                                 final min = 0) "Pressure"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.RealOutput TDewPoi(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            final min=100) "Dew point temperature"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          Modelica.SIunits.Pressure p_w(displayUnit="Pa") "Water vapor pressure";
          constant Real C14=6.54 "Constant used in the equation";
          constant Real C15=14.526 "Constant used in the equation";
          constant Real C16=0.7389 "Constant used in the equation";
          constant Real C17=0.09486 "Constant used in the equation";
          constant Real C18=0.4569 "Constant used in the equation";
          Real alpha "Variable used in the equation";

        equation
          p_w = phi * Buildings.Utilities.Psychrometrics.Functions.saturationPressure(TDryBul);
          alpha = Modelica.Math.log(p_w/1000.0);

          TDewPoi = (C14 + C15*alpha + C16*alpha^2 + C17*alpha^3 + C18*(p_w/1000.0)^0.1984)+273.15;

        annotation (
            defaultComponentName="dewPoi",
            Documentation(info="<html>
<p>
Dew point temperature calculation for moist air above freezing temperature.
</p>
<p>
The correlation used in this model is valid for dew point temperatures between
<i>0</i>&deg;C and <i>93</i>&deg;C. It is the correlation from 2005
ASHRAE Handbook Fundamentals, p. 6.9.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 7, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={  Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-44,82},{-22,64}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="X"),
                Polygon(
                  points={{-48,88},{-46,74},{-50,74},{-48,88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-92,14},{-72,-12}},
                  lineColor={0,0,127},
                  textString="phi"),
                Text(
                  extent={{-92,100},{-62,56}},
                  lineColor={0,0,127},
                  textString="TDryBul"),
                Text(
                  extent={{-90,-72},{-72,-90}},
                  lineColor={0,0,127},
                  textString="p"),
                Polygon(
                  points={{86,-74},{76,-72},{76,-76},{86,-74}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{76,-78},{86,-94}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="T"),
                Line(points={{-48,84},{-48,-74}}),
                Text(
                  extent={{60,14},{98,-12}},
                  lineColor={0,0,127},
                  textString="TDewPoi"),
                Line(points={{82,-72},{-66,-72}}),
                Line(points={{-48,-40},{-38,-36},{-24,-30},{8,-2},{20,22},{28,54},{32,
                      74}}),
                Line(
                  points={{68,-12},{-2,-12}},
                  color={255,0,0},
                  thickness=0.5),
                Polygon(
                  points={{-2,-12},{12,-10},{12,-14},{-2,-12}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{66,-44},{-48,-44}}, color={175,175,175}),
                Line(points={{68,-18},{-10,-18}}, color={175,175,175}),
                Line(points={{70,6},{12,6}}, color={175,175,175}),
                Line(points={{68,32},{22,32}}, color={175,175,175})}));
        end TDewPoi_TDryBulPhi;

        block TWetBul_TDryBulPhi
          "Block to compute the wet bulb temperature based on relative humidity"

          Interfaces.RealInput TDryBul(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            final min=100) "Dry bulb temperature"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Interfaces.RealInput phi(
            final min=0,
            final max=1)
            "Relative air humidity"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

          Interfaces.RealInput p(
            final quantity="Pressure",
            final unit="Pa",
            final min = 0) "Pressure"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.RealOutput TWetBul(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            final min=100) "Wet bulb temperature"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          Modelica.SIunits.Conversions.NonSIunits.Temperature_degC TDryBul_degC
            "Dry bulb temperature in degree Celsius";
          Real rh_per(min=0) "Relative humidity in percentage";

        equation
            TDryBul_degC = TDryBul - 273.15;
            rh_per       = 100*phi;
            TWetBul      = 273.15 + TDryBul_degC
               * Modelica.Math.atan(0.151977 * sqrt(rh_per + 8.313659))
               + Modelica.Math.atan(TDryBul_degC + rh_per)
               - Modelica.Math.atan(rh_per-1.676331)
               + 0.00391838 * rh_per^(1.5) * Modelica.Math.atan( 0.023101 * rh_per)  - 4.686035;

        annotation (
            defaultComponentName="wetBul",
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-92,100},{-62,56}},
                  lineColor={0,0,127},
                  textString="TDryBul"),
                Text(
                  extent={{-92,14},{-72,-12}},
                  lineColor={0,0,127},
                  textString="phi"),
                Text(
                  extent={{-90,-72},{-72,-90}},
                  lineColor={0,0,127},
                  textString="p"),
                Text(
                  extent={{62,22},{92,-22}},
                  lineColor={0,0,127},
                  textString="TWetBul"),
                Line(points={{78,-74},{-48,-74}}),
                Text(
                  extent={{76,-78},{86,-94}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="T"),
                Line(
                  points={{76,-46},{26,-4}},
                  color={255,0,0},
                  thickness=0.5),
                Line(points={{-48,-48},{-2,-30},{28,-4},{48,32},{52,72}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(points={{-48,84},{-48,-74}}),
                Text(
                  extent={{-44,82},{-22,64}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="X"),
                Polygon(
                  points={{86,-74},{76,-72},{76,-76},{86,-74}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-48,88},{-46,74},{-50,74},{-48,88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{26,-4},{36,-10},{34,-12},{26,-4}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This block computes the wet bulb temperature for a given dry bulb temperature, relative air humidity
and atmospheric pressure.
</p>
<p>
The block uses the approximation of Stull (2011) to compute
the wet bulb temperature without requiring a nonlinear equation.
The approximation by Stull is valid for a relative humidity of <i>5%</i> to <i>99%</i>,
a temperature range from <i>-20</i>&deg;C to <i>50</i>&deg;C
and standard sea level pressure.
For this range of data, the approximation error is <i>-1</i> Kelvin to <i>+0.65</i> Kelvin,
with a mean error of less than <i>0.3</i> Kelvin.
</p>
<p>
The model is validated in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Psychrometrics.Validation.TWetBul_TDryBulPhi\">
Buildings.Controls.OBC.CDL.Psychrometrics.Validation.TWetBul_TDryBulPhi</a>.
</p>
<p>
For a model that takes the mass fraction instead of the relative humidity as an input, see
<a href=\"modelica://Buildings.Utilities.Psychrometrics.TWetBul_TDryBulXi\">
Buildings.Utilities.Psychrometrics.TWetBul_TDryBulXi</a>.
</p>
<h4>References</h4>
<p>
Stull, Roland.
<i><a href=\"http://dx.doi.org/10.1175/JAMC-D-11-0143.1\">
Wet-Bulb Temperature from Relative Humidity and Air Temperature
Roland Stull.</a></i>
Journal of Applied Meteorology and Climatology.
Volume 50, Issue 11, pp. 2267-2269. November 2011
DOI: 10.1175/JAMC-D-11-0143.1
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 11, 2017, by Jianjun Hu:<br/>
Changed the model so to avoid using nonlinear equation.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Changed icon.
</li>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Corrected exact implementation.
See  <a href=\"https://github.com/iea-annex60/modelica-annex60/issues/474\">#474</a>
for a discussion.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
Updated model to use
<code>Buildings.Utilities.Psychrometrics.Functions.saturationPressure()</code>
and
<code>Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid()</code>
as these functions have been moved from the medium to the psychrometrics package.
</li>
<li>
October 1, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TWetBul_TDryBulPhi;

        block h_TDryBulPhi
          "Block to compute the specific enthalpy based on relative humidity"

          Interfaces.RealInput TDryBul(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            final min=100) "Dry bulb temperature"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
          Interfaces.RealInput phi(final min=0, final max=1)
            "Relative air humidity"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.RealInput p(
            final quantity="Pressure",
            final unit="Pa",
            final min = 0) "Pressure"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

          Interfaces.RealOutput h(
            final quantity="SpecificEnergy",
            final unit="J/kg") "Specific enthalpy"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          Modelica.SIunits.Conversions.NonSIunits.Temperature_degC TDryBul_degC
            "Dry bulb temperature in degree Celsius";
          Modelica.SIunits.Pressure p_w(displayUnit="Pa") "Water vapor pressure";
          Modelica.SIunits.MassFraction XiDryBul(nominal=0.01)
            "Water vapor mass fraction at dry bulb state";

          // Modelica.SIunits.Temperature T_ref = 273.15
          //     "Reference temperature for psychrometric calculations"
          // constant Modelica.SIunits.SpecificHeatCapacity cpAir=1006
          //   "Specific heat capacity of air";
          // constant Modelica.SIunits.SpecificHeatCapacity cpSte=1860
          //   "Specific heat capacity of water vapor";
          // constant Modelica.SIunits.SpecificHeatCapacity cpWatLiq = 4184
          //   "Specific heat capacity of liquid water";
          // constant Modelica.SIunits.SpecificEnthalpy h_fg = 2501014.5
          //   "Enthalpy of evaporation of water at the reference temperature";
          // constant Real k_mair = 0.6219647130774989 "Ratio of molar weights";

        equation
          TDryBul_degC = TDryBul - 273.15;
          p_w = phi * Buildings.Utilities.Psychrometrics.Functions.saturationPressure(TDryBul);
          XiDryBul = 0.6219647130774989*p_w/(p-p_w);
          h = 1006*TDryBul_degC + XiDryBul*(2501014.5+1860*TDryBul_degC);

            annotation (
            defaultComponentName="ent",
            Documentation(info="<html>
<p>
The correlation used in this model is from 2005
ASHRAE Handbook Fundamentals, p. 6.9.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 7, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-44,-52},{-30,-48},{0,-36},{32,-8},{44,16},{52,48},{56,68}},
                  color={215,215,215},
                  smooth=Smooth.Bezier),
                Line(
                  points={{66,-58},{10,-28}},
                  color={255,0,0},
                  thickness=0.5),
                Text(
                  extent={{-44,82},{-22,64}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="X"),
                Polygon(
                  points={{-48,88},{-46,74},{-50,74},{-48,88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-92,14},{-72,-12}},
                  lineColor={0,0,127},
                  textString="phi"),
                Text(
                  extent={{-92,100},{-62,56}},
                  lineColor={0,0,127},
                  textString="TDryBul"),
                Text(
                  extent={{-90,-72},{-72,-90}},
                  lineColor={0,0,127},
                  textString="p"),
                Line(points={{78,-74},{-48,-74}}),
                Polygon(
                  points={{86,-74},{76,-72},{76,-76},{86,-74}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{76,-78},{86,-94}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="T"),
                Line(points={{-48,84},{-48,-74}}),
                Text(
                  extent={{74,14},{94,-12}},
                  lineColor={0,0,127},
                  textString="h")}));
        end h_TDryBulPhi;

        package Validation "Collection of models that validate the psychrometrics blocks of the CDL"

          model TDewPoi_TDryBulPhi
            "Model to test the dew point temperature computation"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Psychrometrics.TDewPoi_TDryBulPhi
              dewBulPhi "Model for dew point temperature"
              annotation (Placement(transformation(extent={{16,74},{36,94}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant p(k=101325)
              "Pressure"
              annotation (Placement(transformation(extent={{-94,8},{-74,28}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp phi(
              duration=1,
              height=1,
              offset=0.001) "Relative humidity" annotation (Placement(
                  transformation(extent={{-94,40},{-74,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TDryBul(k=273.15
                   + 29.4) "Dry bulb temperature" annotation (Placement(
                  transformation(extent={{-94,74},{-74,94}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant p2(k=101325)
              "Pressure" annotation (Placement(transformation(extent={{-94,-94},
                      {-74,-74}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp TDryBul2(
              duration=1,
              height=35,
              offset=273.15 + 2.0) "Dry bulb temperature" annotation (Placement(
                  transformation(extent={{-94,-28},{-74,-8}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant phi2(k=0.4)
              "Relative humidity" annotation (Placement(transformation(extent={
                      {-94,-60},{-74,-40}})));

           // ============ Below blocks are from Buildings Library ============
            Buildings.Utilities.Psychrometrics.TDewPoi_pW TDewPoi "Dew point temperature"
              annotation (Placement(transformation(extent={{18,4},{38,24}})));
            Buildings.Utilities.Psychrometrics.X_pTphi X_pTphi "Steam mass fraction"
              annotation (Placement(transformation(extent={{-46,4},{-26,24}})));
            Buildings.Utilities.Psychrometrics.pW_X humRat(use_p_in=false)
              "Water vapor pressure"
              annotation (Placement(transformation(extent={{-12,4},{8,24}})));
            // ===================================================================

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
              "Dew point temperature difference"
              annotation (Placement(transformation(extent={{52,40},{72,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Psychrometrics.TDewPoi_TDryBulPhi
              dewBulPhi1 "Model for dew point temperature"
              annotation (Placement(transformation(extent={{18,-28},{38,-8}})));
            Buildings.Utilities.Psychrometrics.TDewPoi_pW TDewPoi1
              "Dew point temperature"
              annotation (Placement(transformation(extent={{20,-98},{40,-78}})));
            Buildings.Utilities.Psychrometrics.pW_X humRat1(use_p_in=false)
              "Water vapor pressure"
              annotation (Placement(transformation(extent={{-10,-98},{10,-78}})));
            Buildings.Utilities.Psychrometrics.X_pTphi X_pTphi1 "Steam mass fraction"
              annotation (Placement(transformation(extent={{-44,-98},{-24,-78}})));
            Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
              "Dew point temperature difference" annotation (Placement(
                  transformation(extent={{52,-60},{72,-40}})));

          equation
            connect(humRat.p_w, TDewPoi.p_w)
              annotation (Line(points={{9,14},{12,14},{17,14}},
                color={0,0,127}));
            connect(X_pTphi.X[1], humRat.X_w)
              annotation (Line(points={{-25,14},{-22,14},{-13,14}},
                color={0,0,127}));
            connect(TDryBul.y, dewBulPhi.TDryBul)
              annotation (Line(points={{-72,84},{-68,84},{-68,92},{14,92}},
                color={0,0,127}));
            connect(phi.y, dewBulPhi.phi)
              annotation (Line(points={{-72,50},{-62,50},{-62,84},{14,84}},
                color={0,0,127}));
            connect(p.y, dewBulPhi.p)
              annotation (Line(points={{-72,18},{-56,18},{-56,76},{14,76}},
                color={0,0,127}));
            connect(p.y, X_pTphi.p_in)
              annotation (Line(points={{-72,18},{-56,18},{-56,20},{-48,20}},
                color={0,0,127}));
            connect(TDryBul.y, X_pTphi.T)
              annotation (Line(points={{-72,84},{-68,84},{-68,14},{-48,14}},
                color={0,0,127}));
            connect(phi.y, X_pTphi.phi)
              annotation (Line(points={{-72,50},{-62,50},{-62,8},{-48,8}},
                color={0,0,127}));
            connect(TDewPoi.T, add.u2)
              annotation (Line(points={{39,14},{44,14},{44,44},{50,44}},
                color={0,0,127}));
            connect(dewBulPhi.TDewPoi, add.u1)
              annotation (Line(points={{38,84},{42,84},{42,56},{50,56}},
                color={0,0,127}));
            connect(TDryBul2.y, dewBulPhi1.TDryBul)
              annotation (Line(points={{-72,-18},{-68,-18},{-68,-10},{16,-10}},
                color={0,0,127}));
            connect(TDryBul2.y, X_pTphi1.T)
              annotation (Line(points={{-72,-18},{-68,-18},{-68,-88},{-46,-88}},
                color={0,0,127}));
            connect(p2.y, X_pTphi1.p_in)
              annotation (Line(points={{-72,-84},{-56,-84},{-56,-82},{-46,-82}},
                color={0,0,127}));
            connect(p2.y, dewBulPhi1.p)
              annotation (Line(points={{-72,-84},{-56,-84},{-56,-26},{16,-26}},
                color={0,0,127}));
            connect(phi2.y, dewBulPhi1.phi)
              annotation (Line(points={{-72,-50},{-62,-50},{-62,-18},{16,-18}},
                color={0,0,127}));
            connect(phi2.y, X_pTphi1.phi)
              annotation (Line(points={{-72,-50},{-62,-50},{-62,-94},{-46,-94}},
                color={0,0,127}));
            connect(X_pTphi1.X[1], humRat1.X_w)
              annotation (Line(points={{-23,-88},{-11,-88},{-11,-88}},
                color={0,0,127}));
            connect(humRat1.p_w, TDewPoi1.p_w)
              annotation (Line(points={{11,-88},{19,-88},{19,-88}},
                color={0,0,127}));
            connect(dewBulPhi1.TDewPoi, add1.u1)
              annotation (Line(points={{40,-18},{44,-18},{44,-44},{50,-44}},
                color={0,0,127}));
            connect(TDewPoi1.T, add1.u2)
              annotation (Line(points={{41,-88},{46,-88},{46,-56},{50,-56}},
                color={0,0,127}));

          annotation (experiment(StopTime=1.0, Tolerance = 1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Psychrometrics/Validation/TDewPoi_TDryBulPhi.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This examples is a unit test for the dew point temperature computation <a href=\"modelica://Buildings.Controls.OBC.CDL.Psychrometrics.TDewPoi_TDryBulPhi\">
Buildings.Controls.OBC.CDL.Psychrometrics.TDewPoi_TDryBulPhi</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 7, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end TDewPoi_TDryBulPhi;

          model TWetBul_TDryBulPhi
            "Model to test the wet bulb temperature computation"
            package Medium = Buildings.Media.Air     "Medium model"
              annotation (choicesAllMatching = true);

            hil_flexlab_model.Controls_HIL.OBC.CDL.Psychrometrics.TWetBul_TDryBulPhi
              wetBulPhi "Model for wet bulb temperature"
              annotation (Placement(transformation(extent={{-10,46},{10,66}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant p(k=101325)
              "Pressure" annotation (Placement(transformation(extent={{-90,-34},
                      {-70,-14}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp phi(
              duration=1,
              height=0.95,
              offset=0.05) "Relative humidity"
              annotation (Placement(transformation(extent={{-90,6},{-70,26}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TDryBul(k=273.15
                   + 29.4) "Dry bulb temperature" annotation (Placement(
                  transformation(extent={{-90,46},{-70,66}})));

           // ============ Below blocks are from Buildings Library ============
            Buildings.Utilities.Psychrometrics.TWetBul_TDryBulPhi wetBulPhi_BuiLib(
              redeclare package Medium = Medium, approximateWetBulb=true)
              "Model for wet bulb temperature"
              annotation (Placement(transformation(extent={{-10,6},{10,26}})));
            Buildings.Utilities.Psychrometrics.TWetBul_TDryBulXi wetBulXi(
              redeclare package Medium = Medium, approximateWetBulb=true)
              "Model for wet bulb temperature using Xi as an input, used to verify consistency with wetBulPhi"
              annotation (Placement(transformation(extent={{-10,-34},{10,-14}})));
            Buildings.Utilities.Psychrometrics.X_pTphi x_pTphi "Computes mass fraction"
              annotation (Placement(transformation(extent={{-32,-30},{-20,-18}})));
            // ===================================================================

            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
              "Wet bulb temperature difference"
              annotation (Placement(transformation(extent={{40,6},{60,26}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
              "Wet bulb temperature difference" annotation (Placement(
                  transformation(extent={{40,-34},{60,-14}})));
          equation
            connect(x_pTphi.X[1], wetBulXi.Xi[1])
              annotation (Line(points={{-19.4,-24},{-11,-24}},
                color={0,0,127}));
            connect(TDryBul.y, wetBulPhi.TDryBul)
              annotation (Line(points={{-68,56},{-40,56},{-40,64},{-12,64}},
                color={0,0,127}));
            connect(TDryBul.y, wetBulPhi_BuiLib.TDryBul)
              annotation (Line(points={{-68,56},{-40,56},{-40,24},{-11,24}},
                color={0,0,127}));
            connect(TDryBul.y, wetBulXi.TDryBul)
              annotation (Line(points={{-68,56},{-40,56},{-40,-10},{-16,-10},{-16,-16},{
                    -11,-16}},
                color={0,0,127}));
            connect(p.y, x_pTphi.p_in)
              annotation (Line(points={{-68,-24},{-52,-24},{-52,-20.4},{-33.2,-20.4}},
                color={0,0,127}));
            connect(phi.y, x_pTphi.phi)
              annotation (Line(points={{-68,16},{-46,16},{-46,-27.6},{-33.2,-27.6}},
                color={0,0,127}));
            connect(p.y, wetBulXi.p)
              annotation (Line(points={{-68,-24},{-52,-24},{-52,-32},{-11,-32}},
                color={0,0,127}));
            connect(phi.y, wetBulPhi_BuiLib.phi)
              annotation (Line(points={{-68,16},{-11,16}},
                color={0,0,127}));
            connect(phi.y, wetBulPhi.phi)
              annotation (Line(points={{-68,16},{-46,16},{-46,52},{-28,52},{-28,56},{-12,
                    56}},
                color={0,0,127}));
            connect(p.y, wetBulPhi.p)
              annotation (Line(points={{-68,-24},{-52,-24},{-52,48},{-12,48}},
                color={0,0,127}));
            connect(p.y, wetBulPhi_BuiLib.p)
              annotation (Line(points={{-68,-24},{-52,-24},{-52,8},{-11,8}},
                color={0,0,127}));
            connect(TDryBul.y, x_pTphi.T)
              annotation (Line(points={{-68,56},{-40,56},{-40,-24},{-33.2,-24}},
                color={0,0,127}));
            connect(wetBulPhi.TWetBul, add.u1)
              annotation (Line(points={{12,56},{22,56},{22,22},{38,22}},
                color={0,0,127}));
            connect(wetBulPhi_BuiLib.TWetBul, add.u2)
              annotation (Line(points={{11,16},{28,16},{28,10},{38,10}},
                color={0,0,127}));
            connect(add1.u1, add.u1)
              annotation (Line(points={{38,-18},{22,-18},{22,30},{22,30},{22,22},{38,22}},
                color={0,0,127}));
            connect(wetBulXi.TWetBul, add1.u2)
              annotation (Line(points={{11,-24},{28,-24},{28,-30},{38,-30}},
                color={0,0,127}));

          annotation (experiment(StopTime=1.0,Tolerance = 1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Psychrometrics/Validation/TWetBul_TDryBulPhi.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This examples is a unit test for the dew point temperature computation <a href=\"modelica://Buildings.Controls.OBC.CDL.Psychrometrics.TWetBul_TDryBulPhi\">
Buildings.Controls.OBC.CDL.Psychrometrics.TWetBul_TDryBulPhi</a>.
</p>
<p>
The model contains an assert that validates the model based on a single operating point from Example 17.1 in
Ananthanarayanan (2013).
</p>
<h4>References</h4>
<p>
Ananthanarayanan, P. N. Basic refrigeration and air conditioning. Tata McGraw-Hill Education, 2013.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 7, 2017, by Jianjun Hu:<br/>
First implementation in CDL package.
</li>
<li>
June 23, 2016, by Michael Wetter:<br/>
Changed graphical annotation.
</li>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Updated example with validation data.
See  <a href=\"https://github.com/ibpsa/modelica/issues/474\">#474</a>
for a discussion.
</li>
<li>
October 1, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end TWetBul_TDryBulPhi;

          model h_TDryBulPhi "Model to test the specific enthalpy computation"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Psychrometrics.h_TDryBulPhi hBulPhi
              "Model for specific enthalpy computation"
              annotation (Placement(transformation(extent={{46,-10},{66,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant p(k=101325)
              "Pressure" annotation (Placement(transformation(extent={{-64,-42},
                      {-44,-22}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp phi(
              duration=1,
              height=1,
              offset=0.001) "Relative humidity" annotation (Placement(
                  transformation(extent={{-64,-10},{-44,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TDryBul(k=273.15
                   + 29.4) "Dry bulb temperature" annotation (Placement(
                  transformation(extent={{-64,24},{-44,44}})));

           // ============ Below blocks are from Buildings Library ============
            // ===================================================================

          equation
            connect(TDryBul.y, hBulPhi.TDryBul)
              annotation (Line(points={{-43,34},{0,34},{0,8},{45,8}},
                color={0,0,127}));
            connect(phi.y, hBulPhi.phi)
              annotation (Line(points={{-43,0},{0,0},{45,0}},
                color={0,0,127}));
            connect(p.y, hBulPhi.p)
              annotation (Line(points={{-43,-32},{0,-32},{0,-8},{45,-8}},
                color={0,0,127}));

          annotation (experiment(StopTime=1.0, Tolerance = 1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Psychrometrics/Validation/h_TDryBulPhi.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This examples is a unit test for the specific enthalpy computation <a href=\"modelica://Buildings.Controls.OBC.CDL.Psychrometrics.h_TDryBulPhi\">
Buildings.Controls.OBC.CDL.Psychrometrics.h_TDryBulPhi</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 7, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end h_TDryBulPhi;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Psychrometrics\">
Buildings.Controls.OBC.CDL.Psychrometrics</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={8.0,14.0},
                  lineColor={78,138,73},
                  fillColor={78,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
        end Validation;
      annotation (
      Documentation(info="<html>
<p>
This package contains blocks for psychrometric calculations.
</p>
</html>",
      revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Line(points={{-78,86},{-78,-72}}),
              Polygon(
                points={{-78,88},{-76,74},{-80,74},{-78,88}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-74,84},{-52,66}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="X"),
              Line(points={{-78,-46},{-64,-42},{-40,-32},{-16,-18},{10,6},{30,40},{38,
                  72}},
              color={0,0,0},
              smooth=Smooth.Bezier),
              Line(points={{72,-72},{-76,-72}}),
              Polygon(
                points={{74,-72},{64,-70},{64,-74},{74,-72}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{72,-80},{82,-96}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="T")}));
      end Psychrometrics;

      package Routing "Package with blocks that combine and extract signals"

        block BooleanReplicator "Boolean signal replicator"
          parameter Integer nout=1 "Number of outputs";
          Interfaces.BooleanInput u "Connector of Boolean input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.BooleanOutput y[nout] "Connector of Boolean output signals"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = fill(u, nout);

        annotation (
            defaultComponentName="booRep",
            Icon(graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={255,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Line(points={{-100,0},{-6,0}}, color={255,0,255}),
                Line(points={{100,0},{10,0}}, color={255,0,255}),
                Line(points={{0,0},{100,10}}, color={255,0,255}),
                Line(points={{0,0},{100,-10}}, color={255,0,255}),
                Ellipse(
                  extent={{-14,16},{16,-14}},
                  lineColor={0,0,0},
                  fillColor={255,0,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name")}),
            Documentation(info="<html>
<p>
This block replicates the Boolean input signal to an array of <code>nout</code>
identical Boolean output signals.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end BooleanReplicator;

        block IntegerReplicator "Integer signal replicator"
          parameter Integer nout=1 "Number of outputs";
          Interfaces.IntegerInput u "Connector of Integer input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.IntegerOutput y[nout] "Connector of Integer output signals"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = fill(u, nout);

        annotation (
            defaultComponentName="intRep",
            Icon(graphics={Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={255,127,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Line(points={{-100,0},{-6,0}}, color={255,127,0}),
                Line(points={{100,0},{10,0}}, color={255,127,0}),
                Line(points={{0,0},{100,10}}, color={255,127,0}),
                Line(points={{0,0},{100,-10}}, color={255,127,0}),
                Ellipse(
                  extent={{-14,16},{16,-14}},
                  lineColor={0,0,0},
                  fillColor={255,127,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name")}),
            Documentation(info="<html>
<p>
This block replicates the Integer input signal to an array of <code>nout</code>
identical Integer output signals.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end IntegerReplicator;

        block RealExtractSignal "Extract signals from an input signal vector"
          parameter Integer nin = 1 "Number of inputs";
          parameter Integer nout = 1 "Number of outputs";
          parameter Integer extract[nout]=1:nout "Extracting vector";
          Interfaces.RealInput u[nin] "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.RealOutput y[nout] "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          for i in 1:nout loop
            y[i] = u[extract[i]];
          end for;

        annotation (
            defaultComponentName="extSig",
            Icon(graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-90,51},{-50,-49}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Rectangle(
                    extent={{50,50},{90,-50}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Polygon(
                    points={{-94.4104,1.90792},{-94.4104,-2.09208},{-90.4104,-0.0920762},
                        {-94.4104,1.90792}},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Line(points={{-72,2},{-60.1395,12.907},{-49.1395,12.907}}, color={0,0,127}),
                  Line(points={{-73,4},{-59,40},{-49,40}}, color={0,0,127}),
                  Line(points={{-113,0},{-76.0373,-0.0180176}}, color={0,0,127}),
                  Ellipse(
                    extent={{-81.0437,4.59255},{-71.0437,-4.90745}},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Line(points={{-73,-5},{-60,-40},{-49,-40}}, color={0,0,127}),
                  Line(points={{-72,-2},{-60.0698,-12.907},{-49.0698,-12.907}}, color={0,0,127}),
                  Polygon(
                    points={{-48.8808,-11},{-48.8808,-15},{-44.8808,-13},{-48.8808,-11}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Line(points={{-46,13},{-35,13},{35,-30},{45,-30}}, color={0,0,127}),
                  Line(points={{-45,40},{-35,40},{35,0},{44,0}}, color={0,0,127}),
                  Line(points={{-45,-40},{-34,-40},{35,30},{44,30}}, color={0,0,127}),
                  Polygon(
                    points={{-49,42},{-49,38},{-45,40},{-49,42}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Polygon(
                    points={{-48.8728,-38.0295},{-48.8728,-42.0295},{-44.8728,-40.0295},
                        {-48.8728,-38.0295}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Polygon(
                    points={{-48.9983,14.8801},{-48.9983,10.8801},{-44.9983,12.8801},{-48.9983,14.8801}},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Ellipse(
                    extent={{69.3052,4.12743},{79.3052,-5.37257}},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Line(points={{80,0},{100,0}}, color={0,0,127}),
                  Polygon(
                    points={{43.1618,32.3085},{43.1618,28.3085},{47.1618,30.3085},{43.1618,32.3085}},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Polygon(
                    points={{43.2575,1.80443},{43.2575,-2.19557},{47.2575,-0.195573},{43.2575,1.80443}},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Polygon(
                    points={{43.8805,-28.1745},{43.8805,-32.1745},{47.8805,-30.1745},{43.8805,-28.1745}},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Line(points={{48,0},{70,0}}, color={0,0,127}),
                  Line(points={{47,30},{60,30},{73,3}}, color={0,0,127}),
                  Line(points={{49,-30},{60,-30},{74,-4}}, color={0,0,127}),
                  Text(
                    extent={{-150,-150},{150,-110}},
                    lineColor={0,0,0},
                    textString="extract=%extract"),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Extract signals from the input connector and transfer them
to the output connector.
</p>
<p>
The extracting scheme is given by the integer vector <code>extract</code>.
This vector specifies which input signals are taken and in which
order they are transferred to the output vector. Note that the
dimension of <code>extract</code> has to match the number of outputs.
Additionally, the dimensions of the input connector signals and
the output connector signals have to be explicitly defined via the
parameters <code>nin</code> and <code>nout</code>.
</p>
<h4>Example</h4>
<p>
The specification
</p>
<pre>     nin = 7 \"Number of inputs\";
     nout = 4 \"Number of outputs\";
     extract[nout] = {6,3,3,2} \"Extracting vector\";
</pre>
<p>extracts four output signals (<code>nout=4</code>)
from the seven elements of the
input vector (<code>nin=7</code>):</p>
<pre>   output no. 1 is set equal to input no. 6
   output no. 2 is set equal to input no. 3
   output no. 3 is set equal to input no. 3
   output no. 4 is set equal to input no. 2
</pre>
</html>",         revisions="<html>
<ul>
<li>
July 19, 2018, by Jianjun Hu:<br/>
Changed block name.
</li>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end RealExtractSignal;

        block RealExtractor
          "Extract scalar signal out of signal vector dependent on Integer input index"

          parameter Boolean allowOutOfRange=false "Index may be out of range";
          parameter Integer nin=1 "Number of inputs";
          parameter Real outOfRangeValue=1e10 "Output signal if index is out of range";

          Interfaces.IntegerInput index
            "Index of input vector element to be extracted out"
            annotation (Placement(transformation(origin={0,-120},extent={{-20,-20},{20,20}},
                rotation=90)));
          Interfaces.RealInput u[nin] "Connector of Real input signals"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        protected
          Real k[nin] "Indicator used to extract the signal";

        initial equation
          pre(index) = 0;

        equation
          when {initial(),change(index)} then
            for i in 1:nin loop
              k[i] = if index == i then 1 else 0;
            end for;
          end when;
          y = if not allowOutOfRange or index > 0 and index <= nin
              then k*u
              else outOfRangeValue;

          annotation (
           defaultComponentName="extIndSig",
           Icon(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}), graphics={
                             Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-80,50},{-40,-50}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{-84.4104,1.9079},{-84.4104,-2.09208},{-80.4104,-0.09208},{
                          -84.4104,1.9079}},
                      lineColor={0,0,127},
                      fillColor={0,0,0},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-62,2},{-50.1395,12.907},{-39.1395,12.907}}, color={0,0,
                          127}),
                    Line(points={{-63,4},{-49,40},{-39,40}}, color={0,0,127}),
                    Line(points={{-102,0},{-65.0373,-0.01802}}, color={0,0,127}),
                    Ellipse(
                      extent={{-70.0437,4.5925},{-60.0437,-4.90745}},
                      lineColor={0,0,127},
                      fillColor={0,0,127},
                      fillPattern=FillPattern.Solid),
                    Line(points={{-63,-5},{-50,-40},{-39,-40}}, color={0,0,127}),
                    Line(points={{-62,-2},{-50.0698,-12.907},{-39.0698,-12.907}}, color={
                          0,0,127}),
                    Polygon(
                      points={{-38.8808,-11},{-38.8808,-15},{-34.8808,-13},{-38.8808,-11}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{-39,42},{-39,38},{-35,40},{-39,42}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{-38.8728,-38.0295},{-38.8728,-42.0295},{-34.8728,-40.0295},
                          {-38.8728,-38.0295}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Polygon(
                      points={{-38.9983,14.8801},{-38.9983,10.8801},{-34.9983,12.8801},{-38.9983,
                          14.8801}},
                      lineColor={0,0,127},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-30,50},{30,-50}},
                      fillColor={235,235,235},
                      fillPattern=FillPattern.Solid,
                      lineColor={0,0,127}),
                    Line(points={{100,0},{0,0}}, color={0,0,127}),
                    Line(points={{0,2},{0,-104}}, color={255,128,0}),
                    Line(points={{-35,40},{-20,40}}, color={0,0,127}),
                    Line(points={{-35,13},{-20,13}}, color={0,0,127}),
                    Line(points={{-35,-13},{-20,-13}}, color={0,0,127}),
                    Line(points={{-35,-40},{-20,-40}}, color={0,0,127}),
                    Polygon(points={{0,0},{-20,13},{-20,13},{0,0},{0,0}}, lineColor={0,0,
                          127}),
                    Ellipse(
                      extent={{-6,6},{6,-6}},
                      lineColor={255,128,0},
                      fillColor={255,128,0},
                      fillPattern=FillPattern.Solid),
                  Text(
                    lineColor={0,0,255},
                    extent={{-150,110},{150,150}},
                    textString="%name")}),
          Documentation(info="<html>
<p>
Block that extracts a scalar output signal out the
vector of input signals dependent on the Integer
value of the input <code>index</code>:</p>
<pre>    y = u [ index ] ;
</pre>
<p>
where index is an additional Integer input signal.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 19, 2018, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end RealExtractor;

        block RealReplicator "Real signal replicator"
          parameter Integer nout=1 "Number of outputs";
          Interfaces.RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Interfaces.RealOutput y[nout] "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));

        equation
          y = fill(u, nout);

        annotation (
            defaultComponentName="reaRep",
            Icon(graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Line(points={{-100,0},{-6,0}}, color={0,0,127}),
                Line(points={{100,0},{10,0}}, color={0,0,127}),
                Line(points={{0,0},{100,10}}, color={0,0,127}),
                Line(points={{0,0},{100,-10}}, color={0,0,127}),
                Ellipse(
                  extent={{-14,16},{16,-14}},
                  lineColor={0,0,0},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name")}),
            Documentation(info="<html>
<p>
This block replicates the Real input signal to an array of <code>nout</code>
identical Real output signals.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        end RealReplicator;

        package Validation "Collection of models that validate the routing blocks of the CDL"

          model BooleanReplicator "Validation model for the BooleanReplicator block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Routing.BooleanReplicator booRep(nout=3)
              "Block that outputs the array replicating input value"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(period=
                  0.2) "Block that outputs boolean pulse" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));

          equation
            connect(booPul.y, booRep.u)
              annotation (Line(points={{-19,0},{18,0}}, color={255,0,255}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Routing/Validation/BooleanReplicator.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Routing.BooleanReplicator\">
Buildings.Controls.OBC.CDL.Routing.BooleanReplicator</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end BooleanReplicator;

          model IntegerReplicator "Validation model for the IntegerReplicator block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Routing.IntegerReplicator intRep(nout=3)
              "Block that outputs the array replicating input value"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram(
              height=5,
              duration=1,
              offset=-2) "Block that outputs ramp signal" annotation (Placement(
                  transformation(extent={{-60,-10},{-40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.RealToInteger reaToInt
              "Convert Real input to Integer output" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}})));

          equation
            connect(ram.y, reaToInt.u)
              annotation (Line(points={{-39,0},{-12,0}}, color={0,0,127}));
            connect(reaToInt.y, intRep.u)
              annotation (Line(points={{11,0},{38,0}}, color={255,127,0}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Routing/Validation/IntegerReplicator.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Routing.IntegerReplicator\">
Buildings.Controls.OBC.CDL.Routing.IntegerReplicator</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end IntegerReplicator;

          model RealExtractSignal
            "Validation model for the extract signal block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Routing.RealExtractSignal extSig(
              nin=5,
              nout=3,
              extract={1,2,5})
              "Block that extracts signals from an input signal vector"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram(
              height=5,
              duration=1,
              offset=-2) "Block that outputs ramp signal" annotation (Placement(
                  transformation(extent={{-60,50},{-40,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram1(
              duration=1,
              height=4,
              offset=-1) "Block that outputs ramp signal" annotation (Placement(
                  transformation(extent={{-60,-40},{-40,-20}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram2(
              duration=1,
              height=3,
              offset=-2) "Block that outputs ramp signal" annotation (Placement(
                  transformation(extent={{-60,-70},{-40,-50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pul(amplitude
                =0.5, period=0.2) "Generate pulse signal of type Real"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pul1(
              period=0.2,
              amplitude=1.5,
              offset=-0.2) "Generate pulse signal of type Real" annotation (
                Placement(transformation(extent={{-60,-10},{-40,10}})));

          equation
            connect(ram.y, extSig.u[1])
              annotation (Line(points={{-39,60},{-39,60},{-12,60},{-12,-1.6},{-2,-1.6}},
                color={0,0,127}));
            connect(pul.y, extSig.u[2])
              annotation (Line(points={{-39,30},{-39,30},{-16,30},{-16,-0.8},{-2,-0.8}},
                color={0,0,127}));
            connect(pul1.y, extSig.u[3])
              annotation (Line(points={{-39,0},{-20,0},{-2,0}}, color={0,0,127}));
            connect(ram1.y, extSig.u[4])
              annotation (Line(points={{-39,-30},{-39,-30},{-20,-30},{-20,0.8},{-2,0.8}},
                color={0,0,127}));
            connect(ram2.y, extSig.u[5])
              annotation (Line(points={{-39,-60},{-24,-60},{-24,1.6},{-2,1.6}},
                color={0,0,127}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Routing/Validation/RealExtractSignal.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Routing.RealExtractSignal\">
Buildings.Controls.OBC.CDL.Routing.RealExtractSignal</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end RealExtractSignal;

          model RealExtractor "Validation model for the extractor block"

            hil_flexlab_model.Controls_HIL.OBC.CDL.Routing.RealExtractor extIndSig(nin=5)
              "Block that extracts signal from an input signal vector"
              annotation (Placement(transformation(extent={{40,70},{60,90}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram(
              height=5,
              duration=1,
              offset=-2) "Block that outputs ramp signal" annotation (Placement(
                  transformation(extent={{-80,70},{-60,90}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram1(
              duration=1,
              height=4,
              offset=-1) "Block that outputs ramp signal" annotation (Placement(
                  transformation(extent={{-80,-20},{-60,0}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram2(
              duration=1,
              height=3,
              offset=-2) "Block that outputs ramp signal" annotation (Placement(
                  transformation(extent={{-80,-50},{-60,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pul(amplitude
                =0.5, period=0.2) "Generate pulse signal of type Real"
              annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pul1(
              period=0.2,
              amplitude=1.5,
              offset=-0.2) "Generate pulse signal of type Real" annotation (
                Placement(transformation(extent={{-80,10},{-60,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt(k=2)
              "Index to extract input signal"
              annotation (Placement(transformation(extent={{20,20},{40,40}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Routing.RealExtractor extIndSig1(nin=5)
              "Block that extracts signal from an input signal vector"
              annotation (Placement(transformation(extent={{40,-50},{60,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Integers.Sources.Constant conInt1(k=6)
              "Index to extract input signal" annotation (Placement(
                  transformation(extent={{20,-90},{40,-70}})));

          equation
            connect(ram.y, extIndSig.u[1])
              annotation (Line(points={{-59,80},{8,80},{8,78.4},{38,78.4}},
                color={0,0,127}));
            connect(pul.y, extIndSig.u[2])
              annotation (Line(points={{-59,50},{4,50},{4,79.2},{38,79.2}},
                color={0,0,127}));
            connect(pul1.y, extIndSig.u[3])
              annotation (Line(points={{-59,20},{-10,20},{-10,80},{38,80}},
                color={0,0,127}));
            connect(ram1.y, extIndSig.u[4])
              annotation (Line(points={{-59,-10},{0,-10},{0,80.8},{38,80.8}},
                color={0,0,127}));
            connect(ram2.y, extIndSig.u[5])
              annotation (Line(points={{-59,-40},{-4,-40},{-4,81.6},{38,81.6}},
                color={0,0,127}));
            connect(conInt.y, extIndSig.index)
              annotation (Line(points={{41,30},{50,30},{50,68}},
                color={255,127,0}));
            connect(conInt1.y, extIndSig1.index)
              annotation (Line(points={{41,-80},{50,-80},{50,-52}},
                color={255,127,0}));
            connect(ram.y, extIndSig1.u[1])
              annotation (Line(points={{-59,80},{8,80},{8,-41.6},{38,-41.6}},
                color={0,0,127}));
            connect(pul.y, extIndSig1.u[2])
              annotation (Line(points={{-59,50},{4,50},{4,-40.8},{38,-40.8}},
                color={0,0,127}));
            connect(pul1.y, extIndSig1.u[3])
              annotation (Line(points={{-59,20},{-10,20},{-10,-40},{38,-40}},
                color={0,0,127}));
            connect(ram1.y, extIndSig1.u[4])
              annotation (Line(points={{-59,-10},{0,-10},{0,-39.2},{38,-39.2}},
                color={0,0,127}));
            connect(ram2.y, extIndSig1.u[5])
              annotation (Line(points={{-59,-40},{-4,-40},{-4,-38.4},{38,-38.4}},
                color={0,0,127}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Routing/Validation/RealExtractor.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Routing.RealExtractor\">
Buildings.Controls.OBC.CDL.Routing.RealExtractor</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 19, 2018, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end RealExtractor;

          model RealReplicator "Validation model for the RealReplicator block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Routing.RealReplicator reaRep(nout=3)
              "Block that outputs the array replicating input value"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp ram(
              height=5,
              duration=1,
              offset=-2) "Block that outputs ramp signal" annotation (Placement(
                  transformation(extent={{-60,-10},{-40,10}})));

          equation
            connect(ram.y, reaRep.u)
              annotation (Line(points={{-39,0},{-12,0}}, color={0,0,127}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Routing/Validation/RealReplicator.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Routing.RealReplicator\">
Buildings.Controls.OBC.CDL.Routing.RealReplicator</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 24, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end RealReplicator;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Routing\">
Buildings.Controls.OBC.CDL.Routing</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={8.0,14.0},
                  lineColor={78,138,73},
                  fillColor={78,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
        end Validation;
        annotation (Documentation(info="<html>
<p>
This package contains blocks to combine and extract signals.
</p>
</html>"),       Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Line(points={{-90,0},{4,0}}, color={95,95,95}),
              Line(points={{88,65},{48,65},{-8,0}}, color={95,95,95}),
              Line(points={{-8,0},{93,0}}, color={95,95,95}),
              Line(points={{87,-65},{48,-65},{-8,0}}, color={95,95,95})}));
      end Routing;

      package SetPoints "Package with blocks for setpoint resets"

        block SupplyReturnTemperatureReset
          "Block to compute the supply and return set point"

          parameter Real m = 1.3 "Exponent for heat transfer";
          parameter Modelica.SIunits.Temperature TSup_nominal "Supply temperature"
            annotation (Dialog(group="Nominal conditions"));
          parameter Modelica.SIunits.Temperature TRet_nominal "Return temperature"
            annotation (Dialog(group="Nominal conditions"));
          parameter Modelica.SIunits.Temperature TZon_nominal = 293.15 "Zone temperature"
            annotation (Dialog(group="Nominal conditions"));
          parameter Modelica.SIunits.Temperature TOut_nominal "Outside temperature"
            annotation (Dialog(group="Nominal conditions"));
          parameter Modelica.SIunits.TemperatureDifference dTOutHeaBal(displayUnit="K") = 8
            "Offset for heating curve";

          Interfaces.RealInput TSetZon(
            final quantity="ThermodynamicTemperature",
            final unit = "K",
            displayUnit = "degC", min=200) "Zone setpoint temperature"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Interfaces.RealInput TOut(
            final quantity="ThermodynamicTemperature",
            final unit = "K",
            displayUnit = "degC",
            min=200) "Outside temperature"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Interfaces.RealOutput TSup(
            final quantity="ThermodynamicTemperature",
            final unit = "K",
            displayUnit = "degC",
            min=200) "Setpoint for supply temperature"
            annotation (Placement(transformation(extent={{100,40},{140,80}})));
          Interfaces.RealOutput TRet(
            final quantity="ThermodynamicTemperature",
            final unit = "K",
            displayUnit = "degC",
            min=200) "Setpoint for return temperature"
            annotation (Placement(transformation(extent={{100,-80},{140,-40}})));

        protected
          parameter Modelica.SIunits.Temperature TOutOffSet_nominal =  TOut_nominal + dTOutHeaBal
            "Effective outside temperature for heat transfer at nominal conditions (takes into account zone heat gains)";
          Real qRel "Relative heating load = Q_flow/Q_flow_nominal";
          Modelica.SIunits.Temperature TOutOffSet
            "Effective outside temperature for heat transfer (takes into account zone heat gains)";

        equation
          TOutOffSet = TOut + dTOutHeaBal;
          // Relative heating load, compared to nominal conditions
          qRel = max(0, (TSetZon-TOutOffSet)/(TZon_nominal-TOutOffSet_nominal));
          TSup = TSetZon
                  + ((TSup_nominal+TRet_nominal)/2-TZon_nominal) * qRel^(1/m)
                  + (TSup_nominal-TRet_nominal)/2 * qRel;
          TRet = TSup - qRel * (TSup_nominal-TRet_nominal);

        annotation (
          defaultComponentName="watRes",
          Documentation(info="<html>
<p>
This block computes the set point temperatures for the
supply and return water temperature.
The set point for the zone air temperature can be an input to the model.
It allows to use this model with systems that have night set back.
</p>
<p>
If used to reset the temperature in a heating system,
the parameter <code>dTOutHeaBal</code> can be used to shift the heating curve
to take into account that heat gains from solar, equipment and people
make up for some of the transmission losses.
For example, in energy efficient houses, the heating may not be switched on if
the outside air temperature is greater than
<i>12</i>&deg;C, even if a zone temperature of <i>20</i>&deg;C is required.
In such a situation, set <code>dTOutHeaBal=20-12=8</code> Kelvin to
shift the heating curve.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 3, 2020, by Jianjun Hu:<br/>
Changed name from <code>HotWaterTemperatureReset</code> to 
<code>SupplyReturnTemperatureReset</code>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/860\">#860</a>.
</li>
<li>
January 10, 2017, by Milica Grahovac:<br/>
First CDL implementation.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 13, 2013, by Michael Wetter:<br/>
Corrected error that led to wrong results if the zone air temperature is
different from its nominal value <code>TZon_nominal</code>.
See ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/74\">#74</a>.
</li>
<li>
November 21, 2011, by Michael Wetter:<br/>
Improved documentation.
</li>
<li>
February 5, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Polygon(
                  points={{90,-82},{68,-74},{68,-90},{90,-82}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(points={{-90,-82},{82,-82}}, color={192,192,192}),
                Line(points={{-80,76},{-80,-92}}, color={192,192,192}),
                Polygon(
                  points={{-80,88},{-88,66},{-72,66},{-80,86},{-80,88}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-80,-82},{60,32}}),
                Line(
                  points={{-80,-82},{-42,-38},{4,2},{60,32}},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-80,-82},{-58,-42},{-4,8},{60,32}},
                  smooth=Smooth.Bezier),
                Text(
                  extent={{-152,120},{-102,70}},
                  lineColor={0,0,127},
                  textString="TOut"),
                Text(
                  visible=use_TRoo_in,
                  extent={{-152,-4},{-102,-54}},
                  lineColor={0,0,127},
                  textString="TRoo"),
                Text(
                  extent={{40,86},{90,36}},
                  lineColor={0,0,127},
                  textString="TSup"),
                Text(
                  extent={{42,-30},{92,-80}},
                  lineColor={0,0,127},
                  textString="TRet"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end SupplyReturnTemperatureReset;

        package Validation "Collection of models that validate the SetPoints blocks of the CDL"

          model SupplyReturnTemperatureReset "Test model for the heating curve"
            hil_flexlab_model.Controls_HIL.OBC.CDL.SetPoints.SupplyReturnTemperatureReset
              heaCur(
              m=1,
              TSup_nominal=333.15,
              TRet_nominal=313.15,
              TOut_nominal=263.15)
              "Compute the supply and return set point of heating systems with varying outdoor temperature"
              annotation (Placement(transformation(extent={{20,30},{40,50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Ramp TOut(
              height=40,
              duration=1,
              offset=263.15,
              y(unit="K"))
              "Outdoor temperature varying from -10 degC to 30 degC"
              annotation (Placement(transformation(extent={{-60,50},{-40,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.SetPoints.SupplyReturnTemperatureReset
              heaCur1(
              m=1,
              dTOutHeaBal=15,
              TSup_nominal=333.15,
              TRet_nominal=313.15,
              TOut_nominal=263.15)
              "Compute the supply and return set point of heating systems with changing room setpoint temperature"
              annotation (Placement(transformation(extent={{20,-50},{40,-30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse TRoo1(
              offset=273.15 + 20,
              startTime=0.5,
              amplitude=-5,
              period=1,
              y(unit="K")) "Night set back from 20 degC to 15 degC" annotation
              (Placement(transformation(extent={{-60,-70},{-40,-50}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TOut1(k=273.15
                   - 10, y(unit="K")) "Constant outdoor air temperature"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TRoo(k=273.15
                   + 20, y(unit="K")) "Room temperature 20 degC" annotation (
                Placement(transformation(extent={{-60,10},{-40,30}})));

          equation
            connect(TOut1.y, heaCur1.TOut)
              annotation (Line(points={{-38,-20},{-38,-20},{0,-20},{0,-34},{18,-34}},
                color={0,0,127}));
            connect(TOut.y, heaCur.TOut)
              annotation (Line(points={{-38,60},{-38,60},{0,60},{0,46},{18,46}},
                color={0,0,127}));
            connect(TRoo.y, heaCur.TSetZon)
              annotation (Line(points={{-38,20},{0,20},{0,34},{18,34}},
                color={0,0,127}));
            connect(TRoo1.y, heaCur1.TSetZon)
              annotation (Line(points={{-38,-60},{0,-60},{0,-46},{18,-46}},
                color={0,0,127}));

          annotation (experiment(Tolerance=1e-6, StopTime=1.0),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/SetPoints/Validation/SupplyReturnTemperatureReset.mos"
                "Simulate and plot"),
            Documentation(info="<html>
<p>
Example that demonstrates the use of the hot water temperature reset
for a heating system.
The parameters of the block <code>heaCur</code>
are for a heating system with
<i>60</i>&deg;C supply water temperature and
<i>40</i>&deg;C return water temperature at
an outside temperature of
<i>-10</i>&deg;C and a room temperature of
<i>20</i>&deg;C. The offset for the temperature reset is
<i>8</i> Kelvin, i.e., above
<i>12</i>&deg;C outside temperature, there is no heating load.
The figure below shows the computed supply and return water temperatures.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/CDL/SetPoints/SupplyReturnTemperatureReset.png\"
border=\"1\"
alt=\"Supply and return water temperatures.\"/>
</p>
</html>",           revisions="<html>
<ul>
<li>
July 18, 2017, by Jianjun Hu:<br/>
First implementation in CDL.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end SupplyReturnTemperatureReset;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.SetPoints\">
Buildings.Controls.OBC.CDL.SetPoints</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={8.0,14.0},
                  lineColor={78,138,73},
                  fillColor={78,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
        end Validation;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains components models to compute set points for control systems.
</p>
</html>"),
        Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Ellipse(
                origin={10.0,10.0},
                fillColor={76,76,76},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{-80.0,-80.0},{-20.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,-80.0},{60.0,-20.0}}),
              Ellipse(
                origin={10.0,10.0},
                fillColor={128,128,128},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{0.0,0.0},{60.0,60.0}}),
              Ellipse(
                origin={10.0,10.0},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                extent={{-80.0,0.0},{-20.0,60.0}})}));
      end SetPoints;

      package Utilities "Package with utility functions"

        block Assert
          "Print a warning message when input becomes false"

          parameter String message "Message written when u becomes false";

          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput u
            "Boolean input that triggers assert when it becomes false"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        equation
          assert(u, message, AssertionLevel.warning);

        annotation (
          defaultComponentName="assMes",
          Icon(graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,80},{-80,-60},{80,-60},{0,80}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Text(
                  extent={{-100,160},{100,106}},
                  lineColor={0,0,255},
                  textString="%name"),
                Polygon(
                  points={{0,72},{-72,-56},{72,-56},{0,72}},
                  lineColor={0,0,0},
                  fillColor={255,255,170},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-4,38},{2,-24}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Ellipse(
                  extent={{-6,-32},{4,-42}},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Block that writes a warning if the input becomes <code>false</code>.
</p>
<p>
Tools or control systems are expected to write <code>message</code> together
with a time stamp to an output device and/or a log file.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 6, 2017, by Michael Wetter:<br/>
Simplified implementation.
</li>
<li>
November 3, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Assert;

        block SunRiseSet "Next sunrise and sunset time"
          parameter Modelica.SIunits.Angle lat(displayUnit="deg") "Latitude";
          parameter Modelica.SIunits.Angle lon(displayUnit="deg") "Longitude";
          parameter Modelica.SIunits.Time timZon(displayUnit="h") "Time zone";

          Interfaces.RealOutput nextSunRise(
            final quantity="Time",
            final unit="s",
            displayUnit="h") "Time of next sunrise"
            annotation (Placement(transformation(extent={{100,40},{140,80}})));
          Interfaces.RealOutput nextSunSet(
            final quantity="Time",
            final unit="s",
            displayUnit="h") "Time of next sunset"
            annotation (Placement(transformation(extent={{100,-20},{140,20}})));
          Interfaces.BooleanOutput sunUp "Output true if the sun is up"
            annotation (Placement(transformation(extent={{100,-80},{140,-40}})));
        protected
          constant Real k1 = sin(23.45*2*Modelica.Constants.pi/360) "Intermediate constant";
          constant Real k2 = 2*Modelica.Constants.pi/365.25 "Intermediate constant";

          parameter Modelica.SIunits.Time staTim(fixed=false) "Simulation start time";

          Modelica.SIunits.Time eqnTim "Equation of time";
          Modelica.SIunits.Time timDif "Time difference between local and civil time";
          Modelica.SIunits.Time timCor "Time correction";
          Modelica.SIunits.Angle decAng "Declination angle";
          Real Bt "Intermediate variable to calculate equation of time";
          Real cosHou "Cosine of hour angle";

          function nextHourAngle "Calculate the hour angle when the sun rises or sets next time"
            input Modelica.SIunits.Time t "Current simulation time";
            input Modelica.SIunits.Angle lat "Latitude";
            output Modelica.SIunits.Angle houAng "Solar hour angle";
            output Modelica.SIunits.Time tNext "Timesnap when sun rises or sets next time";
            output Modelica.SIunits.Time timCor "Time correction";
          protected
            Integer iDay;
            Boolean compute "Flag, set to false when the sun rise or sets ";
            Real Bt "Intermediate variable to calculate equation of time";
            Modelica.SIunits.Time eqnTim "Equation of time";
            Modelica.SIunits.Time timDif "Time difference";
            Modelica.SIunits.Angle decAng "Declination angle";
            Real cosHou "Cosine of hour angle";
          algorithm
            iDay := 1;
            compute := true;
            while compute loop
              tNext := t+iDay*86400;
              Bt := Modelica.Constants.pi*((tNext + 86400)/86400 - 81)/182;
              eqnTim := 60*(9.87*Modelica.Math.sin(2*Bt) - 7.53*Modelica.Math.cos(Bt) -
                        1.5*Modelica.Math.sin(Bt));
              timCor := eqnTim + timDif;
              decAng := Modelica.Math.asin(-k1*Modelica.Math.cos((tNext/86400 + 10)*k2));
              cosHou := -Modelica.Math.tan(lat)*Modelica.Math.tan(decAng);
              compute := abs(cosHou) > 1;
              iDay := iDay + 1;
            end while;
            houAng := Modelica.Math.acos(cosHou);
          end nextHourAngle;

          function sunRise "Output the next sunrise time"
            input Modelica.SIunits.Time t "Current simulation time";
            input Modelica.SIunits.Time staTim "Simulation start time";
            input Modelica.SIunits.Angle lat "Latitude";
            output Modelica.SIunits.Time nextSunRise;
          protected
            Modelica.SIunits.Angle houAng "Solar hour angle";
            Modelica.SIunits.Time tNext "Timesnap when sun rises next time";
            Modelica.SIunits.Time timCor "Time correction";
            Modelica.SIunits.Time sunRise "Sunrise of the same day as input time";
            Real cosHou "Cosine of hour angle";
          algorithm
            (houAng,tNext,timCor) := nextHourAngle(t, lat);
            sunRise :=(12 - houAng*24/(2*Modelica.Constants.pi) - timCor/3600)*3600 +
                       floor(tNext/86400)*86400;
            //If simulation start time has passed the sunrise of the initial day, output
            //the sunrise of the next day.
            if staTim > sunRise then
              nextSunRise := sunRise + 86400;
            else
              nextSunRise := sunRise;
            end if;
          end sunRise;

          function sunSet "Output the next sunset time"
            input Modelica.SIunits.Time t "Current simulation time";
            input Modelica.SIunits.Time staTim "Simulation start time";
            input Modelica.SIunits.Angle lat "Latitude";
            output Modelica.SIunits.Time nextSunSet;
          protected
            Modelica.SIunits.Angle houAng "Solar hour angle";
            Modelica.SIunits.Time tNext "Timesnap when sun sets next time";
            Modelica.SIunits.Time timCor "Time correction";
            Modelica.SIunits.Time sunSet "Sunset of the same day as input time";
            Real cosHou "Cosine of hour angle";
          algorithm
            (houAng,tNext,timCor) := nextHourAngle(t, lat);
            sunSet :=(12 + houAng*24/(2*Modelica.Constants.pi) - timCor/3600)*3600 +
                      floor(tNext/86400)*86400;
            //If simulation start time has passed the sunset of the initial day, output
            //the sunset of the next day.
            if staTim > sunSet then
              nextSunSet := sunSet + 86400;
            else
              nextSunSet := sunSet;
            end if;
          end sunSet;

        initial equation
          staTim = time;
          nextSunRise = sunRise(time-86400,staTim,lat);
          //In the polar cases where the sun is up during initialization, the next sunset
          //actually occurs before the next sunrise
          if cosHou < -1 then
            nextSunSet = sunSet(time-86400,staTim,lat) - 86400;
          else
            nextSunSet = sunSet(time-86400,staTim,lat);
          end if;

        equation
          Bt = Modelica.Constants.pi*((time + 86400)/86400 - 81)/182;
          eqnTim = 60*(9.87*Modelica.Math.sin(2*Bt) - 7.53*Modelica.Math.cos(Bt) - 1.5*
                  Modelica.Math.sin(Bt));
          timDif = lon*43200/Modelica.Constants.pi - timZon;
          timCor = eqnTim + timDif;
          decAng = Modelica.Math.asin(-k1*Modelica.Math.cos((time/86400 + 10)*k2));
          cosHou = -Modelica.Math.tan(lat)*Modelica.Math.tan(decAng);

          //When time passes the current sunrise/sunset, output the next sunrise/sunset
          when time >= pre(nextSunRise) then
            nextSunRise = sunRise(time,staTim,lat);
          end when;

          when time >= pre(nextSunSet) then
            nextSunSet = sunSet(time,staTim,lat);
          end when;

          sunUp = nextSunSet < nextSunRise;

        annotation (defaultComponentName="sunRiseSet",
          Documentation(info="<html>
<p>
This block outputs the next sunrise and sunset time.
The sunrise time keeps constant until the model time reaches the next sunrise,
at which time the output gets updated.
Similarly, the output for the next sunset is updated at each sunset.
</p>
<p>
The time zone parameter is based on UTC time; for instance, Eastern Standard Time is -5h.
Note that daylight savings time is not considered in this component.
</p>
<h4>Validation</h4>
<p>
A validation can be found at
<a href=\"modelica://Buildings.Controls.OBC.CDL.Utilities.Validation.SunRiseSet\">
Buildings.Controls.OBC.CDL.Utilities.Validation.SunRiseSet</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 27, 2018, by Kun Zhang:<br/>
First implementation.
This is for
issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/829\">829</a>.
</li>
</ul>
</html>"),
        Icon(graphics={  Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-100,160},{100,106}},
                    lineColor={0,0,255},
                    textString="%name"),
                  Ellipse(
                    extent={{70,-100},{-70,20}},
                    lineColor={238,46,47},
                    startAngle=0,
                    endAngle=180),
                  Line(
                    points={{-94,-40},{92,-40},{92,-40}},
                    color={28,108,200},
                    thickness=0.5),
                  Line(points={{0,60},{0,32}}, color={238,46,47}),
                  Line(points={{60,40},{40,20}}, color={238,46,47}),
                  Line(points={{94,-6},{70,-6}}, color={238,46,47}),
                  Line(
                    points={{10,10},{-10,-10}},
                    color={238,46,47},
                    origin={-50,30},
                    rotation=90),
                  Line(points={{-70,-6},{-94,-6}}, color={238,46,47})}));
        end SunRiseSet;

        package Validation "Collection of models that validate the utilities blocks of the CDL"
          model Assert "Validate the Assert block"
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.Assert assert(message=
                  "input became false")
              "Trigger warning and print warning message"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Pulse booPul(period=
                  0.5) "Output boolean pulse" annotation (Placement(
                  transformation(extent={{-40,-10},{-20,10}})));

          equation
            connect(booPul.y, assert.u)
              annotation (Line(points={{-19,0},{18,0}},   color={255,0,255}));

          annotation (
            experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Utilities/Validation/Assert.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
Validation test for the block
<a href=\"modelica://Buildings.Controls.OBC.CDL.Utilities.Assert\">
Buildings.Controls.OBC.CDL.Utilities.Assert</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
November 3, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Ellipse(lineColor = {75,138,73},
                          fillColor={255,255,255},
                          fillPattern = FillPattern.Solid,
                          extent = {{-100,-100},{100,100}}),
                  Polygon(lineColor = {0,0,255},
                          fillColor = {75,138,73},
                          pattern = LinePattern.None,
                          fillPattern = FillPattern.Solid,
                          points = {{-36,60},{64,0},{-36,-60},{-36,60}})}));
          end Assert;

          model SunRiseSet "Test model for the block SunRiseSet"
            extends Modelica.Icons.Example;

            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetArctic(
              lat=1.2566370614359,
              lon=-1.2566370614359,
              timZon=-18000) "Arctic circle case"
              annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetSf(
              lat=0.6457718232379,
              lon=-2.1293016874331,
              timZon=-28800)
              "San Francisco as an example in the northen hemisphere"
              annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetAntarctic(
              lat=-1.3089969389957,
              lon=0.99483767363677,
              timZon=14400) "Antarctic circle case"
              annotation (Placement(transformation(extent={{-10,10},{10,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetSyd(
              lat=-0.59341194567807,
              lon=2.6354471705114,
              timZon=36000) "Sydney as an example in the southern hemisphere"
              annotation (Placement(transformation(extent={{-10,-70},{10,-50}})));

          annotation (
            experiment(StopTime=31536000, Tolerance=1e-06),
            __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Utilities/Validation/SunRiseSet.mos"
                  "Simulate and plot"),
            Documentation(info="<html>
<p>
This example includes four instances of the
<a href=\"modelica://Buildings.Controls.OBC.CDL.Utilities.SunRiseSet\">
Buildings.Controls.OBC.CDL.Utilities.SunRiseSet</a> block:
Two normal cases, an arctic and antarctic case.
The normal cases are represented by San Francisco and Sydney,
where there is a sunrise and sunset every day.
</p>
<p>
Above the arctic circle and below the antarctic circle,
in winter and summer there is a period in which there is no sunset and sunrise
for a few days.
Hence, the output signals of the block remain constant.
</p>
</html>", revisions="<html>
<ul>
<li>
November 27, 2018, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"));
          end SunRiseSet;

          model SunRiseSetNegativeStartTime "Test model for the block SunRiseSet with negative start time"
            extends Modelica.Icons.Example;

            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetArctic(
              lat=1.2566370614359,
              lon=-1.2566370614359,
              timZon=-18000) "Arctic circle case"
              annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetSf(
              lat=0.6457718232379,
              lon=-2.1293016874331,
              timZon=-28800)
              "San Francisco as a test example in the northen hemisphere"
              annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetAntarctic(
              lat=-1.3089969389957,
              lon=0.99483767363677,
              timZon=14400) "Antarctic circle case"
              annotation (Placement(transformation(extent={{-10,10},{10,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetSyd(
              lat=-0.59341194567807,
              lon=2.6354471705114,
              timZon=36000)
              "Sydney as a test example in the southern hemisphere" annotation
              (Placement(transformation(extent={{-10,-70},{10,-50}})));

          annotation (
            experiment(StartTime=-43200, StopTime=259200, Tolerance=1e-06),
            __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Utilities/Validation/SunRiseSetNegativeStartTime.mos"
                  "Simulate and plot"),
            Documentation(info="<html>
<p>This example includes 4 tests for the <a href=\"modelica://Buildings.Controls.OBC.CDL.Utilities.SunRiseSet\">
Buildings.Controls.OBC.CDL.Utilities.SunRiseSet</a> block: 2 normal cases, an arctic and antarctic case.
The normal cases are represented by San Francisco and Sydney, where there is a sunrise and sunset every day. </p>
<p>This model starts the simulation from -12 hour instead of 0. </p>
</html>", revisions="<html>
<ul>
<li>
November 27, 2018, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"));
          end SunRiseSetNegativeStartTime;

          model SunRiseSetPositiveStartTime "Test model for the block SunRiseSet with positive start time"
            extends Modelica.Icons.Example;

            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetArctic(
              lat=1.2566370614359,
              lon=-1.2566370614359,
              timZon=-18000) "Arctic circle case"
              annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetSf(
              lat=0.6457718232379,
              lon=-2.1293016874331,
              timZon=-28800)
              "San Francisco as a test example in the northen hemisphere"
              annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetAntarctic(
              lat=-1.3089969389957,
              lon=0.99483767363677,
              timZon=14400) "Antarctic circle case"
              annotation (Placement(transformation(extent={{-10,10},{10,30}})));
            hil_flexlab_model.Controls_HIL.OBC.CDL.Utilities.SunRiseSet sunRiseSetSyd(
              lat=-0.59341194567807,
              lon=2.6354471705114,
              timZon=36000)
              "Sydney as a test example in the southern hemisphere" annotation
              (Placement(transformation(extent={{-10,-70},{10,-50}})));

          annotation (
            experiment(StartTime=43200, StopTime=345600, Tolerance=1e-06),
            __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/CDL/Utilities/Validation/SunRiseSetPositiveStartTime.mos"
                  "Simulate and plot"),
            Documentation(info="<html>
<p>This example includes 4 tests for the <a href=\"modelica://Buildings.Controls.OBC.CDL.Utilities.SunRiseSet\">
Buildings.Controls.OBC.CDL.Utilities.SunRiseSet</a> block: 2 normal cases, an arctic and antarctic case.
The normal cases are represented by San Francisco and Sydney, where there is a sunrise and sunset every day. </p>
<p>This model starts the simulation from 12 hour instead of 0. </p>
</html>", revisions="<html>
<ul>
<li>
November 27, 2018, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"));
          end SunRiseSetPositiveStartTime;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Utilities\">
Buildings.Controls.OBC.CDL.Utilities</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),Icon(graphics={
                Rectangle(
                  lineColor={200,200,200},
                  fillColor={248,248,248},
                  fillPattern=FillPattern.HorizontalCylinder,
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Rectangle(
                  lineColor={128,128,128},
                  extent={{-100.0,-100.0},{100.0,100.0}},
                  radius=25.0),
                Polygon(
                  origin={8.0,14.0},
                  lineColor={78,138,73},
                  fillColor={78,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
        end Validation;
      annotation (
      preferredView="info", Documentation(info="<html>
<p>
This package contains utility models
that are used throughout the library.
</p>
</html>"),
      Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
          Polygon(
            origin={1.3835,-4.1418},
            rotation=45.0,
            fillColor={64,64,64},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
            points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},
            {20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},
            {25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
            {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},
            {0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
            {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
          Polygon(
            origin={10.1018,5.218},
            rotation=-45.0,
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},
            {10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},
            {5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
            {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
      end Utilities;

      package Types "Package with type definitions"

        type Day = enumeration(
            WorkingDay "Working day, such as Monday through Friday",
            NonWorkingDay "Non-working day, such as week-ends, but not holidays",
            Holiday "Holiday") "Enumeration for the day types" annotation (
            Documentation(info="<html>
<p>
Enumeration for the type of days.
The possible values are:
</p>
<ol>
<li>
WorkingDay
</li>
<li>
NonWorkingDay
</li>
<li>
Holiday
</li>
</ol>
</html>",         revisions="<html>
<ul>
<li>
February 27, 2017 by Milica Grahovac:<br/>
First CDL implementation.
</li>
<li>
March 20, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        type Extrapolation = enumeration(
            HoldLastPoint "Hold the first/last table point outside of the table scope",
            LastTwoPoints
              "Extrapolate by using the derivative at the first/last table points outside of the table scope",
            Periodic "Repeat the table scope periodically")
          "Enumeration defining the extrapolation of time table interpolation"
          annotation (Documentation(info="<html>
<p>
Enumeration for the type of extrapolation that is used when reading data from a table.
The possible values are:
</p>

<table border=\"1\" summary=\"Explanation of the enumeration\">
<tr>
<th>Enumeration</th>
<th>Description</th></tr>
<tr><td><code>HoldLastPoint</code></td>
<td>
Hold the first or last point outside of the table scope.
</td></tr>
<tr><td><code>LastTwoPoints</code></td>
<td>
Extrapolate by using the derivative at the first or last table points outside of the table scope.
</td></tr>
<tr><td><code>Periodic</code></td>
<td>
Repeat the table scope periodically.
</td></tr>
</table>
</html>"));
        type Reset = enumeration(
            Disabled "Disabled",
            Parameter "Use parameter value",
            Input "Use input signal") "Options for integrator reset" annotation (
            Documentation(info="<html>
<p>
Enumeration to define the choice of integrator reset.
Possible values are:
</p>
<table border=\"1\" summary=\"Explanation of the enumeration\">
<tr>
<th>Enumeration</th>
<th>Description</th></tr>
<tr><td><code>Disabled</code></td>
<td>
Use this setting to disable the integrator reset.
</td></tr>
<tr><td><code>Parameter</code></td>
<td>
Use this setting to use reset the integrator to the value of the parameter.
</td></tr>
<tr><td><code>Input</code></td>
<td>Use this setting to reset the integrator to the value obtained
from the input signal.
</td></tr>
 </table>
</html>",         revisions="<html>
<ul>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
        type SimpleController = enumeration(
            P "P controller",
            PI "PI controller",
            PD "PD controller",
            PID "PID controller")
          "Enumeration defining P, PI, PD, or PID simple controller type" annotation (
            Evaluate=true, Documentation(info="<html>
<p>
Enumeration to define the type of the controller.
Possible values are:
</p>
<table border=\"1\" summary=\"Explanation of the enumeration\">
<tr>
<th>Enumeration</th>
<th>Description</th></tr>
<tr><td><code>P</code></td>
<td>
Controller with proportional term.
</td></tr>
<tr><td><code>PI</code></td>
<td>
Controller with proportional and integral terms.
</td></tr>
<tr><td><code>PD</code></td>
<td>
Controller with proportional and derivative term.
</td></tr>
<tr><td><code>PID</code></td>
<td>
Controller with proportional, integral and derivative terms.
</td></tr>
</table>
</html>",         revisions="<html>
<ul>
<li>
March 23, 2017, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
        type Smoothness = enumeration(
            LinearSegments "Table points are linearly interpolated",
            ConstantSegments
              "Table points are not interpolated, but the previous tabulated value is returned")
          "Enumeration defining the smoothness of table interpolation" annotation (
            Documentation(info="<html>
<p>
Enumeration for the type of smoothness that is used when interpolating data from a table.
The possible values are:
</p>

<table border=\"1\" summary=\"Explanation of the enumeration\">
<tr>
<th>Enumeration</th>
<th>Description</th></tr>
<tr><td><code>LinearSegments</code></td>
<td>
Linearly interpolate table points.
</td></tr>
<tr><td><code>ConstantSegments</code></td>
<td>
Do not interpolate, but rather use the previously tabulated value.
</td></tr>
</table>
</html>"));
        type ZeroTime = enumeration(
            UnixTimeStamp "Thu, 01 Jan 1970 00:00:00 local time",
            UnixTimeStampGMT "Thu, 01 Jan 1970 00:00:00 GMT",
            Custom "User specified local time",
            NY2010 "New year 2010, 00:00:00 local time",
            NY2011 "New year 2011, 00:00:00 local time",
            NY2012 "New year 2012, 00:00:00 local time",
            NY2013 "New year 2013, 00:00:00 local time",
            NY2014 "New year 2014, 00:00:00 local time",
            NY2015 "New year 2015, 00:00:00 local time",
            NY2016 "New year 2016, 00:00:00 local time",
            NY2017 "New year 2017, 00:00:00 local time",
            NY2018 "New year 2018, 00:00:00 local time",
            NY2019 "New year 2019, 00:00:00 local time",
            NY2020 "New year 2020, 00:00:00 local time")
          "Enumeration to set the date corresponding to time = 0"
          annotation (Documentation(info="<html>
<p>
Type for choosing how to set the reference time in
<a href=\"modelica://Buildings.Controls.OBC.CDL.Continuous.Sources.CalendarTime\">
Buildings.Controls.OBC.CDL.Continuous.Sources.CalendarTime</a>.
</p>
<p>
For example, <code>CDL.Types.TimeReference.NY2016</code>
means that if model time is <i>0</i>, it is
January 1, 2016, 0:00:00 local time.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 14, 2017, by Michael Wetter:<br/>
Revised documentation.
</li>
<li>
February 23, 2017, by Milica Grahovac:<br/>
Initial CDL implementation.
</li>
<li>
September 10, 2016, by Michael Wetter:<br/>
Revised implementation and moved to new package
<a href=\"modelica://Buildings.Utilities.Time.CalendarTime.Types\">
Buildings.Utilities.Time.CalendarTime.Types</a>.
</li>
<li>
August 3, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
      annotation (Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>"),       Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),                  Polygon(
                origin={-12.167,-23},
                fillColor={128,128,128},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},
                    {14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,
                    -30},{4.167,20},{12.167,65}},
                smooth=Smooth.Bezier,
                lineColor={0,0,0}), Polygon(
                origin={2.7403,1.6673},
                fillColor={128,128,128},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,
                  10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,
                  4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
                smooth=Smooth.Bezier)}));
      end Types;

      package Interfaces "Package with connectors for input and output signals"

        connector BooleanInput = input Boolean "'input Boolean' as connector"
          annotation (
          defaultComponentName="u",
          Icon(graphics={Polygon(
                lineColor={255,0,255},
                fillColor={255,0,255},
                fillPattern=FillPattern.Solid,
                points={{0,50},{100,0},{0,-50}})},
              coordinateSystem(
              extent={{-100,-100},{100,100}},
              preserveAspectRatio=true,
              initialScale=0.2)),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{0,50},{100,0},{0,-50},{0,50}},
                lineColor={255,0,255},
                fillColor={255,0,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-10,85},{-10,60}},
                lineColor={255,0,255},
                textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        connector BooleanOutput = output Boolean "'output Boolean' as connector"
          annotation (
          defaultComponentName="y",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100,-100},{100,100}}),
              graphics={Polygon(
                lineColor={255,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                points={{-100,50},{0,0},{-100,-50}})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{-100,50},{0,0},{-100,-50},{-100,50}},
                lineColor={255,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{30,110},{30,60}},
                lineColor={255,0,255},
                textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 19, 2019, by Jianjun Hu:<br/>
On both icon and diagram layer, added the initialScale.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        connector DayTypeInput = input Types.Day "Input connector for day types"
        annotation (
          defaultComponentName="u",
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Polygon(
              lineColor={0,127,0},
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid,
              points={{0,50},{100,0},{0,-50}})}),
          Diagram(
            coordinateSystem(preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Polygon(
              lineColor={0,127,0},
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid,
              points={{0,50},{100,0},{0,-50}}),
            Text(
              lineColor={0,127,0},
              extent={{-10.0,60.0},{-10.0,85.0}},
              textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one input signal of type
<a href=\"modelica://Buildings.Controls.OBC.CDL.Types.Day\">
Buildings.Controls.OBC.CDL.Types.Day</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
July 17, 2017 by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"));
        connector DayTypeOutput =output Types.Day  "Output connector for day types"
        annotation (
          defaultComponentName="y",
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Polygon(
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-100,50},{0,0},{-100,-50}})}),
          Diagram(
            coordinateSystem(preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Polygon(
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-100.0,50.0},{0.0,0.0},{-100.0,-50.0}}),
            Text(
              lineColor={0,127,0},
              extent={{30.0,60.0},{30.0,110.0}},
              textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one output signal of type
<a href=\"modelica://Buildings.Controls.OBC.CDL.Types.Day\">
Buildings.Controls.OBC.CDL.Types.Day</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 19, 2019, by Jianjun Hu:<br/>
On both icon and diagram layer, added the initialScale.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 11, 2016, by Milica Grahovac:<br/>
First CDL implementation.
</li>
<li>
March 20, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        connector IntegerInput = input Integer "'input Integer' as connector"
          annotation (
          defaultComponentName="u",
          Icon(graphics={Polygon(
                lineColor={255,127,0},
                fillColor={255,127,0},
                fillPattern=FillPattern.Solid,
                points={{0,50},{100,0},{0,-50}})},
                coordinateSystem(
              extent={{-100,-100},{100,100}},
              preserveAspectRatio=true,
              initialScale=0.2)),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{0,50},{100,0},{0,-50},{0,50}},
                lineColor={255,127,0},
                fillColor={255,127,0},
                fillPattern=FillPattern.Solid), Text(
                extent={{-10,85},{-10,60}},
                lineColor={255,127,0},
                textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one input signal of type Integer.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        connector IntegerOutput = output Integer "'output Integer' as connector"
          annotation (
          defaultComponentName="y",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                lineColor={255,127,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                points={{-100,50},{0,0},{-100,-50}})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100,-100},{100,100}}), graphics={Polygon(
                points={{-100,50},{0,0},{-100,-50},{-100,50}},
                lineColor={255,127,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{30,110},{30,60}},
                lineColor={255,127,0},
                textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one output signal of type Integer.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 19, 2019, by Jianjun Hu:<br/>
On both icon and diagram layer, added the initialScale.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        connector RealInput = input Real "'input Real' as connector"
        annotation (
          defaultComponentName="u",
          Icon(graphics={
            Polygon(
              lineColor={0,0,127},
              fillColor={0,0,127},
              fillPattern=FillPattern.Solid,
              points={{0,50},{100,0},{0,-50}})},
            coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}},
              preserveAspectRatio=true,
              initialScale=0.2)),
          Diagram(
            coordinateSystem(preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Polygon(
              lineColor={0,0,127},
              fillColor={0,0,127},
              fillPattern=FillPattern.Solid,
              points={{0.0,50.0},{100.0,0.0},{0.0,-50.0},{0.0,50.0}}),
            Text(
              lineColor={0,0,127},
              extent={{-10.0,60.0},{-10.0,85.0}},
              textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
        connector RealOutput = output Real "'output Real' as connector"
        annotation (
          defaultComponentName="y",
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Polygon(
              lineColor={0,0,127},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-100,50},{0,0},{-100,-50}})}),
          Diagram(
            coordinateSystem(preserveAspectRatio=true,
              initialScale=0.2,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Polygon(
              lineColor={0,0,127},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-100.0,50.0},{0.0,0.0},{-100.0,-50.0}}),
            Text(
              lineColor={0,0,127},
              extent={{30.0,60.0},{30.0,110.0}},
              textString="%name")}),
          Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 19, 2019, by Jianjun Hu:<br/>
On both icon and diagram layer, added the initialScale.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
March 1, 2019, by Michael Wetter:<br/>
On the icon layer, changed connector size and added the connector name.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1375\">issue 1375</a>.
</li>
<li>
January 6, 2017, by Michael Wetter:<br/>
First implementation, based on the implementation of the
Modelica Standard Library.
</li>
</ul>
</html>"));
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains implementations of connectors for input
and output signals of blocks.
</p>
<p>
The connectors are compatible with, and equivalent to,
the connectors from the Modelica Standard Library.
They are here implemented to make the <code>CDL</code>
package a self-contained package.
</p>
</html>"),
        Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Polygon(origin={20.0,0.0},
                lineColor={64,64,64},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                points={{-10.0,70.0},{10.0,70.0},{40.0,20.0},{80.0,20.0},{80.0,-20.0},{40.0,-20.0},{10.0,-70.0},{-10.0,-70.0}}),
              Polygon(fillColor={102,102,102},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                points={{-100.0,20.0},{-60.0,20.0},{-30.0,70.0},{-10.0,70.0},{-10.0,-70.0},{-30.0,-70.0},{-60.0,-20.0},{-100.0,-20.0}})}));
      end Interfaces;
    annotation (
    Documentation(info="<html>
<p>
Package that has elementary input-output blocks
that form the Control Description Language (CDL).
The implementation is structured into sub-packages.
The packages <code>Validation</code> and <code>Examples</code>
contain validation and example models.
These are not part of the CDL specification, but rather
implemented to provide reference responses computed by the CDL blocks.
For a specification of CDL, see
<a href=\"http://obc.lbl.gov/specification/cdl.html\">
http://obc.lbl.gov/specification/cdl.html</a>.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Firt implementation, based on the blocks from the Modelica Standard Library.
</li>
</ul>
</html>"),     Icon(graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Ellipse(
              origin={10.0,10.0},
              fillColor={76,76,76},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-80.0,-80.0},{-20.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,-80.0},{60.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,0.0},{60.0,60.0}}),
            Ellipse(
              origin={10.0,10.0},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-80.0,0.0},{-20.0,60.0}})}));
    end CDL;

    package OutdoorLights "Package with models for outdoor lighting controls"
      extends Modelica.Icons.Package;

      block DaylightControlled "Controlling the outdoor lighting based on whether the sun is up"
        parameter Real lat(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Latitude";
        parameter Real lon(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Longitude";
        parameter Real timZon(
          final quantity="Time",
          final unit="s",
          displayUnit="h") "Time zone of location";

        CDL.Interfaces.RealOutput y(
          final min = 0,
          final max = 1,
          unit="1") "Output true if lights should be on"
         annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        CDL.Utilities.SunRiseSet sunRiseSet(
        final lat=lat,
        final lon=lon,
        final timZon=timZon) "Output next sunrise and sunset time, and whether the sun is up"
         annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
        CDL.Logical.Not not1 "Logical not"
         annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
        CDL.Conversions.BooleanToReal booToRea "Boolean to real converter"
         annotation (Placement(transformation(extent={{40,-10},{60,10}})));

      equation
        connect(sunRiseSet.sunUp, not1.u) annotation (Line(points={{-58,-6},{-34,-6},{
                -34,0},{-22,0}}, color={255,0,255}));
        connect(not1.y, booToRea.u)
          annotation (Line(points={{2,0},{38,0}}, color={255,0,255}));
        connect(booToRea.y, y)
          annotation (Line(points={{62,0},{120,0}}, color={0,0,127}));
      annotation (
      defaultComponentName="dayCon",
      Documentation(
      info="<html>
<p>
This block outputs on/off control signals for outdoor lighting devices based on
daylight time.
The outdoor lights will be automatically turned off during daylight hours,
and turned on when there is no daylight.
</p>
<h4>Validation</h4>
<p>
A validation can be found at
<a href=\"modelica://Buildings.Controls.OBC.OutdoorLights.Validation.DaylightControlled\">
Buildings.Controls.OBC.OutdoorLights.Validation.DaylightControlled</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
Feb 13, 2019, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"),
      Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{22,70},{24,-96}},
                lineColor={28,108,200},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Line(points={{14,46},{32,46}}, color={0,0,0}),
              Line(points={{6,70},{40,70}}, color={0,0,0}),
              Rectangle(
                extent={{8,-96},{40,-98}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Rectangle(
                extent={{14,72},{32,70}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{22,80},{24,72}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Polygon(
                points={{8,70},{10,70},{18,46},{16,46},{8,70}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Polygon(
                points={{38,70},{36,70},{28,46},{30,46},{38,70}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-100,100},{100,-102}},
                lineColor={0,0,0},
                pattern=LinePattern.None),
              Ellipse(
                extent={{-128,128},{-71.5,71.5}},
                lineColor={238,46,47},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                startAngle=0,
                endAngle=90,
                closure=EllipseClosure.None),
              Line(points={{-88,70},{-88,64}}, color={238,46,47}),
              Line(points={{-70,90},{-62,90}}, color={238,46,47}),
              Line(points={{-76,78},{-72,74}}, color={238,46,47}),
              Text(
                extent={{-164,144},{164,106}},
                lineColor={0,0,255},
                textString="%name")}));
      end DaylightControlled;

      package Validation "Collection of models that validate the outdoor lighting controllers"

        model DaylightControlled "Validation model for the outdoor lighting control based on daylight"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.OutdoorLights.DaylightControlled dayCon(
            lat=0.6457718232379,
            lon=-2.1293016874331,
            timZon=-28800)
            "Controlling the outdoor lighting based on daylight time"
            annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
        annotation (
        experiment(StopTime=604800.0, Tolerance=1e-06),
          __Dymola_Commands(file=
            "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/OutdoorLights/Validation/DaylightControlled.mos"
            "Simulate and plot"),
        Documentation(
        info="<html>
<p>
This example validates the block
<a href=\"modelica://Buildings.Controls.OBC.OutdoorLights.DaylightControlled\">
Buildings.Controls.OBC.OutdoorLights.DaylightControlled</a>.
The parameters are selected for the location of San Francisco.
</p>
</html>",         revisions="<html>
<ul>
<li>
Feb 13, 2019, by Kun Zhang:<br/>
First implemenation.
</li>
</ul>
</html>"));
        end DaylightControlled;
      annotation (
      Documentation(
      info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.OutdoorLights\">
Buildings.Controls.OBC.OutdoorLights</a>.
</p>
</html>"),
      Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Polygon(
                origin={8.0,14.0},
                lineColor={78,138,73},
                fillColor={78,138,73},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
      end Validation;
    annotation (
    Documentation(
    info="<html>
<p>
This package contains outdoor lighting controllers.
</p>
</html>"),
    Icon(graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              extent={{0,70},{2,-96}},
              lineColor={28,108,200},
              fillColor={135,135,135},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Line(points={{-8,46},{10,46}},color={0,0,0}),
            Line(points={{-16,70},{18,70}},color={0,0,0}),
            Rectangle(
              extent={{-14,-96},{18,-98}},
              fillColor={135,135,135},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-8,72},{10,70}},
              fillColor={135,135,135},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Rectangle(
              extent={{0,80},{2,72}},
              fillColor={135,135,135},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-14,70},{-12,70},{-4,46},{-6,46},{-14,70}},
              fillColor={135,135,135},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{16,70},{14,70},{6,46},{8,46},{16,70}},
              fillColor={135,135,135},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Rectangle(
              extent={{-122,100},{78,-102}},
              lineColor={0,0,0},
              pattern=LinePattern.None),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0)}));
    end OutdoorLights;

    package Shade "Shading control sequences"

      block Shade_H "Shade controller with solar irradiation as input"

        parameter Real HHigh(
          final quantity="Irradiance",
          final unit="W/m2")
          "if y=0 and H>=HHigh, switch to y=1";

        parameter Real HLow(
          final quantity="Irradiance",
          final unit="W/m2")
          "if y=1 and H<=HLow, switch to y=0";

        CDL.Interfaces.RealInput H(final unit = "W/m2")
          "Measured irradiation"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        CDL.Interfaces.RealOutput y(
          final min = 0,
          final max = 1,
          unit="1")
          "Control signal"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        CDL.Continuous.Hysteresis hys(
          final uLow=HLow,
          final uHigh=HHigh)
          "Hysteresis block"
          annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
        CDL.Conversions.BooleanToReal booToRea "Boolean to real converter"
          annotation (Placement(transformation(extent={{20,-10},{40,10}})));

      equation
        connect(H, hys.u)
          annotation (Line(points={{-120,0},{-42,0}}, color={0,0,127}));
        connect(hys.y, booToRea.u)
          annotation (Line(points={{-18,0},{18,0}}, color={255,0,255}));
        connect(booToRea.y, y) annotation (Line(points={{42,0},{120,0}},color={0,0,127}));
        annotation (
              defaultComponentName = "shaH",
              Icon(coordinateSystem(extent={{-100,-80},{100,100}}),
                   graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-164,144},{164,106}},
                lineColor={0,0,127},
                textString="%name"),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-29}}, color={192,192,192}),
              Polygon(
                points={{92,-29},{70,-21},{70,-37},{92,-29}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-79,-29},{84,-29}}, color={192,192,192}),
              Line(points={{-79,-29},{41,-29}}),
              Line(points={{-15,-21},{1,-29},{-15,-36}}),
              Line(points={{41,51},{41,-29}}),
              Line(points={{33,3},{41,22},{50,3}}),
              Line(points={{-49,51},{81,51}}),
              Line(points={{-4,59},{-19,51},{-4,43}}),
              Line(points={{-59,29},{-49,11},{-39,29}}),
              Line(points={{-49,51},{-49,-29}}),
              Text(
                extent={{-92,-49},{-9,-92}},
                lineColor={192,192,192},
                textString="%HLow"),
              Text(
                extent={{2,-49},{91,-92}},
                lineColor={192,192,192},
                textString="%HHigh"),
              Rectangle(extent={{-91,-49},{-8,-92}}, lineColor={192,192,192}),
              Line(points={{-49,-29},{-49,-49}}, color={192,192,192}),
              Rectangle(extent={{2,-49},{91,-92}}, lineColor={192,192,192}),
              Line(points={{41,-29},{41,-49}}, color={192,192,192})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              initialScale=0.05)),
      Documentation(info="<html>
<p>
Block that outputs a shade control signal <i>y &isin; {0, 1}</i> as follows:
</p>
<ul>
<li> When <code>y=0</code> and the input <code>H</code> becomes
     greater than the parameter <code>HHigh</code>, the output
     switches to <code>y=1</code>.
</li>
<li> When <code>y=1</code> and the input <code>H</code> becomes
     less than the parameter <code>HLow</code>, the output
     switches to <code>y=0</code>.
</li>
</ul>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/Shade/Shade_H.png\"
   alt=\"Shade control chart\" />
</p>
</html>",       revisions="<html>
<ul>
<li>
June 8, 2018, by Michael Wetter:<br/>
Reimplemented model to make it analogous to the hysteresis block.
</li>
<li>
June 01, 2018, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Shade_H;

      block Shade_T "Shade controller with temperature as input"

        parameter Real THigh(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC")
          "if y=0 and T>=THigh, switch to y=1";

        parameter Real TLow(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC")
          "if y=1 and T<=TLow, switch to y=0";

        CDL.Interfaces.RealInput T(final unit = "K")
          "Measured temperature"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        CDL.Interfaces.RealOutput y(
          final min = 0,
          final max = 1,
          unit="1")
          "Control signal"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        CDL.Continuous.Hysteresis hys(
          final uLow=TLow,
          final uHigh=THigh)
          "Temperature hysteresis"
          annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
        CDL.Conversions.BooleanToReal booToRea "Boolean to real converter"
          annotation (Placement(transformation(extent={{20,-10},{40,10}})));

      equation
        connect(T, hys.u)
          annotation (Line(points={{-120,0},{-42,0}}, color={0,0,127}));
        connect(hys.y, booToRea.u)
          annotation (Line(points={{-18,0},{18,0}},
                                                  color={255,0,255}));
        connect(booToRea.y, y) annotation (Line(points={{42,0},{120,0}},color={0,0,127}));
        annotation (
              defaultComponentName = "shaT",
              Icon(coordinateSystem(extent={{-100,-80},{100,100}}),
                   graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-164,144},{164,106}},
                lineColor={0,0,127},
                textString="%name"),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-29}}, color={192,192,192}),
              Polygon(
                points={{92,-29},{70,-21},{70,-37},{92,-29}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-79,-29},{84,-29}}, color={192,192,192}),
              Line(points={{-79,-29},{41,-29}}),
              Line(points={{-15,-21},{1,-29},{-15,-36}}),
              Line(points={{41,51},{41,-29}}),
              Line(points={{33,3},{41,22},{50,3}}),
              Line(points={{-49,51},{81,51}}),
              Line(points={{-4,59},{-19,51},{-4,43}}),
              Line(points={{-59,29},{-49,11},{-39,29}}),
              Line(points={{-49,51},{-49,-29}}),
              Text(
                extent={{-92,-49},{-9,-92}},
                lineColor={192,192,192},
                textString="%TLow"),
              Text(
                extent={{2,-49},{91,-92}},
                lineColor={192,192,192},
                textString="%THigh"),
              Rectangle(extent={{-91,-49},{-8,-92}}, lineColor={192,192,192}),
              Line(points={{-49,-29},{-49,-49}}, color={192,192,192}),
              Rectangle(extent={{2,-49},{91,-92}}, lineColor={192,192,192}),
              Line(points={{41,-29},{41,-49}}, color={192,192,192})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              initialScale=0.05)),
      Documentation(info="<html>
<p>
Block that outputs a shade control signal <i>y &isin; {0, 1}</i> as follows:
</p>
<ul>
<li> When <code>y=0</code> and the input <code>T</code> becomes
     greater than the parameter <code>THigh</code>, the output
     switches to <code>y=1</code>.
</li>
<li> When <code>y=1</code> and the input <code>T</code> becomes
     less than the parameter <code>TLow</code>, the output
     switches to <code>y=0</code>.
</li>
</ul>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/OBC/Shade/Shade_T.png\"
   alt=\"Shade control chart\" />
</p>
</html>",       revisions="<html>
<ul>
<li>
June 8, 2018, by Michael Wetter:<br/>
Reimplemented model to make it analogous to the hysteresis block.
</li>
<li>
June 01, 2018, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Shade_T;

      package Validation "Collection of validation models"

        model Shade_H "Validation model for shading control based on solar irradiance"

          hil_flexlab_model.Controls_HIL.OBC.Shade.Shade_H shaH(HHigh=500, HLow
              =400) "Shade controller"
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));

          CDL.Continuous.Sources.Sine H(
            final amplitude=500,
            final freqHz=1/(2*1800),
            final offset=250)
            "Solar irradiance"
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));

        equation
          connect(H.y, shaH.H) annotation (Line(points={{-19,0},{18,0}}, color={0,0,127}));
          annotation (
            experiment(StopTime=1800.0, Tolerance=1e-06),
            __Dymola_Commands(file=
                "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/Shade/Validation/Shade_H.mos"
                "Simulate and plot"),
            Icon(graphics={Ellipse(
                  lineColor={75,138,73},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  extent={{-100,-100},{100,100}}), Polygon(
                  lineColor={0,0,255},
                  fillColor={75,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}})),
            Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.Shade.Shade_H\">
Buildings.Controls.OBC.Shade.Shade_H</a>
for a solar irradiance input signal.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 8, 2018, by Michael Wetter:<br/>
Refactored model for new implemenation.
</li>
<li>
June 05, 2018, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Shade_H;

        model Shade_T "Validation model for shade control based on temperature"

          hil_flexlab_model.Controls_HIL.OBC.Shade.Shade_T shaT(THigh=298.15,
              TLow=295.15) "Shade controller"
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));

          CDL.Continuous.Sources.Sine T(
            final amplitude=10,
            final freqHz=1/(2*1800),
            final offset=293.15)
            "Measured temperature"
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));

        equation
          connect(T.y, shaT.T) annotation (Line(points={{-19,0},{18,0}}, color={0,0,127}));
          annotation (
            experiment(StopTime=1800.0, Tolerance=1e-06),
            __Dymola_Commands(file=
                "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/Shade/Validation/Shade_T.mos"
                "Simulate and plot"),
            Icon(graphics={Ellipse(
                  lineColor={75,138,73},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  extent={{-100,-100},{100,100}}), Polygon(
                  lineColor={0,0,255},
                  fillColor={75,138,73},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-36,58},{64,-2},{-36,-62},{-36,58}})}),
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}})),
            Documentation(info="<html>
<p>
This example validates
<a href=\"modelica://Buildings.Controls.OBC.Shade.Shade_T\">
Buildings.Controls.OBC.Shade.Shade_T</a>
for a temperature input signal.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 8, 2018, by Michael Wetter:<br/>
Refactored model for new implemenation.
</li>
<li>
June 05, 2018, by Milica Grahovac:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Shade_T;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.OBC.Shade\">
Buildings.Controls.OBC.Shade</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"),
        Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Polygon(
                origin={8.0,14.0},
                lineColor={78,138,73},
                fillColor={78,138,73},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
      end Validation;
      annotation (
        Documentation(info="<html>
        <p>
        This package contains shade control sequences.
        </p>
        </html>",    revisions="<html>
        <ul>
        <li>
        June 07, 2018, by Milica Grahovac:<br/>
        First implementation.
        </li>
        </ul>
        </html>"),
        Icon(coordinateSystem(extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100,-100},{100,100}},
              radius=25.0),
            Ellipse(
              origin={10.0,10.0},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-80.0,0.0},{-20.0,60.0}}),
            Ellipse(
              origin={10.0,10.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,0.0},{60.0,60.0}}),
            Ellipse(
              origin={10.0,10.0},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,-80.0},{60.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              fillColor={76,76,76},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-80.0,-80.0},{-20.0,-20.0}}),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0)}), Diagram(coordinateSystem(extent={{-100,-100},{
              100,100}})));
    end Shade;

    package UnitConversions "Package with blocks for unit conversion"

      block From_Btu "Block that converts work from British thermal units to joule"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            quantity="Work") "Work in British thermal units"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="J", final quantity="Work") "Work in joule"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1055.056 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_Btu",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="Btu"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="J"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts work given in British thermal units [Btu] to joule [J].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_Btu;

      block From_BtuPerHour "Block that converts power from British thermal units per hour to watt"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            quantity="Power") "Power in British thermal units per hour"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="W", final quantity="Power") "Power in watt"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 0.2930711 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_BtuPerHour",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="Btu/h"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="W"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts power given in British thermal units per hour [Btu/h] to watt [W].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_BtuPerHour;

      block From_bar "Block that converts pressure from bar to pascal"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="bar", final quantity="Pressure") "Pressure in bar"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="Pa", final quantity="Pressure") "Pressure in pascal"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 100000. "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_bar",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="bar"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="Pa"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts pressure given in bar [bar] to pascal [Pa].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_bar;

      block From_cfm "Block that converts volume flow from cubic feet per minute to cubic meters per second"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            quantity="VolumeFlowRate") "Volume flow in cubic feet per minute"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="m3/s", final quantity="VolumeFlowRate")
          "Volume flow in cubic meters per second"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 0.000471947 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_cfm",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="cfm"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="m3/s"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts volume flow given in cubic feet per minute [cfm] to cubic meters per second [m3/s].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_cfm;

      block From_degC "Block that converts temperature from degree Celsius to kelvin"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="degC", final quantity="ThermodynamicTemperature")
          "Temperature in degree Celsius"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="K", final quantity="ThermodynamicTemperature")
          "Temperature in kelvin"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1. "Multiplier";
        constant Real p = 273.15 "Adder";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter conv(final p=p,
            final k=k) "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_degC",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="degC"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="K"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts temperature given in degree Celsius [degC] to kelvin [K].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_degC;

      block From_degF "Block that converts temperature from degree Fahrenheit to kelvin"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="degF", final quantity="ThermodynamicTemperature")
          "Temperature in degree Fahrenheit"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="K", final quantity="ThermodynamicTemperature")
          "Temperature in kelvin"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 5./9. "Multiplier";
        constant Real p = -32. * (5./9.) + 273.15 "Adder";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter conv(final p=p,
            final k=k) "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_degF",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="degF"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="K"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts temperature given in degree Fahrenheit [degF] to kelvin [K].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_degF;

      block From_gal "Block that converts volume from gallon to cubic meter"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            quantity="Volume") "Volume in gallon"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="m3", final quantity="Volume") "Volume in cubic meter"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 0.003785412 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_gal",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="gal"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="m3"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts volume given in gallon [gal] to cubic meter [m3].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_gal;

      block From_hp "Block that converts power from horsepower to watt"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            quantity="Power") "Power in horsepower"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="W", final quantity="Power") "Power in watt"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 0.7457 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_hp",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="hp"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="W"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts power given in horsepower [hp] to watt [W].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_hp;

      block From_inH2O "Block that converts pressure from inch of water gauge (at 60 degF) to pascal"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            quantity="Pressure") "Pressure in inch of water gauge (at 60 degF)"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="Pa", final quantity="Pressure") "Pressure in pascal"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 248.84 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_inH2O",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="inH2O"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="Pa"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts pressure given in inch of water gauge (at 60 degF) [inH2O] to pascal [Pa].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_inH2O;

      block From_psi "Block that converts pressure from pound-force per square inch to pascal"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            quantity="Pressure") "Pressure in pound-force per square inch"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="Pa", final quantity="Pressure") "Pressure in pascal"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 6895. "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_psi",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="psi"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="Pa"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts pressure given in pound-force per square inch [psi] to pascal [Pa].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_psi;

      block From_quad "Block that converts work from quads to joule"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            quantity="Work") "Work in quads"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="J", final quantity="Work") "Work in joule"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1055.56e15 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_quad",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="quad"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="J"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts work given in quads [quad] to joule [J].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_quad;

      block From_ton "Block that converts power from ton of refrigeration to watt"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            quantity="Power") "Power in ton of refrigeration"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="W", final quantity="Power") "Power in watt"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 3517. "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "from_ton",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="ton"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="W"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts power given in ton of refrigeration [ton] to watt [W].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end From_ton;

      block To_Btu "Block that converts work from joule to British thermal units"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="J", final quantity="Work") "Work in joule"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            quantity="Work") "Work in British thermal units"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./1055.056 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_Btu",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="J"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="Btu"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts work given in joule [J] to British thermal units [Btu].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_Btu;

      block To_BtuPerHour "Block that converts power from watt to British thermal units per hour"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="W", final quantity="Power") "Power in watt"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            quantity="Power") "Power in British thermal units per hour"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./0.2930711 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_BtuPerHour",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="W"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="Btu/h"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts power given in watt [W] to British thermal units per hour [Btu/h].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_BtuPerHour;

      block To_bar "Block that converts pressure from pascal to bar"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="Pa", final quantity="Pressure") "Pressure in pascal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="bar", final quantity="Pressure") "Pressure in bar"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./100000. "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_bar",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="Pa"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="bar"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts pressure given in pascal [Pa] to bar [bar].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_bar;

      block To_cfm "Block that converts volume flow from cubic meters per second to cubic feet per minute"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="m3/s", final quantity="VolumeFlowRate")
          "Volume flow in cubic meters per second"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            quantity="VolumeFlowRate") "Volume flow in cubic feet per minute"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./0.000471947 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_cfm",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="m3/s"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="cfm"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts volume flow given in cubic meters per second [m3/s] to cubic feet per minute [cfm].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_cfm;

      block To_degC "Block that converts temperature from kelvin to degree Celsius"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="K", final quantity="ThermodynamicTemperature")
          "Temperature in kelvin"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="degC", final quantity="ThermodynamicTemperature")
          "Temperature in degree Celsius"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1. "Multiplier";
        constant Real p = -273.15 "Adder";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter conv(final p=p,
            final k=k) "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_degC",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="K"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="degC"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts temperature given in kelvin [K] to degree Celsius [degC].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_degC;

      block To_degF "Block that converts temperature from kelvin to degree Fahrenheit"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="K", final quantity="ThermodynamicTemperature")
          "Temperature in kelvin"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            unit="degF", final quantity="ThermodynamicTemperature")
          "Temperature in degree Fahrenheit"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 9./5. "Multiplier";
        constant Real p = (-9./5.) * 273.15 + 32 "Adder";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter conv(final p=p,
            final k=k) "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_degF",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="K"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="degF"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts temperature given in kelvin [K] to degree Fahrenheit [degF].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_degF;

      block To_gal "Block that converts volume from cubic meter to gallon"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="m3", final quantity="Volume") "Volume in cubic meter"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            quantity="Volume") "Volume in gallon"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./0.003785412 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_gal",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="m3"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="gal"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts volume given in cubic meter [m3] to gallon [gal].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_gal;

      block To_hp "Block that converts power from watt to horsepower"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="W", final quantity="Power") "Power in watt"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            quantity="Power") "Power in horsepower"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./0.7457 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_hp",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="W"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="hp"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts power given in watt [W] to horsepower [hp].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_hp;

      block To_inH2O "Block that converts pressure from pascal to inch of water gauge (at 60 degF)"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="Pa", final quantity="Pressure") "Pressure in pascal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            quantity="Pressure") "Pressure in inch of water gauge (at 60 degF)"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./248.84 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_inH2O",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="Pa"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="inH2O"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts pressure given in pascal [Pa] to inch of water gauge (at 60 degF) [inH2O].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_inH2O;

      block To_psi "Block that converts pressure from pascal to pound-force per square inch"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="Pa", final quantity="Pressure") "Pressure in pascal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            quantity="Pressure") "Pressure in pound-force per square inch"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./6895. "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_psi",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="Pa"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="psi"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts pressure given in pascal [Pa] to pound-force per square inch [psi].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_psi;

      block To_quad "Block that converts work from joule to quads"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="J", final quantity="Work") "Work in joule"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            quantity="Work") "Work in quads"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./1055.56e15 "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_quad",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="J"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="quad"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts work given in joule [J] to quads [quad].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_quad;

      block To_ton "Block that converts power from watt to ton of refrigeration"

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput u(final
            unit="W", final quantity="Power") "Power in watt"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput y(final
            quantity="Power") "Power in ton of refrigeration"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));

      protected
        constant Real k = 1./3517. "Multiplier";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain conv(final k=k)
          "Unit converter"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      equation
        connect(u, conv.u)
          annotation (Line(points={{-120,0},{-12,0}},color={0,0,127}));
        connect(conv.y, y)
          annotation (Line(points={{12,0},{120,0}},color={0,0,127}));
        annotation (
            defaultComponentName = "to_ton",
          Icon(graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{20,58}}, color={28,108,200}),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Text(
                extent={{-80,50},{0,10}},
                lineColor={0,0,127},
                textString="W"),
              Text(
                extent={{10,-70},{90,-30}},
                lineColor={0,0,127},
                textString="ton"),
              Polygon(
              points={{90,0},{30,20},{30,-20},{90,0}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0})}),
              Documentation(info="<html>
<p>
Converts power given in watt [W] to ton of refrigeration [ton].
</p>
</html>",       revisions="<html>
<ul>
<li>
July 05, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
      end To_ton;

      package Validation "Collection of models that validate the unit conversion blocks of the CDL"

        model From_Btu "Validation model for unit conversion from British thermal units to joule"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1. "Validation input";
          parameter Real kin1 = 2. "Validation input 1";
          parameter Real kout = 1.*1055.056 "Validation output";
          parameter Real kout1 = 2.*1055.056 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_Btu from_Btu
            "Unit converter from British thermal units to joule "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_Btu from_Btu1
            "Unit converter from British thermal units to joule "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_Btu1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_Btu1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_Btu.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_Btu.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_Btu.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates work unit conversion from British thermal units to joule.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_Btu;

        model From_BtuPerHour "Validation model for unit conversion from British thermal units per hour to watt"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1./0.2930711 "Validation input";
          parameter Real kin1 = 1000./0.2930711 "Validation input 1";
          parameter Real kout = 1 "Validation output";
          parameter Real kout1 = 1000 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_BtuPerHour from_BtuPerHour
            "Unit converter from British thermal units per hour to watt "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_BtuPerHour from_BtuPerHour1
            "Unit converter from British thermal units per hour to watt "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_BtuPerHour1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_BtuPerHour1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_BtuPerHour.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_BtuPerHour.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_BtuPerHour.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates power unit conversion from British thermal units per hour to watt.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_BtuPerHour;

        model From_bar "Validation model for unit conversion from bar to pascal"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1. "Validation input";
          parameter Real kin1 = 0.00025 "Validation input 1";
          parameter Real kout = 1.*100000. "Validation output";
          parameter Real kout1 = 0.00025*100000. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_bar from_bar
            "Unit converter from bar to pascal "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_bar from_bar1
            "Unit converter from bar to pascal "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_bar1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_bar1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_bar.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_bar.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_bar.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates pressure unit conversion from bar to pascal.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_bar;

        model From_cfm "Validation model for unit conversion from cubic feet per minute to cubic meters per second"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 100. "Validation input";
          parameter Real kin1 = 2000. "Validation input 1";
          parameter Real kout = 100.*0.000471947 "Validation output";
          parameter Real kout1 = 2000.*0.000471947 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_cfm from_cfm
            "Unit converter from cubic feet per minute to cubic meters per second "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_cfm from_cfm1
            "Unit converter from cubic feet per minute to cubic meters per second "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_cfm1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_cfm1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_cfm.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_cfm.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_cfm.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates volume flow unit conversion from cubic feet per minute to cubic meters per second.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_cfm;

        model From_degC "Validation model for unit conversion from degree Celsius to kelvin"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 0. "Validation input";
          parameter Real kin1 = 100. "Validation input 1";
          parameter Real kout = 273.15 "Validation output";
          parameter Real kout1 = 373.15 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_degC from_degC
            "Unit converter from degree Celsius to kelvin "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_degC from_degC1
            "Unit converter from degree Celsius to kelvin "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_degC1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_degC1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_degC.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_degC.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_degC.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates temperature unit conversion from degree Celsius to kelvin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_degC;

        model From_degF "Validation model for unit conversion from degree Fahrenheit to kelvin"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 32. "Validation input";
          parameter Real kin1 = 100. * (9./5.) + 32. "Validation input 1";
          parameter Real kout = 273.15 "Validation output";
          parameter Real kout1 = 373.15 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_degF from_degF
            "Unit converter from degree Fahrenheit to kelvin "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_degF from_degF1
            "Unit converter from degree Fahrenheit to kelvin "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_degF1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_degF1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_degF.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_degF.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_degF.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates temperature unit conversion from degree Fahrenheit to kelvin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_degF;

        model From_gal "Validation model for unit conversion from gallon to cubic meter"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1. "Validation input";
          parameter Real kin1 = 100. "Validation input 1";
          parameter Real kout = 1.*0.003785412 "Validation output";
          parameter Real kout1 = 100.*0.003785412 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_gal from_gal
            "Unit converter from gallon to cubic meter "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_gal from_gal1
            "Unit converter from gallon to cubic meter "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_gal1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_gal1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_gal.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_gal.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_gal.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates volume unit conversion from gallon to cubic meter.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_gal;

        model From_hp "Validation model for unit conversion from horsepower to watt"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 10. "Validation input";
          parameter Real kin1 = 45. "Validation input 1";
          parameter Real kout = 10.*0.7457 "Validation output";
          parameter Real kout1 = 45.*0.7457 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_hp from_hp
            "Unit converter from horsepower to watt "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_hp from_hp1
            "Unit converter from horsepower to watt "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_hp1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_hp1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_hp.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_hp.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_hp.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates power unit conversion from horsepower to watt.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_hp;

        model From_inH2O "Validation model for unit conversion from inch of water gauge (at 60 degF) to pascal"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 25./248.84 "Validation input";
          parameter Real kin1 = 100000./248.84 "Validation input 1";
          parameter Real kout = 25 "Validation output";
          parameter Real kout1 = 100000 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_inH2O from_inH2O
            "Unit converter from inch of water gauge (at 60 degF) to pascal "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_inH2O from_inH2O1
            "Unit converter from inch of water gauge (at 60 degF) to pascal "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_inH2O1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_inH2O1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_inH2O.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_inH2O.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_inH2O.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates pressure unit conversion from inch of water gauge (at 60 degF) to pascal.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_inH2O;

        model From_psi "Validation model for unit conversion from pound-force per square inch to pascal"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 0.0036 "Validation input";
          parameter Real kin1 = 1. "Validation input 1";
          parameter Real kout = 0.0036*6895. "Validation output";
          parameter Real kout1 = 1.*6895. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_psi from_psi
            "Unit converter from pound-force per square inch to pascal "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_psi from_psi1
            "Unit converter from pound-force per square inch to pascal "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_psi1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_psi1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_psi.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_psi.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_psi.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates pressure unit conversion from pound-force per square inch to pascal.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_psi;

        model From_quad "Validation model for unit conversion from quads to joule"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1. "Validation input";
          parameter Real kin1 = 2. "Validation input 1";
          parameter Real kout = 1.*1055.56e15 "Validation output";
          parameter Real kout1 = 2.*1055.56e15 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_quad from_quad
            "Unit converter from quads to joule "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_quad from_quad1
            "Unit converter from quads to joule "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_quad1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_quad1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_quad.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_quad.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_quad.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates work unit conversion from quads to joule.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_quad;

        model From_ton "Validation model for unit conversion from ton of refrigeration to watt"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1. "Validation input";
          parameter Real kin1 = 100. "Validation input 1";
          parameter Real kout = 3517. "Validation output";
          parameter Real kout1 = 351700. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_ton from_ton
            "Unit converter from ton of refrigeration to watt "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.From_ton from_ton1
            "Unit converter from ton of refrigeration to watt "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,from_ton1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(from_ton1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(from_ton.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,from_ton.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/From_ton.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates power unit conversion from ton of refrigeration to watt.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end From_ton;

        model To_Btu "Validation model for unit conversion from joule to British thermal units"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1.*1055.056 "Validation input";
          parameter Real kin1 = 2.*1055.056 "Validation input 1";
          parameter Real kout = 1. "Validation output";
          parameter Real kout1 = 2. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_Btu to_Btu
            "Unit converter from joule to British thermal units "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_Btu to_Btu1
            "Unit converter from joule to British thermal units "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_Btu1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_Btu1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_Btu.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_Btu.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_Btu.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates work unit conversion from joule to British thermal units.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_Btu;

        model To_BtuPerHour "Validation model for unit conversion from watt to British thermal units per hour"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1 "Validation input";
          parameter Real kin1 = 1000 "Validation input 1";
          parameter Real kout = 1./0.2930711 "Validation output";
          parameter Real kout1 = 1000./0.2930711 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_BtuPerHour to_BtuPerHour
            "Unit converter from watt to British thermal units per hour "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_BtuPerHour to_BtuPerHour1
            "Unit converter from watt to British thermal units per hour "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_BtuPerHour1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_BtuPerHour1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_BtuPerHour.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_BtuPerHour.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_BtuPerHour.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates power unit conversion from watt to British thermal units per hour.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_BtuPerHour;

        model To_bar "Validation model for unit conversion from pascal to bar"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1.*100000. "Validation input";
          parameter Real kin1 = 0.00025*100000. "Validation input 1";
          parameter Real kout = 1. "Validation output";
          parameter Real kout1 = 0.00025 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_bar to_bar
            "Unit converter from pascal to bar "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_bar to_bar1
            "Unit converter from pascal to bar "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_bar1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_bar1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_bar.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_bar.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_bar.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates pressure unit conversion from pascal to bar.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_bar;

        model To_cfm "Validation model for unit conversion from cubic meters per second to cubic feet per minute"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 100.*0.000471947 "Validation input";
          parameter Real kin1 = 2000.*0.000471947 "Validation input 1";
          parameter Real kout = 100. "Validation output";
          parameter Real kout1 = 2000. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_cfm to_cfm
            "Unit converter from cubic meters per second to cubic feet per minute "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_cfm to_cfm1
            "Unit converter from cubic meters per second to cubic feet per minute "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_cfm1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_cfm1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_cfm.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_cfm.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_cfm.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates volume flow unit conversion from cubic meters per second to cubic feet per minute.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_cfm;

        model To_degC "Validation model for unit conversion from kelvin to degree Celsius"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 273.15 "Validation input";
          parameter Real kin1 = 373.15 "Validation input 1";
          parameter Real kout = 0. "Validation output";
          parameter Real kout1 = 100. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_degC to_degC
            "Unit converter from kelvin to degree Celsius "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_degC to_degC1
            "Unit converter from kelvin to degree Celsius "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_degC1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_degC1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_degC.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_degC.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_degC.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates temperature unit conversion from kelvin to degree Celsius.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_degC;

        model To_degF "Validation model for unit conversion from kelvin to degree Fahrenheit"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 273.15 "Validation input";
          parameter Real kin1 = 373.15 "Validation input 1";
          parameter Real kout = 32. "Validation output";
          parameter Real kout1 = 100. * (9./5.) + 32. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_degF to_degF
            "Unit converter from kelvin to degree Fahrenheit "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_degF to_degF1
            "Unit converter from kelvin to degree Fahrenheit "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_degF1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_degF1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_degF.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_degF.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_degF.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates temperature unit conversion from kelvin to degree Fahrenheit.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_degF;

        model To_gal "Validation model for unit conversion from cubic meter to gallon"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1.*0.003785412 "Validation input";
          parameter Real kin1 = 100.*0.003785412 "Validation input 1";
          parameter Real kout = 1. "Validation output";
          parameter Real kout1 = 100. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_gal to_gal
            "Unit converter from cubic meter to gallon "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_gal to_gal1
            "Unit converter from cubic meter to gallon "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_gal1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_gal1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_gal.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_gal.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_gal.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates volume unit conversion from cubic meter to gallon.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_gal;

        model To_hp "Validation model for unit conversion from watt to horsepower"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 10.*0.7457 "Validation input";
          parameter Real kin1 = 45.*0.7457 "Validation input 1";
          parameter Real kout = 10. "Validation output";
          parameter Real kout1 = 45. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_hp to_hp
            "Unit converter from watt to horsepower "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_hp to_hp1
            "Unit converter from watt to horsepower "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_hp1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_hp1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_hp.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_hp.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_hp.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates power unit conversion from watt to horsepower.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_hp;

        model To_inH2O "Validation model for unit conversion from pascal to inch of water gauge (at 60 degF)"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 25. "Validation input";
          parameter Real kin1 = 100000. "Validation input 1";
          parameter Real kout = 25./248.84 "Validation output";
          parameter Real kout1 = 100000./248.84 "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_inH2O to_inH2O
            "Unit converter from pascal to inch of water gauge (at 60 degF) "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_inH2O to_inH2O1
            "Unit converter from pascal to inch of water gauge (at 60 degF) "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_inH2O1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_inH2O1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_inH2O.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_inH2O.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_inH2O.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates pressure unit conversion from pascal to inch of water gauge (at 60 degF).
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_inH2O;

        model To_psi "Validation model for unit conversion from pascal to pound-force per square inch"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 0.0036*6895. "Validation input";
          parameter Real kin1 = 1.*6895. "Validation input 1";
          parameter Real kout = 0.0036 "Validation output";
          parameter Real kout1 = 1. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_psi to_psi
            "Unit converter from pascal to pound-force per square inch "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_psi to_psi1
            "Unit converter from pascal to pound-force per square inch "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_psi1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_psi1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_psi.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_psi.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_psi.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates pressure unit conversion from pascal to pound-force per square inch.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_psi;

        model To_quad "Validation model for unit conversion from joule to quads"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 1.*1055.56e15 "Validation input";
          parameter Real kin1 = 2.*1055.56e15 "Validation input 1";
          parameter Real kout = 1. "Validation output";
          parameter Real kout1 = 2. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_quad to_quad
            "Unit converter from joule to quads "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_quad to_quad1
            "Unit converter from joule to quads "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_quad1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_quad1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_quad.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_quad.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_quad.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates work unit conversion from joule to quads.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_quad;

        model To_ton "Validation model for unit conversion from watt to ton of refrigeration"
          extends Modelica.Icons.Example;

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(k2=-1)
            "Difference between the calculated and expected conversion output"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));

        protected
          parameter Real kin = 3517. "Validation input";
          parameter Real kin1 = 351700. "Validation input 1";
          parameter Real kout = 1. "Validation output";
          parameter Real kout1 = 100. "Validation output 1";

          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_ton to_ton
            "Unit converter from watt to ton of refrigeration "
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          hil_flexlab_model.Controls_HIL.OBC.UnitConversions.To_ton to_ton1
            "Unit converter from watt to ton of refrigeration "
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value(final k=
                kin) "Value to convert"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant value1(final k=
                kin1) "Value to convert" annotation (Placement(transformation(
                  extent={{-60,-40},{-40,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result(final k=
                kout) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant result1(final k=
                kout1) "Expected converted value"
            annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));

        equation
          connect(result.y, add.u2)
            annotation (Line(points={{2,20},{10,20},{10,44},{18,44}}, color={0,0,127}));
          connect(result1.y, add1.u2)
            annotation (Line(points={{2,-60},{10,-60},{10,-36},{18,-36}}, color={0,0,127}));
          connect(value1.y,to_ton1.u)
            annotation (Line(points={{-38,-30},{-22,-30}}, color={0,0,127}));
          connect(to_ton1.y, add1.u1)
            annotation (Line(points={{2,-30},{8,-30},{8,-24},{18,-24}}, color={0,0,127}));
          connect(to_ton.y, add.u1)
            annotation (Line(points={{2,50},{10,50},{10,56},{18,56}}, color={0,0,127}));
          connect(value.y,to_ton.u)
            annotation (Line(points={{-38,50}, {-22,50}}, color={0,0,127}));
          annotation (Icon(graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent = {{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points = {{-36,60},{64,0},{-36,-60},{-36,60}})}),
                        Diagram(coordinateSystem( preserveAspectRatio=false)),
                    experiment(StopTime=10.0, Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/UnitConversions/Validation/To_ton.mos"
            "Simulate and plot"),
            Documentation(
            info="<html>
<p>
This model validates power unit conversion from watt to ton of refrigeration.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 05, 2018, Milica Grahovac<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"));
        end To_ton;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that validate the blocks in
<a href=\"modelica://Buildings.Controls.OBC.UnitConversions\">
Buildings.Controls.OBC.UnitConversions</a>.
</p>
<p>
The examples plot various outputs, which have been verified against
analytical solutions. These model outputs are stored as reference data to
allow continuous validation whenever models in the library change.
</p>
</html>"),Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100,-100},{100,100}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100,-100},{100,100}},
                radius=25.0),
              Polygon(
                origin={8,14},
                lineColor={78,138,73},
                fillColor={78,138,73},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
      end Validation;
    annotation (
    Documentation(
    info="<html>
<p>
Package with blocks for unit conversions.
</p>
</html>",
    revisions="<html>
<ul>
<li>
August 1, 2018, by Milica Grahovac:<br/>
Generated with <code>Buildings/Resources/src/Controls/OBC/UnitConversions/unit_converters.py</code>.<br/>
First implementation.
</li>
</ul>
</html>"),     Icon(graphics={
      Rectangle(
        lineColor={200,200,200},
        fillColor={248,248,248},
        fillPattern=FillPattern.HorizontalCylinder,
        extent={{-100.0,-100.0},{100.0,100.0}},
        radius=25.0),
      Rectangle(
        lineColor={128,128,128},
        extent={{-100.0,-100.0},{100.0,100.0}},
        radius=25.0),
            Polygon(
            points={{92,-42},{32,-22},{32,-62},{92,-42}},
            lineColor={191,0,0},
            fillColor={191,0,0},
            fillPattern=FillPattern.Solid),
            Line(points={{-88,-42},{32,-42}},
                color={191,0,0}),
            Text(
              extent={{-72,78},{72,6}},
              lineColor={0,0,0},
            textString="SI")}));
    end UnitConversions;

    package Utilities "Package with utility functions"

      block OptimalStart
        "Block that outputs the optimal start time for an HVAC system before occupancy"
        parameter Real tOptMax(
          final quantity="Time",
          final unit="s",
          displayUnit="h",
          final min=0,
          max=21600) = 10800
          "Maximum optimal start time";
        parameter Integer nDay(min=1) = 3
          "Number of previous days used to compute the optimal start up time";
        parameter Boolean computeHeating = false
          "Set to true to compute optimal start for heating";
        parameter Boolean computeCooling = false
          "Set to true to compute optimal start for cooling";
        parameter Real uLow(
          final quantity="TemperatureDifference",
          final unit="K",
          final min=0) = 0
          "Threshold to determine if the zone temperature reaches the occupied setpoint,
     must be a non-negative number";
        parameter Real uHigh(
          final quantity="TemperatureDifference",
          final unit="K",
          final min=0) = 0.5
          "Threshold to determine the need to start the HVAC system before occupancy,
     must be greater than uLow";
        parameter Real thrOptOn(
          final quantity="Time",
          final unit="s",
          displayUnit="h",
          final min=0,
          max=10800) = 60
          "Threshold time, optimal start on signal becomes true when tOpt larger than thrOptOn";

        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSetZonHea(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC",
          min=200) if computeHeating
          "Zone heating setpoint temperature during occupancy" annotation (
            Placement(transformation(extent={{-180,60},{-140,100}}),
              iconTransformation(extent={{-140,60},{-100,100}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TZon(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC",
          min=200) "Zone temperature" annotation (Placement(transformation(
                extent={{-180,-50},{-140,-10}}), iconTransformation(extent={{-140,
                  -50},{-100,-10}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TSetZonCoo(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC",
          min=200) if computeCooling
          "Zone cooling setpoint temperature during occupancy" annotation (
            Placement(transformation(extent={{-180,10},{-140,50}}),
              iconTransformation(extent={{-140,10},{-100,50}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput tNexOcc(
          final quantity="Time",
          final unit="s",
          displayUnit="h") "Time until next occupancy" annotation (Placement(
              transformation(extent={{-180,-100},{-140,-60}}),
              iconTransformation(extent={{-140,-100},{-100,-60}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput tOpt(
          final quantity="Time",
          final unit="s",
          displayUnit="h") "Optimal start time duration of HVAC system"
          annotation (Placement(transformation(extent={{140,20},{180,60}}),
              iconTransformation(extent={{100,20},{140,60}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput optOn
          "Outputs true if the HVAC system remains in the optimal start period"
          annotation (Placement(transformation(extent={{140,-60},{180,-20}}),
              iconTransformation(extent={{100,-60},{140,-20}})));

        hil_flexlab_model.Controls_HIL.OBC.Utilities.BaseClasses.OptimalStartCalculation
          optHea(
          final tOptMax=tOptMax,
          final thrOptOn=thrOptOn,
          final tOptDef=tOptDef,
          final nDay=nDay,
          final uLow=uLow,
          final uHigh=uHigh) if computeHeating
          "Optimal start time for heating system"
          annotation (Placement(transformation(extent={{20,60},{40,80}})));
        hil_flexlab_model.Controls_HIL.OBC.Utilities.BaseClasses.OptimalStartCalculation
          optCoo(
          final tOptMax=tOptMax,
          final thrOptOn=thrOptOn,
          final tOptDef=tOptDef,
          final nDay=nDay,
          final uLow=uLow,
          final uHigh=uHigh) if computeCooling
          "Optimal start time for cooling system"
          annotation (Placement(transformation(extent={{20,-80},{40,-60}})));
      protected
        parameter Real tOptDef(
           final quantity="Time",
          final unit="s",
          displayUnit="h") = 3600
          "Default optimal start time";
        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Max max
          "Get the maximum optimal start time "
          annotation (Placement(transformation(extent={{100,30},{120,50}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.AddParameter addPar(p=-
              tOptMax, k=1) "Maximum optimal start time"
          annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hysSta(
          pre_y_start=false,
          uHigh=60,
          uLow=0) "Hysteresis to activate the optimal start boolean output"
          annotation (Placement(transformation(extent={{-70,-10},{-50,10}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Or or2
          "Get the optimal start boolean output"
          annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dTHea(final k1=+1,
            final k2=-1) if computeHeating
          "Temperature difference between heating setpoint and zone temperature"
          annotation (Placement(transformation(extent={{-80,70},{-60,90}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dTCoo(final k1=+1,
            final k2=-1) if computeCooling
          "Temperature difference between zone temperature and cooling setpoint"
          annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.FallingEdge falEdg
          "Stop calculation"
          annotation (Placement(transformation(extent={{-30,-10},{-10,10}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant con2(final k=0)
          if not computeHeating
          "Becomes effective when optimal start is only for heating"
          annotation (Placement(transformation(extent={{60,40},{80,60}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant con1(final k=0)
          if not computeCooling
          "Becomes effective when optimal start is only for cooling"
          annotation (Placement(transformation(extent={{60,10},{80,30}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant con(final k=
              false) if not computeHeating
          "Becomes effective when optimal start is only for heating"
          annotation (Placement(transformation(extent={{60,-30},{80,-10}})));
        hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Sources.Constant con3(final k=
              false) if not computeCooling
          "Becomes effective when optimal start is only for cooling"
          annotation (Placement(transformation(extent={{60,-94},{80,-74}})));
      equation
        connect(TSetZonCoo, dTCoo.u2) annotation (Line(points={{-160,30},{-132,30},{-132,
                -56},{-82,-56}},     color={0,0,127}));
        connect(TZon, dTCoo.u1) annotation (Line(points={{-160,-30},{-126,-30},{-126,-44},
                {-82,-44}},color={0,0,127}));
        connect(TZon, dTHea.u2) annotation (Line(points={{-160,-30},{-126,-30},{-126,74},
                {-82,74}}, color={0,0,127}));
        connect(TSetZonHea, dTHea.u1) annotation (Line(points={{-160,80},{-126,80},{-126,
                86},{-82,86}},  color={0,0,127}));
        connect(max.y, tOpt) annotation (Line(points={{122,40},{160,40}},
                      color={0,0,127}));
        connect(con2.y, max.u1) annotation (Line(points={{82,50},{88,50},{88,46},{98,
                46}},      color={0,0,127}));
        connect(con1.y, max.u2) annotation (Line(points={{82,20},{88,20},{88,34},{98,
                34}}, color={0,0,127}));
        connect(dTCoo.y, optCoo.TDif) annotation (Line(points={{-58,-50},{-22,-50},{-22,
                -62},{18,-62}}, color={0,0,127}));
        connect(dTHea.y, optHea.TDif)   annotation (Line(points={{-58,80},{-8,80},{-8,78},{18,78}},
                                                      color={0,0,127}));
        connect(tNexOcc, addPar.u) annotation (Line(points={{-160,-80},{-120,-80},{-120,
                0},{-102,0}},     color={0,0,127}));
        connect(addPar.y, hysSta.u)   annotation (Line(points={{-78,0},{-72,0}}, color={0,0,127}));
        connect(hysSta.y, falEdg.u) annotation (Line(points={{-48,0},{-32,0}},
                            color={255,0,255}));
        connect(tNexOcc, optHea.tNexOcc) annotation (Line(points={{-160,-80},{-120,-80},
                {-120,62},{18,62}}, color={0,0,127}));
        connect(optCoo.tOpt, max.u2) annotation (Line(points={{42,-66},{88,-66},{88,
                34},{98,34}},  color={0,0,127}));
        connect(optHea.tOpt, max.u1) annotation (Line(points={{42,74},{88,74},{88,46},
                {98,46}}, color={0,0,127}));
        connect(tNexOcc, optCoo.tNexOcc) annotation (Line(points={{-160,-80},{-68,-80},
                {-68,-78},{18,-78}}, color={0,0,127}));
        connect(falEdg.y, optHea.staCal) annotation (Line(points={{-8,0},{0,0},{0,70},
                {18,70}},     color={255,0,255}));
        connect(falEdg.y, optCoo.staCal) annotation (Line(points={{-8,0},{0,0},{0,-70},
                {18,-70}},      color={255,0,255}));
        connect(or2.y,optOn)    annotation (Line(points={{122,-40},{160,-40}}, color={255,0,255}));
        connect(con.y, or2.u1) annotation (Line(points={{82,-20},{92,-20},{92,-40},{98,
                -40}}, color={255,0,255}));
        connect(con3.y, or2.u2) annotation (Line(points={{82,-84},{92,-84},{92,-48},{98,
                -48}}, color={255,0,255}));
        connect(optCoo.optOn, or2.u2) annotation (Line(points={{42,-74},{50,-74},{50,-48},
                {98,-48}}, color={255,0,255}));
        connect(optHea.optOn, or2.u1) annotation (Line(points={{42,66},{92,66},{92,-40},
                {98,-40}}, color={255,0,255}));
         annotation (
      defaultComponentName="optSta",
        Documentation(info="<html>
<p>
This block predicts the shortest time for an HVAC system to meet the occupied setpoint
prior to the scheduled occupancy. The block requires inputs of zone temperature,
occupied zone setpoint(s) and next occupancy. The two outputs are the optimal start
duration <code>tOpt</code> and the optimal start on signal <code>optOn</code> for
the HVAC system.
</p>
<p>
The block estimates the thermal mass of a zone using its measured air temperature gradient
with respect to time. Once the temperature slope of a zone is known, the optimal start
time can be calculated by the difference between the zone temperature
and the occupied setpoint divided by the temperature slope, assuming the zone responds
as if all thermal mass were concentrated in the room air.
</p>
<p>
The temperature slope is self-tuned based on past data. The moving
average of the temperature slope of the past <code>nDay</code> days
is calculated and used for
the prediction of the optimal start time in the current day.
</p>
<h4>Parameters</h4>
<p>
The parameter <code>nDay</code> is used to compute the moving average of the temperature
slope; the first <code>n</code> days of simulation is therefore used to
initialize the block.
</p>
<p>
The parameter
<code>tOptMax</code> is the maximum allowed optimal start time.
</p>
<p>
The block includes two hysteresis parameters <code>uLow</code> and <code>uHigh</code>.
The parameter
<code>uLow</code> is used to determine if the zone temperature reaches
the setpoint. The algorithm assumes that the zone temperature has reached the setpoint if
<code>TSetZonHea-TZon &le; uLow</code> for a heating system, or
<code>TZon-TSetZonCoo &le; uLow</code> for a cooling system, where
<code>TSetZonHea</code>
denotes the zone heating setpoint during occupancy, <code>TSetZonCoo</code>
denotes the zone cooling setpoint during occupancy, and <code>TZon</code> denotes the
zone temperature.
The parameter
<code>uHigh</code> is used by the algorithm to determine if there is a need to
start the HVAC system prior to occupancy. If
<code>TSetZonHea-TZon &le; uHigh</code> for heating case or
<code>TZon-TSetZonCoo &le; uHigh</code> for cooling case,
then there is no need for the system to start before the occupancy.
</p>
<p>
The optimal start is only active (i.e., the optimal start on signal <code>optOn</code>
becomes true) if the optimal start time is larger than the parameter
<code>thrOptOn</code>.
</p>
<h4>Configuration for HVAC systems</h4>
<p>
The block can be used for heating system only or cooling system only or for both
heating and cooling system.
The two parameters <code>computeHeating</code> and <code>computeCooling</code> are
used to configure the block for these three scenarios.
</p>
<p>
The block calculates the optimal start time separately for heating and cooling systems.
The base class
<a href=\"modelica://Buildings.Controls.OBC.Utilities.BaseClasses.OptimalStartCalculation\">
Buildings.Controls.OBC.Utilities.BaseClasses.OptimalStartCalculation</a> is used
for the calculation.
</p>
<h4>Algorithm</h4>
<p>
The algorithm is as follows:
</p>
<h5>Step 1: Calculate temeperature slope <code>TSlo</code></h5>
<p>
Once the HVAC system is started, a timer records the time duration
<code>&Delta;t</code> for the zone temperature to reach the
setpoint. At the time when the timer starts, the zone temperature <code>TSam1</code> is sampled.
The temperature slope is
approximated using the equation <code>TSlo = |TSetZonOcc-TSam1|/&Delta;t</code>,
where <code>TSetZonOcc</code> is the occupied zone setpoint. Note that if <code>
&Delta;t</code> is greater than the maximum optimal start time <code>tOptMax</code>,
then <code>tOptMax</code> is used instead of <code>&Delta;t</code>.
This is to avoid corner cases where the setpoint is never reached, e.g., the HVAC
system is undersized, or there is a steady-state error associated with the HVAC control.
</p>
<h5>Step 2: Calculate temperature slope moving average <code>TSloMa</code></h5>
<p>
After computing the temperature slope of each day, the moving average of the
temperature slope <code>TSloMa</code> during the previous <code>nDay</code> days
is calculated. Please refer to
<a href=\"modelica://Buildings.Controls.OBC.CDL.Discrete.TriggeredMovingMean\">
Buildings.Controls.OBC.CDL.Discrete.TriggeredMovingMean</a> for details about
the moving average algorithm.
</p>
<h5>Step 3: Calculate optimal start time <code>tOpt</code></h5>
<p>
Each day at a certain time before the occupancy, the algorithm takes another
sample of the zone temperature, denoted as <code>TSam2</code>. The sample
takes place <code>tOptMax</code> prior to occupancy start time.
</p>
<p>
The optimal start time is then calculated as <code>tOpt = |TSetZonOcc-TSam2|/TSloMa</code>.
</p>
<h4>Validation</h4>
<p>
Validation models can be found in the package
<a href=\"modelica://Buildings.Controls.OBC.Utilities.Validation\">
Buildings.Controls.OBC.Utilities.Validation</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
December 15, 2019, by Kun Zhang:<br/>
First implementation.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1589\">issue #1589</a>.
</li>
</ul>
</html>"),
      Diagram(coordinateSystem(extent={{-140,-100},{140,100}})),
          Icon(graphics={
                Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
              Line(points={{-70,40},{10,40},{10,-28},{70,-28}}, color={28,108,200}),
             Line(
                points={{-34,40},{-20,32},{-12,22},{-6,2},{0,-16},{10,-28}},
                smooth=Smooth.Bezier,
                color={238,46,47}),
              Text(
                extent={{-68,56},{-44,40}},
                lineColor={28,108,200},
                textString="TSet"),
              Polygon(points={{-70,92},{-78,70},{-62,70},{-70,92}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-70,70},{-70,-78}}, color={192,192,192}),
              Line(points={{-88,-60},{70,-60}},
                                            color={192,192,192}),
              Polygon(points={{92,-60},{70,-52},{70,-68},{92,-60}},
                lineColor={192,192,192}, fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
             Line(
                points={{10,40},{24,32},{32,22},{38,2},{44,-16},{54,-28}},
                smooth=Smooth.Bezier,
                color={28,108,200},
                pattern=LinePattern.Dot),
              Text(
                lineColor={0,0,255},
                extent={{-150,110},{150,150}},
                textString="%name"),
              Ellipse(
                extent={{79,-33},{93,-47}},
                lineColor=DynamicSelect({235,235,235}, if optOn then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if optOn then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid),
              Text(
                extent={{226,106},{106,56}},
                lineColor={0,0,0},
                textString=DynamicSelect("", String(tOpt, leftjustified=false, significantDigits=3)))}));
      end OptimalStart;

      package Validation "Collection of validation models"

        model OptimalStartCoolingNegativeStartTime
          "Validation model for the block OptimalStart for cooling system with a negative start time"

          hil_flexlab_model.Controls_HIL.OBC.Utilities.OptimalStart optStaCoo(
              computeHeating=false, computeCooling=true)
            "Optimal start for cooling system"
            annotation (Placement(transformation(extent={{20,0},{40,20}})));
          Modelica.Blocks.Continuous.Integrator TRoo(k = 0.0000005, y_start = 24 + 273.15)
            "Room air temperature" annotation (
            Placement(transformation(extent = {{-40, 0}, {-20, 20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TSetCooOcc(k=24 +
                273.15) "Zone cooling setpoint during occupancy"
            annotation (Placement(transformation(extent={{-40,70},{-20,90}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine TOut(
            amplitude=5,
            freqHz=1/86400,
            offset=28 + 273.15,
            startTime(displayUnit="s") = -691200)
            "Outdoor dry bulb temperature to test cooling system" annotation (
              Placement(transformation(extent={{-194,-20},{-174,0}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain UA(k=100)
            "Overall heat loss coefficient"
            annotation (Placement(transformation(extent={{-120,0},{-100,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dT(k1=-1)
            "Temperature difference between zone and outdoor"
            annotation (Placement(transformation(extent={{-160,0},{-140,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dTdt
            "Temperature derivative"
            annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain QCoo(k=-2000)
            "Heat extraction in the zone" annotation (Placement(transformation(
                  extent={{-120,-60},{-100,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea(realTrue=
                -6) "Convert Boolean to Real signal"
            annotation (Placement(transformation(extent={{60,0},{80,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add
            "Reset setpoint from unoccupied to occupied during optimal start period"
            annotation (Placement(transformation(extent={{120,0},{140,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conPID(
            controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

            Ti=1,
            reverseAction=true) "PI control signal for the cooling power"
            annotation (Placement(transformation(extent={{160,0},{180,20}})));
          hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSch(occupancy
              =3600*{7,19}, period=24*3600) "Daily schedule" annotation (
              Placement(transformation(extent={{-40,-60},{-20,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal TSetCoo(
            realTrue=273.15 + 24,
            realFalse=273.15 + 30,
            y(final unit="K", displayUnit="degC"))
            "Room temperature set point for cooling"
            annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
        equation
          connect(dT.y, UA.u)   annotation (Line(points={{-138,10},{-122,10}}, color={0,0,127}));
          connect(TOut.y, dT.u2) annotation (Line(points={{-172,-10},{-166,-10},{-166,4},
                  {-162,4}}, color={0,0,127}));
          connect(dTdt.y, TRoo.u) annotation (
            Line(points = {{-58, 10}, {-42, 10}}, color = {0, 0, 127}));
          connect(QCoo.y, dTdt.u2) annotation (Line(points={{-98,-50},{-88,-50},{-88,4},
                  {-82,4}}, color={0,0,127}));
          connect(TRoo.y, optStaCoo.TZon) annotation (
            Line(points={{-19,10},{-8,10},{-8,7},{18,7}},          color = {0, 0, 127}));
          connect(TRoo.y, dT.u1) annotation (
            Line(points = {{-19, 10}, {-14, 10}, {-14, 36}, {-166, 36}, {-166, 16}, {-162, 16}}, color = {0, 0, 127}));
          connect(TSetCooOcc.y, optStaCoo.TSetZonCoo) annotation (Line(points={{-18,80},
                  {0,80},{0,13},{18,13}},       color={0,0,127}));
          connect(UA.y, dTdt.u1) annotation (Line(points={{-98,10},{-90,10},{-90,16},{-82,
                  16}}, color={0,0,127}));
          connect(optStaCoo.optOn, booToRea.u) annotation (Line(points={{42,6},{50,6},{50,
                  10},{58,10}}, color={255,0,255}));
          connect(add.y, conPID.u_s)   annotation (Line(points={{142,10},{158,10}}, color={0,0,127}));
          connect(TRoo.y, conPID.u_m) annotation (
            Line(points = {{-19, 10}, {-14, 10}, {-14, -20}, {170, -20}, {170, -2}}, color = {0, 0, 127}));
          connect(occSch.tNexOcc, optStaCoo.tNexOcc) annotation (Line(points={{-19,-44},
                  {0,-44},{0,2},{18,2}},     color={0,0,127}));
          connect(conPID.y, QCoo.u) annotation (Line(points={{182,10},{188,10},{188,-80},
                  {-130,-80},{-130,-50},{-122,-50}}, color={0,0,127}));
          connect(occSch.occupied, TSetCoo.u) annotation (Line(points={{-19,-56},{10,-56},
                  {10,-50},{58,-50}}, color={255,0,255}));
          connect(TSetCoo.y, add.u2) annotation (Line(points={{82,-50},{110,-50},{110,4},
                  {118,4}}, color={0,0,127}));
          connect(booToRea.y, add.u1) annotation (Line(points={{82,10},{86,10},{86,16},{
                  118,16}}, color={0,0,127}));
          annotation (
          experiment(
              StartTime=-660000,
              StopTime=0,
              Tolerance=1e-06),
              __Dymola_Commands(file=
          "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/Utilities/Validation/OptimalStartCoolingNegativeStartTime.mos"
          "Simulate and plot"),
          Documentation(info="<html>
<p>
This model is to validate the block
<a href=\"modelica://Buildings.Controls.OBC.Utilities.OptimalStart\">
Buildings.Controls.OBC.Utilities.OptimalStart</a> for space cooling system with
a negative simulation start time.
</p>
<p>
The room is modelled as a simple differential equation with a time constant of
around 5.6 hours. The cooling power is relatively large compared to the heat gain from
the outdoor temperature. The outdoor temperature is repetitive each day;
the optimal start time converges to a small amount of time <code>tOpt</code> after a few days.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 19, 2020, by Michael Wetter:<br/>
Simplified setpoint implementation.'
</li>
<li>
December 15, 2019, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent={{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points={{-36,60},{64,0},{-36,-60},{-36,60}})}),
                Diagram(
                coordinateSystem(preserveAspectRatio=false, extent={{-200,-160},{200,
                    160}})));
        end OptimalStartCoolingNegativeStartTime;

        model OptimalStartCoolingPositiveStartTime
          "Validation model for the block OptimalStart for cooling system with a positive start time"

          hil_flexlab_model.Controls_HIL.OBC.Utilities.OptimalStart optStaCoo(
              computeHeating=false, computeCooling=true)
            "Optimal start for cooling system"
            annotation (Placement(transformation(extent={{20,0},{40,20}})));
          Modelica.Blocks.Continuous.Integrator TRoo(k = 0.0000005, y_start = 24 + 273.15)
            "Room air temperature" annotation (
            Placement(transformation(extent = {{-40, 0}, {-20, 20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TSetCooOcc(k=24 +
                273.15) "Zone cooling setpoint during occupancy"
            annotation (Placement(transformation(extent={{-40,70},{-20,90}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine TOut(
            amplitude=5,
            freqHz=1/86400,
            offset=28 + 273.15,
            startTime(displayUnit="s") = 0)
            "Outdoor dry bulb temperature to test cooling system" annotation (
              Placement(transformation(extent={{-194,-20},{-174,0}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain UA(k=100)
            "Overall heat loss coefficient"
            annotation (Placement(transformation(extent={{-120,0},{-100,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dT(k1=-1)
            "Temperature difference between zone and outdoor"
            annotation (Placement(transformation(extent={{-160,0},{-140,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dTdt
            "Temperature derivative"
            annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain QCoo(k=-2000)
            "Heat extraction in the zone" annotation (Placement(transformation(
                  extent={{-120,-60},{-100,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea(realTrue=
                -6) "Convert Boolean to Real signal"
            annotation (Placement(transformation(extent={{60,0},{80,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add
            "Reset setpoint from unoccupied to occupied during optimal start period"
            annotation (Placement(transformation(extent={{120,0},{140,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conPID(
            controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

            Ti=1,
            reverseAction=true) "PI control signal for the cooling power"
            annotation (Placement(transformation(extent={{160,0},{180,20}})));
          hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSch(occupancy
              =3600*{7,19}, period=24*3600) "Daily schedule" annotation (
              Placement(transformation(extent={{-40,-60},{-20,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal TSetCoo(
            realTrue=273.15 + 24,
            realFalse=273.15 + 30,
            y(final unit="K", displayUnit="degC"))
            "Room temperature set point for cooling"
            annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
        equation
          connect(dT.y, UA.u)   annotation (Line(points={{-138,10},{-122,10}}, color={0,0,127}));
          connect(TOut.y, dT.u2) annotation (Line(points={{-172,-10},{-166,-10},{-166,4},
                  {-162,4}}, color={0,0,127}));
          connect(dTdt.y, TRoo.u) annotation (
            Line(points = {{-58, 10}, {-42, 10}}, color = {0, 0, 127}));
          connect(QCoo.y, dTdt.u2) annotation (Line(points={{-98,-50},{-88,-50},{-88,4},
                  {-82,4}}, color={0,0,127}));
          connect(TRoo.y, optStaCoo.TZon) annotation (
            Line(points={{-19,10},{-8,10},{-8,7},{18,7}},          color = {0, 0, 127}));
          connect(TRoo.y, dT.u1) annotation (
            Line(points = {{-19, 10}, {-14, 10}, {-14, 36}, {-166, 36}, {-166, 16}, {-162, 16}}, color = {0, 0, 127}));
          connect(TSetCooOcc.y, optStaCoo.TSetZonCoo) annotation (Line(points={{-18,80},
                  {0,80},{0,13},{18,13}},       color={0,0,127}));
          connect(UA.y, dTdt.u1) annotation (Line(points={{-98,10},{-90,10},{-90,16},{-82,
                  16}}, color={0,0,127}));
          connect(optStaCoo.optOn, booToRea.u) annotation (Line(points={{42,6},{50,6},{50,
                  10},{58,10}}, color={255,0,255}));
          connect(add.y, conPID.u_s)   annotation (Line(points={{142,10},{158,10}}, color={0,0,127}));
          connect(TRoo.y, conPID.u_m) annotation (
            Line(points = {{-19, 10}, {-14, 10}, {-14, -20}, {170, -20}, {170, -2}}, color = {0, 0, 127}));
          connect(occSch.tNexOcc, optStaCoo.tNexOcc) annotation (Line(points={{-19,-44},
                  {0,-44},{0,2},{18,2}},     color={0,0,127}));
          connect(conPID.y, QCoo.u) annotation (Line(points={{182,10},{188,10},{188,-80},
                  {-130,-80},{-130,-50},{-122,-50}}, color={0,0,127}));
          connect(occSch.occupied, TSetCoo.u) annotation (Line(points={{-19,-56},{10,
                  -56},{10,-50},{58,-50}}, color={255,0,255}));
          connect(TSetCoo.y, add.u2) annotation (Line(points={{82,-50},{100,-50},{100,4},
                  {118,4}}, color={0,0,127}));
          connect(booToRea.y, add.u1) annotation (Line(points={{82,10},{100,10},{100,16},
                  {118,16}}, color={0,0,127}));
          annotation (
          experiment(
              StartTime=34000,
              StopTime=864000,
              Tolerance=1e-06),
              __Dymola_Commands(file=
          "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/Utilities/Validation/OptimalStartCoolingPositiveStartTime.mos"
          "Simulate and plot"),
          Documentation(info="<html>
<p>
This model is to validate the block
<a href=\"modelica://Buildings.Controls.OBC.Utilities.OptimalStart\">
Buildings.Controls.OBC.Utilities.OptimalStart</a> for space cooling system
with a positive simulation start time.
</p>
<p>
The room is modelled as a simple differential equation with a time constant of
around 5.6 hours. The cooling power is relatively large compared to the heat gain from
the outdoor temperature. The outdoor temperature is repetitive each day;
the optimal start time converges to a small amount of time <code>tOpt</code> after a few days.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 19, 2020, by Michael Wetter:<br/>
Simplified setpoint implementation.'
</li>
<li>
December 15, 2019, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent={{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points={{-36,60},{64,0},{-36,-60},{-36,60}})}),
                Diagram(
                coordinateSystem(preserveAspectRatio=false, extent={{-200,-160},{200,
                    160}})));
        end OptimalStartCoolingPositiveStartTime;

        model OptimalStartHeating
          "Validation model for the block OptimalStart for heating system"

          hil_flexlab_model.Controls_HIL.OBC.Utilities.OptimalStart optStaHea(
              computeHeating=true, computeCooling=false)
            "Optimal start for heating system"
            annotation (Placement(transformation(extent={{20,0},{40,20}})));
          Modelica.Blocks.Continuous.Integrator TRoo(k = 0.000005, y_start = 21 + 273.15)
            "Room air temperature" annotation (
            Placement(transformation(extent = {{-40, 0}, {-20, 20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TSetHeaOcc(k=21 +
                273.15) "Zone heating setpoint during occupancy"
            annotation (Placement(transformation(extent={{-40,70},{-20,90}})));
          hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSch(occupancy
              =3600*{7,19}, period=24*3600) "Daily schedule" annotation (
              Placement(transformation(extent={{-40,-60},{-20,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain UA(k=10)
            "Overall heat loss coefficient"
            annotation (Placement(transformation(extent={{-120,0},{-100,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dT(k1=-1)
            "Temperature difference between zone and outdoor"
            annotation (Placement(transformation(extent={{-160,0},{-140,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dTdt
            "Temperature derivative"
            annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain QHea(k=500)
            "Heat injection in the zone" annotation (Placement(transformation(
                  extent={{-120,-60},{-100,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea(realTrue=
                6) "Convert Boolean to Real signal"
            annotation (Placement(transformation(extent={{60,0},{80,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine TOut(
            amplitude=10,
            freqHz=1/86400,
            phase=3.1415926535898,
            offset=10 + 273.15,
            startTime(displayUnit="d") = -172800)
            "Outdoor dry bulb temperature to test heating system" annotation (
              Placement(transformation(extent={{-192,-20},{-172,0}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conPID(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,
              Ti=1.5) "PI control for space heating"
            annotation (Placement(transformation(extent={{160,0},{180,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add
            "Reset temperature from unoccupied to occupied for optimal start period"
            annotation (Placement(transformation(extent={{120,0},{140,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal TSetHea(
            realTrue=273.15 + 21,
            realFalse=273.15 + 15,
            y(final unit="K", displayUnit="degC"))
            "Room temperature set point for heating"
            annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
        equation
          connect(dT.y, UA.u)    annotation (Line(points={{-138,10},{-122,10}},
                                                                              color={0,0,127}));
          connect(dTdt.y, TRoo.u) annotation (
            Line(points = {{-58, 10}, {-42, 10}}, color = {0, 0, 127}));
          connect(QHea.y, dTdt.u2) annotation (Line(points={{-98,-50},{-88,-50},{-88,4},
                  {-82,4}},  color={0,0,127}));
          connect(TRoo.y, optStaHea.TZon) annotation (
            Line(points={{-19,10},{-12,10},{-12,7},{18,7}},          color = {0, 0, 127}));
          connect(occSch.tNexOcc, optStaHea.tNexOcc) annotation (Line(points={{-19,-44},
                  {0,-44},{0,2},{18,2}},   color={0,0,127}));
          connect(TSetHeaOcc.y, optStaHea.TSetZonHea) annotation (Line(points={{-18,80},
                  {0,80},{0,18},{18,18}},    color={0,0,127}));
          connect(TRoo.y, dT.u1) annotation (
            Line(points = {{-19, 10}, {-12, 10}, {-12, 32}, {-166, 32}, {-166, 16}, {-162, 16}}, color = {0, 0, 127}));
          connect(UA.y, dTdt.u1) annotation (Line(points={{-98,10},{-90,10},{-90,16},{
                  -82,16}}, color={0,0,127}));
          connect(add.y, conPID.u_s)   annotation (Line(points={{142,10},{158,10}}, color={0,0,127}));
          connect(conPID.y, QHea.u) annotation (Line(points={{182,10},{184,10},{184,-70},
                  {-126,-70},{-126,-50},{-122,-50}},
                                                  color={0,0,127}));
          connect(TRoo.y, conPID.u_m) annotation (
            Line(points = {{-19, 10}, {-12, 10}, {-12, -16}, {170, -16}, {170, -2}}, color = {0, 0, 127}));
          connect(optStaHea.optOn, booToRea.u) annotation (Line(points={{42,6},{50,6},{50,
                  10},{58,10}},     color={255,0,255}));
          connect(TOut.y, dT.u2) annotation (Line(points={{-170,-10},{-166,-10},{-166,4},
                  {-162,4}}, color={0,0,127}));
          connect(TSetHea.u, occSch.occupied) annotation (Line(points={{58,-50},{10,-50},
                  {10,-56},{-19,-56}}, color={255,0,255}));
          connect(TSetHea.y, add.u2) annotation (Line(points={{82,-50},{104,-50},{104,4},
                  {118,4}}, color={0,0,127}));
          connect(booToRea.y, add.u1) annotation (Line(points={{82,10},{104,10},{104,16},
                  {118,16}}, color={0,0,127}));
          annotation (
          experiment(
              StartTime=-172800,
              StopTime=604800,
              Tolerance=1e-06),
              __Dymola_Commands(file=
          "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/Utilities/Validation/OptimalStartHeating.mos"
          "Simulate and plot"),
          Documentation(info="<html>
<p>
This model is to validate the block
<a href=\"modelica://Buildings.Controls.OBC.Utilities.OptimalStart\">
Buildings.Controls.OBC.Utilities.OptimalStart</a> for space heating system.
</p>
<p>
The room is modelled as a simple differential equation with a time constant of
around 5.6 hours.
The outdoor temperature is also repetitive each day;
the optimal start time converges to a small amount of time <code>tOpt</code> after a few days.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 19, 2020, by Michael Wetter:<br/>
Simplified setpoint implementation.'
</li>
<li>
December 15, 2019, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent={{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points={{-36,60},{64,0},{-36,-60},{-36,60}})}),
                Diagram(
                coordinateSystem(preserveAspectRatio=false, extent={{-200,-160},{200,
                    160}})));
        end OptimalStartHeating;

        model OptimalStartHeatingCooling
          "Validation model for the block OptimalStart for both heating and cooling system"

          hil_flexlab_model.Controls_HIL.OBC.Utilities.OptimalStart optSta(
              computeHeating=true, computeCooling=true)
            "Optimal start for both heating and cooling system"
            annotation (Placement(transformation(extent={{40,0},{60,20}})));
          Modelica.Blocks.Continuous.Integrator TRoo(k = 0.0000004, y_start = 19 + 273.15)
            "Room air temperature" annotation (
            Placement(transformation(extent = {{-20, 0}, {0, 20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TSetCooOcc(k=24 +
                273.15) "Zone cooling setpoint during occupancy"
            annotation (Placement(transformation(extent={{-20,60},{0,80}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine TOutBase(
            amplitude=5,
            freqHz=1/86400,
            offset=15 + 273.15,
            startTime(displayUnit="h") = 0)
            "Outdoor dry bulb temperature, base component" annotation (
              Placement(transformation(extent={{-208,-20},{-188,0}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain UA(k=25)
            "Overall heat loss coefficient"
            annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dT(k1=-1)
            "Temperature difference between zone and outdoor"
            annotation (Placement(transformation(extent={{-140,0},{-120,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain QCoo(k=-4000)
            "Heat extraction in the zone" annotation (Placement(transformation(
                  extent={{-100,-40},{-80,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea1(realTrue=
                -6) "Convert Boolean to Real signal"
            annotation (Placement(transformation(extent={{80,0},{100,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1
            "Reset temperature from unoccupied to occupied for optimal start period"
            annotation (Placement(transformation(extent={{140,0},{160,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conPID1(
            controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

            Ti=3,
            reverseAction=true) "PI control for space cooling"
            annotation (Placement(transformation(extent={{180,0},{200,20}})));
          hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSch(occupancy
              =3600*{7,19}, period=24*3600) "Daily schedule"
            annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum mulSum(nin=3)
            "Sum heat gains"
            annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant TSetHeaOcc(k=21 +
                273.15) "Zone heating setpoint during occupancy"
            annotation (Placement(transformation(extent={{-20,100},{0,120}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea2(realTrue=
                6) "Convert Boolean to Real signal"
            annotation (Placement(transformation(extent={{80,40},{100,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2
            "Reset temperature from unoccupied to occupied for optimal start period"
            annotation (Placement(transformation(extent={{140,40},{160,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conPID(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,
              Ti=3) "PI control for space heating"
            annotation (Placement(transformation(extent={{180,40},{200,60}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain QHea(k=2000)
            "Heat injection in the zone" annotation (Placement(transformation(
                  extent={{-100,-110},{-80,-90}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add TOut
            "Outdoor dry bulb temperature" annotation (Placement(transformation(
                  extent={{-170,-40},{-150,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pul(
            amplitude=15,
            period(displayUnit="d") = 1209600,
            startTime(displayUnit="d") = 604800)
            "Range of outdoor dry bulb temperature" annotation (Placement(
                transformation(extent={{-210,-60},{-190,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal TSetHea(
            realTrue=273.15 + 21,
            realFalse=273.15 + 15,
            y(final unit="K", displayUnit="degC"))
            "Room temperature set point for heating"
            annotation (Placement(transformation(extent={{80,-70},{100,-50}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal TSetCoo(
            realTrue=273.15 + 24,
            realFalse=273.15 + 30,
            y(final unit="K", displayUnit="degC"))
            "Room temperature set point for cooling"
            annotation (Placement(transformation(extent={{80,-40},{100,-20}})));
        equation
          connect(dT.y, UA.u)   annotation (Line(points={{-118,10},{-102,10}}, color={0,0,127}));
          connect(TRoo.y, optSta.TZon) annotation (
            Line(points={{1,10},{10,10},{10,7},{38,7}},          color = {0, 0, 127}));
          connect(TRoo.y, dT.u1) annotation (
            Line(points = {{1, 10}, {6, 10}, {6, 34}, {-146, 34}, {-146, 16}, {-142, 16}}, color = {0, 0, 127}));
          connect(TSetCooOcc.y, optSta.TSetZonCoo) annotation (Line(points={{2,70},{10,70},
                  {10,13},{38,13}},      color={0,0,127}));
          connect(optSta.optOn, booToRea1.u) annotation (Line(points={{62,6},{70,6},{70,
                  10},{78,10}}, color={255,0,255}));
          connect(add1.y, conPID1.u_s)   annotation (Line(points={{162,10},{178,10}},   color={0,0,127}));
          connect(TRoo.y, conPID1.u_m) annotation (
            Line(points = {{1, 10}, {6, 10}, {6, -6}, {190, -6}, {190, -2}}, color = {0, 0, 127}));
          connect(occSch.tNexOcc, optSta.tNexOcc) annotation (Line(points={{1,-44},{10,-44},
                  {10,2},{38,2}},       color={0,0,127}));
          connect(UA.y, mulSum.u[1]) annotation (Line(points={{-78,10},{-70,10},{-70,
                  11.3333},{-62,11.3333}},
                                  color={0,0,127}));
          connect(TRoo.u, mulSum.y) annotation (
            Line(points = {{-22, 10}, {-38, 10}}, color = {0, 0, 127}));
          connect(TSetHeaOcc.y, optSta.TSetZonHea) annotation (Line(points={{2,110},{14,
                  110},{14,18},{38,18}}, color={0,0,127}));
          connect(optSta.optOn, booToRea2.u) annotation (Line(points={{62,6},{70,6},{70,
                  50},{78,50}}, color={255,0,255}));
          connect(add2.y, conPID.u_s)   annotation (Line(points={{162,50},{178,50}}, color={0,0,127}));
          connect(conPID.u_m, dT.u1) annotation (Line(points={{190,38},{190,34},{-146,34},
                  {-146,16},{-142,16}}, color={0,0,127}));
          connect(conPID1.y, QCoo.u) annotation (Line(points={{202,10},{210,10},{210,
                  -80},{-110,-80},{-110,-30},{-102,-30}},
                                                     color={0,0,127}));
          connect(conPID.y, QHea.u) annotation (Line(points={{202,50},{212,50},{212,
                  -130},{-108,-130},{-108,-100},{-102,-100}},
                                                      color={0,0,127}));
          connect(QCoo.y, mulSum.u[2]) annotation (Line(points={{-78,-30},{-70,-30},{-70,
                  10},{-62,10}}, color={0,0,127}));
          connect(QHea.y, mulSum.u[3]) annotation (Line(points={{-78,-100},{-68,-100},{
                  -68,8.66667},{-62,8.66667}},
                                           color={0,0,127}));
          connect(TOutBase.y, TOut.u1) annotation (Line(points={{-186,-10},{-178,-10},{
                  -178,-24},{-172,-24}}, color={0,0,127}));
          connect(TOut.y, dT.u2) annotation (Line(points={{-148,-30},{-146,-30},{-146,4},
                  {-142,4}}, color={0,0,127}));
          connect(pul.y, TOut.u2) annotation (Line(points={{-188,-50},{-176,-50},{-176,
                  -36},{-172,-36}}, color={0,0,127}));
          connect(TSetCoo.y, add1.u2) annotation (Line(points={{102,-30},{130,-30},{130,
                  4},{138,4}}, color={0,0,127}));
          connect(occSch.occupied, TSetCoo.u) annotation (Line(points={{1,-56},{60,-56},
                  {60,-30},{78,-30}}, color={255,0,255}));
          connect(TSetHea.u, occSch.occupied) annotation (Line(points={{78,-60},{60,-60},
                  {60,-56},{1,-56}}, color={255,0,255}));
          connect(booToRea1.y, add1.u1) annotation (Line(points={{102,10},{120,10},{120,
                  16},{138,16}}, color={0,0,127}));
          connect(booToRea2.y, add2.u1) annotation (Line(points={{102,50},{120,50},{120,
                  56},{138,56}}, color={0,0,127}));
          connect(TSetHea.y, add2.u2) annotation (Line(points={{102,-60},{126,-60},{126,
                  44},{138,44}}, color={0,0,127}));
          annotation (
          experiment(
              StopTime=2419200,
              Tolerance=1e-06),
              __Dymola_Commands(file=
          "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/Utilities/Validation/OptimalStartHeatingCooling.mos"
          "Simulate and plot"),
          Documentation(info="<html>
<p>
This models validates both space heating and cooling for the block
<a href=\"modelica://Buildings.Controls.OBC.Utilities.OptimalStart\">
Buildings.Controls.OBC.Utilities.OptimalStart</a>.
</p>
<p>
The first ten days is to test the heating case with a lower outdoor temperature.
The next ten days has a higher outdoor temprature, which is to test the cooling case.
The zone model has a time constant of 27.8 hours. The optimal start block converges separately
to an optimal start time for heating and cooling. Note that during the three transition
days, the zone temperature is in the deadband, so there is no need to optimally start
the heating or cooling system in advance.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 19, 2020, by Michael Wetter:<br/>
Simplified setpoint implementation.'
</li>
<li>
December 15, 2019, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent={{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points={{-36,60},{64,0},{-36,-60},{-36,60}})}),
                Diagram(
                coordinateSystem(preserveAspectRatio=false, extent={{-220,-160},{220,160}})));
        end OptimalStartHeatingCooling;

        model OptimalStartNoHeatingNoCooling
          "Validation model for the block OptimalStart for the case with no preheating nor precooling"

          hil_flexlab_model.Controls_HIL.OBC.Utilities.OptimalStart optSta(
              computeHeating=false, computeCooling=false)
            "Optimal start for both heating and cooling system"
            annotation (Placement(transformation(extent={{40,0},{60,20}})));
          Modelica.Blocks.Continuous.Integrator TRoo(k = 0.0000004, y_start = 19 + 273.15)
            "Room air temperature" annotation (
            Placement(transformation(extent = {{-20, 0}, {0, 20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Sine TOutBase(
            amplitude=5,
            freqHz=1/86400,
            offset=15 + 273.15,
            startTime(displayUnit="h") = 0)
            "Outdoor dry bulb temperature, base component" annotation (
              Placement(transformation(extent={{-208,-20},{-188,0}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain UA(k=25)
            "Overall heat loss coefficient"
            annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add dT(k1=-1)
            "Temperature difference between zone and outdoor"
            annotation (Placement(transformation(extent={{-140,0},{-120,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain QCoo(k=-4000)
            "Heat extraction in the zone" annotation (Placement(transformation(
                  extent={{-100,-40},{-80,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea1(realTrue=
                -6) "Convert Boolean to Real signal"
            annotation (Placement(transformation(extent={{80,0},{100,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1
            "Reset temperature from unoccupied to occupied for optimal start period"
            annotation (Placement(transformation(extent={{140,0},{160,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conPID1(
            controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,

            Ti=3,
            reverseAction=true) "PI control for space cooling"
            annotation (Placement(transformation(extent={{180,0},{200,20}})));
          hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSch(occupancy
              =3600*{7,19}, period=24*3600) "Daily schedule"
            annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.MultiSum mulSum(nin=3)
            "Sum heat gains"
            annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Conversions.BooleanToReal booToRea2(realTrue=
                6) "Convert Boolean to Real signal"
            annotation (Placement(transformation(extent={{80,40},{100,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2
            "Reset temperature from unoccupied to occupied for optimal start period"
            annotation (Placement(transformation(extent={{140,40},{160,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LimPID conPID(
              controllerType=hil_flexlab_model.Controls_HIL.OBC.CDL.Types.SimpleController.PI,
              Ti=3) "PI control for space heating"
            annotation (Placement(transformation(extent={{180,40},{200,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Gain QHea(k=2000)
            "Heat injection in the zone" annotation (Placement(transformation(
                  extent={{-100,-110},{-80,-90}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add TOut
            "Outdoor dry bulb temperature" annotation (Placement(transformation(
                  extent={{-170,-40},{-150,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Pulse pul(
            amplitude=15,
            period(displayUnit="d") = 1209600,
            startTime(displayUnit="d") = 604800)
            "Range of outdoor dry bulb temperature" annotation (Placement(
                transformation(extent={{-210,-60},{-190,-40}})));
          CDL.Conversions.BooleanToReal TSetHea(
            realTrue=273.15 + 21,
            realFalse=273.15 + 15,
            y(final unit="K", displayUnit="degC"))
            "Room temperature set point for heating"
            annotation (Placement(transformation(extent={{80,-70},{100,-50}})));
          CDL.Conversions.BooleanToReal TSetCoo(
            realTrue=273.15 + 24,
            realFalse=273.15 + 30,
            y(final unit="K", displayUnit="degC"))
            "Room temperature set point for cooling"
            annotation (Placement(transformation(extent={{80,-40},{100,-20}})));
        equation
          connect(dT.y, UA.u)   annotation (Line(points={{-118,10},{-102,10}}, color={0,0,127}));
          connect(TRoo.y, optSta.TZon) annotation (
            Line(points={{1,10},{10,10},{10,7},{38,7}},          color = {0, 0, 127}));
          connect(TRoo.y, dT.u1) annotation (
            Line(points = {{1, 10}, {6, 10}, {6, 34}, {-146, 34}, {-146, 16}, {-142, 16}}, color = {0, 0, 127}));
          connect(optSta.optOn, booToRea1.u) annotation (Line(points={{62,6},{70,6},{70,
                  10},{78,10}}, color={255,0,255}));
          connect(add1.y, conPID1.u_s)   annotation (Line(points={{162,10},{178,10}},   color={0,0,127}));
          connect(TRoo.y, conPID1.u_m) annotation (
            Line(points = {{1, 10}, {6, 10}, {6, -12}, {190, -12}, {190, -2}}, color = {0, 0, 127}));
          connect(occSch.tNexOcc, optSta.tNexOcc) annotation (Line(points={{1,-44},{10,-44},
                  {10,2},{38,2}},       color={0,0,127}));
          connect(UA.y, mulSum.u[1]) annotation (Line(points={{-78,10},{-70,10},{-70,
                  11.3333},{-62,11.3333}},
                                  color={0,0,127}));
          connect(TRoo.u, mulSum.y) annotation (
            Line(points = {{-22, 10}, {-38, 10}}, color = {0, 0, 127}));
          connect(optSta.optOn, booToRea2.u) annotation (Line(points={{62,6},{70,6},{70,
                  50},{78,50}}, color={255,0,255}));
          connect(add2.y, conPID.u_s)   annotation (Line(points={{162,50},{178,50}}, color={0,0,127}));
          connect(conPID.u_m, dT.u1) annotation (Line(points={{190,38},{190,34},{-146,34},
                  {-146,16},{-142,16}}, color={0,0,127}));
          connect(conPID1.y, QCoo.u) annotation (Line(points={{202,10},{210,10},{210,-80},
                  {-110,-80},{-110,-30},{-102,-30}}, color={0,0,127}));
          connect(conPID.y, QHea.u) annotation (Line(points={{202,50},{212,50},{212,-120},
                  {-108,-120},{-108,-100},{-102,-100}},
                                                      color={0,0,127}));
          connect(QCoo.y, mulSum.u[2]) annotation (Line(points={{-78,-30},{-70,-30},{-70,
                  10},{-62,10}}, color={0,0,127}));
          connect(QHea.y, mulSum.u[3]) annotation (Line(points={{-78,-100},{-68,-100},{-68,
                  8.66667},{-62,8.66667}}, color={0,0,127}));
          connect(TOutBase.y, TOut.u1) annotation (Line(points={{-186,-10},{-178,-10},{
                  -178,-24},{-172,-24}}, color={0,0,127}));
          connect(TOut.y, dT.u2) annotation (Line(points={{-148,-30},{-146,-30},{-146,4},
                  {-142,4}}, color={0,0,127}));
          connect(pul.y, TOut.u2) annotation (Line(points={{-188,-50},{-176,-50},{-176,
                  -36},{-172,-36}}, color={0,0,127}));
          connect(TSetCoo.y, add1.u2) annotation (Line(points={{102,-30},{130,-30},{130,
                  4},{138,4}},
                            color={0,0,127}));
          connect(occSch.occupied, TSetCoo.u) annotation (Line(points={{1,-56},{60,-56},
                  {60,-30},{78,-30}}, color={255,0,255}));
          connect(TSetHea.u, occSch.occupied) annotation (Line(points={{78,-60},{60,-60},
                  {60,-56},{1,-56}}, color={255,0,255}));
          connect(TSetHea.y, add2.u2) annotation (Line(points={{102,-60},{126,-60},{126,
                  44},{138,44}}, color={0,0,127}));
          connect(booToRea2.y, add2.u1) annotation (Line(points={{102,50},{126,50},{126,
                  56},{138,56}}, color={0,0,127}));
          connect(booToRea1.y, add1.u1) annotation (Line(points={{102,10},{120,10},{120,
                  16},{138,16}}, color={0,0,127}));
          annotation (
          experiment(
              StopTime=2419200,
              Tolerance=1e-06),
              __Dymola_Commands(file=
          "modelica://Buildings/Resources/Scripts/Dymola/Controls/OBC/Utilities/Validation/OptimalStartNoHeatingNoCooling.mos"
          "Simulate and plot"),
          Documentation(info="<html>
<p>
This models validates the block
<a href=\"modelica://Buildings.Controls.OBC.Utilities.OptimalStart\">
Buildings.Controls.OBC.Utilities.OptimalStart</a> for the case when the optimal start
is not turned on for preheating or precooling before the scheduled occupancy.
</p>
<p>
The results shows that the optimal start time <code>tOpt</code> remains zero and
the optimal start on signal <code>optOn</code> remains false during the simulation.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 19, 2020, by Michael Wetter:<br/>
Simplified setpoint implementation.
</li>
<li>
December 15, 2019, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                graphics={
                Ellipse(lineColor = {75,138,73},
                        fillColor={255,255,255},
                        fillPattern = FillPattern.Solid,
                        extent={{-100,-100},{100,100}}),
                Polygon(lineColor = {0,0,255},
                        fillColor = {75,138,73},
                        pattern = LinePattern.None,
                        fillPattern = FillPattern.Solid,
                        points={{-36,60},{64,0},{-36,-60},{-36,60}})}),
                Diagram(
                coordinateSystem(preserveAspectRatio=false, extent={{-220,-160},{220,160}})));
        end OptimalStartNoHeatingNoCooling;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for blocks in
<a href=\"modelica://Buildings.Controls.OBC.Utilities\">Buildings.Controls.OBC.Utilities</a>.
</p>
</html>"),
        Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100,-100},{100,100}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100,-100},{100,100}},
                radius=25.0),
              Polygon(
                origin={8,14},
                lineColor={78,138,73},
                fillColor={78,138,73},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}));
      end Validation;

      package BaseClasses "Package with base classes"

        block OptimalStartCalculation
          "Base class for the block OptimalStart"
          parameter Real tOptMax(
            final quantity="Time",
            final unit="s") "Maximum optimal start time";
          parameter Real thrOptOn(
            final quantity="Time",
            final unit="s")
            "Threshold time for the output optOn to become true";
          parameter Real tOptDef(
            final quantity="Time",
            final unit="s")
            "Default optimal start time";
          parameter Integer nDay "Number of previous days for averaging the temperature slope";
          parameter Real uLow(
            final quantity="TemperatureDifference",
            final unit="K")
            "Threshold to determine if the zone temperature reaches the occupied setpoint,
     should be a non-negative number";
          parameter Real uHigh(
            final quantity="TemperatureDifference",
            final unit="K")
            "Threshold to determine the need to start the HVAC system before occupancy,
     should be greater than uLow";

          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput TDif(final
              quantity="TemperatureDifference", final unit="K")
            "Zone setpoint temperature during occupancy" annotation (Placement(
                transformation(extent={{-320,100},{-280,140}}),
                iconTransformation(extent={{-140,60},{-100,100}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanInput staCal
            "Start calculation" annotation (Placement(transformation(extent={{-320,
                    20},{-280,60}}), iconTransformation(extent={{-140,-20},{-100,
                    20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealInput tNexOcc(
            final quantity="Time",
            final unit="s",
            displayUnit="h") "Time until next occupancy" annotation (Placement(
                transformation(extent={{-320,-160},{-280,-120}}),
                iconTransformation(extent={{-140,-100},{-100,-60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.RealOutput tOpt(
            final quantity="Time",
            final unit="s",
            displayUnit="h") "Optimal start time of HVAC system" annotation (
              Placement(transformation(extent={{440,40},{480,80}}),
                iconTransformation(extent={{100,20},{140,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Interfaces.BooleanOutput optOn
            "Optimal start boolean output" annotation (Placement(transformation(
                  extent={{440,-80},{480,-40}}), iconTransformation(extent={{
                    100,-60},{140,-20}})));

        protected
          parameter Real temSloDef(
            final quantity="TemperatureSlope",
            final unit="K/s") = 1/3600
            "Default temperature slope in case of zero division";

          hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredMovingMean triMovMea(final n=
                nDay)
            "Calculate the averaged temperature slope over the past n days"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triSam2
            "Get the sampled temperature difference at the same time each day"
            annotation (Placement(transformation(extent={{100,110},{120,130}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triSam3
            "Get the temperature difference when the HVAC system starts"
            annotation (Placement(transformation(extent={{20,70},{40,90}})));

          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant con(final k=0)
            "Deadband case"
            annotation (Placement(transformation(extent={{140,90},{160,110}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant defOptTim(final k=
                tOptDef) "Default optimal start time in case of zero division"
            annotation (Placement(transformation(extent={{-20,30},{0,50}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant defTemSlo(final k=
                temSloDef) "Default temperature slope in case of zero division"
            annotation (Placement(transformation(extent={{120,40},{140,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Edge edg
            "HVAC start time" annotation (Placement(transformation(extent={{-120,
                    -90},{-100,-70}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.FallingEdge falEdg
            "The instant when the zone temperature reaches setpoint"
            annotation (Placement(transformation(extent={{-120,-30},{-100,-10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hys(final
              uLow=uLow, final uHigh=uHigh)
            "Comparing zone temperature with zone setpoint" annotation (
              Placement(transformation(extent={{-260,70},{-240,90}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Hysteresis hysOpt(
            final pre_y_start=false,
            final uHigh=0,
            final uLow=-60) "Hysteresis to activate the optimal start"
            annotation (Placement(transformation(extent={{330,-90},{350,-70}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessEqualThreshold lesEquThr(final
              threshold=1E-15) "Avoid zero division"
            annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessEqualThreshold lesEquThr1(final
              threshold=1E-15) "Avoid zero division"
            annotation (Placement(transformation(extent={{140,-10},{160,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant maxStaTim(final k=
                tOptMax) "Maximum optimal start time"
            annotation (Placement(transformation(extent={{250,40},{270,60}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.TrueHoldWithReset truHol(final
              duration=tOptMax + 11*3600) "Hold the start time for timer"
            annotation (Placement(transformation(extent={{-240,0},{-220,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division temSlo
            "Calculate temperature slope"
            annotation (Placement(transformation(extent={{60,-10},{80,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi
            "Switch to default optimal start time when time duration is 0"
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
           hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Switch swi1
            "Switch to default value when the calculated temperature slope is 0"
            annotation (Placement(transformation(extent={{180,-10},{200,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Pre pre
            "Break algebraic loops" annotation (Placement(transformation(extent
                  ={{390,-40},{410,-20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add1(final k1=+
                1, final k2=-1)
            "Calculate the time duration to reach the setpoint"
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Add add2(final k1=+
                1, final k2=-1)
            "Calculate differential between time-to-next-occupancy and the cool-down time"
            annotation (Placement(transformation(extent={{300,-90},{320,-70}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Min min
            "Get the final optimal start time"
            annotation (Placement(transformation(extent={{286,-10},{306,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Max max
            "Consider the deadband case" annotation (Placement(transformation(
                  extent={{180,104},{200,124}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triSam
            "The instant when the zone temperature reaches setpoint with maximum time cutoff"
            annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triSam1
            "Record the start time when the HVAC system is turned on"
            annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Latch lat
            "Stop calculation when the zone temperature reaches setpoint"
            annotation (Placement(transformation(extent={{-190,70},{-170,90}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Timer tim(final reset=
                true)
            "Record time duration for the zone temperature to reach setpoint"
            annotation (Placement(transformation(extent={{-180,0},{-160,20}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.Not not1
            "Becomes true when the setpoint is reached" annotation (Placement(
                transformation(extent={{-230,70},{-210,90}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Division tOptCal
            "Calculate optimal start time using the averaged previous temperature slope"
            annotation (Placement(transformation(extent={{220,-10},{240,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.ModelTime modTim
            "Model time"
            annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Sources.Constant con1(final k=
                86400) "Daily period"
            annotation (Placement(transformation(extent={{0,-90},{20,-70}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.Modulo mod
            "Get the modulo"
            annotation (Placement(transformation(extent={{40,-70},{60,-50}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.LessEqualThreshold lesEquThr2(final
              threshold=1E-06)
            "Get the instant when the simulation time arrives at midnight"
            annotation (Placement(transformation(extent={{80,-70},{100,-50}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Discrete.TriggeredSampler triSam4
            "Get the sampled optimal start time at the same time each day"
            annotation (Placement(transformation(extent={{250,-10},{270,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Continuous.GreaterThreshold greThr(final
              threshold=thrOptOn) "The threshold for optOn signal becomes true"
            annotation (Placement(transformation(extent={{320,-10},{340,10}})));
          hil_flexlab_model.Controls_HIL.OBC.CDL.Logical.And and2 "Logical and"
            annotation (Placement(transformation(extent={{360,-40},{380,-20}})));

        equation
          connect(tim.y, triSam.u)  annotation (Line(points={{-158,10},{-102,10}},
                                                      color={0,0,127}));
          connect(falEdg.y, triSam.trigger) annotation (Line(points={{-98,-20},{-90,-20},
                  {-90,-1.8}},                                                                     color={255,0,255}));
          connect(not1.y, lat.clr) annotation (Line(points={{-208,80},{-200,80},{-200,74},
                  {-192,74}}, color={255,0,255}));
          connect(swi1.y, tOptCal.u2) annotation (Line(points={{202,0},{210,0},{210,-6},
                  {218,-6}}, color={0,0,127}));
          connect(temSlo.y, triMovMea.u)  annotation (Line(points={{82,0},{98,0}},     color={0,0,127}));
          connect(lesEquThr.y, swi.u2)   annotation (Line(points={{2,0},{18,0}},      color={255,0,255}));
          connect(lesEquThr1.y, swi1.u2)    annotation (Line(points={{162,0},{178,0}},     color={255,0,255}));
          connect(TDif, hys.u) annotation (Line(points={{-300,120},{-272,120},{-272,80},
                  {-262,80}},
                        color={0,0,127}));
          connect(triMovMea.y, lesEquThr1.u)   annotation (Line(points={{122,0},{138,0}},     color={0,0,127}));
          connect(staCal, triSam2.trigger) annotation (Line(points={{-300,40},{-120,40},
                  {-120,100},{110,100},{110,108.2}},
                                            color={255,0,255}));
          connect(TDif,triSam3. u)   annotation (Line(points={{-300,120},{0,120},{0,80},
                  {18,80}},                                color={0,0,127}));
          connect(pre.y,triSam3. trigger) annotation (Line(points={{412,-30},{420,-30},
                  {420,30},{30,30},{30,68.2}},
                                            color={255,0,255}));
          connect(pre.y, lat.u) annotation (Line(points={{412,-30},{420,-30},{420,-100},
                  {-196,-100},{-196,80},{-192,80}},
                                               color={255,0,255}));
          connect(edg.y, triSam1.trigger) annotation (Line(points={{-98,-80},{-90,-80},
                  {-90,-61.8}},color={255,0,255}));
          connect(triSam1.y, add1.u2) annotation (Line(points={{-78,-50},{-72,-50},{-72,
                  -6},{-62,-6}}, color={0,0,127}));
          connect(triSam.y, add1.u1) annotation (Line(points={{-78,10},{-72,10},{-72,6},
                  {-62,6}}, color={0,0,127}));
          connect(swi.y, temSlo.u2)    annotation (Line(points={{42,0},{46,0},{46,-6},{
                  58,-6}},                                                                      color={0,0,127}));
          connect(add1.y, lesEquThr.u)   annotation (Line(points={{-38,0},{-22,0}},
                                                                                 color={0,0,127}));
          connect(add1.y, swi.u3) annotation (Line(points={{-38,0},{-30,0},{-30,-18},{8,
                  -18},{8,-8},{18,-8}},
                                    color={0,0,127}));
          connect(triMovMea.y, swi1.u3) annotation (Line(points={{122,0},{128,0},{128,
                  -18},{164,-18},{164,-8},{178,-8}},
                                                color={0,0,127}));
          connect(TDif, triSam2.u)   annotation (Line(points={{-300,120},{98,120}},  color={0,0,127}));
          connect(tNexOcc, add2.u2) annotation (Line(points={{-300,-140},{290,-140},{290,
                  -86},{298,-86}}, color={0,0,127}));
          connect(add2.y, hysOpt.u) annotation (Line(points={{322,-80},{328,-80}},
                             color={0,0,127}));
          connect(min.y, add2.u1) annotation (Line(points={{308,0},{314,0},{314,-58},{
                  290,-58},{290,-74},{298,-74}},
                                             color={0,0,127}));
          connect(con.y, max.u2) annotation (Line(points={{162,100},{170,100},{170,108},
                  {178,108}},color={0,0,127}));
          connect(triSam2.y, max.u1)    annotation (Line(points={{122,120},{178,120}}, color={0,0,127}));
          connect(staCal, truHol.u) annotation (Line(points={{-300,40},{-260,40},{-260,
                  10},{-242,10}}, color={255,0,255}));
          connect(truHol.y, tim.u)    annotation (Line(points={{-218,10},{-182,10}}, color={255,0,255}));
          connect(tim.y, triSam1.u) annotation (Line(points={{-158,10},{-140,10},{-140,
                  -50},{-102,-50}},
                              color={0,0,127}));
          connect(min.y, tOpt) annotation (Line(points={{308,0},{314,0},{314,60},{460,
                  60}},
                color={0,0,127}));
          connect(not1.u, hys.y)    annotation (Line(points={{-232,80},{-238,80}}, color={255,0,255}));
          connect(lat.y, edg.u) annotation (Line(points={{-168,80},{-134,80},{-134,-80},
                  {-122,-80}},
                             color={255,0,255}));
          connect(lat.y, falEdg.u) annotation (Line(points={{-168,80},{-134,80},{-134,
                  -20},{-122,-20}},
                              color={255,0,255}));
          connect(modTim.y, mod.u1) annotation (Line(points={{22,-40},{28,-40},{28,-54},
                  {38,-54}}, color={0,0,127}));
          connect(con1.y, mod.u2) annotation (Line(points={{22,-80},{28,-80},{28,-66},{
                  38,-66}}, color={0,0,127}));
          connect(mod.y, lesEquThr2.u)   annotation (Line(points={{62,-60},{78,-60}}, color={0,0,127}));
          connect(lesEquThr2.y, triMovMea.trigger) annotation (Line(points={{102,-60},{
                  110,-60},{110,-12}}, color={255,0,255}));
          connect(tOptCal.y, triSam4.u)   annotation (Line(points={{242,0},{248,0}}, color={0,0,127}));
          connect(staCal, triSam4.trigger) annotation (Line(points={{-300,40},{-260,40},
                  {-260,-108},{260,-108},{260,-11.8}}, color={255,0,255}));
          connect(triSam4.y, min.u2) annotation (Line(points={{272,0},{276,0},{276,-6},
                  {284,-6}}, color={0,0,127}));
          connect(maxStaTim.y, min.u1) annotation (Line(points={{272,50},{278,50},{278,
                  6},{284,6}}, color={0,0,127}));
          connect(defOptTim.y, swi.u1)  annotation (Line(points={{2,40},{8,40},{8,8},{18,8}}, color={0,0,127}));
          connect(defTemSlo.y, swi1.u1) annotation (Line(points={{142,50},{170,50},{170,
                  8},{178,8}}, color={0,0,127}));
          connect(max.y, tOptCal.u1) annotation (Line(points={{202,114},{212,114},{212,
                  6},{218,6}}, color={0,0,127}));
          connect(triSam3.y, temSlo.u1)   annotation (Line(points={{42,80},{48,80},{48,6},{58,6}}, color={0,0,127}));
          connect(min.y, greThr.u)  annotation (Line(points={{308,0},{318,0}}, color={0,0,127}));
          connect(hysOpt.y, and2.u2) annotation (Line(points={{352,-80},{354,-80},{354,
                  -38},{358,-38}}, color={255,0,255}));
          connect(greThr.y, and2.u1) annotation (Line(points={{342,0},{354,0},{354,-30},
                  {358,-30}}, color={255,0,255}));
          connect(and2.y, pre.u) annotation (Line(points={{382,-30},{386,-30},{386,-30},
                  {388,-30}}, color={255,0,255}));
          connect(pre.y, optOn) annotation (Line(points={{412,-30},{428,-30},{428,-60},
                  {460,-60},{460,-60}}, color={255,0,255}));
           annotation (
        defaultComponentName="optStaCal",
          Documentation(info="<html>
<p>
This base class contains the algorithm for the optimal start calculation. For the
description of the algorithm, please refer to the documentation for the block
<a href=\"modelica://Buildings.Controls.OBC.Utilities.OptimalStart\">
Buildings.Controls.OBC.Utilities.OptimalStart</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 15, 2019, by Kun Zhang:<br/>
First implementation.
</li>
</ul>
</html>"),
        Diagram(coordinateSystem(extent={{-280,-160},{440,160}})),
            Icon(graphics={
                  Rectangle(
                    extent={{-100,-100},{100,100}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                Text(
                  lineColor={0,0,255},
                  extent={{-150,110},{150,150}},
                  textString="%name")}));
        end OptimalStartCalculation;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes to construct blocks in
<a href=\"modelica://Buildings.Controls.OBC.Utilities\">Buildings.Controls.OBC.Utilities</a>.
</p>
</html>"),
        Icon(graphics={
              Rectangle(
                lineColor={200,200,200},
                fillColor={248,248,248},
                fillPattern=FillPattern.HorizontalCylinder,
                extent={{-100,-100},{100,100}},
                radius=25.0),
              Rectangle(
                lineColor={128,128,128},
                extent={{-100,-100},{100,100}},
                radius=25.0),
              Ellipse(
                extent={{-30,-30},{30,30}},
                lineColor={128,128,128},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains utility blocks, base classes and validation models for
the OpenBuildingControl (OBC) library.
</p>
</html>"),
    Icon(graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
        Polygon(
          origin={1.3835,-4.1418},
          rotation=45.0,
          fillColor={64,64,64},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},
          {20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},
          {25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},
          {15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},
          {0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},
          {-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
        Polygon(
          origin={10.1018,5.218},
          rotation=-45.0,
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid,
          points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},
          {10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},
          {5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},
          {-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
    end Utilities;
  annotation (
  Documentation(info="<html>
<p>
Package that contains a library of elementary control blocks
and a library that implements control sequences from the ASHRAE Guideline 36.
</p>
<p>
These implementations have been developed
through the OpenBuildingControl (<a href=\"https://obc.lbl.gov\">obc.lbl.gov</a>) project
that develops a process and tools for the
performance evaluation, specification and verification
of building control sequences.
</p>
<p>
For a tutorial for how to implement control sequences using the
Control Description Language (CDL), see
<a href=\"modelica://Buildings.Examples.Tutorial.CDL\">
Buildings.Examples.Tutorial.CDL</a>.
</p>
</html>"));
  end OBC;

  package SetPoints "Package with models for control set points"
    extends Modelica.Icons.VariantsPackage;
    block OccupancySchedule "Occupancy schedule with look-ahead"
      extends Modelica.Blocks.Icons.Block;

      parameter Real occupancy[:]=3600*{7, 19}
        "Occupancy table, each entry switching occupancy on or off";
      parameter Boolean firstEntryOccupied = true
        "Set to true if first entry in occupancy denotes a changed from unoccupied to occupied";
      parameter Modelica.SIunits.Time period =   86400 "End time of periodicity";

      Modelica.Blocks.Interfaces.RealOutput tNexNonOcc
        "Time until next non-occupancy"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      Modelica.Blocks.Interfaces.RealOutput tNexOcc "Time until next occupancy"
        annotation (Placement(transformation(extent={{100,50},{120,70}})));
      Modelica.Blocks.Interfaces.BooleanOutput occupied
        "Outputs true if occupied at current time"
        annotation (Placement(transformation(extent={{100,-70},{120,-50}})));

    protected
      final parameter Integer nRow = size(occupancy,1)
        "Number of rows in the schedule";

      output Modelica.SIunits.Time offSet=integer(time/period)*period
        "Time off-set, in multiples of period, that is used to switch the time when doing the table lookup";
      output Integer nexStaInd "Next index when occupancy starts";
      output Integer nexStoInd "Next index when occupancy stops";

      output Integer iPerSta
        "Counter for the period in which the next occupancy starts";
      output Integer iPerSto
        "Counter for the period in which the next occupancy stops";

      output Modelica.SIunits.Time tOcc "Time when next occupancy starts";
      output Modelica.SIunits.Time tNonOcc "Time when next non-occupancy starts";

    encapsulated function switchInteger
      import Modelica;
      extends Modelica.Icons.Function;
      input Integer x1;
      input Integer x2;
      output Integer y1;
      output Integer y2;
    algorithm
      y1:=x2;
      y2:=x1;
    end switchInteger;

    encapsulated function switchReal
      import Modelica;
      extends Modelica.Icons.Function;
      input Real x1;
      input Real x2;
      output Real y1;
      output Real y2;
    algorithm
      y1:=x2;
      y2:=x1;
    end switchReal;

    initial algorithm
      // Check parameters for correctness
     assert(mod(nRow, 2) < 0.1,
       "The parameter \"occupancy\" must have an even number of elements.\n");
     assert(0 <= occupancy[1],
       "The first element of \"occupancy\" must be bigger than or equal to zero."
       + "\n   Received occupancy[1] = " + String(occupancy[1]));
     assert(period >= occupancy[nRow],
       "The parameter \"period\" must be greater than or equal to the last element of \"occupancy\"."
       + "\n   Received period      = " + String(period)
       + "\n            occupancy[" + String(nRow) +
         "] = " + String(occupancy[nRow]));
      for i in 1:nRow-1 loop
        assert(occupancy[i] < occupancy[i+1],
          "The elements of the parameter \"occupancy\" must be strictly increasing.");
      end for;

     // Initialize variables
     iPerSta   := integer(time/period);
     iPerSto   := iPerSta;

     // First, assume that the first entry is occupied
     nexStaInd := 1;
     nexStoInd := 2;
     // nRow is an even number
     for i in 1:2:nRow-1 loop
       if time >= occupancy[i] + iPerSta*period then
         nexStaInd := i+2;
       end if;
     end for;
     for i in 2:2:nRow loop
       if time >= occupancy[i] + iPerSto*period then
         nexStoInd := i+2;
       end if;
     end for;
     if nexStaInd > nRow then
        nexStaInd := 1;
        iPerSta :=iPerSta + 1;
     end if;
     if nexStoInd > nRow then
        nexStoInd := 2;
        iPerSto :=iPerSto + 1;
     end if;
     tOcc    := occupancy[nexStaInd]+iPerSta*period;
     tNonOcc := occupancy[nexStoInd]+iPerSto*period;
     occupied := tNonOcc < tOcc;

     // Now, correct if the first entry is vaccant instead of occupied
     if not firstEntryOccupied then
       (nexStaInd, nexStoInd) := switchInteger(nexStaInd, nexStoInd);
       (iPerSta, iPerSto)     := switchInteger(iPerSta,   iPerSto);
       (tOcc, tNonOcc)        := switchReal(tOcc,      tNonOcc);
       occupied := not occupied;
     end if;

    equation
      when time >= pre(tOcc) then
        // Changed the index that computes the time until the next occupancy
        nexStaInd = if pre(nexStaInd) + 2 <= nRow then (pre(nexStaInd) + 2)
                    else (if firstEntryOccupied then 1 else 2);
        iPerSta = if pre(nexStaInd) + 2 <= nRow then pre(iPerSta)
                    else (pre(iPerSta) + 1);
        tOcc = occupancy[nexStaInd] + iPerSta*period;
        occupied = not pre(occupied);

        nexStoInd = pre(nexStoInd);
        iPerSto   = pre(iPerSto);
        tNonOcc   = pre(tNonOcc);
      elsewhen time >= pre(tNonOcc) then
        // Changed the index that computes the time until the next non-occupancy
        nexStoInd = if pre(nexStoInd) + 2 <= nRow then (pre(nexStoInd) + 2)
                    else (if firstEntryOccupied then 2 else 1);
        iPerSto = if pre(nexStoInd) + 2 <= nRow then pre(iPerSto)
                   else (pre(iPerSto) + 1);
        tNonOcc =  occupancy[nexStoInd] + iPerSto*period;
        occupied =  not pre(occupied);

        nexStaInd = pre(nexStaInd);
        iPerSta   = pre(iPerSta);
        tOcc      = pre(tOcc);
      end when;

     tNexOcc    =  tOcc-time;
     tNexNonOcc =  tNonOcc-time;

      annotation (
        Icon(graphics={
            Line(
              points={{-62,-68},{-38,-20},{-14,-70}},
              color={0,0,255}),
            Line(
              points={{-38,-20},{-38,44}},
              color={0,0,255}),
            Ellipse(extent={{-54,74},{-22,44}}, lineColor={0,0,255}),
            Line(
              points={{-66,22},{-38,36}},
              color={0,0,255}),
            Line(
              points={{-38,36},{-6,20}},
              color={0,0,255}),
            Text(
              extent={{34,74},{90,50}},
              lineColor={0,0,255},
              textString="occupancy"),
            Text(
              extent={{32,16},{92,-16}},
              lineColor={0,0,255},
              textString="non-occupancy"),
            Text(
              extent={{34,-44},{94,-76}},
              lineColor={0,0,255},
              textString="occupied")}),
    defaultComponentName="occSch",
    Documentation(info="<html>
<p>
This model outputs whether the building is currently occupied,
and how long it will take until the next time when the building
will be occupied or non-occupied.
The latter may be used, for example, to start a ventilation system
half an hour before occupancy starts in order to ventilate the room.
</p>
<p>
The occupancy is defined by a time schedule of the form
</p>
<pre>
  occupancy = 3600*{7, 12, 14, 19}
</pre>
<p>
This indicates that the occupancy is from <i>7:00</i> until <i>12:00</i>
and from <i>14:00</i> to <i>19:00</i>. This will be repeated periodically.
The parameter <code>periodicity</code> defines the periodicity.
The period always starts at <i>t=0</i> seconds.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 30, 2017, by Michael Wetter:<br/>
Rewrote using <code>equation</code> rather than <code>algorithm</code>
and removed assertion.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/844\">issue 844</a>.
</li>
<li>
September 11, 2012, by Michael Wetter:<br/>
Added <code>pre</code> operator in <code>when</code> clause and relaxed
tolerance in <code>assert</code> statement.
</li>
<li>
July 26, 2012, by Michael Wetter:<br/>
Fixed a bug that caused an error in the schedule if the simulation start time was negative or equal to the first entry in the schedule.
</li>
<li>
February 16, 2012, by Michael Wetter:<br/>
Removed parameter <code>startTime</code>. It was removed because <code>startTime=0</code>
would imply that the schedule should not start for one day if the simulation were
to be started at <i>t=-8760</i> seconds.
Fixed bug that prevented schedule to start when the simulation was started at a time that
is higher than <code>endTime</code>.
Renamed parameter <code>endTime</code> to <code>period</code>.
</li>
<li>
April 2, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end OccupancySchedule;

    block SupplyReturnTemperatureReset
      "Block to compute the supply and return set point"
      extends Modelica.Blocks.Icons.Block;

      parameter Real m = 1.3 "Exponent for heat transfer";
      parameter Modelica.SIunits.Temperature TSup_nominal "Supply temperature"
        annotation (Dialog(group="Nominal conditions"));
      parameter Modelica.SIunits.Temperature TRet_nominal "Return temperature"
        annotation (Dialog(group="Nominal conditions"));
      parameter Modelica.SIunits.Temperature TRoo_nominal = 293.15
        "Room temperature"
        annotation (Dialog(group="Nominal conditions"));
      parameter Modelica.SIunits.Temperature TOut_nominal "Outside temperature"
        annotation (Dialog(group="Nominal conditions"));

      parameter Boolean use_TRoo_in = false
        "Get the room temperature set point from the input connector"
        annotation(Evaluate=true, HideResult=true);
      parameter Modelica.SIunits.Temperature TRoo = 293.15
        "Fixed value of room temperature set point"
        annotation(Dialog(enable = not use_TRoo_in));
      parameter Modelica.SIunits.TemperatureDifference dTOutHeaBal(displayUnit="K") = 8
        "Offset for heating curve";
      Modelica.Blocks.Interfaces.RealInput TRoo_in(final quantity="ThermodynamicTemperature",
                                                   final unit = "K", displayUnit = "degC", min=0) if
              use_TRoo_in "Room air temperature set point"
        annotation (Placement(transformation(extent={{-139,-80},{-99,-40}})));

      Modelica.Blocks.Interfaces.RealInput TOut(final quantity="ThermodynamicTemperature",
                                                final unit = "K", displayUnit = "degC", min=0)
        "Outside temperature"
        annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
      Modelica.Blocks.Interfaces.RealOutput TSup(final quantity="ThermodynamicTemperature",
                                                final unit = "K", displayUnit = "degC", min=0)
        "Setpoint for supply temperature"
        annotation (Placement(transformation(extent={{100,50},{120,70}})));
      Modelica.Blocks.Interfaces.RealOutput TRet(final quantity="ThermodynamicTemperature",
                                                final unit = "K", displayUnit = "degC", min=0)
        "Setpoint for return temperature"
        annotation (Placement(transformation(extent={{100,-70},{120,-50}})));

    protected
      Modelica.Blocks.Interfaces.RealInput TRoo_in_internal(final quantity="ThermodynamicTemperature",
                                                            final unit = "K", displayUnit = "degC", min=0)
        "Needed to connect to conditional connector";
      Real qRel "Relative heating load = Q_flow/Q_flow_nominal";
      Modelica.SIunits.Temperature TOutOffSet
        "Effective outside temperature for heat transfer (takes into account room heat gains)";
      parameter Modelica.SIunits.Temperature TOutOffSet_nominal =  TOut_nominal + dTOutHeaBal
        "Effective outside temperature for heat transfer at nominal conditions (takes into account room heat gains)";

    equation
      connect(TRoo_in, TRoo_in_internal);
      if not use_TRoo_in then
        TRoo_in_internal = TRoo;
      end if;
     TOutOffSet = TOut + dTOutHeaBal;
     // Relative heating load, compared to nominal conditions
     qRel = max(0, (TRoo_in_internal-TOutOffSet)/(TRoo_nominal-TOutOffSet_nominal));
     TSup = TRoo_in_internal
              + ((TSup_nominal+TRet_nominal)/2-TRoo_nominal) * qRel^(1/m)
              + (TSup_nominal-TRet_nominal)/2 * qRel;
     TRet = TSup - qRel * (TSup_nominal-TRet_nominal);
      annotation (
    defaultComponentName="watRes",
    Documentation(info="<html>
<p>
This block computes the set point temperatures for the
supply and return water temperature.
The set point for the room air temperature can either be specified
by a parameter, or it can be an input to the model. The latter allows
to use this model with systems that have night set back.
</p>
<p>
If used to reset the temperature in a heating system,
the parameter <code>dTOutHeaBal</code> can be used to shift the heating curve
to take into account that heat gains from solar, equipment and people
make up for some of the transmission losses.
For example, in energy efficient houses, the heating may not be switched on if
the outside air temperature is greater than
<i>12</i>&deg;C, even if a room temperature of <i>20</i>&deg;C is required.
In such a situation, set <code>dTOutHeaBal=20-12=8</code> Kelvin to
shift the heating curve.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 03, 2020, by Jianjun Hu:<br/>
Changed name from <code>HotWaterTemperatureReset</code> to 
<code>SupplyReturnTemperatureReset</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1273\">#1273</a>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 13, 2013, by Michael Wetter:<br/>
Corrected error that led to wrong results if the room air temperature is
different from its nominal value <code>TRoo_nominal</code>.
See ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/74\">#74</a>.
</li>
<li>
November 21, 2011, by Michael Wetter:<br/>
Improved documentation.
</li>
<li>
February 5, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),     Icon(graphics={
            Polygon(
              points={{90,-82},{68,-74},{68,-90},{90,-82}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(points={{-90,-82},{82,-82}}, color={192,192,192}),
            Line(points={{-80,76},{-80,-92}}, color={192,192,192}),
            Polygon(
              points={{-80,88},{-88,66},{-72,66},{-80,86},{-80,88}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-80,-82},{60,32}}),
            Line(
              points={{-80,-82},{-42,-38},{4,2},{60,32}},
              smooth=Smooth.Bezier),
            Line(
              points={{-80,-82},{-58,-42},{-4,8},{60,32}},
              smooth=Smooth.Bezier),
            Text(
              extent={{-152,120},{-102,70}},
              lineColor={0,0,127},
              textString="TOut"),
            Text(
              visible=use_TRoo_in,
              extent={{-152,-4},{-102,-54}},
              lineColor={0,0,127},
              textString="TRoo"),
            Text(
              extent={{40,86},{90,36}},
              lineColor={0,0,127},
              textString="TSup"),
            Text(
              extent={{42,-30},{92,-80}},
              lineColor={0,0,127},
              textString="TRet")}));
    end SupplyReturnTemperatureReset;

    model Table
      "Model for a set point that is interpolated based on a user-specified table"
      extends Modelica.Blocks.Interfaces.SISO;
      parameter Real table[:,2]=fill(0.0, 1, 2)
        "Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])";

      parameter Real offset=0 "Offset of output signal";

      parameter Boolean constantExtrapolation = true
        "If true, then y=y1 for u<u1, and y=yMax for u>uMax";

    protected
      final parameter Integer nRow = if constantExtrapolation then
                            size(table,1)+2 else
                            size(table,1) "Number of rows";
      final parameter Real[nRow,2] offsetVector = [zeros(nRow), offset*ones(nRow)]
        "Vector to take offset of output signal into account";
      Modelica.Blocks.Tables.CombiTable1D tab(
        tableOnFile=false,
        final table= (if constantExtrapolation then
                        cat(1, [table[1,1]-1, table[1,2]],
                               table,
                               [table[end,1]+1, table[end,2]]) else
                        table)
                      +offsetVector) "Table used for interpolation"
        annotation (Placement(transformation(extent={{-20,-10},{2,10}})));
    equation
      connect(u, tab.u[1]) annotation (Line(
          points={{-120,0},{-70,0},{-70,0},{-22,0}},
          color={0,0,127}));

      connect(tab.y[1], y) annotation (Line(
          points={{3.1,0},{53.55,0},{53.55,0},{110,0}},
          color={0,0,127}));

      annotation (
    defaultComponentName="tab",
    Documentation(info="<html>
<p>
This block can be used to schedule a set-point by using piecewise linear functions.
For example, the instances
</p>
<pre>
Buildings.Controls.SetPoints.Table tabLinExt(constantExtrapolation=false,
                                             table=[20, 0.0;
                                                    22, 0.5;
                                                    25, 0.5;
                                                    26, 1.0]);
Buildings.Controls.SetPoints.Table tabConExt(constantExtrapolation=true,
                                             table=[20, 0.0;
                                                    22, 0.5;
                                                    25, 0.5;
                                                    26, 1.0]);
</pre>
<p>
will cause the following output:
</p>
<p>
<img src=\"modelica://Buildings/Resources/Images/Controls/SetPoints/Table.png\" border=\"1\" alt=\"Table output.\"/>
</p>
<p>
For the default setting <code>constantExtrapolation=true</code>, the
block outputs
<code>y=y1+offset</code> for <code>u &le; u1</code>, and
<code>y=yMax+offset</code> for <code>u &ge; uMax</code>.
Otherwise, the table is linearly extrapolated with a constant derivative.
</p>
<p>
Note that the first column must be strictly increasing.
</p>
</html>",
    revisions="<html>
<ul>
<li>
August 30, 2016, by Michael Wetter:<br/>
Changed protected final parameter <code>nCol</code> to <code>nRow</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/555\">issue 555</a>.
</li>
<li>
April 5, 2011, by Michael Wetter:<br/>
Fixed wrong table declaration.
</li>
<li>
July 13, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(graphics={
        Text(
          extent={{-78,-45},{-40,-56}},
          lineColor={0,0,0},
          textString="offset"),
        Line(
          points={{-42,-24},{-42,-74}},
          color={95,95,95},
          thickness=0.25,
          arrow={Arrow.None,Arrow.None}),
        Line(
          points={{-82,-24},{-22,-24},{26,24}},
          color={0,0,255},
          thickness=0.5),
        Line(points={{-82,64},{-82,-84}}, color={95,95,95}),
        Text(
          extent={{-80,88},{-39,68}},
          lineColor={0,0,0},
          textString="y"),
        Polygon(
          points={{-82,86},{-88,64},{-76,64},{-82,86}},
          lineColor={95,95,95},
          fillColor={95,95,95},
          fillPattern=FillPattern.Solid),
        Polygon(
          points={{88,-74},{66,-68},{66,-80},{88,-74}},
          lineColor={95,95,95},
          fillColor={95,95,95},
          fillPattern=FillPattern.Solid),
        Line(points={{-92,-74},{80,-74}}, color={95,95,95}),
        Text(
          extent={{68,-84},{92,-95}},
          lineColor={0,0,0},
              textString="u"),
        Polygon(
          points={{-42,-24},{-44,-34},{-39,-34},{-42,-24}},
          lineColor={95,95,95},
          fillColor={95,95,95},
          fillPattern=FillPattern.Solid),
        Polygon(
          points={{-42,-74},{-45,-64},{-40,-64},{-42,-74},{-42,-74}},
          lineColor={95,95,95},
          fillColor={95,95,95},
          fillPattern=FillPattern.Solid),
        Line(
          points={{26,24},{77,24}},
          color={0,0,255},
          thickness=0.5)}));
    end Table;

    package Examples "Collection of models that illustrate model use and test models"
      extends Modelica.Icons.ExamplesPackage;
      model OccupancySchedule "Test model for occupancy schedule with look-ahead"
        extends Modelica.Icons.Example;
        hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSchDay
          "Day schedule"
          annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
        hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSchWee(occupancy
            =3600*{7,19,31,43,55,67,79,91,103,115,127,139}, period=7*24*3600)
          "Week schedule"
          annotation (Placement(transformation(extent={{-60,-40},{-40,-20}})));
        annotation (experiment(StartTime=-86400, Tolerance=1e-6, StopTime=1.2096e+06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/SetPoints/Examples/OccupancySchedule.mos"
              "Simulate and plot"),
          Documentation(info="<html>
<p>
Example that demonstrates the use of the occupancy schedule.
The figure below shows how the time until the next occupancy starts or ends
is decreased. The red line hits zero when the schedule indicates an occupied time,
and the blue line hits zero when the schedule indicates a non-occupied time.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/SetPoints/Examples/OccupancySchedule.png\" border=\"1\" alt=\"Time until next occupancy.\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
November 21, 2011, by Michael Wetter:<br/>
Added documentation.
</li>
</ul>
</html>"));
      end OccupancySchedule;

      model SupplyReturnTemperatureReset "Test model for the heating curve"
        extends Modelica.Icons.Example;
        hil_flexlab_model.Controls_HIL.SetPoints.SupplyReturnTemperatureReset heaCur(
          m=1,
          TSup_nominal=333.15,
          TRet_nominal=313.15,
          TOut_nominal=263.15) "Temperature reset"
          annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
        Modelica.Blocks.Sources.Ramp TOut(
          height=40,
          duration=1,
          offset=263.15)
          "Signal for outside air temperature"
          annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
        hil_flexlab_model.Controls_HIL.SetPoints.SupplyReturnTemperatureReset heaCur1(
          m=1,
          use_TRoo_in=true,
          TSup_nominal=333.15,
          TRet_nominal=313.15,
          TOut_nominal=263.15,
          dTOutHeaBal=15)
          "Temperature reset that uses room temperature as input"
          annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
        Modelica.Blocks.Sources.Step TRoo(
          offset=273.15 + 20,
          startTime=0.5,
          height=-5) "Night set back from 20 to 15 deg C"
          annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
        Modelica.Blocks.Sources.Constant TOut2(k=273.15 - 10)
         "Constant signal for outdoor air temperature"
          annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
      equation
        connect(TOut.y, heaCur.TOut) annotation (Line(
            points={{-59,50},{-50,50},{-50,56},{-42,56}},
            color={0,0,127}));
        connect(TOut2.y, heaCur1.TOut) annotation (Line(
            points={{-59,10},{-50,10},{-50,16},{-42,16}},
            color={0,0,127}));
        connect(TRoo.y, heaCur1.TRoo_in) annotation (Line(
            points={{-59,-30},{-50,-30},{-50,4},{-41.9,4}},
            color={0,0,127}));
        annotation (experiment(Tolerance=1e-6, StopTime=1.0),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/SetPoints/Examples/SupplyReturnTemperatureReset.mos"
              "Simulate and plot"),
          Documentation(info="<html>
<p>
Example that demonstrates the use of the hot water temperature reset
for a heating system.
The parameters of the block <code>heaCur</code>
are for a heating system with
<i>60</i>&deg;C supply water temperature and
<i>40</i>&deg;C return water temperature at
an outside temperature of
<i>-10</i>&deg;C and a room temperature of
<i>20</i>&deg;C. The offset for the temperature reset is
<i>8</i> Kelvin, i.e., above
<i>12</i>&deg;C outside temperature, there is no heating load.
The figure below shows the computed supply and return water temperatures.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Controls/SetPoints/Examples/SupplyReturnTemperatureReset.png\" border=\"1\" alt=\"Supply and return water temperatures.\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
November 21, 2011, by Michael Wetter:<br/>
Added documentation.
</li>
</ul>
</html>"));
      end SupplyReturnTemperatureReset;

      model Table "Test model for table that determines set points"
        extends Modelica.Icons.Example;
        hil_flexlab_model.Controls_HIL.SetPoints.Table tabConExt(table=[20,0;
              22,0.5; 25,0.5; 26,1])
          annotation (Placement(transformation(extent={{-20,40},{0,60}})));
        Modelica.Blocks.Sources.Ramp TRoo(
          duration=1,
          offset=15,
          height=15)
          annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
        hil_flexlab_model.Controls_HIL.SetPoints.Table tabLinExt(
            constantExtrapolation=false, table=[20,0; 22,0.5; 25,0.5; 26,1])
          annotation (Placement(transformation(extent={{-20,0},{0,20}})));
      equation
        connect(TRoo.y, tabLinExt.u) annotation (Line(
            points={{-59,10},{-22,10}},
            color={0,0,127}));
        connect(TRoo.y, tabConExt.u) annotation (Line(
            points={{-59,10},{-50,10},{-50,50},{-22,50}},
            color={0,0,127}));
        annotation (
      experiment(Tolerance=1e-6, StopTime=1.0),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/SetPoints/Examples/Table.mos"
              "Simulate and plot"),
          Documentation(info="<html>
<p>
Example that demonstrates the use of the block
<a href=\"modelica://Buildings.Controls.SetPoints.Table\">
Buildings.Controls.SetPoints.Table</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 21, 2011, by Michael Wetter:<br/>
Added documentation.
</li>
</ul>
</html>"));
      end Table;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Controls.SetPoints\">
Buildings.Controls.SetPoints</a>.
</p>
</html>"));
    end Examples;

    package Validation "Collection of validation models"
      extends Modelica.Icons.ExamplesPackage;

      model OccupancyScheduleNegativeStartTime
        "Test model for occupancy schedule with look-ahead"
        extends Modelica.Icons.Example;
        hil_flexlab_model.Controls_HIL.SetPoints.OccupancySchedule occSchDay(occupancy
            =3600*{7,24}) "Day schedule"
          annotation (Placement(transformation(extent={{-60,60},{-40,80}})));
        OccupancySchedule occSchDay1(occupancy=3600*{0,2})   "Day schedule"
          annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
        OccupancySchedule occSchDay2(
          occupancy=3600*{7,10,17,20},
          firstEntryOccupied=false)                 "Day schedule"
          annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
        annotation (experiment(
            StartTime=-112320,
            StopTime=207360,
            Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/SetPoints/Validation/OccupancyScheduleNegativeStartTime.mos"
              "Simulate and plot"),
          Documentation(info="<html>
<p>
Example that validates the occupancy schedule
for a negative start time.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 30, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end OccupancyScheduleNegativeStartTime;

      model OccupancySchedulePositiveStartTime
        "Validation model for occupancy schedule with positive start time"
        extends OccupancyScheduleNegativeStartTime;
        annotation (experiment(
            StartTime=86400,
            StopTime=207360,
            Tolerance=1e-06),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Controls/SetPoints/Validation/OccupancySchedulePositiveStartTime.mos"
              "Simulate and plot"),
          Documentation(info="<html>
<p>
Example that validates the occupancy schedule
for a positive start time.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 30, 2017, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      end OccupancySchedulePositiveStartTime;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Controls.SetPoints\">
Buildings.Controls.SetPoints</a>.
</p>
<p>
Note that most validation models contain simple input data
which may not be realistic, but for which the correct
output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these
solutions. These model outputs are stored as reference data and
used for continuous validation whenever models in the library change.
</p>
</html>"));
    end Validation;
  annotation (preferredView="info", Documentation(info="<html>
This package contains component models to compute set points of control systems.
For additional models, see also
<a href=\"modelica://Modelica.Blocks.Continuous\">
Modelica.Blocks.Continuous</a>.
</html>"));
  end SetPoints;

  package Types "Package with type definitions"
    extends Modelica.Icons.TypesPackage;

    constant Integer nDayTypes = 3 "Integer with the number of day types";

    type Day = enumeration(
        WorkingDay "Working day, such as Monday through Friday",
        NonWorkingDay "Non-working day, such as week-ends, but not holidays",
        Holiday "Holiday") "Enumeration for the day types"
                                     annotation (Documentation(info="<html>
<p>
Enumeration for the type of days that are used in the demand response models.
The possible values are
</p>
<ol>
<li>
WorkingDay
</li>
<li>
NonWorkingDay
</li>
<li>
Holiday
</li>
</ol>
</html>",   revisions="<html>
<ul>
<li>
March 20, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
  annotation (Documentation(info="<html>
This package contains type definitions.
</html>"));
  end Types;
annotation (
preferredView="info", Documentation(info="<html>
This package contains component models for controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</html>"),
Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Rectangle(
        origin={0.0,35.1488},
        fillColor={255,255,255},
        extent={{-30.0,-20.1488},{30.0,20.1488}}),
      Rectangle(
        origin={0.0,-34.8512},
        fillColor={255,255,255},
        extent={{-30.0,-20.1488},{30.0,20.1488}}),
      Line(
        origin={-51.25,0.0},
        points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
      Polygon(
        origin={-40.0,35.0},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
      Line(
        origin={51.25,0.0},
        points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
      Polygon(
        origin={40.0,-35.0},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}));
end Controls_HIL;
